/** @define {boolean} */
var __UCF_ASSERT__ = true;
/** @define {boolean} */
var __UCF_TRACE__ = true;
/** @define {boolean} */
var __UCF_COVERAGE__ = true;
/** @define {boolean} */
var __UCF_MEASURE__ = true;
/** @define {boolean} */
var __UCF_DEBUG__ = true;
/** @define {boolean} */
var __UCF_IE6__ = false;
var sap = window.sap || {};
(function () {
    /** @class
     * Global JS objects
     *
     *
     */

// Classes array for code coverage
    window["UCF_classes"] = [];

// Pseudo constructor
// TODO: What is this good for ??
//eslint-disable-next-line require-jsdoc
    function UCF_Global() {
        if (__UCF_COVERAGE__) {
            UCF_Global["_"]["UCF_Global"]++;
        }
        ;

    };window["UCF_Global"] = UCF_Global;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Global");
        UCF_Global["_"] = {UCF_Global: 0};
    }
    ;
    ;

    UCF_Global["_checkLeaks"] = (
        function () {
            try {
                return top["document"]["location"]["search"]["indexOf"]("CheckLeaks=X") > -1;
            } catch (ex) {
                return document["location"]["search"]["indexOf"]("CheckLeaks=X") > -1;
            }
        })();

    /* global UCF_JsUtil */
/// <reference path="../util/JsUtil.js"/>
    /** @typedef {{oListener: Object, sFunction: string}} UCF_Tracer_Listener */
    /** @typedef {{iTimeStamp: number, iLevel: number, sText: string, sLocation: string}} UCF_Tracer_TraceEntry */

    /** @type {number} */
    var ERROR = 0;
    window["ERROR"] = ERROR;
    /** @type {number} */
    var WARNING = 1;
    window["WARNING"] = WARNING;
    /** @type {number} */
    var INFO = 2;
    window["INFO"] = INFO;
    /** @type {number} */
    var DEBUG = 3;
    window["DEBUG"] = DEBUG;
    /** @type {number} */
    var START = 0;
    window["START"] = START;
    /** @type {number} */
    var STOP = 1;
    window["STOP"] = STOP;

    /**
     * A tracer class, that is used for all kinds of tracing in LightSpeed.
     * For each trace statement that is within the defined trace level,
     * a Event is fired, that can be used by other objects to display the
     * trace output, write it to a log, or send it to the server.
     * @class UCF_Tracer
     * @constructor
     *
     */
    function UCF_Tracer() {
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["UCF_Tracer"]++;
        }
        ;

    };window["UCF_Tracer"] = UCF_Tracer;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Tracer");
        UCF_Tracer["_"] = {UCF_Tracer: 0};
    }
    ;
    ;

    /**
     * If the Tracer exists, call the trace method on the Tracer object
     * @param {number} iLevel the trace level
     * @param {string} sText the trace text
     * @param {string} sLocation the location the trace statement occurred
     */
    window["_trace"] = function (iLevel, sText, sLocation) {
        UCF_Tracer["trace"](iLevel, sText, sLocation);
    };

    /**
     * If the Tracer exists, call the tracedelayed method on the Tracer object
     * @param {number} iLevel the trace level
     * @param {string} sText the trace text
     * @param {string} sLocation the location the trace statement occurred
     */
    window["_tracedelayed"] = function (iLevel, sText, sLocation) {
        UCF_Tracer["tracedelayed"](iLevel, sText, sLocation);
    };

    /**
     * If the Tracer exists, call the assert method on the Tracer object
     *
     * @param {boolean} bResult the result of the asserted statement
     * @param {string} sStatement the assert statement as a String
     * @param {string} sLocation information about the file/line number, where the
     * assert happened
     */
    window["_assert"] = function (bResult, sStatement, sLocation) {
        UCF_Tracer["assert"](bResult, sStatement, sLocation);
    };

    /**
     * If the Tracer exists, call the measure method on the Tracer object
     *
     * @param {number} iAction chose whether to START or to STOP the measurement
     * @param {string} sId an ID for the measurement to allow nested measurements
     * @param {string} sText a text to display with the result of the measurement
     */
    window["_measure"] = function (iAction, sId, sText) {
        UCF_Tracer["measure"](iAction, sId, sText);
    };

    /**
     * Fatal error, try to trace it, then halt JS execution
     *
     * @param {string} sText the text of the trace message
     * @param {string} sLocation information about the file/line number, where this
     * trace was generated
     */
    window["_fatal"] = function (sText, sLocation) {
        UCF_Tracer["trace"](ERROR, sText, sLocation);
        alert('FATAL ERROR: ' + sText);
    };

    /** @const {number} */
    UCF_Tracer["iTraceLevel"] = INFO;
    /** @const {Object.<string,number>} */
    UCF_Tracer["mTimers"] = {};
    /** @const {Object.<number,UCF_Tracer_Listener>} */
    UCF_Tracer["mListeners"] = {};
    /** @const {number} */
    UCF_Tracer["iCounter"] = 0;

    /**
     * @private
     */
    UCF_Tracer["writeDelayedTrace"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["writeDelayedTrace"]++;
        }
        ;
        /** @type {string} */
        var s;
        /** @type {Array.<UCF_Tracer_TraceEntry>} */
        var aTraces;
        /** @type {number} */
        var i;
        /** @type {UCF_Tracer_TraceEntry} */
        var o;

        // bug in IE11 on Windows 8.1: In Enhanced Protected Mode,
        // window.localStorage exists but you get an 'Access denied' error
        try {
            if (window["localStorage"] && window["JSON"]) {
                // see UCF_JsUtil.bSupportsLocalStorage
                // bug in Safari in-private browser mode. window.localStorage exists but
                // you can't access setItem. Error message 'QUOTA_EXCEEDED_ERR: DOM
                // Exception 22: An attempt was made to add something to storage that
                // exceeded the quota.'
                s = window["localStorage"]["getItem"]('tracedelayed');
                window["localStorage"]["setItem"]('tracedelayed', '');
                if (s) {
                    aTraces = UCF_JsUtil["oJsonParse"]('[' + s + ']');
                    for (i = 0; i < aTraces["length"]; i++) {
                        o = aTraces[i];
                        UCF_Tracer["trace"](o["iLevel"], 'Delayed from previous unload - ' + o["sText"], o["sLocation"]);
                    }
                }
            }
        } catch (ignored) {
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["writeDelayedTrace"] = 0;
    }
    ;

    /**
     * @param {Object} oListener The object, that want to be notified, when
     * something is traced
     * @param {string} sFunction The name of the function to call, when something
     * is traced
     * @private
     */
    UCF_Tracer["addListener"] = function (oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["addListener"]++;
        }
        ;
        UCF_Tracer["mListeners"][UCF_Tracer["iCounter"]++] = {
            "oListener": oListener,
            "sFunction": sFunction
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["addListener"] = 0;
    }
    ;

    /**
     * @param {Object} oListener The object, that want to be notified, when the
     * event occurs
     * @private
     */
    UCF_Tracer["removeListener"] = function (oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["removeListener"]++;
        }
        ;
        /** @type {Object} */
        var oEntry;

        if (UCF_Tracer["mListeners"]) {
            for (oEntry in UCF_Tracer["mListeners"]) {
                if (UCF_Tracer["mListeners"][oEntry]["oListener"] === oListener) {
                    delete UCF_Tracer["mListeners"][oEntry];
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["removeListener"] = 0;
    }
    ;

    /**
     * Notify listeners of the Tracer
     * @param {Object} mParameters parameters to give to the listener
     * @private
     */
    UCF_Tracer["notifyListeners"] = function (mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["notifyListeners"]++;
        }
        ;
        /** @type {Object} */
        var oEntry;
        /** @type {UCF_Tracer_Listener} */
        var o;

        for (oEntry in UCF_Tracer["mListeners"]) {
            o = UCF_Tracer["mListeners"][oEntry];
            o["oListener"][o["sFunction"]](mParameters);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["notifyListeners"] = 0;
    }
    ;

    /**
     * Method for tracing
     * @param {int} iLevel the trace level of the message
     * @param {string} sText the text of the trace message
     * @param {string} sLocation information about the file/line number, where this
     * trace was generated
     * @private
     */
    UCF_Tracer["trace"] = function (iLevel, sText, sLocation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["trace"]++;
        }
        ;
        /** @type {UCF_Tracer_TraceEntry} */
        var mParameters;
        /** @type {string} */
        var sTraceText;

        if (iLevel <= UCF_Tracer["iTraceLevel"]) {

            // Fire a trace event for custom logger tools
            mParameters = {
                "iTimeStamp": new Date()["getTime"](),
                "iLevel": iLevel,
                "sText": sText,
                "sLocation": sLocation
            };
            this["notifyListeners"](mParameters);

            sTraceText = sLocation + ' : ' + sText;

            // Show trace messages in FireBug/Visual Studio
            if (window["console"]) {
                try {
                    switch (iLevel) {
                        case ERROR:
                            console["error"](sTraceText + ' (LS:Error)');
                            break;
                        case WARNING:
                            console["warn"](sTraceText + ' (LS:Warning)');
                            break;
                        case INFO:
                            console["info"](sTraceText + ' (LS:Info)');
                            break;
                        case DEBUG:
                            (console["debug"] || console["info"])(sTraceText + ' (LS:Debug)');
                            break;
                    }
                } catch (e) {
                    // IE11 will throw 'unspecified errors' when trying to write to console
                    // immediately after Dev Tools are closed (F12)
                }
            }
            if (window["Debug"]) {
                window["Debug"]["writeln"](sTraceText);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["trace"] = 0;
    }
    ;

    /**
     * @param {number} iLevel the trace level
     * @param {string} sText the trace text
     * @param {string} sLocation the location the trace statement occurred
     */
    UCF_Tracer["tracedelayed"] = function (iLevel, sText, sLocation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["tracedelayed"]++;
        }
        ;
        /** @type {string} */
        var s;

        UCF_Tracer["trace"](iLevel, sText, sLocation);

        if (UCF_JsUtil["bSupportsLocalStorage"]()) {
            s = window["localStorage"]["getItem"]('tracedelayed');
            if (s) {
                s += ',';
            } else {
                s = '';
            }
            s += '{"iLevel":' + iLevel
                + ',"sText":"' + sText
                + '","sLocation":"' + sLocation + '"}';
            window["localStorage"]["setItem"]('tracedelayed', s);
            if (UCF_Tracer["iTimeout"]) {
                UCF_JsUtil["clearDelayedCall"](UCF_Tracer["iTimeout"]);
            }
            UCF_Tracer["iTimeout"] = UCF_JsUtil["delayedCall"](
                // eslint-disable-next-line no-magic-numbers
                100,
                UCF_Tracer,
                'writeDelayedTrace'
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["tracedelayed"] = 0;
    }
    ;

    /**
     * Method for asserting
     *
     * @param {boolean} bResult the result of the asserted statement
     * @param {string} sStatement the assert statement as a String
     * @param {string} sLocation information about the file/line number, where the
     * assert happened
     *
     * @private
     */
    UCF_Tracer["assert"] = function (bResult, sStatement, sLocation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["assert"]++;
        }
        ;
        if (!bResult) {
            this["trace"](ERROR, 'Assert failed: ' + sStatement, sLocation);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["assert"] = 0;
    }
    ;

    /**
     * Method for measuring runtimes
     *
     * @param {number} iAction chose whether to START or to STOP the measurement
     * @param {string} sId an ID for the measurement to allow nested measurements
     * @param {string} sText a text to display with the result of the measurement
     *
     * @private
     */
    UCF_Tracer["measure"] = function (iAction, sId, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["measure"]++;
        }
        ;

        if (!window["performance"]["mark"]) return; // on IE Quirks mode is undefined

        /** @type {number} */
        var result;

        if (!sText) {
            sText = sId;
        }

        switch (iAction) {
            case START:
                if (sText) {
                    this["trace"](INFO, sText, '');
                }
                try {
                    window["performance"]["mark"](sId + '-start');
                } catch (e) {
                    this["trace"](INFO, e["message"]);
                }
                UCF_Tracer["mTimers"][sId] = new Date()["getTime"]();
                break;
            case STOP:
                result = new Date()["getTime"]() - UCF_Tracer["mTimers"][sId];
                if (sText) {
                    this["trace"](INFO, sText + ' ' + result + 'ms', '');
                }
                try {
                    window["performance"]["mark"](sId + '-stop');
                } catch (e) {
                    this["trace"](INFO, e["message"]);
                }
                try {
                    window["performance"]["measure"](sText, sId + '-start', sId + '-stop');
                } catch (e) {
                    this["trace"](INFO, e["message"]);
                }
                // }
                break;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["measure"] = 0;
    }
    ;

    /**
     * Method to set a new trace level
     *
     * @param {number} iLevel the new level to be used by the tracer
     *
     * @private
     */
    UCF_Tracer["setTraceLevel"] = function (iLevel) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Tracer["_"]["setTraceLevel"]++;
        }
        ;
        UCF_Tracer["iTraceLevel"] = iLevel;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Tracer["_"]["setTraceLevel"] = 0;
    }
    ;

    UCF_Tracer["writeDelayedTrace"]();

    /* global _assert, _trace, INFO, WARNING, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_ErrorMessage */
/// <reference path="./ErrorMessage.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="./RequestUtil.js"/>
    /* global UCF_System */
/// <reference path="../../ls/core/System.js"/>

    window["sap"] = window["sap"] || {};

    /** @type {Object} */
    var sap = window["sap"] || {};

    sap["ls"] = sap["ls"] || {};

    /**
     * A synchronous class loader.
     *
     *
     *
     * @class UCF_ClassLoader
     *
     * @version
     */
    function UCF_ClassLoader() {
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["UCF_ClassLoader"]++;
        }
        ;

    };window["UCF_ClassLoader"] = UCF_ClassLoader;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClassLoader");
        UCF_ClassLoader["_"] = {UCF_ClassLoader: 0};
    }
    ;
    ;

    /** @type {Object.<string, string>} */
    UCF_ClassLoader["mLibraries"] = {};

    UCF_ClassLoader["mClassStrings"] = {};

// ===== registerBaseUrl ======================================================
    /** @type {string} */
    UCF_ClassLoader["sBaseUrl"] = '';
    /** @type {string} */
    UCF_ClassLoader["sQueryString"] = '';

    /**
     * @private
     * @static
     * @type {Object.<string,number>}
     */
    UCF_ClassLoader["oPreloadExpansionCallbackIds"] = {};

    /**
     * Register a library
     *
     * THIS IS ALREADY USED BY sap_pioneer! They register the sap_pioneer_ prefix
     * and the controls P (Pivottable), CH (Chart) and MS (Membertree).
     *
     * @example
     * UCF_ClassLoader.registerLibrary(
     *   'UCF_',
     *   '/lsdev/js/classes/$$.js?123456',
     *   true
     * );
     *
     * @private
     * @param {string} sPrefix class name prefix used to identify the library
     * @param {string} sUrlTemplate the URL where to load files, $$ will be
     * replaced by file name
     * @param {boolean} bRemovePrefix whether the prefix will be removed before
     * accessing the file
     */
    UCF_ClassLoader["registerLibrary"] = function (sPrefix, sUrlTemplate, bRemovePrefix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["registerLibrary"]++;
        }
        ;
        if (UCF_ClassLoader["mLibraries"][sPrefix]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, sPrefix + ' was already registered!', "ClassLoader.js(72): registerLibrary");
            }
            ;
        }
        UCF_ClassLoader["mLibraries"][sPrefix] = {
            "sPrefix": sPrefix,
            "sUrlTemplate": sUrlTemplate,
            "bRemovePrefix": bRemovePrefix
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["registerLibrary"] = 0;
    }
    ;

    /**
     * Finds the library for a given class name
     *
     * @param {string} sClassName The class name
     * @return {string} The library definition for the given class
     * @private
     */
    UCF_ClassLoader["oGetLibrary"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["oGetLibrary"]++;
        }
        ;
        /** @type {string} */
        var sPrefix;

        for (sPrefix in UCF_ClassLoader["mLibraries"]) {
            if (sClassName["indexOf"](sPrefix) === 0) {
                return UCF_ClassLoader["mLibraries"][sPrefix];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["oGetLibrary"] = 0;
    }
    ;

    /**
     * Returns a url to the given file name
     * @param {string} sFilename The filename
     * @return {string} The url to the file based on the base url registered by
     * registerBaseUrl and the optional query string
     * @private
     */
    UCF_ClassLoader["sGetFileUrl"] = function (sFilename) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["sGetFileUrl"]++;
        }
        ;
        return UCF_ClassLoader["sBaseUrl"] + '/' + sFilename + UCF_ClassLoader["sQueryString"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["sGetFileUrl"] = 0;
    }
    ;

    /**
     * Registers a base url ad optional query string for method sGetFileUrl
     * @param {string} sBaseUrl The base url
     * @param {string} sQueryString The query string to be used
     * @private
     */
    UCF_ClassLoader["registerBaseUrl"] = function (sBaseUrl, sQueryString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["registerBaseUrl"]++;
        }
        ;
        UCF_ClassLoader["sBaseUrl"] = sBaseUrl;
        UCF_ClassLoader["sQueryString"] = sQueryString || '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["registerBaseUrl"] = 0;
    }
    ;

    /**
     * @param {string} sClassName the name of the class,
     * @param {boolean} bSuppressError `true` to suppress errors
     * @return {string} the url of the library for the given sClassName
     */
    UCF_ClassLoader["sGetLibraryUrl"] = function (sClassName, bSuppressError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["sGetLibraryUrl"]++;
        }
        ;
        /** @type {Object} */
        var oLibrary = UCF_ClassLoader["oGetLibrary"](sClassName);
        /** @type {string} */
        var sFile;
        /** @type {string} */
        var sUrl;
        /** @type {Window} */
        var oApplyTo;
        /** @type {Array.<string>} */
        var aParts;
        /** @type {number} */
        var i;

        if (oLibrary) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Loading class ' + sClassName + '.', "ClassLoader.js(143): sGetLibraryUrl");
            }
            ;
        } else {
            if (!bSuppressError) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Could not load class ' + sClassName + ', no library found', "ClassLoader.js(146): sGetLibraryUrl");
                }
                ;
            }

            return null;
        }

        sFile = sClassName;
        sUrl = '';
        oApplyTo = window;
        aParts = null;

        if (sFile["indexOf"]('.') > -1) {
            aParts = sFile["split"]('.');
            sFile = aParts[0];
            for (i = 0; i < aParts["length"] - 1; i++) {
                if (!oApplyTo[aParts[i]]) {
                    oApplyTo[aParts[i]] = {};
                }
                oApplyTo = oApplyTo[aParts[i]];
                sFile = sFile + '/' + aParts[i + 1];
            }
            sUrl = oLibrary["sUrlTemplate"]["replace"](/\$\$/, '/' + sFile);
        } else {
            if (oLibrary["bRemovePrefix"]) {
                sFile = sFile["substr"](oLibrary["sPrefix"]["length"]);
            }
            sUrl = oLibrary["sUrlTemplate"]["replace"](/\$\$/, sFile);
        }

        return sUrl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["sGetLibraryUrl"] = 0;
    }
    ;

    /**
     * Applies the given code to a new script tag into the page
     * @param {string} sCode the js code to apply
     * @private
     */
    UCF_ClassLoader["applyScriptTag"] = function (sCode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["applyScriptTag"]++;
        }
        ;
        /** @type {HTMLScriptElement} */
        var oScript = document["createElement"]('script');

        oScript["setAttribute"]('nonce', window["UCF_System"]["sNonce"]);
        oScript["setAttribute"]('type', 'text/javascript');
        oScript["text"] = sCode;
        document["getElementsByTagName"]('head')[0]["appendChild"](oScript);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["applyScriptTag"] = 0;
    }
    ;

    /**
     * Loads a JS class with the given name from the js/classes
     * folder
     *
     * @param {string} sClassName the name of the class to load.
     * @param {string} sUrl (optional) The absolute URL to the js implementation
     * @param {boolean} bSuppressError (optional) Whether to suppress errors while
     * loading the class.
     * @return {string} a string of the class impl
     * @private
     */
    UCF_ClassLoader["sGetClassString"] = function (sClassName, sUrl, bSuppressError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["sGetClassString"]++;
        }
        ;
        /** @type {string} */
        var sClassString = null;
        /** @type {{bSuccess: boolean, sStatusCode: string, oParseError: Object, sText: string, oJson: Object, oDocument: Document}} */
        var oResponse;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === 'string', "typeof sClassName === 'string'", "ClassLoader.js(210): sGetClassString");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sClassName !== '', "sClassName !== ''", "ClassLoader.js(211): sGetClassString");
        }
        ;

        if (sClassName in UCF_ClassLoader["mClassStrings"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Class ' + sClassName + ' was delivered by class string cache', "ClassLoader.js(214): sGetClassString");
            }
            ;
            sClassString = UCF_ClassLoader["mClassStrings"][sClassName];
        } else if (
            sClassName in sap["ls"]["preload"] &&
            UCF_JsUtil["bIsFunction"](sap["ls"]["preload"][sClassName]["toString"])
        ) {
            sClassString = 'sap.ls.preload.' + sClassName + ' = ' + sap["ls"]["preload"][sClassName]["toString"]();
            UCF_ClassLoader["mClassStrings"][sClassName] = sClassString;
        } else {
            oResponse = null;

            if (!sUrl) {
                sUrl = UCF_ClassLoader["sGetLibraryUrl"](sClassName, bSuppressError);
                if (!sUrl) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Could not load class because URL cannot be determined', "ClassLoader.js(228): sGetClassString");
                    }
                    ;

                    return null;
                }
            }

            oResponse = UCF_RequestUtil["sendSyncRequest"](sUrl);

            if (oResponse["bSuccess"]) {
                sClassString = oResponse["sText"];

                try {
                    sClassString += '\r\n//# sourceURL='
                        + document["location"]["protocol"]
                        + '//'
                        + document["location"]["host"]
                        + sUrl["substring"](0, sUrl["indexOf"]('?'));
                } catch (ex) {
                }
            } else {
                sClassString = null;
                if (!bSuppressError) {
                    UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["NETWORK"]);
                }
            }

            UCF_ClassLoader["mClassStrings"][sClassName] = sClassString;
        }

        return sClassString;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["sGetClassString"] = 0;
    }
    ;

    /**
     * Returns the class from window.
     *
     * Returns null when class is loaded but invalid
     * Returns 'undefined' when it is not loaded adn yet undefined
     *
     * @param {string} sClassName The classname of the class to load
     * @return {Object} The class
     * @private
     */
    UCF_ClassLoader["oGetLoadedClass"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["oGetLoadedClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === 'string' && sClassName !== '', "typeof sClassName === 'string' && sClassName !== ''", "ClassLoader.js(270): oGetLoadedClass");
        }
        ;

        return UCF_JsUtil["reduce"](sClassName["split"]('.'), function (oParent, sPart) {
            return oParent && oParent[sPart];
        }, window);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["oGetLoadedClass"] = 0;
    }
    ;

    /**
     * Loads a JS class with the given name from the js/classes
     * folder
     *
     * @param {string} sClassName the name of the class to load.
     * @param {string} [sUrl] The absolute URL to the js implementation
     * @param {boolean} [bSuppressError] Whether to suppress errors while loading
     * the class
     * @private
     */
    UCF_ClassLoader["loadClass"] = function (sClassName, sUrl, bSuppressError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["loadClass"]++;
        }
        ;
        /** @type {string} */
        var sClassString;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === 'string', "typeof sClassName === 'string'", "ClassLoader.js(291): loadClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sClassName !== '', "sClassName !== ''", "ClassLoader.js(292): loadClass");
        }
        ;

        if (window[sClassName]) {
            // class already loaded
        } else if (sClassName in sap["ls"]["preload"]) {
            // class preloaded
            if (sClassName in UCF_ClassLoader["oPreloadExpansionCallbackIds"]) {
                UCF_JsUtil["cancelIdleCallback"](
                    UCF_ClassLoader["oPreloadExpansionCallbackIds"][sClassName]
                );
                delete UCF_ClassLoader["oPreloadExpansionCallbackIds"][sClassName];
            }
            sap["ls"]["preload"][sClassName]();
        } else {
            // class not available
            sClassString = UCF_ClassLoader["sGetClassString"](
                sClassName,
                sUrl,
                bSuppressError
            );

            if (sClassString) {
                if (window["execScript"]) {
                    window["execScript"](sClassString);
                } else {
                    UCF_JsUtil["rawEval"](sClassString);
                }

                if (sClassName in sap["ls"]["preload"]) {
                    sap["ls"]["preload"][sClassName]();
                }
            } else {
                window[sClassName] = null;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["loadClass"] = 0;
    }
    ;

    /**
     * Returns the constructor function of a given class name
     * If the class does not exist, it will be loaded first.
     *
     * @param {string} sClassName the name of the class to load
     * @param {string} [sUrl] The absolute URL to the js implementation
     * @param {boolean} [bSuppressError] Whether to suppress errors while
     * loading the class
     *
     * @return {Object} the class
     */
    UCF_ClassLoader["oGetClass"] = function (sClassName, sUrl, bSuppressError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["oGetClass"]++;
        }
        ;
        /** @type {Object} */
        var oClass;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === 'string' && sClassName !== '', "typeof sClassName === 'string' && sClassName !== ''", "ClassLoader.js(344): oGetClass");
        }
        ;

        oClass = UCF_ClassLoader["oGetLoadedClass"](sClassName);

        if (oClass !== null && (!oClass || typeof oClass !== 'function')) {
            UCF_ClassLoader["loadClass"](sClassName, sUrl, bSuppressError);
            oClass = UCF_ClassLoader["oGetLoadedClass"](sClassName);
        }

        if (!bSuppressError) {
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(oClass, "oClass", "ClassLoader.js(354): oGetClass");
            }
            ;
        }

        return oClass;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["oGetClass"] = 0;
    }
    ;

    /**
     * Connects this class loader to a given parent class loader
     * @param {UCF_ClassLoader} oParentClassLoader The class loader from a
     * different window
     * @public
     */
    UCF_ClassLoader["connectToParentClassLoader"] = function (oParentClassLoader) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["connectToParentClassLoader"]++;
        }
        ;
        if (oParentClassLoader && oParentClassLoader["mClassStrings"]) {
            UCF_ClassLoader["mClassStrings"] = oParentClassLoader["mClassStrings"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["connectToParentClassLoader"] = 0;
    }
    ;

    /**
     * Requests idle callbacks to unpack all wrappers in sap.ls.preload. If the
     * class is synchonously unpacked before the idle callback fired (i.e. because
     * it was requested via oGetClass()), the callback is canceled.
     *
     * @protected
     * @see UCF_ClassLoader#loadClass
     */
    UCF_ClassLoader["requestPreloadExpansion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["requestPreloadExpansion"]++;
        }
        ;
        /** @type {string} */
        var n;

        if (sap && sap["ls"] && sap["ls"]["preload"]) {
            for (n in sap["ls"]["preload"]) {
                if (!(n in window)) {
                    UCF_ClassLoader["oPreloadExpansionCallbackIds"][n] = UCF_JsUtil["requestIdleCallback"](
                        UCF_ClassLoader["fCreatePreloadExpander"](n)
                    );
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["requestPreloadExpansion"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sClassName
     * @return {function({didTimeout: boolean, timeRemaining: function(): number}): void}
     */
    UCF_ClassLoader["fCreatePreloadExpander"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClassLoader["_"]["fCreatePreloadExpander"]++;
        }
        ;

        /** @param {{didTimeout: boolean, timeRemaining: function(): number}} oDeadline */
        function expandPreload(oDeadline) {
            if (!oDeadline["didTimeout"] && oDeadline["timeRemaining"]() > 10) {
                if (!(sClassName in window)) {
                    sap["ls"]["preload"][sClassName]();
                }
                UCF_ClassLoader["oPreloadExpansionCallbackIds"][sClassName] = undefined;
            } else {
                UCF_ClassLoader["oPreloadExpansionCallbackIds"][sClassName] = UCF_JsUtil["requestIdleCallback"](expandPreload);
            }
        };

        return expandPreload;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClassLoader["_"]["fCreatePreloadExpander"] = 0;
    }
    ;

    sap["ls"]["declare"] = function (sName, fConstructor) {
        /** @type {Array.<string>} */
        var aNames = sName["split"]('.');
        /** @type {Object} */
        var o = window;
        /** @type {number} */
        var i;

        for (i = 0; i < aNames["length"]; i++) {
            if (!o[aNames[i]]) {
                o[aNames[i]] = {};
            }
            o = o[aNames[i]];
        }

        o = {};

        return o;
    };

    sap["ls"]["require"] = function (sClassName, fThen) {
        /**
         * @param {string} sClassName
         * @return {UCF_Control}
         */
        function requireSync(sClassName) {
            return UCF_ClassLoader["oGetClass"](sClassName);
        }

        if (typeof sClassName === 'string') {
            return requireSync(sClassName);
        } else if (UCF_JsUtil["bIsArray"](sClassName)
            && UCF_JsUtil["bIsFunction"](fThen)
        ) {
            // TODO convert sync to async loading, e.g. Promise.all(..).then(..)
            fThen["apply"](null, UCF_JsUtil["map"](sClassName, requireSync));

            return null;
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'unknown require(' + typeof sClassName + ')', "ClassLoader.js(456): require");
            }
            ;

            return requireSync(sClassName);
        }
    };

    sap["ls"]["implement"] = function (sImplClassName) {
        return UCF_ClassLoader["oGetClass"](sImplClassName, null, true);
    };

    sap["ls"]["extend"] = function (oA, oB) {
        /** @type {string} */
        var n;

        for (n in oB) {
            if (!oA[n]) {
                oA[n] = oB[n];
            }
        }
    };

    sap["ls"]["factory"] = function (oPrototype) {
        /** @type {function(): void} */
        var Factory = function () {
        };

        Factory["prototype"] = oPrototype;

        return Factory;
    };

    sap["ls"]["newObject"] = function (oPrototype) {
        return new (sap["ls"]["factory"](oPrototype))();
    };

    /**
     * @type {Object.<string,function():void>} contains functions that, when
     * executed, export a class to the window namespace
     */
    sap["ls"]["preload"] = {};

    UCF_ClassLoader.prototype["aPublicMethods"] = ["connectToParentClassLoader"].concat(UCF_ClassLoader.prototype.aPublicMethods || []);

    /**
     *
     *
     * HotkeyValues enumeration
     *
     * @class
     */
    function UCF_HotkeyValues() {
        if (__UCF_COVERAGE__) {
            UCF_HotkeyValues["_"]["UCF_HotkeyValues"]++;
        }
        ;

    };window["UCF_HotkeyValues"] = UCF_HotkeyValues;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_HotkeyValues");
        UCF_HotkeyValues["_"] = {UCF_HotkeyValues: 0};
    }
    ;
    ;

    UCF_HotkeyValues['CTRL_0'] = true;
    UCF_HotkeyValues['CTRL_1'] = true;
    UCF_HotkeyValues['CTRL_2'] = true;
    UCF_HotkeyValues['CTRL_3'] = true;
    UCF_HotkeyValues['CTRL_4'] = true;
    UCF_HotkeyValues['CTRL_5'] = true;
    UCF_HotkeyValues['CTRL_6'] = true;
    UCF_HotkeyValues['CTRL_7'] = true;
    UCF_HotkeyValues['CTRL_8'] = true;
    UCF_HotkeyValues['CTRL_9'] = true;

    UCF_HotkeyValues['CTRL_A'] = true;
    UCF_HotkeyValues['CTRL_B'] = true;
    UCF_HotkeyValues['CTRL_C'] = true;
    UCF_HotkeyValues['CTRL_D'] = true;
    UCF_HotkeyValues['CTRL_E'] = true;
    UCF_HotkeyValues['CTRL_F'] = true;
    UCF_HotkeyValues['CTRL_G'] = true;
    UCF_HotkeyValues['CTRL_H'] = true;
    UCF_HotkeyValues['CTRL_I'] = true;
    UCF_HotkeyValues['CTRL_J'] = true;
    UCF_HotkeyValues['CTRL_K'] = true;
    UCF_HotkeyValues['CTRL_L'] = true;
    UCF_HotkeyValues['CTRL_M'] = true;
    UCF_HotkeyValues['CTRL_N'] = true;
    UCF_HotkeyValues['CTRL_O'] = true;
    UCF_HotkeyValues['CTRL_P'] = true;
    UCF_HotkeyValues['CTRL_Q'] = true;
    UCF_HotkeyValues['CTRL_R'] = true;
    UCF_HotkeyValues['CTRL_S'] = true;
    UCF_HotkeyValues['CTRL_T'] = true;
    UCF_HotkeyValues['CTRL_U'] = true;
    UCF_HotkeyValues['CTRL_V'] = true;
    UCF_HotkeyValues['CTRL_W'] = true;
    UCF_HotkeyValues['CTRL_X'] = true;
    UCF_HotkeyValues['CTRL_Y'] = true;
    UCF_HotkeyValues['CTRL_Z'] = true;

    UCF_HotkeyValues['CTRL_DOT'] = true;
    UCF_HotkeyValues['CTRL_COMMA'] = true;

    UCF_HotkeyValues['ESCAPE'] = true;
    UCF_HotkeyValues['DELETE'] = true;
    UCF_HotkeyValues['INSERT'] = true;
    UCF_HotkeyValues['ENTER'] = true;

    UCF_HotkeyValues['F1'] = true;
    UCF_HotkeyValues['F2'] = true;
    UCF_HotkeyValues['F3'] = true;
    UCF_HotkeyValues['F4'] = true;
    UCF_HotkeyValues['F5'] = true;
    UCF_HotkeyValues['F6'] = true;
    UCF_HotkeyValues['F7'] = true;
    UCF_HotkeyValues['F8'] = true;
    UCF_HotkeyValues['F9'] = true;
    UCF_HotkeyValues['F10'] = true;
    UCF_HotkeyValues['F11'] = true;
    UCF_HotkeyValues['F12'] = true;

    UCF_HotkeyValues['CTRL_F1'] = true;
    UCF_HotkeyValues['CTRL_F2'] = true;
    UCF_HotkeyValues['CTRL_F3'] = true;
    UCF_HotkeyValues['CTRL_F4'] = false;
    UCF_HotkeyValues['CTRL_F5'] = true;
    UCF_HotkeyValues['CTRL_F6'] = true;
    UCF_HotkeyValues['CTRL_F7'] = true;
    UCF_HotkeyValues['CTRL_F8'] = true;
    UCF_HotkeyValues['CTRL_F9'] = true;
    UCF_HotkeyValues['CTRL_F10'] = true;
    UCF_HotkeyValues['CTRL_F11'] = true;
    UCF_HotkeyValues['CTRL_F12'] = true;

    UCF_HotkeyValues['CTRL_SHIFT_F1'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F2'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F3'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F4'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F5'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F6'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F7'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F8'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F9'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F10'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F11'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F12'] = true;

    UCF_HotkeyValues['SHIFT_F1'] = true;
    UCF_HotkeyValues['SHIFT_F2'] = true;
    UCF_HotkeyValues['SHIFT_F3'] = true;
    UCF_HotkeyValues['SHIFT_F4'] = true;
    UCF_HotkeyValues['SHIFT_F5'] = true;
    UCF_HotkeyValues['SHIFT_F6'] = true;
    UCF_HotkeyValues['SHIFT_F7'] = true;
    UCF_HotkeyValues['SHIFT_F8'] = true;
    UCF_HotkeyValues['SHIFT_F9'] = true;
    UCF_HotkeyValues['SHIFT_F10'] = true;
    UCF_HotkeyValues['SHIFT_F11'] = true;
    UCF_HotkeyValues['SHIFT_F12'] = true;

    UCF_HotkeyValues['CTRL_ALT_N'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_0'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_1'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_2'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_3'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_4'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_5'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_6'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_7'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_8'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_9'] = true;

    UCF_HotkeyValues['CTRL_SHIFT_A'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_B'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_C'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_D'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_E'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_F'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_G'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_H'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_I'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_J'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_K'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_L'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_M'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_N'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_O'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_P'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_Q'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_R'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_S'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_T'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_U'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_V'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_W'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_X'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_Y'] = true;
    UCF_HotkeyValues['CTRL_SHIFT_Z'] = true;

    UCF_HotkeyValues['ALT_ARROW_LEFT'] = true;
    UCF_HotkeyValues['ALT_ARROW_UP'] = true;
    UCF_HotkeyValues['ALT_ARROW_RIGHT'] = true;
    UCF_HotkeyValues['ALT_ARROW_DOWN'] = true;

    /**
     * KeyCodes enumeration
     *
     * @class
     *
     *
     * @see KeyNames
     * @version
     */
    function UCF_KeyCodes() {
        if (__UCF_COVERAGE__) {
            UCF_KeyCodes["_"]["UCF_KeyCodes"]++;
        }
        ;

    };window["UCF_KeyCodes"] = UCF_KeyCodes;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_KeyCodes");
        UCF_KeyCodes["_"] = {UCF_KeyCodes: 0};
    }
    ;
    ;

    UCF_KeyCodes["BACKSPACE"] = 8;
    UCF_KeyCodes["TAB"] = 9;
    UCF_KeyCodes["ENTER"] = 13;
    UCF_KeyCodes["SHIFT"] = 16;
    UCF_KeyCodes["CONTROL"] = 17;
    UCF_KeyCodes["ALT"] = 18;
    UCF_KeyCodes["BREAK"] = 19;
    UCF_KeyCodes["CAPS_LOCK"] = 20;
    UCF_KeyCodes["ESCAPE"] = 27;
    UCF_KeyCodes["SPACE"] = 32;
    UCF_KeyCodes["PAGE_UP"] = 33;
    UCF_KeyCodes["PAGE_DOWN"] = 34;
    UCF_KeyCodes["END"] = 35;
    UCF_KeyCodes["HOME"] = 36;
    UCF_KeyCodes["ARROW_LEFT"] = 37;
    UCF_KeyCodes["ARROW_UP"] = 38;
    UCF_KeyCodes["ARROW_RIGHT"] = 39;
    UCF_KeyCodes["ARROW_DOWN"] = 40;
    UCF_KeyCodes["PRINT"] = 44;
    UCF_KeyCodes["INSERT"] = 45;
    UCF_KeyCodes["DELETE"] = 46;
    UCF_KeyCodes["_0"] = 48;
    UCF_KeyCodes["_1"] = 49;
    UCF_KeyCodes["_2"] = 50;
    UCF_KeyCodes["_3"] = 51;
    UCF_KeyCodes["_4"] = 52;
    UCF_KeyCodes["_5"] = 53;
    UCF_KeyCodes["_6"] = 54;
    UCF_KeyCodes["_7"] = 55;
    UCF_KeyCodes["_8"] = 56;
    UCF_KeyCodes["_9"] = 57;
    UCF_KeyCodes["A"] = 65;
    UCF_KeyCodes["B"] = 66;
    UCF_KeyCodes["C"] = 67;
    UCF_KeyCodes["D"] = 68;
    UCF_KeyCodes["E"] = 69;
    UCF_KeyCodes["F"] = 70;
    UCF_KeyCodes["G"] = 71;
    UCF_KeyCodes["H"] = 72;
    UCF_KeyCodes["I"] = 73;
    UCF_KeyCodes["J"] = 74;
    UCF_KeyCodes["K"] = 75;
    UCF_KeyCodes["L"] = 76;
    UCF_KeyCodes["M"] = 77;
    UCF_KeyCodes["N"] = 78;
    UCF_KeyCodes["O"] = 79;
    UCF_KeyCodes["P"] = 80;
    UCF_KeyCodes["Q"] = 81;
    UCF_KeyCodes["R"] = 82;
    UCF_KeyCodes["S"] = 83;
    UCF_KeyCodes["T"] = 84;
    UCF_KeyCodes["U"] = 85;
    UCF_KeyCodes["V"] = 86;
    UCF_KeyCodes["W"] = 87;
    UCF_KeyCodes["X"] = 88;
    UCF_KeyCodes["Y"] = 89;
    UCF_KeyCodes["Z"] = 90;
    UCF_KeyCodes["WINDOWS"] = 91;
    UCF_KeyCodes["CONTEXT_MENU"] = 93;
    UCF_KeyCodes["TURN_OFF"] = 94;
    UCF_KeyCodes["SLEEP"] = 95;
    UCF_KeyCodes["NUMPAD_0"] = 96;
    UCF_KeyCodes["NUMPAD_1"] = 97;
    UCF_KeyCodes["NUMPAD_2"] = 98;
    UCF_KeyCodes["NUMPAD_3"] = 99;
    UCF_KeyCodes["NUMPAD_4"] = 100;
    UCF_KeyCodes["NUMPAD_5"] = 101;
    UCF_KeyCodes["NUMPAD_6"] = 102;
    UCF_KeyCodes["NUMPAD_7"] = 103;
    UCF_KeyCodes["NUMPAD_8"] = 104;
    UCF_KeyCodes["NUMPAD_9"] = 105;
    UCF_KeyCodes["NUMPAD_ASTERISK"] = 106;
    UCF_KeyCodes["NUMPAD_PLUS"] = 107;
    UCF_KeyCodes["NUMPAD_MINUS"] = 109;
    UCF_KeyCodes["NUMPAD_COMMA"] = 110;
    UCF_KeyCodes["NUMPAD_SLASH"] = 111;
    UCF_KeyCodes["F1"] = 112;
    UCF_KeyCodes["F2"] = 113;
    UCF_KeyCodes["F3"] = 114;
    UCF_KeyCodes["F4"] = 115;
    UCF_KeyCodes["F5"] = 116;
    UCF_KeyCodes["F6"] = 117;
    UCF_KeyCodes["F7"] = 118;
    UCF_KeyCodes["F8"] = 119;
    UCF_KeyCodes["F9"] = 120;
    UCF_KeyCodes["F10"] = 121;
    UCF_KeyCodes["F11"] = 122;
    UCF_KeyCodes["F12"] = 123;
    UCF_KeyCodes["NUM_LOCK"] = 144;
    UCF_KeyCodes["SCROLL_LOCK"] = 145;
    UCF_KeyCodes["OPEN_BRACKET"] = 186;
    UCF_KeyCodes["PLUS"] = 187;
    UCF_KeyCodes["COMMA"] = 188;
    UCF_KeyCodes["DASH"] = 189;
    UCF_KeyCodes["DOT"] = 190;
    UCF_KeyCodes["PIPE"] = 191;
    UCF_KeyCodes["SEMICOLON"] = 192;
    UCF_KeyCodes["MINUS"] = 219;
    UCF_KeyCodes["GREAT_ACCENT"] = 220;
    UCF_KeyCodes["EQUALS"] = 221;
    UCF_KeyCodes["SINGLE_QUOTE"] = 222;
    UCF_KeyCodes["BACKSLASH"] = 22;

    /**
     * Mapping between key code and his string representation
     *
     * @class
     *
     * @see KeyCodes
     * @version
     */
    function UCF_KeyNames() {
        if (__UCF_COVERAGE__) {
            UCF_KeyNames["_"]["UCF_KeyNames"]++;
        }
        ;

    };window["UCF_KeyNames"] = UCF_KeyNames;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_KeyNames");
        UCF_KeyNames["_"] = {UCF_KeyNames: 0};
    }
    ;
    ;

    UCF_KeyNames['8'] = 'BACKSPACE';
    UCF_KeyNames['9'] = 'TAB';
    UCF_KeyNames['13'] = 'ENTER';
    UCF_KeyNames['16'] = 'SHIFT';
    UCF_KeyNames['17'] = 'CONTROL';
    UCF_KeyNames['18'] = 'ALT';
    UCF_KeyNames['19'] = 'BREAK';
    UCF_KeyNames['20'] = 'CAPS_LOCK';
    UCF_KeyNames['27'] = 'ESCAPE';
    UCF_KeyNames['32'] = 'SPACE';
    UCF_KeyNames['33'] = 'PAGE_UP';
    UCF_KeyNames['34'] = 'PAGE_DOWN';
    UCF_KeyNames['35'] = 'END';
    UCF_KeyNames['36'] = 'HOME';
    UCF_KeyNames['37'] = 'ARROW_LEFT';
    UCF_KeyNames['38'] = 'ARROW_UP';
    UCF_KeyNames['39'] = 'ARROW_RIGHT';
    UCF_KeyNames['40'] = 'ARROW_DOWN';
    UCF_KeyNames['44'] = 'PRINT';
    UCF_KeyNames['45'] = 'INSERT';
    UCF_KeyNames['46'] = 'DELETE';
    UCF_KeyNames['48'] = '0';
    UCF_KeyNames['49'] = '1';
    UCF_KeyNames['50'] = '2';
    UCF_KeyNames['51'] = '3';
    UCF_KeyNames['52'] = '4';
    UCF_KeyNames['53'] = '5';
    UCF_KeyNames['54'] = '6';
    UCF_KeyNames['55'] = '7';
    UCF_KeyNames['56'] = '8';
    UCF_KeyNames['57'] = '9';
    UCF_KeyNames['65'] = 'A';
    UCF_KeyNames['66'] = 'B';
    UCF_KeyNames['67'] = 'C';
    UCF_KeyNames['68'] = 'D';
    UCF_KeyNames['69'] = 'E';
    UCF_KeyNames['70'] = 'F';
    UCF_KeyNames['71'] = 'G';
    UCF_KeyNames['72'] = 'H';
    UCF_KeyNames['73'] = 'I';
    UCF_KeyNames['74'] = 'J';
    UCF_KeyNames['75'] = 'K';
    UCF_KeyNames['76'] = 'L';
    UCF_KeyNames['77'] = 'M';
    UCF_KeyNames['78'] = 'N';
    UCF_KeyNames['79'] = 'O';
    UCF_KeyNames['80'] = 'P';
    UCF_KeyNames['81'] = 'Q';
    UCF_KeyNames['82'] = 'R';
    UCF_KeyNames['83'] = 'S';
    UCF_KeyNames['84'] = 'T';
    UCF_KeyNames['85'] = 'U';
    UCF_KeyNames['86'] = 'V';
    UCF_KeyNames['87'] = 'W';
    UCF_KeyNames['88'] = 'X';
    UCF_KeyNames['89'] = 'Y';
    UCF_KeyNames['90'] = 'Z';
    UCF_KeyNames['91'] = 'WINDOWS';
    UCF_KeyNames['93'] = 'CONTEXT_MENU';
    UCF_KeyNames['94'] = 'TURN_OFF';
    UCF_KeyNames['95'] = 'SLEEP';
    UCF_KeyNames['96'] = 'NUMPAD_0';
    UCF_KeyNames['97'] = 'NUMPAD_1';
    UCF_KeyNames['98'] = 'NUMPAD_2';
    UCF_KeyNames['99'] = 'NUMPAD_3';
    UCF_KeyNames['100'] = 'NUMPAD_4';
    UCF_KeyNames['101'] = 'NUMPAD_5';
    UCF_KeyNames['102'] = 'NUMPAD_6';
    UCF_KeyNames['103'] = 'NUMPAD_7';
    UCF_KeyNames['104'] = 'NUMPAD_8';
    UCF_KeyNames['105'] = 'NUMPAD_9';
    UCF_KeyNames['106'] = 'NUMPAD_ASTERISK';
    UCF_KeyNames['107'] = 'NUMPAD_PLUS';
    UCF_KeyNames['109'] = 'NUMPAD_MINUS';
    UCF_KeyNames['110'] = 'NUMPAD_COMMA';
    UCF_KeyNames['111'] = 'NUMPAD_SLASH';
    UCF_KeyNames['112'] = 'F1';
    UCF_KeyNames['113'] = 'F2';
    UCF_KeyNames['114'] = 'F3';
    UCF_KeyNames['115'] = 'F4';
    UCF_KeyNames['116'] = 'F5';
    UCF_KeyNames['117'] = 'F6';
    UCF_KeyNames['118'] = 'F7';
    UCF_KeyNames['119'] = 'F8';
    UCF_KeyNames['120'] = 'F9';
    UCF_KeyNames['121'] = 'F10';
    UCF_KeyNames['122'] = 'F11';
    UCF_KeyNames['123'] = 'F12';
    UCF_KeyNames['144'] = 'NUM_LOCK';
    UCF_KeyNames['145'] = 'SCROLL_LOCK';
    UCF_KeyNames['186'] = 'OPEN_BRACKET';
    UCF_KeyNames['187'] = 'PLUS';
    UCF_KeyNames['188'] = 'COMMA';
    UCF_KeyNames['189'] = 'SLASH';
    UCF_KeyNames['190'] = 'DOT';
    UCF_KeyNames['191'] = 'PIPE';
    UCF_KeyNames['192'] = 'SEMICOLON';
    UCF_KeyNames['219'] = 'MINUS';
    UCF_KeyNames['220'] = 'GREAT_ACCENT';
    UCF_KeyNames['221'] = 'EQUALS';
    UCF_KeyNames['222'] = 'SINGLE_QUOTE';
    UCF_KeyNames['226'] = 'BACKSLASH';

    /* global UCF_Global */
/// <reference path="./Global.js"/>
    /* global UCF_Interface */
/// <reference path="./Interface.js"/>
    /* global UCF_JsUtil */

/// <reference path="./util/JsUtil.js"/>

    /**
     * The base class for all UCF objects
     *
     * @class
     *
     * @version
     */
    function UCF_Object() {
        if (__UCF_COVERAGE__) {
            UCF_Object["_"]["UCF_Object"]++;
        }
        ;
        /** @type {boolean} */
        this["bIsDestroyed"] = false;
    };window["UCF_Object"] = UCF_Object;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Object");
        UCF_Object["_"] = {UCF_Object: 0};
    }
    ;
    ;

    /**
     * Destructor method for objects
     * @private
     */
    UCF_Object["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Object["_"]["destroy"]++;
        }
        ;  // eslint-disable-line ur/no-memory-leaks
        if (!this["bIsDestroyed"]) {
            if (UCF_Global["_checkLeaks"]) {
                UCF_JsUtil["checkPossibleLeaks"](this);
            }

            this["bIsDestroyed"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Object["_"]["destroy"] = 0;
    }
    ;

    /**
     * Returns an interface for the object
     * @return {UCF_Interface} The interface for the object
     * @private
     */
    UCF_Object["prototype"]["oGetInterface"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Object["_"]["oGetInterface"]++;
        }
        ;
        return new UCF_Interface(this, this["aPublicMethods"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Object["_"]["oGetInterface"] = 0;
    }
    ;

    /* global UCF_Object */
/// <reference path="./Object.js"/>
    /* global _assert */

/// <reference path="./debug/Tracer.js"/>

    /**
     * Event object, consists of an numerical id and a map of parameters
     *
     *
     *
     * @constructor
     * @template {Object} T
     * @param {number} iId The id of the event
     * @param {T} mParameters A map of parameters for this event
     */
    function UCF_Event(iId, mParameters) {
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["UCF_Event"]++;
        }
        ;
        if (arguments["length"] > 0) {
            UCF_Object["apply"](this);

            this["init"](iId, mParameters);
        }
    };window["UCF_Event"] = UCF_Event;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Event");
        UCF_Event["_"] = {UCF_Event: 0};
    }
    ;
    ;
    UCF_Event["prototype"] = new UCF_Object();
    UCF_Event.prototype["sClassName"] = "UCF_Event";

    /**
     * Copy this event instance. The parameter names and values are copied (no
     * deep-copy).
     *
     * @return {UCF_Event<T>} The new event instance
     */
    UCF_Event["prototype"]["copy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["copy"]++;
        }
        ;
        return new UCF_Event(this["iId"], this["mParameters"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["copy"] = 0;
    }
    ;

    /**
     * Init event with data, needed for pooling
     *
     * @private
     * @param {number} iId the id of the event
     * @param {T} mParameters the event parameters
     */
    UCF_Event["prototype"]["init"] = function (iId, mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["init"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iId === 'number' || typeof iId === 'string', "typeof iId === 'number' || typeof iId === 'string'", "Event.js(43): init");
        }
        ;

        /** @type {number} */
        // eslint-disable-next-line ur/no-memory-leaks
        this["iId"] = iId;
        /** @type {T} */
        this["mParameters"] = mParameters;

        if (!mParameters) {
            mParameters = {};
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["init"] = 0;
    }
    ;

    /**
     * Reset event data, needed for pooling
     * @private
     */
    UCF_Event["prototype"]["reset"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["reset"]++;
        }
        ;
        /** @type {number} */
        this["iId"] = 0;
        /** @type {T} */
        this["mParameters"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["reset"] = 0;
    }
    ;

    /**
     * @protected
     * @return {number} The id of the event
     */
    UCF_Event["prototype"]["iGetId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["iGetId"]++;
        }
        ;
        return this["iId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["iGetId"] = 0;
    }
    ;

    /**
     * @protected
     * @return {T} All parameters of the event
     */
    UCF_Event["prototype"]["mGetParameters"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["mGetParameters"]++;
        }
        ;
        return this["mParameters"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["mGetParameters"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sName The name of the parameter to return.
     * @return {any} The parameter value of the event or null.
     */
    UCF_Event["prototype"]["oGetParam"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["oGetParam"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "Event.js(89): oGetParam");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName !== '', "sName !== ''", "Event.js(90): oGetParam");
        }
        ;

        return this["mParameters"] === undefined || this["mParameters"] === null
            ? null
            : this["mParameters"][sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["oGetParam"] = 0;
    }
    ;

    /**
     * @private
     */
    UCF_Event["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Event["_"]["destroy"]++;
        }
        ;
        this["mParameters"] = null;
        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Event["_"]["destroy"] = 0;
    }
    ;

    /* global UCF_Object */
/// <reference path="./Object.js"/>
    /* global UCF_JsUtil */

/// <reference path="./util/JsUtil.js"/>

    /**
     * Object pool
     *
     *
     * @class
     * @param {Object} oObjectClass class of objects this pool should manage
     */
    function UCF_ObjectPool(oObjectClass) {
        if (__UCF_COVERAGE__) {
            UCF_ObjectPool["_"]["UCF_ObjectPool"]++;
        }
        ;

        UCF_Object["apply"](this);

        this["oObjectClass"] = oObjectClass;

        this["aFreeObjects"] = [];
        this["aUsedObjects"] = [];

    };window["UCF_ObjectPool"] = UCF_ObjectPool;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ObjectPool");
        UCF_ObjectPool["_"] = {UCF_ObjectPool: 0};
    }
    ;
    UCF_ObjectPool["prototype"] = new UCF_Object();
    UCF_ObjectPool.prototype["sClassName"] = "UCF_ObjectPool";

    /** @override */
    UCF_ObjectPool["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ObjectPool["_"]["destroy"]++;
        }
        ;
        UCF_JsUtil["forEach"](this["aFreeObjects"]["concat"](this["aUsedObjects"]), function (oObj) {
            if (oObj && oObj["bIsDestroyed"] === false && oObj["destroy"]) {
                oObj["destroy"]();
            }
        });

        this["aFreeObjects"] = null;
        this["aUsedObjects"] = null;
        this["oObjectClass"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ObjectPool["_"]["destroy"] = 0;
    }
    ;

    /**
     * Borrows an object from the pool
     * @return {Object} The borrowed object
     * @private
     */
    UCF_ObjectPool["prototype"]["oBorrowObject"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ObjectPool["_"]["oBorrowObject"]++;
        }
        ;

        if (this["aFreeObjects"]["length"] === 0) this["createObject"]();

        var oObject = this["aFreeObjects"]["pop"]();
        oObject["init"]["apply"](oObject, arguments);
        this["aUsedObjects"]["push"](oObject);

        return oObject;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ObjectPool["_"]["oBorrowObject"] = 0;
    }
    ;

    /**
     * Returns an object to the pool
     *
     * @param  {Object} oObject the object to return to the pool
     * @private
     */
    UCF_ObjectPool["prototype"]["returnObject"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ObjectPool["_"]["returnObject"]++;
        }
        ;

        oObject["reset"]();

        // TODO if borrowed several objects in parallel, this pop can
        // return wrong object ?!
        this["aUsedObjects"]["pop"]();
        this["aFreeObjects"]["push"](oObject);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ObjectPool["_"]["returnObject"] = 0;
    }
    ;

    /**
     * Creates a new object
     * @private
     */
    UCF_ObjectPool["prototype"]["createObject"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ObjectPool["_"]["createObject"]++;
        }
        ;
        var oObject = new this["oObjectClass"]();
        this["aFreeObjects"]["push"](oObject);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ObjectPool["_"]["createObject"] = 0;
    }
    ;

    /* global UCF_Event */
/// <reference path="./Event.js"/>
    /* global UCF_Object */
/// <reference path="./Object.js"/>
    /* global UCF_ObjectPool */
/// <reference path="./ObjectPool.js"/>
    /* global _assert */
/// <reference path="./debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="./util/JsUtil.js"/>

    /**
     * @typedef {Object} UCF_EventProvider_ObjectListener
     * @property {Object} oListener
     * @property {string} sFunction
     */
    /**
     * @typedef {Object} UCF_EventProvider_FunctionListener
     * @property {function(UCF_Event): void} oListener
     */
    /** @typedef {UCF_EventProvider_FunctionListener|UCF_EventProvider_ObjectListener} UCF_EventProvider_Listener */
    /** @typedef {{[iEventId: number]: UCF_EventProvider_Listener[]}} UCF_EventProvider_Registry */

    /** @typedef {'mEventRegistry'|'mBeforeEventRegistry'|'mAfterEventRegistry'} UCF_EventProvider_RegistryName */

    /**
     * Provides internal eventing facilities for objects, so other objects can attach
     * and detach events, and are notified, when events are fired
     *
     * @depends UCF_ObjectPool
     * @depends UCF_Event
     *
     * @class UCF_EventProvider
     * @extends UCF_Object
     *
     * @version
     */
    function UCF_EventProvider() {
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["UCF_EventProvider"]++;
        }
        ;
        UCF_Object["apply"](this);

        /** @type {UCF_EventProvider_Registry} */
        this["mEventRegistry"] = this["mEventRegistry"] || null;
        /** @type {UCF_EventProvider_Registry} */
        this["mBeforeEventRegistry"] = this["mBeforeEventRegistry"] || null;
        /** @type {UCF_EventProvider_Registry} */
        this["mAfterEventRegistry"] = this["mAfterEventRegistry"] || null;

        /** @type {Object<string, number>} */
        // Don't null E_EVENTS in #destroy(). A control may be destroyed while firing
        // an event and accessing E_EVENTS afterwards (e.g. UCF_Button#handleClick())
        // then throws a NullPointerException.
        // eslint-disable-next-line ur/no-memory-leaks
        this["E_EVENTS"] = this["E_EVENTS"] || {};
    };window["UCF_EventProvider"] = UCF_EventProvider;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_EventProvider");
        UCF_EventProvider["_"] = {UCF_EventProvider: 0};
    }
    ;
    ;
    UCF_EventProvider["prototype"] = new UCF_Object();
    UCF_EventProvider.prototype["sClassName"] = "UCF_EventProvider";

    /** @protected */
    UCF_EventProvider["destroyStatic"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["destroyStatic"]++;
        }
        ;
        UCF_EventProvider["prototype"]["oEventPool"]["destroy"]();
        UCF_EventProvider["prototype"]["oEventPool"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["destroyStatic"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sEvent
     * @param {number} iEventNum
     */
    UCF_EventProvider["prototype"]["defineEvent"] = function (sEvent, iEventNum) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["defineEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sEvent === 'string', "typeof sEvent === 'string'", "EventProvider.js(68): defineEvent");
        }
        ;

        this["E_EVENTS"][sEvent] = iEventNum;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["defineEvent"] = 0;
    }
    ;

    /**
     * @protected
     * @final
     * @param {string[]} aEvents
     */
    UCF_EventProvider["prototype"]["defineEvents"] = function (aEvents) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["defineEvents"]++;
        }
        ;
        /** @type {UCF_EventProvider} */
        var self = this;
        /** @type {string[]} */
        var aNewEvents = UCF_JsUtil["filter"](aEvents, function (sEvent) {
            return !(sEvent in self["E_EVENTS"]);
        });
        /** @type {number} */
        var iAlreadyDefinedEvents = UCF_JsUtil["keys"](this["E_EVENTS"] || {})["length"];

        UCF_JsUtil["forEach"](aNewEvents, function (sEvent, i) {
            self["defineEvent"](sEvent, i + iAlreadyDefinedEvents);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["defineEvents"] = 0;
    }
    ;

    /**
     * Pool is defined on the prototype to be shared among all EventProviders
     */
    UCF_EventProvider["prototype"]["oEventPool"] = new UCF_ObjectPool(UCF_Event);

    /**
     * Adds a event registration for the given object and given event name
     *
     * @private
     * @param {number} iEventId The index of the event to listen for
     * @param {Object|function} oListener The object, that want to be notified, when the event occurs
     * @param {string} sFunction The name of the function to call, when the event occurs
     */
    UCF_EventProvider["prototype"]["attachEvent"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["attachEvent"]++;
        }
        ;
        this["attachToRegistry"](iEventId, oListener, sFunction, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["attachEvent"] = 0;
    }
    ;

    /**
     * Adds a event registration for the given object and given event name before
     * the event will be processed
     *
     * @private
     * @param {number} iEventId The index of the event to listen for
     * @param {Object|function} oListener The object, that want to be notified, when the event occurs
     * @param {string} sFunction The name of the function to call, when the event occurs
     */
    UCF_EventProvider["prototype"]["attachBeforeEvent"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["attachBeforeEvent"]++;
        }
        ;
        this["attachToRegistry"](iEventId, oListener, sFunction, 'mBeforeEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["attachBeforeEvent"] = 0;
    }
    ;

    /**
     * Adds a event registration for the given object and given event name after
     * the event has been processed
     *
     * @private
     * @param {number} iEventId The index of the event to listen for
     * @param {Object|function} oListener The object, that want to be notified, when the event occurs
     * @param {string} sFunction The name of the function to call, when the event occurs
     */
    UCF_EventProvider["prototype"]["attachAfterEvent"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["attachAfterEvent"]++;
        }
        ;
        this["attachToRegistry"](iEventId, oListener, sFunction, 'mAfterEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["attachAfterEvent"] = 0;
    }
    ;

    /**
     * Convenience function to attach to an event and detach in the handler.
     * @param {number} iEventId The index of the event to listen for
     * @param {function} fListener Function to call
     */
    UCF_EventProvider["prototype"]["attachEventOnce"] = function (iEventId, fListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["attachEventOnce"]++;
        }
        ;
        /** @type {UCF_EventProvider} */
        var self = this;
        /** @type {function(): void} */
        var fHandler;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bIsFunction"](fListener), "UCF_JsUtil.bIsFunction(fListener)", "EventProvider.js(147): attachEventOnce");
        }
        ;

        fHandler = function () {
            self["detachFromRegistry"](iEventId, fHandler, 'mEventRegistry');
            fListener();
        };

        this["attachToRegistry"](iEventId, fHandler, null, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["attachEventOnce"] = 0;
    }
    ;

    /**
     * @private
     * @param {number|string} iEventId id of the event to register to
     * @param {Object|function} oListener the listener that should be notified
     * @param {string} [sFunction] the function to call on oListener
     * @param {string} sRegistryName the name of the registry to add the listener to
     */
    UCF_EventProvider["prototype"]["attachToRegistry"] = function (iEventId, oListener, sFunction, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["attachToRegistry"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iEventId === 'number' || typeof iEventId === 'string', "typeof iEventId === 'number' || typeof iEventId === 'string'", "EventProvider.js(165): attachToRegistry");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oListener === 'object' || typeof oListener === 'function', "typeof oListener === 'object' || typeof oListener === 'function'", "EventProvider.js(166): attachToRegistry");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oListener != null, "oListener != null", "EventProvider.js(167): attachToRegistry");
        }
        ;

        if (!this[sRegistryName]) {
            this[sRegistryName] = {};
        }
        if (!this[sRegistryName][iEventId]) {
            this[sRegistryName][iEventId] = [];
        }
        this[sRegistryName][iEventId]["push"]({"oListener": oListener, "sFunction": sFunction});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["attachToRegistry"] = 0;
    }
    ;

    /**
     * Removes a event registration for the given object and given event name
     *
     * @private
     * @param {int} iEventId The index of the event to detach from
     * @param {Object} oListener The object, that want to be notified, when the event occurs
     */
    UCF_EventProvider["prototype"]["detachEvent"] = function (iEventId, oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachEvent"]++;
        }
        ;
        this["detachFromRegistry"](iEventId, oListener, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachEvent"] = 0;
    }
    ;

    /**
     * @private
     * @param {int} iEventId The index of the event to detach from
     * @param {Object} oListener The object, that want to be notified, when the event occurs
     */
    UCF_EventProvider["prototype"]["detachBeforeEvent"] = function (iEventId, oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachBeforeEvent"]++;
        }
        ;
        this["detachFromRegistry"](iEventId, oListener, 'mBeforeEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachBeforeEvent"] = 0;
    }
    ;

    /**
     * @private
     * @param {int} iEventId The index of the event to detach from
     * @param {Object} oListener The object, that want to be notified, when the event occurs
     */
    UCF_EventProvider["prototype"]["detachAfterEvent"] = function (iEventId, oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachAfterEvent"]++;
        }
        ;
        this["detachFromRegistry"](iEventId, oListener, 'mAfterEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachAfterEvent"] = 0;
    }
    ;

    /**
     * @private
     * @param {number|string} iEventId the event id
     * @param {Object|function} oListener the listener to detach
     * @param {string} sRegistryName the name of the registry to detach from
     */
    UCF_EventProvider["prototype"]["detachFromRegistry"] = function (iEventId, oListener, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachFromRegistry"]++;
        }
        ;
        /** @type {Array.<Object>} */
        var aListeners;
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iEventId === 'number' || typeof iEventId === 'string', "typeof iEventId === 'number' || typeof iEventId === 'string'", "EventProvider.js(219): detachFromRegistry");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oListener === 'object' || typeof oListener === 'function', "typeof oListener === 'object' || typeof oListener === 'function'", "EventProvider.js(220): detachFromRegistry");
        }
        ;

        if (this[sRegistryName]) {
            aListeners = this[sRegistryName][iEventId];

            if (aListeners) {
                for (i = 0; i < aListeners["length"]; i++) {
                    if (aListeners[i]["oListener"] === oListener) {
                        aListeners["splice"](i--, 1);
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachFromRegistry"] = 0;
    }
    ;

    /**
     * Removes all event registration for an optinal given object or for all
     *
     * @param {Object} oListener optional The object, that want to be notified, when the event occurs
     *
     * @private
     */
    UCF_EventProvider["prototype"]["detachAllEvents"] = function (oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachAllEvents"]++;
        }
        ;
        this["detachAllFromRegistry"](oListener, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachAllEvents"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object|function} oListener the object to detach all before listeners from
     */
    UCF_EventProvider["prototype"]["detachAllBeforeEvents"] = function (oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachAllBeforeEvents"]++;
        }
        ;
        this["detachAllFromRegistry"](oListener, 'mBeforeEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachAllBeforeEvents"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object|function} oListener the object to detach all after listeners from
     */
    UCF_EventProvider["prototype"]["detachAllAfterEvents"] = function (oListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachAllAfterEvents"]++;
        }
        ;
        this["detachAllFromRegistry"](oListener, 'mAfterEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachAllAfterEvents"] = 0;
    }
    ;

    /**
     * @param {Object|function} oListener the object to detach all listeners
     * @param {string} sRegistryName the name of the registry to detach from
     */
    UCF_EventProvider["prototype"]["detachAllFromRegistry"] = function (oListener, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["detachAllFromRegistry"]++;
        }
        ;
        /** @type {number|string} */
        var iEventId;

        if (this[sRegistryName]) {
            if (oListener) {
                for (iEventId in this[sRegistryName]) {
                    this["detachFromRegistry"](iEventId, oListener, sRegistryName);
                }
            } else {
                this[sRegistryName] = null;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["detachAllFromRegistry"] = 0;
    }
    ;

    /**
     * Fires the given event and notifies all listeners. Listeners must not change
     * the content of the event.
     *
     * @private
     * @param {int} iEventId the event id
     * @param {Object} mParameters the parameter map
     */
    UCF_EventProvider["prototype"]["fireEvent"] = function (iEventId, mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["fireEvent"]++;
        }
        ;
        if (this["bDestroyed"] === true) return;

        /** @type {UCF_Event} */
        var oEvent;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iEventId === 'number' || typeof iEventId === 'string', "typeof iEventId === 'number' || typeof iEventId === 'string'", "EventProvider.js(295): fireEvent");
        }
        ;

        if (
            (this["mBeforeEventRegistry"] && this["mBeforeEventRegistry"][iEventId]) ||
            (this["mEventRegistry"] && this["mEventRegistry"][iEventId]) ||
            (this["mAfterEventRegistry"] && this["mAfterEventRegistry"][iEventId])
        ) {
            oEvent = this["oEventPool"]["oBorrowObject"](iEventId, mParameters);

            if (this["mBeforeEventRegistry"] && this["mBeforeEventRegistry"][iEventId]) {
                this["fireEventToRegistry"](iEventId, oEvent, 'mBeforeEventRegistry');
            }
            if (this["mEventRegistry"] && this["mEventRegistry"][iEventId]) {
                this["fireEventToRegistry"](iEventId, oEvent, 'mEventRegistry');
            }
            if (this["mAfterEventRegistry"] && this["mAfterEventRegistry"][iEventId]) {
                this["fireEventToRegistry"](iEventId, oEvent, 'mAfterEventRegistry');
            }
            // It was destroyed during processing in the handlers (e.g. close of IFrame-popup)
            if (this["bDestroyed"] === true) return;

            this["oEventPool"]["returnObject"](oEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["fireEvent"] = 0;
    }
    ;

    /**
     * @private
     * @param {number} iEventId
     * @param {Object} oEvent
     * @param {UCF_EventProvider_RegistryName} sRegistryName
     */
    UCF_EventProvider["prototype"]["fireEventToRegistry"] = function (iEventId, oEvent, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["fireEventToRegistry"]++;
        }
        ;
        /** @type {Array.<Object|function>} */
        var aEventListeners;

        if (this[sRegistryName]) {
            aEventListeners = this[sRegistryName][iEventId];

            if (aEventListeners) {
                //clone listener array because while execution of handlers entries could be added or removed
                UCF_JsUtil["forEach"](aEventListeners["slice"](0), function (oEntry) {
                    if (oEntry["sFunction"]) {
                        oEntry["oListener"][oEntry["sFunction"]](oEvent);
                    } else {
                        oEntry["oListener"](oEvent);
                    }
                });
            } else {
                throw new Error('Unknown event "' + iEventId + '" in registry "' + sRegistryName + '"');
            }
        } else {
            throw new Error('Unknown registry "' + sRegistryName + '"');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["fireEventToRegistry"] = 0;
    }
    ;

    /**
     * Returns whether the EventProvider has listeners for the given event id
     *
     * @param {int} iEventId the event id
     * @return {boolean} Whether the EventProvider has listeners for the given event id
     *
     * @private
     */
    UCF_EventProvider["prototype"]["hasListeners"] = function (iEventId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["hasListeners"]++;
        }
        ;
        return this["bHasListenersInRegistry"](iEventId, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["hasListeners"] = 0;
    }
    ;

    /**
     * @private
     * @param {number} iEventId the event id
     * @return {boolean} `true` if a before listener is attached, otherwise `false`
     */
    UCF_EventProvider["prototype"]["hasBeforeListeners"] = function (iEventId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["hasBeforeListeners"]++;
        }
        ;
        return this["bHasListenersInRegistry"](iEventId, 'mBeforeEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["hasBeforeListeners"] = 0;
    }
    ;

    /**
     * @private
     * @param {number} iEventId the event id
     * @return {boolean} `true` if an after listener is attached, otherwise `false`
     */
    UCF_EventProvider["prototype"]["hasAfterListeners"] = function (iEventId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["hasAfterListeners"]++;
        }
        ;
        return this["bHasListenersInRegistry"](iEventId, 'mAfterEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["hasAfterListeners"] = 0;
    }
    ;

    /**
     * @private
     * @param {number} iEventId the event id
     * @param {string} sRegistryName the name of the registry to look at
     * @return {boolean} `true` if a listener was found, otherwise `false`
     */
    UCF_EventProvider["prototype"]["bHasListenersInRegistry"] = function (iEventId, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["bHasListenersInRegistry"]++;
        }
        ;
        return this[sRegistryName]
            && this[sRegistryName][iEventId]
            && !UCF_JsUtil["bIsEmpty"](this[sRegistryName][iEventId]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["bHasListenersInRegistry"] = 0;
    }
    ;

    /**
     * @param {number} iEventId the event id
     * @param {object} oListener
     * @param {string} sFunction
     * @return {boolean}
     */
    UCF_EventProvider["prototype"]["bIsListener"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["bIsListener"]++;
        }
        ;
        return this["bIsListenerInRegistry"](iEventId, oListener, sFunction, 'mEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["bIsListener"] = 0;
    }
    ;

    /**
     * @param {number} iEventId the event id
     * @param {object} oListener
     * @param {string} sFunction
     * @return {boolean}
     */
    UCF_EventProvider["prototype"]["bIsBeforeListener"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["bIsBeforeListener"]++;
        }
        ;
        return this["bIsListenerInRegistry"](iEventId, oListener, sFunction, 'mBeforeEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["bIsBeforeListener"] = 0;
    }
    ;

    /**
     * @param {number} iEventId the event id
     * @param {object} oListener
     * @param {string} sFunction
     * @return {boolean}
     */
    UCF_EventProvider["prototype"]["bIsAfterListener"] = function (iEventId, oListener, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["bIsAfterListener"]++;
        }
        ;
        return this["bIsListenerInRegistry"](iEventId, oListener, sFunction, 'mAfterEventRegistry');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["bIsAfterListener"] = 0;
    }
    ;

    /**
     * @private
     * @param {number} iEventId the event id
     * @param {object} oListener
     * @param {string} sFunction
     * @param {string} sRegistryName
     * @return {boolean}
     */
    UCF_EventProvider["prototype"]["bIsListenerInRegistry"] = function (iEventId, oListener, sFunction, sRegistryName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["bIsListenerInRegistry"]++;
        }
        ;
        return this[sRegistryName]
            && this[sRegistryName][iEventId]
            && UCF_JsUtil["find"](this[sRegistryName][iEventId], function (oEntry) {
                return oEntry["oListener"] === oListener
                    && oEntry["sFunction"] === sFunction;
            });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["bIsListenerInRegistry"] = 0;
    }
    ;

    /** @see UCF_Object */
    UCF_EventProvider["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventProvider["_"]["destroy"]++;
        }
        ;
        this["mBeforeEventRegistry"] = null;
        this["mEventRegistry"] = null;
        this["mAfterEventRegistry"] = null;
        this["bDestroyed"] = true;
        UCF_Object.prototype["destroy"]["apply"](this, arguments); // destroy of UCF_Object
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventProvider["_"]["destroy"] = 0;
    }
    ;


    /**
     * A class that creates an Interface for an existing class. If a class returns
     * the interface in its constructor, only the defined functions will be visible,
     * no internals of the class can be accessed.
     *
     * @class
     *
     * @version
     *
     * @param {Object} oObject the instance that needs an interface created
     * @param {Array} aMethods the names of the methods, that should be available
     * on this interface
     */
    function UCF_Interface(oObject, aMethods) {
        aMethods=undefined;
        if (__UCF_COVERAGE__) {
            UCF_Interface["_"]["UCF_Interface"]++;
        }
        ;  // eslint-disable-line ur/no-memory-leaks
        /** @type {string} */
        var sMethodName;
        /** @type {number} */
        var i;
        /** @type {function(Object, string): any} */
        var fCreateDelegator;

        if (oObject && aMethods) {
            // this function is inline to not appear as a method on the interface
            // eslint-disable-next-line require-jsdoc, ur/no-memory-leaks
            fCreateDelegator = function (oObj, sMethod) {
                return function () {
                    return oObj[sMethod]["apply"](oObj, arguments);
                };
            };

            // create functions for all delegated methods
            for (i = 0; i < aMethods["length"]; i++) {
                sMethodName = aMethods[i];
                // eslint-disable-next-line ur/no-memory-leaks
                this[sMethodName] = fCreateDelegator(oObject, sMethodName);
            }
        } else {
            return oObject;
        }
    };window["UCF_Interface"] = UCF_Interface;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Interface");
        UCF_Interface["_"] = {UCF_Interface: 0};
    }
    ;


    /**
     * UCF_ClipboardData
     * Holds info about the contents of the Clipboard
     * @class
     */
    function UCF_ClipboardData() {
        if (__UCF_COVERAGE__) {
            UCF_ClipboardData["_"]["UCF_ClipboardData"]++;
        }
        ;
        this["cleanUp"]();
    };window["UCF_ClipboardData"] = UCF_ClipboardData;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClipboardData");
        UCF_ClipboardData["_"] = {UCF_ClipboardData: 0};
    }
    ;
    ;

    /** @protected */
    UCF_ClipboardData["prototype"]["cleanUp"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardData["_"]["cleanUp"]++;
        }
        ;
        this["oClipboardTable"] = null;
        this["oClipboardContents"] = null;
        this["nColumnCount"] = 0;
        this["sEventSource"] = '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardData["_"]["cleanUp"] = 0;
    }
    ;

    /* global UCF_Object */

/// <reference path="../Object.js"/>

    /**
     * A position is defined by a top and left value
     *
     *
     * @class
     *
     * @param {number} iTop the top position
     * @param {number} iLeft the left position
     */
    function UCF_Position(iTop, iLeft) {
        if (__UCF_COVERAGE__) {
            UCF_Position["_"]["UCF_Position"]++;
        }
        ;
        /** @type {number} */
        this["iTop"] = iTop; //eslint-disable-line ur/no-memory-leaks
        /** @type {number} */
        this["iLeft"] = iLeft; //eslint-disable-line ur/no-memory-leaks
    };window["UCF_Position"] = UCF_Position;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Position");
        UCF_Position["_"] = {UCF_Position: 0};
    }
    ;
    UCF_Position["prototype"] = new UCF_Object();
    UCF_Position.prototype["sClassName"] = "UCF_Position";

    /**
     * Destructor
     */
    UCF_Position["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Position["_"]["destroy"]++;
        }
        ;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Position["_"]["destroy"] = 0;
    }
    ;

    /* global UCF_Object */

/// <reference path="../Object.js"/>

    /**
     * A rectangle is defined by a top position, a left position, a width and a height
     *
     *
     *
     * @class
     *
     * @param {number} iTop the top position
     * @param {number} iLeft the left position
     * @param {number} iWidth the width
     * @param {number} iHeight the height
     */
    function UCF_Rectangle(iTop, iLeft, iWidth, iHeight) {
        if (__UCF_COVERAGE__) {
            UCF_Rectangle["_"]["UCF_Rectangle"]++;
        }
        ;
        /** @type {number} */
        this["iTop"] = iTop; //eslint-disable-line ur/no-memory-leaks
        /** @type {number} */
        this["iLeft"] = iLeft; //eslint-disable-line ur/no-memory-leaks
        /** @type {number} */
        this["iWidth"] = iWidth; //eslint-disable-line ur/no-memory-leaks
        /** @type {number} */
        this["iHeight"] = iHeight; //eslint-disable-line ur/no-memory-leaks
    };window["UCF_Rectangle"] = UCF_Rectangle;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Rectangle");
        UCF_Rectangle["_"] = {UCF_Rectangle: 0};
    }
    ;
    UCF_Rectangle["prototype"] = new UCF_Object();
    UCF_Rectangle.prototype["sClassName"] = "UCF_Rectangle";

    /**
     * Destructor
     */
    UCF_Rectangle["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Rectangle["_"]["destroy"]++;
        }
        ;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Rectangle["_"]["destroy"] = 0;
    }
    ;

    /* global UCF_Object */

/// <reference path="../Object.js"/>

    /**
     * A size is defined by the width and the height
     *
     *
     *
     * @class
     * @param {number} iWidth the width
     * @param {number} iHeight the height
     */
    function UCF_Size(iWidth, iHeight) {
        if (__UCF_COVERAGE__) {
            UCF_Size["_"]["UCF_Size"]++;
        }
        ;
        this["iWidth"] = iWidth; //eslint-disable-line ur/no-memory-leaks
        this["iHeight"] = iHeight; //eslint-disable-line ur/no-memory-leaks
    };window["UCF_Size"] = UCF_Size;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Size");
        UCF_Size["_"] = {UCF_Size: 0};
    }
    ;
    UCF_Size["prototype"] = new UCF_Object();
    UCF_Size.prototype["sClassName"] = "UCF_Size";

    /**
     * equals
     *
     * @private
     * @param {UCF_Size} oSize the size to compare
     * @return {boolean} true if objects are equal
     */
    UCF_Size["prototype"]["equals"] = function (oSize) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Size["_"]["equals"]++;
        }
        ;
        if (oSize === this) {
            return true;
        }

        if (oSize instanceof UCF_Size) {
            return this["iWidth"] === oSize["iWidth"] && this["iHeight"] === oSize["iHeight"];
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Size["_"]["equals"] = 0;
    }
    ;

    /**
     * Destructor
     */
    UCF_Size["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Size["_"]["destroy"]++;
        }
        ;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Size["_"]["destroy"] = 0;
    }
    ;

    /* global _assert */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="./StringUtil.js"/>
    /* global UCF_XSSEncoder */

/// <reference path="./XSSEncoder.js"/>

    /**
     * UCF_AriaStateHelper
     *
     * Provides methods to set the aria states
     *
     *
     * @class
     * @version
     */
    function UCF_AriaStateHelper() {
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["UCF_AriaStateHelper"]++;
        }
        ;

    };window["UCF_AriaStateHelper"] = UCF_AriaStateHelper;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_AriaStateHelper");
        UCF_AriaStateHelper["_"] = {UCF_AriaStateHelper: 0};
    }
    ;
    ;

    /**
     * @private
     * @static
     * @param {HTMLElement} oDomRef the element
     * @param {string} sAttribute the attribute
     * @param {any} oValue the value (`.toString()` will be called on the value to
     * write it to the attribute)
     */
    UCF_AriaStateHelper["setAttribute"] = function (oDomRef, sAttribute, oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setAttribute"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(34): setAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAttribute === 'string', "typeof sAttribute === 'string'", "AriaStateHelper.js(35): setAttribute");
        }
        ;

        if (oDomRef) {
            oDomRef["setAttribute"](sAttribute, oValue["toString"]());
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setAttribute"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {HTMLElement} oDomRef the element
     * @param {string} sAttribute the attribute
     * @param {boolean|string} [sValue] the value or undefined - undefined: Remove the attribute
     */
    UCF_AriaStateHelper["setOrRemoveAttribute"] = function (oDomRef, sAttribute, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setOrRemoveAttribute"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(50): setOrRemoveAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAttribute === 'string', "typeof sAttribute === 'string'", "AriaStateHelper.js(51): setOrRemoveAttribute");
        }
        ;

        if (oDomRef) {
            if (sValue) {
                oDomRef["setAttribute"](sAttribute, sValue);
            } else {
                oDomRef["removeAttribute"](sAttribute);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setOrRemoveAttribute"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {HTMLElement} oDomRef the element
     * @param {string} sAttribute the attribute
     * @param {string} sValue the value
     * @param {bool} bAtBeginning 'true' will add the value at the beginning,
     *                                                        'false' will add the value at the end
     */
    UCF_AriaStateHelper["addOnceToAttribute"] = function (oDomRef, sAttribute, sValue, bAtBeginning) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["addOnceToAttribute"]++;
        }
        ;
        /** @type {string} */
        var sCurrentValue;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(75): addOnceToAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAttribute === 'string', "typeof sAttribute === 'string'", "AriaStateHelper.js(76): addOnceToAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sValue === 'string', "typeof sValue === 'string'", "AriaStateHelper.js(77): addOnceToAttribute");
        }
        ;

        if (oDomRef && sValue) {
            sCurrentValue = oDomRef["getAttribute"](sAttribute);

            if (sCurrentValue) {
                if (!UCF_StringUtil["bContains"](sCurrentValue, sValue)) {
                    if (bAtBeginning) {
                        oDomRef["setAttribute"](sAttribute, sValue + ' ' + sCurrentValue);
                    } else {
                        oDomRef["setAttribute"](sAttribute, sCurrentValue + ' ' + sValue);
                    }
                }
            } else {
                oDomRef["setAttribute"](sAttribute, sValue);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["addOnceToAttribute"] = 0;
    }
    ;

    /**
     * Sets whether the state is expanded or not
     *
     * @protected
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The expanded state
     */
    UCF_AriaStateHelper["setExpanded"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setExpanded"]++;
        }
        ;
        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-expanded', bState);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setExpanded"] = 0;
    }
    ;

    /**
     * Removes the aria-expanded attribute from given DomRef
     *
     * @protected
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     */
    UCF_AriaStateHelper["removeExpanded"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["removeExpanded"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(116): removeExpanded");
        }
        ;
        if (oDomRef) {
            oDomRef["removeAttribute"]('aria-expanded');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["removeExpanded"] = 0;
    }
    ;

    /**
     * Sets whether the state is disabled or not
     *
     * @protected
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The disabled state
     */
    UCF_AriaStateHelper["setDisabled"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setDisabled"]++;
        }
        ;
        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-disabled', bState);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setDisabled"] = 0;
    }
    ;

    /**
     * Sets whether the state is readonly or not
     *
     * @protected
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The readonly state
     */
    UCF_AriaStateHelper["setReadonly"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setReadonly"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bState === 'boolean', "typeof bState === 'boolean'", "AriaStateHelper.js(143): setReadonly");
        }
        ;

        UCF_AriaStateHelper["setOrRemoveAttribute"](
            oDomRef,
            'aria-readonly',
            bState && 'true'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setReadonly"] = 0;
    }
    ;

    /**
     * Sets whether the state is selected or not
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The selected state
     */
    UCF_AriaStateHelper["setSelected"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setSelected"]++;
        }
        ;
        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-selected', bState);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setSelected"] = 0;
    }
    ;

    /**
     * Sets to identify a current position during navigation
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {'date'|'time'|'location'|'step'|'page'|boolean } oValue the value to set
     */
    UCF_AriaStateHelper["setCurrent"] = function (oDomRef, oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setCurrent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(173): setCurrent");
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oValue === 'date' || oValue === 'time' || oValue === 'location' || oValue === 'step' || oValue === 'page' || typeof oValue === 'boolean', "oValue === 'date' || oValue === 'time' || oValue === 'location' || oValue === 'step' || oValue === 'page' || typeof oValue === 'boolean'", "AriaStateHelper.js(175): setCurrent");
        }
        ;

        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-current', oValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setCurrent"] = 0;
    }
    ;

    /**
     * Sets the input state to WARNING
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState how to change the state
     */
    UCF_AriaStateHelper["setWarning"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setWarning"]++;
        }
        ;

        if (bState) {
            this["addOnceToAttribute"](oDomRef, 'aria-describedby', 'ARIA_WARN');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setWarning"] = 0;
    }
    ;

    /**
     * Sets the input state to INVALID
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param { boolean } bState how to change the state
     */
    UCF_AriaStateHelper["setInvalid"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setInvalid"]++;
        }
        ;
        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-invalid', bState);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setInvalid"] = 0;
    }
    ;

    /**
     * Sets the id of the active decendant for the given dom element
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id for the active decendant
     */
    UCF_AriaStateHelper["setActivedescendant"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setActivedescendant"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "AriaStateHelper.js(216): setActivedescendant");
        }
        ;

        UCF_AriaStateHelper["setOrRemoveAttribute"](
            oDomRef,
            'aria-activedescendant',
            sId
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setActivedescendant"] = 0;
    }
    ;

    /**
     * Sets the id of the element that describes the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the element that describes the given dom ref
     */
    UCF_AriaStateHelper["setDescribedby"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setDescribedby"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "AriaStateHelper.js(234): setDescribedby");
        }
        ;

        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-describedby', sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setDescribedby"] = 0;
    }
    ;

    /**
     * Adds the id of the element that describes the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the element that describes the given dom ref
     */
    UCF_AriaStateHelper["addDescribedby"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["addDescribedby"]++;
        }
        ;
        UCF_AriaStateHelper["addOnceToAttribute"](oDomRef, 'aria-describedby', sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["addDescribedby"] = 0;
    }
    ;

    /**
     * Removes the id of the element that described the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     */
    UCF_AriaStateHelper["removeDescribedby"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["removeDescribedby"]++;
        }
        ;
        oDomRef["removeAttribute"]('aria-describedby');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["removeDescribedby"] = 0;
    }
    ;

    /**
     * Adds the id of the element that labels the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the element that describes the given dom ref
     * @param {string} sAriaAttribute aria attribute
     */
    UCF_AriaStateHelper["addAriaLabelTag"] = function (oDomRef, sId, sAriaAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["addAriaLabelTag"]++;
        }
        ;
        UCF_AriaStateHelper["addOnceToAttribute"](oDomRef, sAriaAttribute, sId, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["addAriaLabelTag"] = 0;
    }
    ;

    /**
     * Adds the text of the element that labels the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sText The text of the element that labels the given dom ref
     */
    UCF_AriaStateHelper["addLabel"] = function (oDomRef, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["addLabel"]++;
        }
        ;
        UCF_AriaStateHelper["addOnceToAttribute"](oDomRef, 'aria-label', sText);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["addLabel"] = 0;
    }
    ;

    /**
     * Sets the id of the element that labels the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the element that labels the given dom ref
     */
    UCF_AriaStateHelper["setLabelledBy"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setLabelledBy"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-labelledby', sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setLabelledBy"] = 0;
    }
    ;

    /**
     * Sets the label of the element with the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sText The label text
     */
    UCF_AriaStateHelper["setLabel"] = function (oDomRef, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setLabel"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-label', sText);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setLabel"] = 0;
    }
    ;

    /**
     * Sets the aria-live attribute of the element with the given dom ref and value
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sValue May be assertive, off, polite
     */
    UCF_AriaStateHelper["setLive"] = function (oDomRef, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setLive"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-live', sValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setLive"] = 0;
    }
    ;

    /**
     * Sets the aria-details attribute of the element with the given dom ref and text
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sText The details text
     */
    UCF_AriaStateHelper["setDetails"] = function (oDomRef, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setDetails"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-details', sText);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setDetails"] = 0;
    }
    ;

    /**
     * Sets the id of the controls for the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the control for the dom ref
     */
    UCF_AriaStateHelper["setControls"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setControls"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-controls', sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setControls"] = 0;
    }
    ;

    /**
     * Sets the id of the element that owns the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sId The id of the element that owns the given dom ref
     */
    UCF_AriaStateHelper["setOwns"] = function (oDomRef, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setOwns"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-owns', sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setOwns"] = 0;
    }
    ;

    /**
     * Sets the size (number of items) contained for the dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {number} iSetSize The size (number of items) contained for the dom ref
     */
    UCF_AriaStateHelper["setSetsize"] = function (oDomRef, iSetSize) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setSetsize"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iSetSize === 'number', "typeof iSetSize === 'number'", "AriaStateHelper.js(368): setSetsize");
        }
        ;

        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-setsize', iSetSize);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setSetsize"] = 0;
    }
    ;

    /**
     * Sets the position in a set for the dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {number} iPos The position in a set for the dom ref
     */
    UCF_AriaStateHelper["setPosinset"] = function (oDomRef, iPos) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setPosinset"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iPos === 'number', "typeof iPos === 'number'", "AriaStateHelper.js(382): setPosinset");
        }
        ;

        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-posinset', iPos);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setPosinset"] = 0;
    }
    ;

    /**
     * Sets whether the pressed is checked or not
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The pressed state
     */
    UCF_AriaStateHelper["setPressed"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setPressed"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bState === 'boolean', "typeof bState === 'boolean'", "AriaStateHelper.js(396): setPressed");
        }
        ;

        UCF_AriaStateHelper["setAttribute"](oDomRef, 'aria-pressed', bState);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setPressed"] = 0;
    }
    ;

    /**
     * Sets whether the state is checked or not
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bState The checked state
     * @private
     */
    UCF_AriaStateHelper["setChecked"] = function (oDomRef, bState) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setChecked"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bState === null || bState || !bState, "bState === null || bState || !bState", "AriaStateHelper.js(408): setChecked");
        }
        ;

        UCF_AriaStateHelper["setAttribute"](
            oDomRef,
            'aria-checked',
            bState === null ? 'mixed' : bState
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setChecked"] = 0;
    }
    ;

    /**
     * Sets whether the tabindex is set or removed
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} bSet `true` if the tabindex should be set; `false` will
     * remove the tab index
     */
    UCF_AriaStateHelper["setTabIndex"] = function (oDomRef, bSet) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setTabIndex"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(427): setTabIndex");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bSet === 'boolean', "typeof bSet === 'boolean'", "AriaStateHelper.js(428): setTabIndex");
        }
        ;

        if (oDomRef) {
            if (bSet) {
                UCF_DomUtil["setTabIndex"](oDomRef, '0');
            } else {
                UCF_DomUtil["resetTabIndex"](oDomRef);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setTabIndex"] = 0;
    }
    ;

    /**
     * Sets the aria role of the element with the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sName The name of the role that will be assigned to the
     * element with the given dom ref
     */
    UCF_AriaStateHelper["setRole"] = function (oDomRef, sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setRole"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'role', sName);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setRole"] = 0;
    }
    ;

    /**
     * Sets the title tag of the element with the given dom ref
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sName The value of the title tag that will be assigned to
     * the element with the given dom ref
     */
    UCF_AriaStateHelper["setTitle"] = function (oDomRef, sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setTitle"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'title', sName);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setTitle"] = 0;
    }
    ;

    /**
     * Sets whether the element has a popup menud or not
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {boolean} sType The type, may be listbox, tree, dialog, grid
     */
    UCF_AriaStateHelper["setHasPopup"] = function (oDomRef, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setHasPopup"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-haspopup', sType);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setHasPopup"] = 0;
    }
    ;

    /**
     * Checks if a control has a label and adds this information to the chosen aria
     * attribute.
     *
     * @protected
     * @static
     * @param {HTMLElement} oLS The Lightspeed object
     * @param {string} sId Id of the control which the label is for
     * @param {HTMLElement} oAriaDomRef The dom ref of the DOM element which should get
     * aria-labelledby attribute, may differ from sId
     * @param {string} sAriaAttribute Name of the aria attribute which should be used
     */
    UCF_AriaStateHelper["setLabelInfo"] = function (oLS, sId, oAriaDomRef, sAriaAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setLabelInfo"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oLabel;
        /** @type {HTMLElement} */
        var oControl;
        /** @type {string} */
        var sLabelID;
        /** @type {string} */
        var sLabelText;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS != null, "oLS != null", "AriaStateHelper.js(499): setLabelInfo");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "AriaStateHelper.js(500): setLabelInfo");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oAriaDomRef != null, "oAriaDomRef != null", "AriaStateHelper.js(501): setLabelInfo");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAriaAttribute === 'string', "typeof sAriaAttribute === 'string'", "AriaStateHelper.js(502): setLabelInfo");
        }
        ;

        if (oAriaDomRef) {
            oControl = UCF_DomUtil["$"](sId);

            if (oControl && oControl["sLabelledBy"]) {
                oLabel = UCF_DomUtil["$"](oControl["sLabelledBy"]);
                if (oLabel) {
                    sLabelID = oLabel["id"];
                    sLabelText = oLabel["title"];
                }
            } else {
                oLabel = UCF_AriaStateHelper["oGetLabel"](oLS, sId);
                if (oLabel) {
                    sLabelID = oLabel["oDomRef"]["getAttribute"]('id');
                    sLabelText = oLabel["sGetDisplayedText"]();
                }
            }

            if (oLabel) {
                if (sAriaAttribute === 'aria-labelledby') {
                    if (sLabelID) {
                        UCF_AriaStateHelper["addAriaLabelTag"](
                            oAriaDomRef,
                            sLabelID + '-arialabel',
                            sAriaAttribute
                        );
                    }
                } else if (sAriaAttribute === 'aria-label') {
                    if (sLabelText) {
                        UCF_AriaStateHelper["addAriaLabelTag"](
                            oAriaDomRef,
                            sLabelText + ' ' + oLabel["sTooltip"],
                            sAriaAttribute
                        );
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setLabelInfo"] = 0;
    }
    ;

    /**
     * Retrieves the label control of a control.
     *
     * @see UCF_AccessibilityHelper.applyLabelingInfo
     * @protected
     * @static
     * @param {HTMLElement} oLS The Lightspeed object
     * @param {string} sId Id of the control
     * @return {Object} The label for the control with sId
     */
    UCF_AriaStateHelper["oGetLabel"] = function (oLS, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["oGetLabel"]++;
        }
        ;
        /** @type {NodeListOf<HTMLLabelElement>} */
        var aLabels;
        /** @type {HTMLLabelElement} */
        var oLabel;
        /** @type {HTMLElement} */
        var oControl;
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS != null, "oLS != null", "AriaStateHelper.js(563): oGetLabel");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "AriaStateHelper.js(564): oGetLabel");
        }
        ;

        if (sId) {
            aLabels = document["getElementsByTagName"]('LABEL');
            oControl = document["getElementById"](sId);

            for (i = 0; i < aLabels["length"]; i++) {
                oLabel = (
                    aLabels[i]["getAttribute"]('ct') === 'L' ||
                    aLabels[i]["getAttribute"]('sub-ct') === 'ComboBox'
                ) && oLS["oGetControlByDomRef"](aLabels[i]);
                if (oLabel && oLabel["sLabelFor"] === sId) {
                    if (oControl) {
                        oControl["sLabelledBy"] = oLabel["sId"];
                    }

                    return oLabel;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["oGetLabel"] = 0;
    }
    ;

    /**
     * Sets the value text of an element
     *
     * @private
     * @static
     * @param {HTMLElement} oDomRef The dom ref
     * @param {string} sText The value text assigned to the element with the given
     * dom ref
     */
    UCF_AriaStateHelper["setValueText"] = function (oDomRef, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setValueText"]++;
        }
        ;
        UCF_AriaStateHelper["setOrRemoveAttribute"](oDomRef, 'aria-valuetext', sText);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setValueText"] = 0;
    }
    ;

    /**
     * Provides a string assembled using the innerHtml of a set of DomNodes
     * @param {Object} oDomRef The  given dom ref
     *
     * @return {string} description
     * */
    UCF_AriaStateHelper["getDescriptionByElements"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["getDescriptionByElements"]++;
        }
        ;
        /** @type {string} */
        var sDescribedByIds;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "AriaStateHelper.js(611): getDescriptionByElements");
        }
        ;

        if (oDomRef) {
            sDescribedByIds = oDomRef["getAttribute"]('aria-describedby');

            if (sDescribedByIds) {
                return UCF_JsUtil["reduce"](
                    sDescribedByIds["split"](' '),
                    function (sDescribedByIds, sId) {
                        var oRef;

                        if (sId !== ' ') {
                            oRef = UCF_DomUtil["$"](sId);

                            if (oRef) {
                                return UCF_JsUtil["filter"](
                                    [sDescribedByIds, oRef["innerHTML"]],
                                    function (sIdentity) {
                                        return sIdentity;
                                    }
                                )["join"](' ');
                            }
                        }

                        return sDescribedByIds;
                    },
                    ''
                );
            } else {
                return null;
            }
        } else {
            return '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["getDescriptionByElements"] = 0;
    }
    ;

    /**
     * Renders a div with role=alert and a text, e.g. for messages
     * @param {string} sText The value text assigned to the element with the given
     * id
     * @param {string} sId The id of the control
     *
     * @private
     */
    UCF_AriaStateHelper["setAlert"] = function (sText, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["setAlert"]++;
        }
        ;
        /** @type {string} */
        var sAriaId = sId || 'sapur-aria-alert';
        /** @type {HTMLDivElement} */
        var oAriaDiv;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sText === 'string', "typeof sText === 'string'", "AriaStateHelper.js(659): setAlert");
        }
        ;

        if (sText) {
            oAriaDiv = UCF_DomUtil["$"](sAriaId);

            if (oAriaDiv) {
                UCF_AriaStateHelper["setRole"](oAriaDiv, 'alert');
                oAriaDiv["innerHTML"] = UCF_XSSEncoder["encodeHTML"](sText);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["setAlert"] = 0;
    }
    ;

    /**
     * Returns the message type text
     *
     * @param {UCF_LS} oLS the LightSpeed to use
     * @param {string} sType type of the message
     * @return {string} message type text
     */
    UCF_AriaStateHelper["sGetMessageTypeString"] = function (oLS, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_AriaStateHelper["_"]["sGetMessageTypeString"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS != null, "oLS != null", "AriaStateHelper.js(679): sGetMessageTypeString");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sType === 'string', "typeof sType === 'string'", "AriaStateHelper.js(680): sGetMessageTypeString");
        }
        ;

        switch (sType) {
            case 'ERROR':
                return oLS["sGetText"]('SAPUR_ERROR');
            case 'OK':
                return oLS["sGetText"]('SAPUR_SUCCESS');
            case 'STOP':
                return oLS["sGetText"]('SAPUR_STOP');
            case 'WARNING':
                return oLS["sGetText"]('SAPUR_WARNING');
            case 'LOADING':
                return oLS["sGetText"]('SAPUR_LOADING');
            case 'INFO':
                return oLS["sGetText"]('SAPUR_INFO');
            case 'NOTIFICATION':
                return oLS["sGetText"]('SAPUR_NOTIFICATION');
            case 'ALERT':
                return oLS["sGetText"]('SAPUR_ALERT');
            case 'TASK':
                return oLS["sGetText"]('SAPUR_TASK');
            default:
                return '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_AriaStateHelper["_"]["sGetMessageTypeString"] = 0;
    }
    ;

    /* global UCF_EventProvider */
/// <reference path="../EventProvider.js"/>
    /* global _assert, _trace, DEBUG, WARNING */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>
    /* global UCF_System */

/// <reference path="../../ls/core/System.js"/>
    /**
     * BrowserHistory
     *
     * The browser history manages the history of the browser or simulates it.
     * Additionally it supports the backprevention
     * functionality.
     *
     * After some problems with the approach of simply supporting a back and
     * forward event we came to the conclusion that we need to use the built-in
     * history of the browser because when location hash is set by JS or user entry
     * in the location bar Safari and FireFox always create a history entry in the
     * built in history. This is done regardless if the anchor (name="#...") exists
     * in the page or not while IE only creates an entry for existing one (dynamic
     * creation failed)
     *
     * In IE the history entries are simulated by a shadow history implemented in
     * the "backprevention.html" running in a dynamic created IFrame. In FireFox
     * also the IFrame is used for the backprevention because it is more reliable
     * as hash change notification by hash polling Safari does not create any
     * history entries in the build-in history of the browser for navigations in
     * IFrames (I assume that is a bug). Therefore the IFrame is useless and is not
     * created. Instead this class tries to do the backprevention by has polling to
     * check if hash has changed and triggering a histrory forward navigation if
     * the initial hash has been reached.
     *
     * Some new browsers support the event "onhashchange". If this is the case this
     * mechanism is used instead of hash polling for hash change notification.
     *
     * All implementation can fail and do not work 100% because the browser
     * sometimes jumps over history entries when clicking very rapidly on browsers
     * back button.
     *
     * ---
     *
     * Exposes the URL parameter "sap-ls-notifyHistoryChanged=" in ClientDebug,
     * that will bring up an alert window whenever the history changes.
     *
     * @class
     *
     * @see {UCF_Page}
     */
    function UCF_BrowserHistory() {
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["UCF_BrowserHistory"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['HashChanged']);

        /** @type {HTMLIFrameElement} */
        this["oIframe"] = null;
        /** @type {boolean} */
        this["bActivated"] = false;
        /** @type {boolean} */
        this["bBackPrevention"] = false;
        /** @type {boolean} */
        this["bHistorySupport"] = false;
        /** @type {string} */
        this["sInitialHash"] = null;
        /** @type {string} */
        this["sLastHash"] = null;
    };window["UCF_BrowserHistory"] = UCF_BrowserHistory;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_BrowserHistory");
        UCF_BrowserHistory["_"] = {UCF_BrowserHistory: 0};
    }
    ;
    ;
    UCF_BrowserHistory["prototype"] = new UCF_EventProvider();
    UCF_BrowserHistory.prototype["sClassName"] = "UCF_BrowserHistory";

    /**
     * Used when backprevention by hash polling is activated
     *
     * @private
     * @static
     * @const {string}
     */
    UCF_BrowserHistory["BACKPREVENTION_HASH"] = '#...';

    /**
     * The hash polling interval in milliseconds
     *
     * @private
     * @static
     * @const {number}
     */
    UCF_BrowserHistory["HASH_POLLING_INTERVAL"] = 200;

    /**
     * @private
     * @static
     * @const {number}
     */
    UCF_BrowserHistory["HISTORY_CHANGED_POLLING_INTERVAL"] = 500;

    /** @override */
    UCF_BrowserHistory["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["destroy"]++;
        }
        ;
        this["cleanUp"]();
        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["destroy"] = 0;
    }
    ;

    /**
     * Cleanup all references and states to initial
     * @public
     */
    UCF_BrowserHistory["prototype"]["cleanUp"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["cleanUp"]++;
        }
        ;
        this["stopHashNotification"]();
        this["sInitialHash"] = null;
        this["sLastHash"] = null;
        this["cleanUpIFrame"]();
        this["bActivated"] = false;
        this["bBackPrevention"] = false;
        this["bHistorySupport"] = false;
        this["cleanupNativeHistoryChangeNotification"]();
        this["iNativeHistoryEntriesCount"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["cleanUp"] = 0;
    }
    ;

    /**
     * Initializes and activates the browser history. The method checks depending
     * on the browser type in which way the history support and/or the
     * backprevention has to be realized.
     *
     * @public
     * @param {boolean} bBackPrevention whether backprevention is enabled
     * @param {boolean} bHistorySupport whether history support is enabled
     * @param {boolean} bPageInitial whether page is initial
     */
    UCF_BrowserHistory["prototype"]["init"] = function (bBackPrevention, bHistorySupport, bPageInitial) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["init"]++;
        }
        ;
        var bNeedIFrame;

        if (!this["bActivated"]) {
            // Only IE in Quirks uses IFrame
            bNeedIFrame = UCF_UserAgent["bIsIE"]()
                && window["UCF_System"]["sDevice"] !== 'standards'
                && (bHistorySupport || bBackPrevention);

            this["bActivated"] = true;

            this["bBackPrevention"] = bBackPrevention;
            this["bHistorySupport"] = bHistorySupport;
            this["sInitialHash"] = this["sGetHash"]();
            this["sLastHash"] = this["sInitialHash"];

            this["initNativeHistoryChangeNotification"]();

            if (bNeedIFrame) {
                // Ensure to use IFrame based approch only in IE11 as it is not CSP2.0 conform.

                // Create the IFrame delayed when the application starts to optimize the
                // start up time
                if (bPageInitial) {
                    // eslint-disable-next-line no-magic-numbers
                    UCF_JsUtil["delayedCall"](500, this, 'createIFrame');
                } else {
                    this["createIFrame"]();
                }
            } else if (this["bBackPrevention"]) {
                // When no Iframe is used and backprevention is turned on use hash change
                // notification for backprevention
                this["setHash"](UCF_BrowserHistory["BACKPREVENTION_HASH"]);
                this["setHash"](this["sInitialHash"]);
            }

            // Start the hash notification process when history support is turned on or
            // hash change notification is used for backprevention
            if (this["bHistorySupport"] || !bNeedIFrame && this["bBackPrevention"]) {
                this["startHashNotification"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["init"] = 0;
    }
    ;

    /**
     * Creates an Iframe, applies it to the active DOM and loads the browser
     * history HTML. Used for IE11 Quirks Mode
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["createIFrame"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["createIFrame"]++;
        }
        ;
        /** @type {HTMLIFrameElement} */
        var oIframe;
        /** @type {UCF_BrowserHistory} */
        var self;

        if (this["oIframe"]) {
            this["cleanUpIFrame"]();
        }

        if (!this["oIframe"]) {
            self = this;

            oIframe = document["createElement"]('IFRAME');
            oIframe["setAttribute"](
                'id',
                'sap-ui-BrowserHistory-' + UCF_JsUtil["iGetTimeStamp"]()
            );
            oIframe["tabIndex"] = '-1';
            UCF_DomUtil["setStyle"](oIframe, {
                "height": '1px',
                "width": '100px',
                "position": 'absolute',
                "top": '-10px'
            });
            oIframe["src"] = this["sGetIframeJSSource"]();
            oIframe["onload"] = function () {
                /** @type {boolean} */
                var bBackPrevention;
                /** @type {boolean} */
                var bHistorySupport;

                if (self["oIframe"]["bLsInitialized"]) {
                    // This case should never occur, but occurs in IE. Try
                    // re-initialization
                    bBackPrevention = self["bBackPrevention"];
                    bHistorySupport = self["bHistorySupport"];

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(WARNING, 'IE history bug detected. Trying to re-initialize BrowserHistory. For details see SAP note 2202543', "BrowserHistory.js(219): onload");
                    }
                    ;

                    self["oIframe"]["bLsInitialized"] = false;
                    self["cleanUp"]();
                    self["init"](bBackPrevention, bHistorySupport, false);
                } else {
                    self["oIframe"]["bLsInitialized"] = true;
                    self["applyIframeScriptProvider"](self["oIframe"]["contentWindow"]);
                }
            };

            // Is IE8's Trident 4 engine? See SAP note 1662387
            // eslint-disable-next-line no-magic-numbers
            if (UCF_UserAgent["bIsTrident"](4, true)) {
                oIframe["onactivate"] = this["fOnActivateIFrameIE8"];
            }

            document["body"]["appendChild"](oIframe);

            this["oIframe"] = oIframe;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["createIFrame"] = 0;
    }
    ;

    /**
     * Cleanup the IFrame DOM
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["cleanUpIFrame"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["cleanUpIFrame"]++;
        }
        ;
        if (this["oIframe"]) {
            UCF_DomUtil["removeFromDom"](this["oIframe"]);
            this["oIframe"]["onactivate"] = null;
            this["oIframe"]["onload"] = null;
            this["oIframe"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["cleanUpIFrame"] = 0;
    }
    ;

    /**
     * The function which is bound to the IFrames "onactivate" event handler to
     * mage problem described in SAP note 1662387
     *
     * @private
     * @return {boolean} Always returns false
     */
    UCF_BrowserHistory["prototype"]["fOnActivateIFrameIE8"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["fOnActivateIFrameIE8"]++;
        }
        ;
        /** @type {Element} */
        var oToFocus = window["event"]["fromElement"];

        if (oToFocus && oToFocus["focus"] && oToFocus["tagName"] !== 'BODY') {
            oToFocus["focus"]();
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'IE8 focus exception applied. SAP note 1662387.', "BrowserHistory.js(269): fOnActivateIFrameIE8");
            }
            ;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["fOnActivateIFrameIE8"] = 0;
    }
    ;

    /**
     * Starts notification process for hash changes
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["startHashNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["startHashNotification"]++;
        }
        ;
        /** @type {UCF_BrowserHistory} */
        var self;

        if (this["bIsHashChangeEventSupported"]()) {
            // use native HashChange when available
            self = this;
            this["onNativeHashChange"] = function (oDomEvent) {
                self["checkHash"]();
            };

            UCF_DomUtil["attachEvent"](
                window,
                'hashchange',
                this["onNativeHashChange"],
                false
            );
        } else if (!this["oHashInterval"]) {
            // else use polling approach
            this["oHashInterval"] = UCF_JsUtil["intervalCall"](
                UCF_BrowserHistory["HASH_POLLING_INTERVAL"],
                this,
                'checkHash'
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["startHashNotification"] = 0;
    }
    ;

    /**
     * Stops notification process for hash changes
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["stopHashNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["stopHashNotification"]++;
        }
        ;
        if (this["bIsHashChangeEventSupported"]()) {
            if (this["onNativeHashChange"]) {
                // cleanup only when attached before
                UCF_DomUtil["detachEvent"](
                    window,
                    'hashchange',
                    this["onNativeHashChange"],
                    false
                );
                this["onNativeHashChange"] = null;
            }
        } else if (this["oHashInterval"]) {
            UCF_JsUtil["clearIntervalCall"](this["oHashInterval"]);
            this["oHashInterval"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["stopHashNotification"] = 0;
    }
    ;

    /**
     * Returns true if the browser supports hash change notification by a native
     * browser event
     *
     * @private
     * @return {boolean} IsHashChangeEventSupported
     */
    UCF_BrowserHistory["prototype"]["bIsHashChangeEventSupported"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["bIsHashChangeEventSupported"]++;
        }
        ;
        return ('onhashchange' in window) // when feature exits
            // IE only supports feature in standards mode
            && (!UCF_UserAgent["bIsIE"]() || window["UCF_System"]["sDevice"] === 'standards');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["bIsHashChangeEventSupported"] = 0;
    }
    ;

    /**
     * Checks if hash changed
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["checkHash"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["checkHash"]++;
        }
        ;
        if (this["sGetHash"]() !== this["sLastHash"]) {
            if (!this["oIframe"] &&
                this["bBackPrevention"] &&
                this["sGetHash"]() === UCF_BrowserHistory["BACKPREVENTION_HASH"]
            ) {
                // Backprevention when no IFrame is used

                if (this["bHistorySupport"]) {
                    // Do not create a hash entry for this case because it will destroy the
                    // forward history
                    UCF_JsUtil["delayedCall"](0, window["history"], 'forward');
                } else {
                    // This is more relieable than "window.history.forward()" but destroys
                    // the forward history
                    this["setHash"](this["sInitialHash"]);
                }

            } else {
                this["setHash"](this["sGetHash"]());

                if (this["bActivated"] && this["bHistorySupport"]) {
                    this["fireEvent"](this["E_EVENTS"]["HashChanged"], {
                        "sName": 'HashChanged',
                        "sNewHash": this["sGetHash"](),
                        "sOldHash": this["sLastHash"]
                    });
                }

                this["sLastHash"] = this["sGetHash"]();
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["checkHash"] = 0;
    }
    ;

    /**
     * Central method to set hash to the location object
     *
     * @public
     * @param {string} sHash the hash to set
     */
    UCF_BrowserHistory["prototype"]["setHash"] = function (sHash) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["setHash"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === 'string', "typeof sHash === 'string'", "BrowserHistory.js(390): setHash");
        }
        ;

        // Continue when activated and history support or hash polling is used
        if (
            this["bActivated"] &&
            (this["bHistorySupport"] || this["bBackPrevention"] && !this["oIframe"])
        ) {
            if (this["oIframe"]) {
                try {
                    // Use the frame functionality to set hash
                    this["oIframe"]["contentWindow"]["setHash"](sHash);
                } catch (oException) {
                    // eslint-disable-next-line no-magic-numbers
                    UCF_JsUtil["delayedCall"](100, this, 'setHash', [sHash]);
                }
            } else {
                // Use the own method to set hash
                this["setHashDirect"](this["sNormalizeHash"](sHash), false);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["setHash"] = 0;
    }
    ;

    /**
     * The browser histories own method to set the has to the location object. It
     * does not influence history stack.
     *
     * @public
     * @param {string} sHash
     * @param {boolean} bSkipDelayed When "false" the functionality is executed
     * delayed
     * @return {number} The index of the delayed called that is triggered if not
     * skipped delayed.
     */
    UCF_BrowserHistory["prototype"]["setHashDirect"] = function (sHash, bSkipDelayed) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["setHashDirect"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === 'string', "typeof sHash === 'string'", "BrowserHistory.js(424): setHashDirect");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bSkipDelayed === 'boolean', "typeof bSkipDelayed === 'boolean'", "BrowserHistory.js(425): setHashDirect");
        }
        ;

        if (bSkipDelayed) {
            if (sHash !== this["sGetHash"]()) {
                document["location"]["hash"] = sHash;
            }

            return null;
        } else {
            return UCF_JsUtil["delayedCall"](0, this, 'setHashDirect', [sHash, true]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["setHashDirect"] = 0;
    }
    ;

    /**
     * Central method to get the hash from the location object
     * @public
     * @return {string} the hash string
     */
    UCF_BrowserHistory["prototype"]["sGetHash"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["sGetHash"]++;
        }
        ;
        return document["location"]["hash"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["sGetHash"] = 0;
    }
    ;

    /**
     * Normalizes the hash code. Independend if the hash has a leading "#" or not
     * the result has a leading "#"
     *
     * @public
     * @param {string} sHash hash value
     * @return {string} the normalized hash string
     */
    UCF_BrowserHistory["prototype"]["sNormalizeHash"] = function (sHash) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["sNormalizeHash"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === 'string', "typeof sHash === 'string'", "BrowserHistory.js(456): sNormalizeHash");
        }
        ;

        return '#' + sHash["replace"]('#', '');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["sNormalizeHash"] = 0;
    }
    ;

    /**
     * Returns the HTML content of the browser history HTML ready to inject into
     * iFramewriter
     *
     * @private
     * @return {string}
     */
    UCF_BrowserHistory["prototype"]["sGetIframeJSSource"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["sGetIframeJSSource"]++;
        }
        ;
        // Called only in IE11 Quirks Mode as it is not CSP conform.
        // Ensure to use IFrame based approch only in IE11.
        // All other browsers doesn't call this see UCF_BrowserHistory.prototype.init -> flag bNeedIFrame
        return UCF_DomUtil["sGetIframeJSSource"]('<html>\n' +
            '	<body onscroll="onScrolling(event)">\n' +
            '		<div style="height: 3000px">\n' +
            '			<a name="h0" id="h0" style="position:absolute; top:0;">h0</a>\n' +
            '			<a name="h1" id="h1" style="position:absolute; top:1000;">h1</a>\n' +
            '			<a name="h2" id="h2" style="position:absolute; top:2000;">h2</a>\n' +
            '		</div>\n' +
            '	</body>\n' +
            '</html>');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["sGetIframeJSSource"] = 0;
    }
    ;

    /**
     * This HTML provides backprevention functionality by creating history entries
     * in the browser's built-in history and doing forward navigation when the
     * initial entry has been reached. It also supports a shadow history for hash
     * navigation. This can be activated for IE because IE does not create any
     * history entries in the built-in history for anchors (name="#...") which do
     * not exist on the page. Safari and FireFox creates history entries for each
     * kind of hash set by JS or by user entry in the location bar. Safari even
     * does not create any history entries in the build-in history of the browser
     * for navigations in IFrames (We assume that is a bug).
     *
     * So in IE mode the hash history can be simulated with this coding, in FireFox
     * only the backprevention is used the rest is done by the built-in history and
     * other browsers are not supported yet (Use hash polling by interval for them
     * or onhashChange browser event).
     *
     * Three markers have been used to be able to determine navigation direction
     * (forward, backward)
     *
     * The loading URL has to include the hash pointer to "h0"
     * (e.g. .../browserHistory.html#h0")
     * The string "bBackPrevention" in the URL determines if backprevention is
     * turned on/off (e.g. .../browserHistory.html?bBackPrevention#h0)
     *
     * The "setHash" method is the only method to be called from outside.
     *
     * @private
     * @param {Object} oContextWindow window object
     */
    UCF_BrowserHistory["prototype"]["applyIframeScriptProvider"] = function (oContextWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["applyIframeScriptProvider"]++;
        }
        ;
        /** @type {Array<number|string>} */
        var aHistory = [-1];
        /** @type {number} */
        var iHistoryPos = 0;
        /** @type {number} */
        var iHashPos = 0;
        /** @type {boolean} */
        var bUseShadowHistory = false;
        /** @type {boolean} */
        var bTransportHash = false;
        /** @type {boolean} */
        var bBackPrevention = this["bBackPrevention"];
        /** @type {boolean} */
        var bInitialized = false;
        /** @type {boolean} */
        var bHistoryExists = false;

        /**
         * Sets the hash
         * @public
         * @param {string} sHash hash value
         */
        oContextWindow["setHash"] = function (sHash) {
            /** @type {string} */
            var sCurrHistoryEntry;

            if (!bInitialized) {
                // eslint-disable-next-line no-magic-numbers
                setTimeout(function () {
                    oContextWindow["setHash"](sHash);
                }, 100);
            }

            if (sHash !== oContextWindow["parent"]["document"]["location"]["hash"]) {
                oContextWindow["parent"]["document"]["location"]["hash"] = sHash;
            }

            if (bUseShadowHistory) {
                sCurrHistoryEntry = aHistory[iHistoryPos];

                if (sCurrHistoryEntry["replace"]('#', '') !== sHash["replace"]('#', '')) {
                    while (aHistory["length"] - 1 > iHistoryPos) {
                        aHistory["pop"]();
                    }

                    aHistory["push"](sHash);
                    iHistoryPos = aHistory["length"] - 1;

                    oContextWindow["increment"]();
                }
            }

            bHistoryExists = true;
        };

        /** @private */
        oContextWindow["init"] = function () {
            /** @type {boolean} */
            var bIsIE = UCF_UserAgent["bIsIE"](); // /MSIE (\d+\.\d+);/.test(navigator.userAgent);

            bUseShadowHistory = bIsIE;
            bTransportHash = bIsIE;

            if (bBackPrevention) {
                if (bUseShadowHistory) {
                    aHistory["push"](-1);
                    iHistoryPos++;
                }
                oContextWindow["increment"]();
            }

            if (bUseShadowHistory) {
                aHistory[iHistoryPos] = oContextWindow["parent"]["document"]["location"]["hash"];
            }

            bInitialized = true;
        };

        /**
         * @private
         * @param {boolean} bByBackPrevention `true` if incrementing by
         * back prevention
         */
        oContextWindow["increment"] = function (bByBackPrevention) {
            // eslint-disable-next-line no-magic-numbers
            iHashPos = (oContextWindow["iGetPositionByScroll"]() + 1) % 3;

            if (bByBackPrevention && bHistoryExists) {
                setTimeout(function () {
                    oContextWindow["history"]["forward"]();
                }, 0);
            } else {
                setTimeout(function () {
                    oContextWindow["document"]["location"]["hash"] = '#h' + iHashPos;
                }, 0);
            }
        };

        /**
         * @private
         * @return {number}
         */
        oContextWindow["iGetPositionByScroll"] = function () {
            /** @type {number} */
            var iScrollPos = oContextWindow["document"]["body"]["scrollTop"];

            // eslint-disable-next-line no-magic-numbers
            return iScrollPos < 500 ? 0 : (iScrollPos < 1500 ? 1 : 2);
        };

        /**
         * @private
         * @param {UIEvent} event the scroll
         */
        oContextWindow["onScrolling"] = function (event) {
            /** @type {number} */
            var iCurrPos = oContextWindow["iGetPositionByScroll"]();
            /** @type {boolean} */
            var bInitiateBackprevention;

            if (iHashPos !== iCurrPos) {
                bInitiateBackprevention = bBackPrevention && !bUseShadowHistory;

                if (bUseShadowHistory) {
                    // eslint-disable-next-line no-magic-numbers
                    if (iCurrPos === 0 && iHashPos === 2 || iCurrPos === iHashPos + 1) {
                        // forward
                        iHistoryPos = Math["min"](iHistoryPos + 1, aHistory["length"] - 1);
                    } else {
                        // backward => Check if backprevention has to be initiated
                        bInitiateBackprevention = bBackPrevention && iHistoryPos === 1;
                        if (!bInitiateBackprevention) {
                            iHistoryPos = Math["max"](iHistoryPos - 1, 0);
                        }
                    }

                    if (bTransportHash && !bInitiateBackprevention) {
                        // Update embedding window with hash entry determined in the shadow
                        // history
                        oContextWindow["parent"]["document"]["location"]["hash"] = aHistory[iHistoryPos];
                    }
                }

                iHashPos = iCurrPos;

                if (bInitiateBackprevention) {
                    oContextWindow["increment"](true);
                }
            }
        };

        oContextWindow["init"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["applyIframeScriptProvider"] = 0;
    }
    ;

    /**
     * Initializes the native History Change Notification
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["initNativeHistoryChangeNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["initNativeHistoryChangeNotification"]++;
        }
        ;
        /** @type {UCF_BrowserHistory} */
        var self;

        if (!this["bBackPrevention"]) {
            self = this;

            window["onpopstate"] = function (event) {
                self["notifyNativeHistoryChanged"](
                    'Detected changed history by popstate event'
                );
            };

            this["iNativeHistoryEntriesCount"] = window["history"]["length"];
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'History Change Notification initialized with initial "' + this["iNativeHistoryEntriesCount"] + '" entry count', "BrowserHistory.js(684): initNativeHistoryChangeNotification");
            }
            ;
            this["oHistoryChangedInterval"] = UCF_JsUtil["intervalCall"](
                UCF_BrowserHistory["HISTORY_CHANGED_POLLING_INTERVAL"],
                this,
                'checkNativeHistoryChangeNotification'
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["initNativeHistoryChangeNotification"] = 0;
    }
    ;

    /**
     * Cleans up the state introduced by native History Change Notification
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["cleanupNativeHistoryChangeNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["cleanupNativeHistoryChangeNotification"]++;
        }
        ;
        if (this["oHistoryChangedInterval"]) {
            UCF_JsUtil["clearIntervalCall"](this["oHistoryChangedInterval"]);
            this["oHistoryChangedInterval"] = null;
        }

        window["onpopstate"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["cleanupNativeHistoryChangeNotification"] = 0;
    }
    ;

    /**
     * Checks if native history entries have changed and notfies if changed
     *
     * @private
     */
    UCF_BrowserHistory["prototype"]["checkNativeHistoryChangeNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["checkNativeHistoryChangeNotification"]++;
        }
        ;
        /** @type {number} */
        var iNativeHistoryEntriesCount = window["history"]["length"];

        if (this["iNativeHistoryEntriesCount"] !== iNativeHistoryEntriesCount) {
            this["notifyNativeHistoryChanged"](
                'Detected changed history length from ' +
                this["iNativeHistoryEntriesCount"] + ' to ' +
                iNativeHistoryEntriesCount
            );
            this["iNativeHistoryEntriesCount"] = iNativeHistoryEntriesCount;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["checkNativeHistoryChangeNotification"] = 0;
    }
    ;

    /**
     * Defines how to notify when history change detected
     *
     * @private
     * @param {string} sMessage the message
     */
    UCF_BrowserHistory["prototype"]["notifyNativeHistoryChanged"] = function (sMessage) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserHistory["_"]["notifyNativeHistoryChanged"]++;
        }
        ;
        if (
            // eslint-disable-next-line no-undef
            __UCF_DEBUG__ &&
            location["href"]["indexOf"]('sap-ls-notifyHistoryChanged=') !== -1
        ) {
            alert('NativeHistoryChanged: ' + sMessage);
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(WARNING, sMessage, "BrowserHistory.js(742): notifyNativeHistoryChanged");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserHistory["_"]["notifyNativeHistoryChanged"] = 0;
    }
    ;

    UCF_BrowserHistory.prototype["aPublicMethods"] = ["cleanUp", "init", "setHash", "setHashDirect", "sGetHash", "sNormalizeHash", "setHash"].concat(UCF_BrowserHistory.prototype.aPublicMethods || []);
    /* global UCF_Object */
/// <reference path="../Object.js"/>
    /* global UCF_JsUtil */

/// <reference path="./JsUtil.js"/>

    /**
     * A simple object to cache computations (i.e. compute them only when the cache
     * is not invalidated).
     *
     * @example
     * function expensive_computation() {
     *   var numbers = 0;
     *   for (var i = Number.MIN_VALUE; i < Number.MAX_VALUE; i++)
     *     numbers++;
     *   return numbers;
     * }
     * var oCache = new UCF_Cache();
     * oCache.get('expensive-computation', expensive_computation);
     * // => takes forever to compute, caches return value
     * oCache.get('expensive-computation', expensive_computation);
     * // => returns cached value instantly
     * oCache.invalidate('expensive-computation');
     * // or oCache.invalidate();
     * oCache.get('expensive-computation', expensive_computation);
     * // => runs closure again
     *
     * @class UCF_Cache
     * @extends UCF_Object
     */
    function UCF_Cache() {
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["UCF_Cache"]++;
        }
        ;
        UCF_Object["apply"](this, arguments);

        /** @type {Object.<string, any>} */
        this["mEntries"] = {};
        /** @type {Object.<string,number>} */
        this["oAFs"] = {};
    };window["UCF_Cache"] = UCF_Cache;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Cache");
        UCF_Cache["_"] = {UCF_Cache: 0};
    }
    ;
    ;
    UCF_Cache["prototype"] = new UCF_Object();
    UCF_Cache.prototype["sClassName"] = "UCF_Cache";

    /** @override */
    UCF_Cache["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["destroy"]++;
        }
        ;
        /** @type {UCF_Cache} */
        var self = this;

        // cancel cached animationframes
        UCF_JsUtil["forEach"](
            UCF_JsUtil["keys"](this["oAFs"]),
            function (sId) {
                self["cancelAnimationFrame"](sId);
            }
        );
        this["oAFs"] = null;

        // delete cached values. don't randomly destroy() values here, can't decide
        // if they have been created by cache owner.
        this["mEntries"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["destroy"] = 0;
    }
    ;

    /**
     * @protected
     * @template T
     * @param {string} sId the id of the cache entry
     * @param {T|function(): T} fValue closure that computes the value if it is not
     * cached
     * @return {T}
     */
    UCF_Cache["prototype"]["get"] = function (sId, fValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["get"]++;
        }
        ;
        if (fValue !== undefined && !this["has"](sId)) {
            this["mEntries"][sId] = UCF_JsUtil["bIsFunction"](fValue) ? fValue() : fValue;
        }

        return this["mEntries"][sId];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["get"] = 0;
    }
    ;

    /**
     * @protected
     * @param {string} sId the id of the cache entry
     * @param {Object} oValue the value to cache in the entry
     */
    UCF_Cache["prototype"]["set"] = function (sId, oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["set"]++;
        }
        ;
        this["mEntries"][sId] = oValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["set"] = 0;
    }
    ;

    /**
     * @protected
     * @param {string} sId the id of the cache entry
     * @return {boolean}
     */
    UCF_Cache["prototype"]["has"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["has"]++;
        }
        ;
        return sId in this["mEntries"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["has"] = 0;
    }
    ;

    /**
     * @protected
     * sId ids of cache entries to invalidate
     */
    UCF_Cache["prototype"]["invalidate"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["invalidate"]++;
        }
        ;
        /** @type {UCF_Cache} */
        var self;

        if (arguments["length"] > 0) {
            self = this;

            UCF_JsUtil["forEach"](
                UCF_JsUtil["arrayFrom"](arguments),
                function (sId) {
                    delete self["mEntries"][sId];
                }
            );
        } else {
            this["mEntries"] = {};
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["invalidate"] = 0;
    }
    ;

    /**
     * Requests an animation frame if no animation frame is requested for the same
     * sId already.
     *
     * @example
     * var oCache = new UCF_Cache();
     * oCache.requestAnimationFrame('first', function() { alert(1); });
     * // => requests an animation frame to alert(1);
     * oCache.requestAnimationFrame('first', function() { alert(2); });
     * // => if the first animation frame hasn't been executed yet,
     * // alert(2) will not be enqueued, because it is enqeueued for the same id
     *
     * @protected
     * @param {string} sId the id to request the animation frame for
     * @param {function(): void} fAnimationFrame the function to execute in the
     * animation frame
     */
    UCF_Cache["prototype"]["requestAnimationFrame"] = function (sId, fAnimationFrame) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["requestAnimationFrame"]++;
        }
        ;
        var self = this;

        if (!(sId in this["oAFs"])) {
            this["oAFs"][sId] = UCF_JsUtil["requestAnimationFrame"](function () {
                fAnimationFrame();
                delete self["oAFs"][sId];
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["requestAnimationFrame"] = 0;
    }
    ;

    /**
     * Cancels the animation frame requested for the sId
     *
     * @protected
     * @param {string} sId the id of the animation frame to cancel
     */
    UCF_Cache["prototype"]["cancelAnimationFrame"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Cache["_"]["cancelAnimationFrame"]++;
        }
        ;
        if (sId in this["oAFs"]) {
            UCF_JsUtil["cancelAnimationFrame"](this["oAFs"][sId]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Cache["_"]["cancelAnimationFrame"] = 0;
    }
    ;

    /* global UCF_ResourceUtil */
/// <reference path="../../ls/core/ResourceUtil.js"/>
    /* global UCF_System */
/// <reference path="../../ls/core/System.js"/>
    /* global _assert, _trace, INFO */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_ClipboardData */
/// <reference path="../types/ClipboardData.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>
    /* global UCF_XSSEncoder */

/// <reference path="./XSSEncoder.js"/>

    /**
     * Provides methods to set the clipboard data of the browser
     *
     *
     * @class
     * @version
     * @depends UCF_ClipboardData
     *
     */
    function UCF_ClipboardUtil() {
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["UCF_ClipboardUtil"]++;
        }
        ;

    };window["UCF_ClipboardUtil"] = UCF_ClipboardUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClipboardUtil");
        UCF_ClipboardUtil["_"] = {UCF_ClipboardUtil: 0};
    }
    ;
    ;

    UCF_ClipboardUtil["sLsClipboardBagId"] = "lsClipboardBag";
    UCF_ClipboardUtil["oClipboardData"] = new UCF_ClipboardData();


    /**
     * Destroys all references called by LS.destroy
     * @public
     */
    UCF_ClipboardUtil["destroyStatic"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["destroyStatic"]++;
        }
        ;
        UCF_ClipboardUtil["cleanup"]();
        UCF_ClipboardUtil["cleanUpClipboardBag"]();
        UCF_ClipboardUtil["oClipboardData"] = null;

        if (UCF_ClipboardUtil["oWriteToClipboard"] && UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"] && UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["getUCFInstance"]()) {
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["getUCFInstance"]()["close"]();
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["destroy"]();
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"] = null;
        }
        UCF_ClipboardUtil["oWriteToClipboard"] = null;

        if (UCF_ClipboardUtil["oReadFromClipboard"] && UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"] && UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["getUCFInstance"]()) {
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"]["getUCFInstance"]()["close"]();
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"]["destroy"]();
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"] = null;
        }
        UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"] = null;
        UCF_ClipboardUtil["oReadFromClipboard"] = null;


    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["destroyStatic"] = 0;
    }
    ;


    /**
     * Returns the ClipboardBag.
     * The ClipboardBag is a special HTML container which can be used to set a given HTML to the clipboard
     * It is created lazy by calling this method and is appended to the active DOM.
     * There is only one ClipboardBag needed for each framework.
     * @return {Object} The ClipboardBag
     * @private
     */
    UCF_ClipboardUtil["oGetClipboardBag"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["oGetClipboardBag"]++;
        }
        ;
        var oDomRefClipboardBag = UCF_DomUtil["$"](UCF_ClipboardUtil["sLsClipboardBagId"]);

        if (!oDomRefClipboardBag) {
            var oDomRefButton = document["createElement"]("button");

            oDomRefButton["onselectstart"] = function () {
                window["event"]["cancelBubble"] = true;
            };

            oDomRefClipboardBag = document["createElement"]("div");
            oDomRefClipboardBag["setAttribute"]("id", UCF_ClipboardUtil["sLsClipboardBagId"]);
            oDomRefClipboardBag["style"]["overflow"] = "hidden";
            oDomRefClipboardBag["style"]["position"] = "absolute";
            oDomRefClipboardBag["style"]["top"] = "-10000px";
            oDomRefClipboardBag["style"]["height"] = "1px";
            oDomRefClipboardBag["style"]["width"] = "1px";
            oDomRefClipboardBag["appendChild"](oDomRefButton);

            oDomRefClipboardBag["appendChild"](document["createElement"]("div"));

            document["body"]["appendChild"](oDomRefClipboardBag);
        }

        return oDomRefClipboardBag;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["oGetClipboardBag"] = 0;
    }
    ;

    /**
     * Removes the ClipboardBag from the DOM
     *
     * @private
     */
    UCF_ClipboardUtil["cleanUpClipboardBag"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["cleanUpClipboardBag"]++;
        }
        ;
        var oDomRefClipboardBag = UCF_DomUtil["$"](UCF_ClipboardUtil["sLsClipboardBagId"]);

        if (oDomRefClipboardBag) {
            oDomRefClipboardBag["parentNode"]["removeChild"](oDomRefClipboardBag);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["cleanUpClipboardBag"] = 0;
    }
    ;

    /**
     * Sets a given HTML to the browser clipboard. The HTML must not contain a BUTTON, INPUT, TEXTAREA tag
     *
     * Ensure sHtmlContent has no un-encoded user content. Don't use it for unsafe HTML
     *
     * @public
     * @param {string} sHtmlContent the HTML to be set in the clipboard.
     */
    UCF_ClipboardUtil["setHtmlToClipboard"] = function (sHtmlContent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["setHtmlToClipboard"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sHtmlContent) === "string", "typeof(sHtmlContent) === \"string\"", "ClipboardUtil.js(119): setHtmlToClipboard");
        }
        ;

        var oDomRefClipboardBag = UCF_ClipboardUtil["oGetClipboardBag"](),
            oDomRefContainer = oDomRefClipboardBag["firstChild"],
            oDomRefPreparationContainer = oDomRefClipboardBag["lastChild"];

        oDomRefPreparationContainer["style"]["display"] = "none";
        // eslint-disable-next-line no-unsanitized/property
        oDomRefPreparationContainer["innerHTML"] = sHtmlContent;
        oDomRefPreparationContainer["style"]["display"] = "block";

        //TODO WD specific for SapTable selection copy
        if (oDomRefPreparationContainer["firstChild"]
            && oDomRefPreparationContainer["firstChild"]["getAttribute"]("ct") === "ST"
            && oDomRefPreparationContainer["firstChild"]["tBodies"][0]
            && oDomRefPreparationContainer["firstChild"]["tBodies"][0]["firstChild"]
            && oDomRefPreparationContainer["firstChild"]["tBodies"][0]["firstChild"]["firstChild"]
        ) {
            // eslint-disable-next-line no-unsanitized/property
            oDomRefPreparationContainer["innerHTML"] = oDomRefPreparationContainer["firstChild"]["tBodies"][0]["firstChild"]["firstChild"]["innerHTML"];
        }

        oDomRefPreparationContainer["style"]["display"] = "none";

        var oCollectionInputFields = oDomRefPreparationContainer["firstChild"]["getElementsByTagName"]("input"),
            oInputField = null,
            oNewElement = null;

        while (oCollectionInputFields["length"] > 0) {
            oInputField = oCollectionInputFields[0];
            oNewElement = document["createElement"]("span");
            oNewElement["innerHTML"] = UCF_XSSEncoder["encodeHTML"](oInputField["value"]);
            oInputField["parentNode"]["replaceChild"](oNewElement, oInputField);
        }

        UCF_ClipboardUtil["convertClassToStyle"](oDomRefPreparationContainer["firstChild"]);

        // eslint-disable-next-line no-unsanitized/property
        oDomRefContainer["innerHTML"] = oDomRefPreparationContainer["innerHTML"];

        if (!oDomRefContainer["firstChild"]) {
            oDomRefContainer["innerHTML"] = "<div>No data available</div>";
        }

        var oRange = oDomRefContainer["createTextRange"](),
            oActiveElement = UCF_DomUtil["oGetActiveElement"]();

        oRange["select"]();
        oRange["execCommand"]("Copy");

        UCF_DomUtil["focusDomElement"](oActiveElement);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["setHtmlToClipboard"] = 0;
    }
    ;
    /**
     * Transfers relevant CSS class properties to the style attribute
     *
     * @private
     * @param {string} oDomRefContent the HTML to be converted
     */
    UCF_ClipboardUtil["convertClassToStyle"] = function (oDomRefContent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["convertClassToStyle"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefContent) === "object", "typeof(oDomRefContent) === \"object\"", "ClipboardUtil.js(179): convertClassToStyle");
        }
        ;

        if (oDomRefContent["tagName"] === "TABLE") {
            oDomRefContent["style"]["borderCollapse"] = oDomRefContent["currentStyle"]["borderCollapse"];
            oDomRefContent["className"] = "";
        } else if (oDomRefContent["className"] && oDomRefContent["currentStyle"]) {
            oDomRefContent["style"]["backgroundColor"] = oDomRefContent["currentStyle"]["backgroundColor"];
            oDomRefContent["style"]["fontSize"] = "8pt";
            oDomRefContent["style"]["fontFamily"] = "Arial,Helvetica,sans-serif;";

            oDomRefContent["className"] = "";
        }

        if (oDomRefContent["tagName"] === "TD" || oDomRefContent["tagName"] === "TH") {
            // eslint-disable-next-line no-unsanitized/property
            oDomRefContent["innerHTML"] = UCF_XSSEncoder["encodeHTML"](oDomRefContent["innerText"]);
            oDomRefContent["style"]["padding"] = "4px 6px";
        }

        if (oDomRefContent["childNodes"]) {
            for (var n = 0; n < oDomRefContent["childNodes"]["length"]; n++) {
                UCF_ClipboardUtil["convertClassToStyle"](oDomRefContent["childNodes"][n]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["convertClassToStyle"] = 0;
    }
    ;
    /**
     * Returns the clipboard table as an 2 dim. array
     *
     * @public
     * @return {Object} The clipboard table as an 2 dim. array
     */
    UCF_ClipboardUtil["getClipboardTable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getClipboardTable"]++;
        }
        ;
        if (UCF_ClipboardUtil["oClipboardData"] && UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"])
            return UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"];
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getClipboardTable"] = 0;
    }
    ;

    /**
     * Returns the clipboard contents as string
     *
     * @public
     * @return {string} The clipboard contents as string
     */

    UCF_ClipboardUtil["getClipboardContents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getClipboardContents"]++;
        }
        ;
        if (UCF_ClipboardUtil["oClipboardData"])
            return UCF_ClipboardUtil["oClipboardData"]["oClipboardContents"];
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getClipboardContents"] = 0;
    }
    ;

    /**
     * Returns the number of rows of the clipboard table
     *
     * @public
     * @return {integer} The number of rows of the clipboard table
     */

    UCF_ClipboardUtil["getNumberOfRows"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getNumberOfRows"]++;
        }
        ;
        if (!UCF_ClipboardUtil["isTable"]())
            return 0;
        return UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"]["length"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getNumberOfRows"] = 0;
    }
    ;

    /**
     * Returns the number of columns of the clipboard table
     *
     * @public
     * @return {int} The number of columns of the clipboard table
     */

    UCF_ClipboardUtil["getNumberOfColumns"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getNumberOfColumns"]++;
        }
        ;
        if (!UCF_ClipboardUtil["isTable"]())
            return 0;
        return UCF_ClipboardUtil["oClipboardData"]["nColumnCount"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getNumberOfColumns"] = 0;
    }
    ;

    /**
     * Returns true if the clipboard contains a table
     *
     * @public
     * @return {boolean} true if the clipboard contains a table
     */
    UCF_ClipboardUtil["isTable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["isTable"]++;
        }
        ;
        return (UCF_ClipboardUtil["oClipboardData"] && UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"] != null);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["isTable"] = 0;
    }
    ;

    /**
     * Returns the contents of a table cell
     *
     * @public
     * @param {int} row the rowindex as in integer
     * @param {int} column the column index as in integer
     * @return {string} The contents of a table cell
     */
    UCF_ClipboardUtil["getCellData"] = function (row, column) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getCellData"]++;
        }
        ;
        if (UCF_ClipboardUtil["oClipboardData"] && UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"][row][column])
            return UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"][row][column];
        return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getCellData"] = 0;
    }
    ;

    /**
     * Returns the id of the paste event source
     *
     * @public
     * @return {string} The id of the paste event source
     */
    UCF_ClipboardUtil["getEventSource"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["getEventSource"]++;
        }
        ;
        if (!UCF_ClipboardUtil["isTable"]())
            return '';
        return UCF_ClipboardUtil["oClipboardData"]["sEventSource"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["getEventSource"] = 0;
    }
    ;

    /**
     * Creates the table
     *
     * @private
     * @param {string} sClipboardData String
     * @return {boolean} true if a table was created
     */
    UCF_ClipboardUtil["tokenizeClipboard"] = function (sClipboardData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["tokenizeClipboard"]++;
        }
        ;
        var sRows;
        sRows = sClipboardData["split"]("\r\n");
        if (sRows["length"] === 1)
            sRows = sClipboardData["split"]("\n");
        if (sRows["length"] === 1)
            sRows = sClipboardData["split"]("\r");
        if (sRows["length"] > 1 && sRows[sRows["length"] - 1]["length"] === 0)
            sRows = sRows["slice"](0, sRows["length"] - 1);
        UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"] = new Array(sRows["length"]);
        var iNumberOfRows = UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"]["length"];
        var columns_length;
        UCF_ClipboardUtil["oClipboardData"]["nColumnCount"] = 0;
        for (var i = 0; i < iNumberOfRows; i++) {
            var columns = sRows[i]["split"]("\t");
            if (columns) {
                UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"][i] = new Array(columns["length"]);
                if (UCF_ClipboardUtil["oClipboardData"]["nColumnCount"] < columns["length"])
                    UCF_ClipboardUtil["oClipboardData"]["nColumnCount"] = columns["length"];
                columns_length = columns["length"];
                if (window["UCF_System"]["bIsRTL"])
                    for (var j = 0; j < columns_length; j++)
                        UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"][i][j] = columns[columns_length - 1 - j];
                else
                    for (j = 0; j < columns_length; j++)
                        UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"][i][j] = columns[j];
            }
        }
        if (sRows["length"] === 1 && UCF_ClipboardUtil["oClipboardData"]["nColumnCount"] === 1) {
            UCF_ClipboardUtil["oClipboardData"]["oClipboardTable"] = null;
            UCF_ClipboardUtil["oClipboardData"]["nColumnCount"] = 0;
            return false;
        }
        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["tokenizeClipboard"] = 0;
    }
    ;

    /**
     * Reads the clipboard and parses it's contents
     *
     * @public
     * @param {event} pasteevent LS Event Object
     */
    UCF_ClipboardUtil["parseClipboard"] = function (pasteevent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["parseClipboard"]++;
        }
        ;
        if (pasteevent == null) {
            pasteevent = window["event"];
            if (pasteevent["target"])
                UCF_ClipboardUtil["oClipboardData"]["sEventSource"] = pasteevent["target"]["id"];
            else
                UCF_ClipboardUtil["oClipboardData"]["sEventSource"] = pasteevent["srcElement"]["id"];
        } else
            UCF_ClipboardUtil["oClipboardData"]["sEventSource"] = pasteevent["oSource"]["id"];
        if (typeof pasteevent["oDomEvent"]["clipboardData"] !== "undefined")
            UCF_ClipboardUtil["oClipboardData"]["oClipboardContents"] = pasteevent["oDomEvent"]["clipboardData"]["getData"]('text/plain');
        else if (typeof window["clipboardData"] !== "undefined")
            UCF_ClipboardUtil["oClipboardData"]["oClipboardContents"] = window["clipboardData"]["getData"]('Text');
        else return;
        UCF_ClipboardUtil["tokenizeClipboard"](UCF_ClipboardUtil["oClipboardData"]["oClipboardContents"]);
        if (!UCF_ClipboardUtil["isTable"]())
            UCF_ClipboardUtil["cleanup"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["parseClipboard"] = 0;
    }
    ;

    /**
     * Cleans the global clipboard data object
     * @private
     */
    UCF_ClipboardUtil["cleanup"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["cleanup"]++;
        }
        ;
        UCF_ClipboardUtil["oClipboardData"]["cleanUp"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["cleanup"] = 0;
    }
    ;

    /**
     * Paste the Clipboard Contents to the visible range of a table,
     * the clipboard must have been parsed before. The pasting
     * starts with the cell holding the given control
     *
     * @public
     * @param {Object} oInputField LS EditfieldBase Object
     */
    UCF_ClipboardUtil["pasteIntoTable"] = function (oInputField) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["pasteIntoTable"]++;
        }
        ;
        var oTable = oInputField["oParentControl"];
        while (oTable && !UCF_JsUtil["bInstanceOf"](oTable, "UCF_SapTable"))
            oTable = oTable["oParentControl"];
        if (!oTable)
            return;
        var oMatrix = oTable["aGetVisibleContentGrid"]();
        var cols = UCF_ClipboardUtil["getNumberOfColumns"]();
        var rows = UCF_ClipboardUtil["getNumberOfRows"]();
        for (var iRow = 0; iRow < rows; iRow++)
            for (var iCol = 0; iCol < cols; iCol++) {
                var iColNumber = iCol;
                if (window["UCF_System"]["bIsRTL"])
                    iColNumber = cols - iCol - 1;
                if (oMatrix[oMatrix["iFocusRow"] + iRow] === undefined) return;
                var oMatrixElement = oMatrix[oMatrix["iFocusRow"] + iRow][oMatrix["iFocusColumn"] + iColNumber];
                if (!oMatrixElement)
                    break;
                if (UCF_DomUtil["bContains"](oMatrixElement, UCF_DomUtil["oGetFirstFocusableDomRef"](oMatrixElement))) {
                    var oEditField = oTable["oGetControlByDomRef"](UCF_DomUtil["oGetFirstFocusableDomRef"](oMatrixElement), true);
                    if (UCF_JsUtil["bInstanceOf"](oEditField, "UCF_EditFieldBase"))
                        oEditField["importValue"](UCF_ClipboardUtil["getCellData"](iRow, iCol));
                }
            }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["pasteIntoTable"] = 0;
    }
    ;

    /**
     * Paste the clipboard contents to the visible range of a table,
     *
     * @public
     * @param {Object} oEditfield LS Object - the event source
     * @param {Object} oBrowserEvent LS Event Object
     * @return {boolean} true is the contents where pasted otherwise false
     */
    UCF_ClipboardUtil["pasteToTable"] = function (oEditfield, oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["pasteToTable"]++;
        }
        ;
        UCF_ClipboardUtil["parseClipboard"](oBrowserEvent);
        if (UCF_ClipboardUtil["isTable"]()) {
            UCF_ClipboardUtil["pasteIntoTable"](oEditfield);
            UCF_ClipboardUtil["cleanup"]();
            return true;
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["pasteToTable"] = 0;
    }
    ;

    UCF_ClipboardUtil["sLsClipboardElementId"] = "lsClipboardElement";
    UCF_ClipboardUtil["oWriteToClipboard"] = {};

    /**
     * Copies text to the clipboard
     * @public
     * @param { string } sText the text to copy to the clipboard
     * @param { UCF_LS } oLS
     * @param { UCF_ClipboardUtil_ReadClipboardCallback } fCallback
     * @throws {Error} if it didn't work...
     */
    UCF_ClipboardUtil["copyTextToClipboard"] = function (sText, oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["copyTextToClipboard"]++;
        }
        ;
        if (!fCallback) {
            fCallback = function (err) {
                if (err) {
                    throw err;
                }
            };
        }
        UCF_ClipboardUtil["oWriteToClipboard"]["bAlreadyTried"] = false;
        UCF_ClipboardUtil["copyToClipboard"](sText, oLS, fCallback);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["copyTextToClipboard"] = 0;
    }
    ;

    /**
     * Creates the clipboard element, selects the text and copies it to the clipboard
     * @private
     * @param {string} sText the text to copy to the clipboard
     * @param { UCF_LS } oLS
     * @param { UCF_ClipboardUtil_ReadClipboardCallback } fCallback
     */
    UCF_ClipboardUtil["copyToClipboard"] = function (sText, oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["copyToClipboard"]++;
        }
        ;
        if (navigator["clipboard"]) {
            // Chrome >= 66, Firefox >= 64,
            // https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/writeText
            navigator["clipboard"]["writeText"](sText)["then"](function () {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Copying to clipboard was successful!', "ClipboardUtil.js(454): copyToClipboard");
                }
                ;
                fCallback(null);
            }, function (err) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Could not copy text: ' + err, "ClipboardUtil.js(457): copyToClipboard");
                }
                ;
                if (UCF_ClipboardUtil["oWriteToClipboard"]["bAlreadyTried"]) {
                    // Popup detour failed
                    UCF_ClipboardUtil["fallbackCopyToClipboard"](sText, oLS, fCallback);
                } else {
                    // Firefox allows access to the clipboard from user-initiated event
                    // callbacks only. So we present the user an additional popup with an
                    // [Ok] button in that case to get a user-initiated callback again
                    UCF_ClipboardUtil["writeToClipboardPopup"](sText, oLS, fCallback);
                }
            });
        } else if (UCF_UserAgent["bIsIE"]()) {
            // IE
            if (window["clipboardData"]["setData"]) {
                // IE splits multi-line text with LF instead of CRLF, which causes
                // notepad to display the "wrong" text after pasting it into
                if (window["clipboardData"]["setData"](
                    'Text',
                    sText["replace"](/\r\n/, '\n')["replace"](/\n/, '\r\n')
                )) {
                    fCallback(null);
                } else {
                    fCallback(new Error('Copying text was not successful'));
                }
            }
        } else if (UCF_UserAgent["bIsIOS"]()) {
            // iOS
            UCF_ClipboardUtil["copyToClipboard_iOS"](sText, oLS, fCallback);
        } else if (UCF_UserAgent["bIsEdgeHtml"]()) {
            // Edge currently does not support the clipboard, see
            // https://dev.modern.ie/platform/status/clipboardapi/
            fCallback(new Error('Copying text for Edge not supported'));
        } else {
            // General fallback
            UCF_ClipboardUtil["fallbackCopyToClipboard"](sText, oLS, fCallback);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["copyToClipboard"] = 0;
    }
    ;

    UCF_ClipboardUtil["fallbackCopyToClipboard"] = function (sText, oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["fallbackCopyToClipboard"]++;
        }
        ;
        var clipboardArea = document["getElementById"](UCF_ClipboardUtil["sLsClipboardElementId"]);
        var oSelectionRange;
        var oRange;
        var textRange;
        var bSuccess;

        if (!clipboardArea) {
            clipboardArea = document["createElement"]('div');
            clipboardArea["id"] = UCF_ClipboardUtil["sLsClipboardElementId"];
            clipboardArea["style"]["position"] = 'fixed';
            clipboardArea["style"]["top"] = -10000;
            clipboardArea["style"]["left"] = 0;
            clipboardArea["style"]["width"] = '2em';
            clipboardArea["style"]["height"] = '2em';
            clipboardArea["style"]["overflow"] = 'hidden';
            clipboardArea["style"]["whiteSpace"] = 'pre';
            clipboardArea["style"]["background"] = '#fff';
            clipboardArea["style"]["color"] = 'initial';
            clipboardArea["style"]["font"] = 'initial';
            clipboardArea["style"]["border"] = 'initial';
            document["body"]["appendChild"](clipboardArea);
        }

        clipboardArea["textContent"] = sText;

        if (window["getSelection"] && document["createRange"]) {
            oSelectionRange = window["getSelection"]();
            oSelectionRange["removeAllRanges"]();
            oRange = document["createRange"]();
            oRange["selectNodeContents"](clipboardArea);
            oSelectionRange["addRange"](oRange);
        } else if (document["selection"] && document["body"]["createTextRange"]) {
            textRange = document["body"]["createTextRange"]();
            textRange["moveToElementText"](clipboardArea);
            textRange["select"]();
        }

        try {
            bSuccess = document["execCommand"]('copy');
            UCF_ClipboardUtil["removeClipboardElement"]();
            if (bSuccess) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Copying text command was successful!', "ClipboardUtil.js(537): fallbackCopyToClipboard");
                }
                ;
                fCallback(null);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Could not copy text, try with popup', "ClipboardUtil.js(540): fallbackCopyToClipboard");
                }
                ;
                UCF_ClipboardUtil["writeToClipboardPopup"](sText, oLS, fCallback);
            }
        } catch (err) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Could not copy text, give up', "ClipboardUtil.js(544): fallbackCopyToClipboard");
            }
            ;
            UCF_ClipboardUtil["removeClipboardElement"]();
            fCallback(new Error('Copying text was not successful'));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["fallbackCopyToClipboard"] = 0;
    }
    ;

    /**
     * Creates the clipboard element for iOS, selects the text and copies it to the
     * clipboard, see
     * https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios
     * @private
     * @param {string} sText the text to copy to the clipboard
     * @param { UCF_LS } oLS
     * @param { UCF_ClipboardUtil_ReadClipboardCallback } fCallback
     */
    UCF_ClipboardUtil["copyToClipboard_iOS"] = function (sText, oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["copyToClipboard_iOS"]++;
        }
        ;
        var clipboardArea = document["getElementById"](UCF_ClipboardUtil["sLsClipboardElementId"]);
        var oSelectionRange;
        var oRange;
        var bSuccess;

        if (!clipboardArea) {
            clipboardArea = document["createElement"]('textarea');
            clipboardArea["id"] = UCF_ClipboardUtil["sLsClipboardElementId"];
            clipboardArea["style"]["position"] = 'fixed';
            clipboardArea["style"]["top"] = -10000;
            clipboardArea["style"]["left"] = 0;
            clipboardArea["style"]["width"] = '2em';
            clipboardArea["style"]["height"] = '2em';
            clipboardArea["style"]["overflow"] = 'hidden';
            clipboardArea["style"]["background"] = 'transparent';
            clipboardArea["style"]["whiteSpace"] = 'pre';
            document["body"]["appendChild"](clipboardArea);
        }

        clipboardArea["contentEditable"] = true;
        clipboardArea["readOnly"] = false;
        clipboardArea["value"] = sText;
        oSelectionRange = window["getSelection"]();
        oSelectionRange["removeAllRanges"]();
        oRange = document["createRange"]();
        oRange["selectNodeContents"](clipboardArea);
        oSelectionRange["addRange"](oRange);
        clipboardArea["contentEditable"] = false;
        clipboardArea["readOnly"] = true;
        clipboardArea["setSelectionRange"](0, 999999);

        try {
            bSuccess = document["execCommand"]('copy');
            if (bSuccess) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Copying text command was successful', "ClipboardUtil.js(594): copyToClipboard_iOS");
                }
                ;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Copying text command was not successful', "ClipboardUtil.js(596): copyToClipboard_iOS");
                }
                ;
                UCF_ClipboardUtil["writeToClipboardPopup"](sText, oLS, fCallback);
            }
        } catch (err) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Copying text command was not successful', "ClipboardUtil.js(600): copyToClipboard_iOS");
            }
            ;
            UCF_ClipboardUtil["removeClipboardElement"]();
            throw new Error('Copying text was not successful');
        }
        UCF_ClipboardUtil["removeClipboardElement"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["copyToClipboard_iOS"] = 0;
    }
    ;

    /**
     * Removes the clipboard element
     */
    UCF_ClipboardUtil["removeClipboardElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["removeClipboardElement"]++;
        }
        ;
        var clipboardArea = document["getElementById"](UCF_ClipboardUtil["sLsClipboardElementId"]);
        if (clipboardArea) {
            try {
                UCF_DomUtil["removeFromDom"](clipboardArea);
            } catch (err) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Oops, unable to remove clipboardArea', "ClipboardUtil.js(616): removeClipboardElement");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["removeClipboardElement"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sText
     * @param {UCF_LS} oLS
     * @param {UCF_ClipboardUtil_ReadClipboardCallback} [fCallback]
     */
    UCF_ClipboardUtil["writeToClipboardPopup"] = function (sText, oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["writeToClipboardPopup"]++;
        }
        ;

        /** */
        function removePopup() {
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["getUCFInstance"]()["close"]();
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["destroy"]();
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"] = null;
        };

        /** */
        function onClose() {
            removePopup();
            if (fCallback) {
                fCallback(new Error('User decided to cancel the operation.'));
            }
        }

        /** */
        function onOk() {
            UCF_ClipboardUtil["oWriteToClipboard"]["bAlreadyTried"] = true;
            UCF_ClipboardUtil["copyToClipboard"](sText, oLS, fCallback);
            removePopup();
        }

        if (UCF_ClipboardUtil["oWriteToClipboard"]["bAlreadyTried"] || !oLS) {
            if (fCallback) {
                fCallback(new Error('Copying text was not successful'));
            }
        } else {
            oLS = oLS["oGetInternal"](window["UCF_System"]);

            /** @type {string[]} */
            var aThemeTags = UCF_ResourceUtil["oExtractCssMetaData"]()["Tags"];

            /* beautify preserve:start */
            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"] = oLS["oCreateClientControl"]({
                "PopupWindow": {
                    "Id": 'lsClipboardWrite-popup',
                    "Title": (oLS["sGetText"]('SAPUR_CLP_POPUP_WRITE') || 'Clipboard Write Access'),
                    "InfoType": 'QUESTION',
                    "IsResizable": false,
                    "HasContentPadding": true,
                    "HasCloseButton": true,
                    "Buttons": [
                        {
                            "Button": UCF_JsUtil["extend"](
                                {
                                    "Id": 'lsClipboardWrite-popup-myok',
                                    "Text": oLS["sGetText"]('SAPUR_CLP_POPUP_ALLOW') || 'Allow'
                                }, UCF_JsUtil["contains"](aThemeTags, 'Fiori_3')
                                    ? {"Design": 'EMPHASIZED'}
                                    : {}
                            )
                        }
                    ],
                    "Content": {
                        "SingleColumnLayout": {
                            "Cells": [
                                {
                                    "SingleColumnLayoutCell": {
                                        "HAlign": 'CENTER',
                                        "Wrapping": false,
                                        "Content": {
                                            "TextView": {
                                                "Text": (oLS["sGetText"]('SAPUR_CLP_POPUP_WRITE_TXT') || 'The current application would like to write into the clipboard')
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                }
            });
            /* beautify preserve:end */

            UCF_ClipboardUtil["oWriteToClipboard"]["oPopup"]["placeAt"](oLS["oGetAssociatedAreaRef"]());
            oLS["oGetClientControlById"]('lsClipboardWrite-popup-myok')["attachPress"](onOk);
            oLS["oGetClientControlById"]('lsClipboardWrite-popup')["attachClose"](onClose);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["writeToClipboardPopup"] = 0;
    }
    ;

    UCF_ClipboardUtil["oReadFromClipboard"] = {};

    /** @typedef {function(Error, string): void} UCF_ClipboardUtil_ReadClipboardCallback */
    /**
     * @public
     * @static
     * @param {UCF_LS} oLS
     * @param {UCF_ClipboardUtil_ReadClipboardCallback} fCallback
     */
    UCF_ClipboardUtil["readFromClipboard"] = function (oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["readFromClipboard"]++;
        }
        ;
        if (window["navigator"]["msSaveOrOpenBlob"] && window["clipboardData"] || UCF_UserAgent["bIsIECompatibilityMode"]()) { // IE
            fCallback(null, window["clipboardData"]["getData"]("Text"));
        } else if (navigator["clipboard"] && navigator["clipboard"]["readText"]) { // Chrome with https
            UCF_ClipboardUtil["readFromClipboardApi"](oLS, fCallback);
        } else { // others
            UCF_ClipboardUtil["readFromClipboardPopup"](oLS, fCallback);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["readFromClipboard"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Object} oLS
     * @param {UCF_ClipboardUtil_ReadClipboardCallback} fCallback
     */
    UCF_ClipboardUtil["readFromClipboardApi"] = function (oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["readFromClipboardApi"]++;
        }
        ;
        navigator["clipboard"]["readText"]()["then"](
            function (sPastedText) {
                fCallback(null, sPastedText);
            },
            function () {
                UCF_ClipboardUtil["readFromClipboardPopup"](oLS, fCallback);
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["readFromClipboardApi"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_LS} oLS
     * @param {UCF_ClipboardUtil_ReadClipboardCallback} fCallback
     */
    UCF_ClipboardUtil["readFromClipboardPopup"] = function (oLS, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClipboardUtil["_"]["readFromClipboardPopup"]++;
        }
        ;
        var removeClipboardArea;
        var onClose;
        var onPaste;
        var onAnyEvent;

        /** */
        removeClipboardArea = function () {
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"]["getUCFInstance"]()["close"]();
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"]["destroy"]();
            UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"] = null;
            UCF_JsUtil["delayedCall"](0, UCF_DomUtil, 'detachEvent', [document, 'paste', onPaste, true]);

            try {
                UCF_DomUtil["removeFromDom"](UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"]);
            } catch (err) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Oops, unable to remove clipboardArea', "ClipboardUtil.js(757): readFromClipboardPopup");
                }
                ;
            }
            UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"] = null;
        };

        /** */
        onClose = function () {
            removeClipboardArea();
            fCallback(new Error('User decided to cancel the operation'));
        };

        /** @param {ClipboardEvent} oDomEvent */
        onPaste = function (oDomEvent) {
            var sPastedText = oDomEvent["clipboardData"]["getData"]('Text') || '';

            removeClipboardArea();
            fCallback(null, sPastedText);
        };

        /**
         * @param {Object} oEvent
         */
        onAnyEvent = function (oEvent) {
            var oBrowserEvent = oEvent["oGetParam"]('oBrowserEvent');
            var sName = oBrowserEvent["sGetName"]();
            var sId = oBrowserEvent["oGetSource"]()["id"];
            if (
                sName === 'blur' &&
                sId === 'lsClipboardPaste-textarea'
            ) {
                UCF_DomUtil["focusDomElement"](UCF_DomUtil["$"]('lsClipboardPaste-textarea'));
            }
        };

        /* beautify preserve:start */
        UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"] = oLS["oCreateClientControl"]({
            "PopupWindow": {
                "Id": 'lsClipboardPaste-popup',
                "Title": (oLS["sGetText"]('SAPUR_CLP_POPUP_READ') || 'Clipboard Read Access'),
                "InfoType": 'QUESTION',
                "Y": (UCF_UserAgent["bIsIOS"]() || UCF_UserAgent["bIsAndroid"]() ? 16 : -1),
                "IsResizable": false,
                "HasContentPadding": true,
                "HasCloseButton": true,
                "Content": {
                    "SingleColumnLayout": {
                        "Cells": [
                            {
                                "SingleColumnLayoutCell": {
                                    "HAlign": 'CENTER',
                                    "Wrapping": false,
                                    "Content": {
                                        "TextView": {
                                            "Text": UCF_UserAgent["bIsIOS"]()
                                                ? (oLS["sGetText"]('SAPUR_CLP_POPUP_TXT_IOS') || 'The current application would like to read from the clipboard. To allow this, press [PASTE]')
                                                : (oLS["sGetText"]('SAPUR_CLP_POPUP_TXT') || 'The current application would like to read from the clipboard. To allow this, press [CTRL][V]')
                                        }
                                    }
                                }
                            }
                        ]
                    }
                }
            }
        });
        /* beautify preserve:end */

        UCF_ClipboardUtil["oReadFromClipboard"]["oPopup"]["placeAt"](oLS["oGetAssociatedAreaRef"]());
        oLS["oGetClientControlById"]('lsClipboardPaste-popup')["attachClose"](onClose);

        UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"] = document["getElementById"]('lsClipboardPaste-textarea');
        if (!UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"]) {
            UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"] = document["createElement"]("TEXTAREA");
            UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"]["setAttribute"]('id', 'lsClipboardPaste-textarea');
            UCF_DomUtil["setStyle"](
                UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"],
                UCF_UserAgent["bIsIOS"]() || UCF_UserAgent["bIsAndroid"]()
                    ? {"position": 'absolute', "top": '-1000px', "left": '-1000px'}
                    : {"display": 'none'}
            );
            UCF_DomUtil["append"](
                UCF_DomUtil["$"]('lsClipboardPaste-popup-cnt'),
                UCF_ClipboardUtil["oReadFromClipboard"]["oClipboardArea"]
            );

            if (UCF_UserAgent["bIsIOS"]() || UCF_UserAgent["bIsAndroid"]()) {
                UCF_DomUtil["focusDomElement"](UCF_DomUtil["$"]('lsClipboardPaste-textarea'));
            }
        }

        if (UCF_UserAgent["bIsIOS"]() || UCF_UserAgent["bIsAndroid"]()) {
            oLS["oBrowserWindow"]["attachEvent"](
                oLS["oBrowserWindow"]["E_EVENTS"]["AnyEvent"], {"onAnyEvent": onAnyEvent},
                'onAnyEvent'
            );
        }

        UCF_DomUtil["attachEvent"](document, 'paste', onPaste, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClipboardUtil["_"]["readFromClipboardPopup"] = 0;
    }
    ;

    UCF_ClipboardUtil.prototype["aPublicMethods"] = ["destroyStatic", "setHtmlToClipboard", "getClipboardTable", "isTable", "getCellData", "getEventSource", "parseClipboard", "pasteIntoTable", "pasteToTable", "copyTextToClipboard", "readFromClipboard"].concat(UCF_ClipboardUtil.prototype.aPublicMethods || []);
    /* global _assert, _trace, WARNING */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="./StringUtil.js"/>

    /* eslint no-magic-numbers:0  */
    /** @typedef {string} UCF_ColorUtil_3Hex e.g. `#fff` */
    /** @typedef {string} UCF_ColorUtil_6Hex e.g. `#ffffff` */
    /** @typedef {string} UCF_ColorUtil_8Hex e.g. `#ffffff80` */
    /** @typedef {string} UCF_ColorUtil_Rgb e.g. `rgb(12, 34, 56)`, `rgb(12,34,56)` */
    /** @typedef {string} UCF_ColorUtil_Rgba e.g. `rgba(12, 34, 56, 0.5)`, `rgba(12,34,56,.5)` */
    /** @typedef {{0:number, 1:number, 2:number, 3:number}} UCF_ColorUtil_RgbaValues e.g. `[12, 34, 56, 78]` */
    /**
     * @typedef {string} UCF_ColorUtil_Colorname e.g. `tomato`
     * @see UCF_ColorUtil.E_COLOR_NAME
     */
    /** @typedef {UCF_ColorUtil_3Hex|UCF_ColorUtil_6Hex|UCF_ColorUtil_8Hex|UCF_ColorUtil_Rgb|UCF_ColorUtil_Rgba|UCF_ColorUtil_RgbaValues|UCF_ColorUtil_Colorname} UCF_ColorUtil_Colorlike */

    /** @typedef {string|number} _Threshold */
    /**
     *
     * @constructor
     */
    function UCF_ColorUtil() {
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["UCF_ColorUtil"]++;
        }
        ;

    };window["UCF_ColorUtil"] = UCF_ColorUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ColorUtil");
        UCF_ColorUtil["_"] = {UCF_ColorUtil: 0};
    }
    ;
    ;
    /**
     * @private
     * @static
     * @const {RegExp}
     */
    UCF_ColorUtil["R_THREE_DIGIT_HEX"] = /^#(?:([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F]))$/;
    /**
     * @private
     * @static
     * @const {RegExp}
     */
    UCF_ColorUtil["R_SIX_DIGIT_HEX"] = /^#(?:([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2}))$/;
    /**
     * @private
     * @static
     * @const {RegExp}
     */
    UCF_ColorUtil["R_EIGHT_DIGIT_HEX"] = /^#(?:([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2}))$/;
    /**
     * @private
     * @static
     * @const {RegExp}
     */
    UCF_ColorUtil["R_RGB"] = /^rgb\((?:(\d{0,3}), ?(\d{0,3}), ?(\d{0,3}))\)$/;
    /**
     * @private
     * @static
     * @const {RegExp}
     */
    UCF_ColorUtil["R_RGBA"] = /^rgba\((?:(\d{0,3}), ?(\d{0,3}), ?(\d{0,3}), ?(\d?\.?\d+))\)$/;
    /**
     * @private
     * @static
     * @const
     * @enum {UCF_ColorUtil_Rgba}
     */
    UCF_ColorUtil["E_COLOR_NAME"] = {
        "antiquewhite": 'rgba(250, 235, 215, 1.0)',
        "aqua": 'rgba(0, 255, 255, 1.0)',
        "aquamarine": 'rgba(127, 255, 212, 1.0)',
        "azure": 'rgba(240, 255, 255, 1.0)',
        "beige": 'rgba(245, 245, 220, 1.0)',
        "bisque": 'rgba(255, 228, 196, 1.0)',
        "black": 'rgba(0, 0, 0, 1.0)',
        "blanchedalmond": 'rgba(255, 228, 196, 1.0)',
        "blue": 'rgba(0, 0, 255, 1.0)',
        "blueviolet": 'rgba(138, 43, 226, 1.0)',
        "brown": 'rgba(165, 42, 42, 1.0)',
        "burlywood": 'rgba(222, 184, 135, 1.0)',
        "cadetblue": 'rgba(95, 158, 160, 1.0)',
        "chartreuse": 'rgba(127, 255, 0, 1.0)',
        "chocolate": 'rgba(210, 105, 30, 1.0)',
        "coral": 'rgba(255, 127, 80, 1.0)',
        "cornflowerblue": 'rgba(100, 149, 237, 1.0)',
        "cornsilk": 'rgba(255, 248, 220, 1.0)',
        "crimson": 'rgba(220, 20, 60, 1.0)',
        "darkblue": 'rgba(0, 0, 139, 1.0)',
        "darkcyan": 'rgba(0, 139, 139, 1.0)',
        "darkgoldenrod": 'rgba(184, 134, 11, 1.0)',
        "darkgray": 'rgba(169, 169, 169, 1.0)',
        "darkgreen": 'rgba(0, 100, 0, 1.0)',
        "darkgrey": 'rgba(169, 169, 169, 1.0)',
        "darkkhaki": 'rgba(189, 183, 107, 1.0)',
        "darkmagenta": 'rgba(139, 0, 139, 1.0)',
        "darkolivegreen": 'rgba(85, 107, 47, 1.0)',
        "darkorange": 'rgba(255, 140, 0, 1.0)',
        "darkorchid": 'rgba(153, 50, 204, 1.0)',
        "darkred": 'rgba(139, 0, 0, 1.0)',
        "darksalmon": 'rgba(233, 150, 122, 1.0)',
        "darkseagreen": 'rgba(143, 188, 143, 1.0)',
        "darkslateblue": 'rgba(72, 61, 139, 1.0)',
        "darkslategray": 'rgba(47, 79, 79, 1.0)',
        "darkslategrey": 'rgba(47, 79, 79, 1.0)',
        "darkturquoise": 'rgba(0, 206, 209, 1.0)',
        "darkviolet": 'rgba(148, 0, 211, 1.0)',
        "deeppink": 'rgba(255, 20, 147, 1.0)',
        "deepskyblue": 'rgba(0, 191, 255, 1.0)',
        "dimgray": 'rgba(105, 105, 105, 1.0)',
        "dimgrey": 'rgba(105, 105, 105, 1.0)',
        "dodgerblue": 'rgba(30, 144, 255, 1.0)',
        "firebrick": 'rgba(178, 34, 34, 1.0)',
        "floralwhite": 'rgba(255, 250, 240, 1.0)',
        "forestgreen": 'rgba(34, 139, 34, 1.0)',
        "fuchsia": 'rgba(255, 0, 255, 1.0)',
        "gainsboro": 'rgba(220, 220, 220, 1.0)',
        "ghostwhite": 'rgba(248, 248, 255, 1.0)',
        "gold": 'rgba(255, 215, 0, 1.0)',
        "goldenrod": 'rgba(218, 165, 32, 1.0)',
        "gray": 'rgba(128, 128, 128, 1.0)',
        "green": 'rgba(0, 128, 0, 1.0)',
        "greenyellow": 'rgba(173, 255, 47, 1.0)',
        "grey": 'rgba(128, 128, 128, 1.0)',
        "honeydew": 'rgba(240, 255, 240, 1.0)',
        "hotpink": 'rgba(255, 105, 180, 1.0)',
        "indianred": 'rgba(205, 92, 92, 1.0)',
        "indigo": 'rgba(75, 0, 130, 1.0)',
        "ivory": 'rgba(255, 255, 240, 1.0)',
        "khaki": 'rgba(240, 230, 140, 1.0)',
        "lavender": 'rgba(230, 230, 250, 1.0)',
        "lavenderblush": 'rgba(255, 240, 245, 1.0)',
        "lawngreen": 'rgba(124, 252, 0, 1.0)',
        "lemonchiffon": 'rgba(255, 250, 205, 1.0)',
        "lightblue": 'rgba(173, 216, 230, 1.0)',
        "lightcoral": 'rgba(240, 128, 128, 1.0)',
        "lightcyan": 'rgba(224, 255, 255, 1.0)',
        "lightgoldenrodyellow": 'rgba(250, 250, 210, 1.0)',
        "lightgray": 'rgba(211, 211, 211, 1.0)',
        "lightgreen": 'rgba(144, 238, 144, 1.0)',
        "lightgrey": 'rgba(211, 211, 211, 1.0)',
        "lightpink": 'rgba(255, 182, 193, 1.0)',
        "lightsalmon": 'rgba(255, 160, 122, 1.0)',
        "lightseagreen": 'rgba(32, 178, 170, 1.0)',
        "lightskyblue": 'rgba(135, 206, 250, 1.0)',
        "lightslategray": 'rgba(119, 136, 153, 1.0)',
        "lightslategrey": 'rgba(119, 136, 153, 1.0)',
        "lightsteelblue": 'rgba(176, 196, 222, 1.0)',
        "lightyellow": 'rgba(255, 255, 224, 1.0)',
        "lime": 'rgba(0, 255, 0, 1.0)',
        "limegreen": 'rgba(50, 205, 50, 1.0)',
        "linen": 'rgba(250, 240, 230, 1.0)',
        "maroon": 'rgba(128, 0, 0, 1.0)',
        "mediumaquamarine": 'rgba(102, 205, 170, 1.0)',
        "mediumblue": 'rgba(0, 0, 205, 1.0)',
        "mediumorchid": 'rgba(186, 85, 211, 1.0)',
        "mediumpurple": 'rgba(147, 112, 219, 1.0)',
        "mediumseagreen": 'rgba(60, 179, 113, 1.0)',
        "mediumslateblue": 'rgba(123, 104, 238, 1.0)',
        "mediumspringgreen": 'rgba(0, 250, 154, 1.0)',
        "mediumturquoise": 'rgba(72, 209, 204, 1.0)',
        "mediumvioletred": 'rgba(199, 21, 133, 1.0)',
        "midnightblue": 'rgba(25, 25, 112, 1.0)',
        "mintcream": 'rgba(245, 255, 250, 1.0)',
        "mistyrose": 'rgba(255, 228, 225, 1.0)',
        "moccasin": 'rgba(255, 228, 181, 1.0)',
        "navajowhite": 'rgba(255, 222, 173, 1.0)',
        "navy": 'rgba(0, 0, 128, 1.0)',
        "oldlace": 'rgba(253, 245, 230, 1.0)',
        "olive": 'rgba(128, 128, 0, 1.0)',
        "olivedrab": 'rgba(107, 142, 35, 1.0)',
        "orangered": 'rgba(255, 69, 0, 1.0)',
        "orchid": 'rgba(218, 112, 214, 1.0)',
        "palegoldenrod": 'rgba(238, 232, 170, 1.0)',
        "palegreen": 'rgba(152, 251, 152, 1.0)',
        "paleturquoise": 'rgba(175, 238, 238, 1.0)',
        "palevioletred": 'rgba(219, 112, 147, 1.0)',
        "papayawhip": 'rgba(255, 239, 213, 1.0)',
        "peachpuff": 'rgba(255, 218, 185, 1.0)',
        "peru": 'rgba(205, 133, 63, 1.0)',
        "pink": 'rgba(255, 192, 203, 1.0)',
        "plum": 'rgba(221, 160, 221, 1.0)',
        "powderblue": 'rgba(176, 224, 230, 1.0)',
        "purple": 'rgba(128, 0, 128, 1.0)',
        "red": 'rgba(255, 0, 0, 1.0)',
        "rosybrown": 'rgba(188, 143, 143, 1.0)',
        "royalblue": 'rgba(65, 105, 225, 1.0)',
        "saddlebrown": 'rgba(139, 69, 19, 1.0)',
        "salmon": 'rgba(250, 128, 114, 1.0)',
        "sandybrown": 'rgba(244, 164, 96, 1.0)',
        "seagreen": 'rgba(46, 139, 87, 1.0)',
        "seashell": 'rgba(255, 245, 238, 1.0)',
        "sienna": 'rgba(160, 82, 45, 1.0)',
        "silver": 'rgba(192, 192, 192, 1.0)',
        "skyblue": 'rgba(135, 206, 235, 1.0)',
        "slateblue": 'rgba(106, 90, 205, 1.0)',
        "slategray": 'rgba(112, 128, 144, 1.0)',
        "slategrey": 'rgba(112, 128, 144, 1.0)',
        "snow": 'rgba(255, 250, 250, 1.0)',
        "springgreen": 'rgba(0, 255, 127, 1.0)',
        "steelblue": 'rgba(70, 130, 180, 1.0)',
        "tan": 'rgba(210, 180, 140, 1.0)',
        "teal": 'rgba(0, 128, 128, 1.0)',
        "thistle": 'rgba(216, 191, 216, 1.0)',
        "tomato": 'rgba(255, 99, 71, 1.0)',
        "transparent": 'rgba(0, 0, 0, 0.0)',
        "turquoise": 'rgba(64, 224, 208, 1.0)',
        "violet": 'rgba(238, 130, 238, 1.0)',
        "wheat": 'rgba(245, 222, 179, 1.0)',
        "white": 'rgba(255, 255, 255, 1.0)',
        "whitesmoke": 'rgba(245, 245, 245, 1.0)',
        "yellow": 'rgba(255, 255, 0, 1.0)',
        "yellowgreen": 'rgba(154, 205, 50, 1.0)'
    };
// #region internal utilities =================================================
// #region   sToHex -----------------------------------------------------------
    /**
     * @private
     * @static
     * @param {number} iNum the number to convert to hex
     * @param {number} [iLength] the length to pad the hex string to
     * @return {string}
     */
    UCF_ColorUtil["sToHex"] = function (iNum, iLength) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sToHex"]++;
        }
        ;
        return UCF_StringUtil["fillChars"](
            iNum["toString"](16),
            '0',
            typeof iLength === 'number' ? iLength : 2,
            true
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sToHex"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #region   aChannels --------------------------------------------------------
    /**
     * @private
     * @static
     * @param {UCF_ColorUtil_Colorlike} sString the color to get the channels from
     * @return {Array<number>}
     */
    UCF_ColorUtil["aChannels"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["aChannels"]++;
        }
        ;
        /** @type {UCF_ColorUtil_Rgba} */
        var sColor = UCF_ColorUtil["sColor"](sString);
        /** @type {Array<string>} */
        var aMatch;

        if (aMatch = UCF_ColorUtil["R_RGBA"]["exec"](sColor)) {
            return UCF_JsUtil["map"](
                aMatch["slice"](1, 5),
                function (s) {
                    return parseFloat(s);
                }
            );
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Could not access channels of "' + sColor + '". Returning [0, 0, 0, 1.0].', "ColorUtil.js(247): aChannels");
            }
            ;

            return [0, 0, 0, 1];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["aChannels"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #endregion =================================================================
// #region functions ==========================================================
    /**
     * @public
     * @static
     * @param {UCF_ColorUtil_Colorlike} sString the color definition
     * @param {boolean} [bStrict=false] `true` to throw an Error if sString can not
     * be parsed to a color
     * @return {UCF_ColorUtil_Rgba} the input, converted to rgba(...)
     */
    UCF_ColorUtil["sColor"] = function (sString, bStrict) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sColor"]++;
        }
        ;
        /** @type {Array<string>} */
        var aMatch;

        if (UCF_JsUtil["bIsArray"](sString) && sString["length"] === 4) {
            return 'rgba(' +
                UCF_JsUtil["map"](sString["slice"](0, 3), Math["round"])["join"](', ') +
                ', ' + sString[3] +
                ')';
        } else if (aMatch = UCF_ColorUtil["R_THREE_DIGIT_HEX"]["exec"](sString)) {
            return 'rgba(' + UCF_JsUtil["map"](
                aMatch["slice"](1),
                function (g) {
                    return (parseInt(g, 16) * 17)["toString"](10);
                }
            )["join"](', ') + ', 1.0)';
        } else if (aMatch = UCF_ColorUtil["R_SIX_DIGIT_HEX"]["exec"](sString)) {
            return 'rgba(' + UCF_JsUtil["map"](
                aMatch["slice"](1),
                function (g) {
                    return parseInt(g, 16)["toString"](10);
                }
            )["join"](', ') + ', 1.0)';
        } else if (aMatch = UCF_ColorUtil["R_EIGHT_DIGIT_HEX"]["exec"](sString)) {
            return 'rgba(' + UCF_JsUtil["map"](
                aMatch["slice"](1, 4),
                function (g) {
                    return parseInt(g, 16)["toString"](10);
                }
            )["join"](', ') + ', ' + (parseInt(aMatch[4], 16) / 255)["toPrecision"](2) + ')';
        } else if (aMatch = UCF_ColorUtil["R_RGB"]["exec"](sString)) {
            return 'rgba(' + aMatch["slice"](1)["join"](', ') + ', 1.0)';
        } else if (aMatch = UCF_ColorUtil["R_RGBA"]["exec"](sString)) {
            return 'rgba(' + aMatch["slice"](1, 4)
                ["concat"]([parseFloat(aMatch[4])])
                ["join"](', ') + ')';
        } else if (sString in UCF_ColorUtil["E_COLOR_NAME"]) {
            return UCF_ColorUtil["E_COLOR_NAME"][sString];
        } else if (bStrict) {
            throw new Error('Could not parse "' + sString + '" to color.');
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Could not parse "' + sString + '" to color. Returning black.', "ColorUtil.js(298): sColor");
            }
            ;

            return 'rgba(0, 0, 0, 1.0)';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sColor"] = 0;
    }
    ;

// #endregion =================================================================
// #region color definition functions =========================================
    /**
     * @public
     * @static
     * @param {_Color} sColor the color to convert to hex
     * @return {string}
     */
    UCF_ColorUtil["sHex"] = function (sColor) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sHex"]++;
        }
        ;
        /** @type {Array<number>} */
        var aChannels = UCF_ColorUtil["aChannels"](sColor);

        return '#' +
            UCF_JsUtil["map"](
                aChannels["slice"](0, 3),
                function (iChannel) {
                    return UCF_ColorUtil["sToHex"](iChannel);
                }
            )["join"]('') +
            (aChannels[3] === 1
                    ? ''
                    : UCF_ColorUtil["sToHex"](Math["round"](aChannels[3] * 255))
            );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sHex"] = 0;
    }
    ;
// #endregion =================================================================
// #region color operation functions ==========================================
// #region   sFade ------------------------------------------------------------
    /**
     * @public
     * @static
     * @param {string} sColor the color to fade to opacity
     * @param {number} iOpacity the opacity
     * @return {_Color}
     */
    UCF_ColorUtil["sFade"] = function (sColor, iOpacity) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sFade"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(0 <= iOpacity && iOpacity <= 1, "0 <= iOpacity && iOpacity <= 1", "ColorUtil.js(337): sFade");
        }
        ;

        return UCF_ColorUtil["sColor"](
            UCF_ColorUtil["aChannels"](sColor)["slice"](0, 3)["concat"]([iOpacity])
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sFade"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #region   sContrast --------------------------------------------------------
    /**
     * @public
     * @param {_Color} sColor
     * @param {_Color} [sDark='#000']
     * @param {_Color} [sLight='#000']
     * @param {_Threshold} [oThreshold=0.5]
     * @return {_Color}
     */
    UCF_ColorUtil["sContrast"] = function (sColor, sDark, sLight, oThreshold) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sContrast"]++;
        }
        ;
        /** @type {number} */
        var iThreshold = typeof oThreshold === 'number'
            ? oThreshold
            : typeof oThreshold === 'string'
                ? (parseInt(oThreshold) || 50) / 100
                : 0.5;
        /** @type {_Color} */
        var sD = typeof sDark === 'string' ? sDark : UCF_ColorUtil["sColor"]('#000');
        /** @type {_Color} */
        var sL = typeof sLight === 'string' ? sLight : UCF_ColorUtil["sColor"]('#fff');

        return UCF_ColorUtil["fLuma"](sColor) >= iThreshold ? sD : sL;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sContrast"] = 0;
    }
    ;
// #endregion
// #endregion =================================================================
// #region color channel functions ============================================
// #region   fAlpha -----------------------------------------------------------
    /**
     * @public
     * @static
     * @param {_Color} sColor the color to get the alpha channel from
     * @return {number} alpha channel [0..1] of the given color
     */
    UCF_ColorUtil["fAlpha"] = function (sColor) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["fAlpha"]++;
        }
        ;
        return UCF_ColorUtil["aChannels"](sColor)[3];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["fAlpha"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #region   fLuma ------------------------------------------------------------
    /**
     * @see {@link https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef}
     * @public
     * @static
     * @param {_Color} sColor
     * @return {number} with 2-digit precision
     */
    UCF_ColorUtil["fLuma"] = function (sColor) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["fLuma"]++;
        }
        ;
        /** @type {number[]} */
        var aChannels = UCF_ColorUtil["aChannels"](sColor);
        /** @type {number} */
        var fRsrgb = aChannels[0] / 255;
        /** @type {number} */
        var fGsrgb = aChannels[1] / 255;
        /** @type {number} */
        var fBsrgb = aChannels[2] / 255;
        /** @type {number} */
        var fR = (fRsrgb <= 0.03928)
            ? (fRsrgb / 12.92)
            : Math["pow"]((fRsrgb + 0.055) / 1.055, 2.4);
        /** @type {number} */
        var fG = (fGsrgb <= 0.03928)
            ? (fGsrgb / 12.92)
            : Math["pow"]((fGsrgb + 0.055) / 1.055, 2.4);
        /** @type {number} */
        var fB = (fBsrgb <= 0.03928)
            ? (fBsrgb / 12.92)
            : Math["pow"]((fBsrgb + 0.055) / 1.055, 2.4);

        return parseFloat((0.2126 * fR + 0.7152 * fG + 0.0722 * fB)["toPrecision"](2));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["fLuma"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #endregion =================================================================
// #region color blending functions ===========================================
// #region   sMix -------------------------------------------------------------
    /**
     * @public
     * @static
     * @param {_Color} sColor1 a color
     * @param {_Color} sColor2 a color
     * @param {number} [iWeight=0.5] the balance point between the two colors
     * @return {_Color}
     */
    UCF_ColorUtil["sMix"] = function (sColor1, sColor2, iWeight) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ColorUtil["_"]["sMix"]++;
        }
        ;
        /** @type {Array<number>} */
        var aChannels1;
        /** @type {Array<number>} */
        var aChannels2;
        /** @type {number} */
        var fAlpha;
        /** @type {number} */
        var iPercentage;
        /** @type {number} */
        var iWeight1;
        /** @type {number} */
        var iWeight2;

        if (typeof iWeight !== 'number') {
            iWeight = .5;
        }
        aChannels1 = UCF_ColorUtil["aChannels"](sColor1);
        aChannels2 = UCF_ColorUtil["aChannels"](sColor2);

        iPercentage = iWeight * 2 - 1;
        fAlpha = aChannels1[3] - aChannels2[3];
        iWeight1 = (((iPercentage * fAlpha === -1)
            ? iPercentage
            : (iPercentage + fAlpha) / (1 + iPercentage * fAlpha)) + 1) / 2;
        iWeight2 = 1 - iWeight1;

        return UCF_ColorUtil["sColor"]([
            aChannels1[0] * iWeight1 + aChannels2[0] * iWeight2,
            aChannels1[1] * iWeight1 + aChannels2[1] * iWeight2,
            aChannels1[2] * iWeight1 + aChannels2[2] * iWeight2,
            aChannels1[3] * iWeight + aChannels2[3] * (1 - iWeight)
        ]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ColorUtil["_"]["sMix"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------
// #endregion =================================================================

    UCF_ColorUtil.prototype["aPublicMethods"] = ["sColor", "sHex", "sFade", "sContrast", "fAlpha", "fLuma", "sMix"].concat(UCF_ColorUtil.prototype.aPublicMethods || []);
    /* global _assert, _measure, _trace, START, STOP, INFO, WARNING, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_Size */
/// <reference path="../types/Size.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="./StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="./XSSEncoder.js"/>
    /* global UCF_ColorUtil */
/// <reference path="../../core/util/ColorUtil.js"/>
    /* global UCF_System */

/// <reference path="../../ls/core/System.js"/>

    /**
     * DOM utility functions
     * @class
     *
     */
    function UCF_DomUtil() {
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["UCF_DomUtil"]++;
        }
        ;
        /**
         * @private
         * @type {Window} the top most scriptable window (see oGetTopWindow())
         */
        UCF_DomUtil["oTopWindow"] = null;
    };window["UCF_DomUtil"] = UCF_DomUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_DomUtil");
        UCF_DomUtil["_"] = {UCF_DomUtil: 0};
    }
    ;
    ;

    /**
     * Destroys all references called by LS.destroy
     * @public
     */
    UCF_DomUtil["destroyStatic"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["destroyStatic"]++;
        }
        ;
        UCF_DomUtil["oActiveElement"] = null;
        UCF_DomUtil["oIgnored"] = null;
        UCF_DomUtil["oTopWindow"] = null;
        UCF_DomUtil["mAppliedIECursorRules"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["destroyStatic"] = 0;
    }
    ;

    /**
     * @private
     * @type {boolean}
     */
    UCF_DomUtil["bIsRTL"] = document["documentElement"]["dir"] === 'rtl';

    /**
     * @private
     * @type {HTMLElement}
     */
    UCF_DomUtil["oActiveElement"] = null;

    /**
     * $ function is the shortcut for document.getElementById
     *
     * @private
     * @param {string} sId the id of the DOM element to return
     * @param {window} oWindow optional the window
     * @return {Element} The element with the given id in the given window.
     */
    UCF_DomUtil["$"] = function (sId, oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["$"]++;
        }
        ;
        /** @type {Element} */
        var oRef;

        if (!oWindow) {
            oWindow = window;
        }

        oRef = oWindow["document"]["getElementById"](sId);
        // IE returns also for elments with name=sId for getElementById therefore
        // check if the id attribute is really sId
        if (oRef) {
            if (oRef["id"] === sId) {
                return oRef;
            }
            if (oRef["name"] === sId && oWindow["document"]["all"]) {
                return oWindow["document"]["all"][sId];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["$"] = 0;
    }
    ;

    /**
     * library function for document.getElementsByClassName(sNames),
     * uses polyfill if native function not available.
     *
     * @param {string} sNames string representing the list of class names to match;
     * class names are separated by whitespace
     * @param {HTMLElement} [oRef=document]
     * @return {HTMLElement[]} list of html elements that match the given selector
     */
    UCF_DomUtil["getElementsByClassName"] = function (sNames, oRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["getElementsByClassName"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oRoot = oRef || document;
        /** @type {string} */
        var aClasses;
        /** @type {function(HTMLElement): boolean} */
        var bMatchesAllClasses;

        if ('getElementsByClassName' in oRoot) {
            return oRoot["getElementsByClassName"](sNames);
        } else {
            aClasses = UCF_StringUtil["sTrim"](sNames)["split"](/\s+/g);
            bMatchesAllClasses = function (oE) {
                return UCF_JsUtil["every"](aClasses, function (sClass) {
                    return UCF_DomUtil["bHasClass"](oE, sClass);
                });
            };

            return 'getElementsByTagName' in oRoot
                ? UCF_JsUtil["filter"](
                    UCF_JsUtil["arrayFrom"](oRoot["getElementsByTagName"]('*')),
                    bMatchesAllClasses
                )
                : UCF_JsUtil["filter"](
                    UCF_JsUtil["arrayFrom"](document["getElementsByTagName"]('*')),
                    function (oE) {
                        return UCF_DomUtil["bContains"](oRoot, oE) && bMatchesAllClasses(oE);
                    }
                );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["getElementsByClassName"] = 0;
    }
    ;

    /**
     * library function for document.querySelectorAll(sSelectors),
     * uses polyfill if native function not available.
     *
     * based on public domain licensed polyfill.js project:
     * https://github.com/inexorabletash/polyfill/blob/85f2c88e2e324cdfd786985285d79af5b925d141/polyfill.js#L4419-L4437
     *
     * @param {string} sSelector selector to find elements in the DOM for
     * @return {NodeList|Array.<HTMLElement>} list of html elements that match
     * the given selector
     */
    UCF_DomUtil["querySelectorAll"] = function (sSelector) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["querySelectorAll"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oStyle;
        /** @type {Array.<HTMLElement>} */
        var aElements;
        /** @type {HTMLElement} */
        var oElement;
        /** @type {RegExpExecArray} */
        var aDottedIdRegexpResult;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sSelector === 'string', "typeof sSelector === 'string'", "DomUtil.js(147): querySelectorAll");
        }
        ;

        aDottedIdRegexpResult = /#([^ ]+\.[^ ]*)/g["exec"](sSelector);

        // LS allows ids with . in it, but querySelectorAll would search for an
        // element with id+class, e.g. #ls.id.0 is an id for LS, but
        // <element id="ls" class="id 0"> would be searched by
        // document.querySelectorAll => don't allow querySelectorAll if id contains .
        if (aDottedIdRegexpResult) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Searching for ID with "." in it (' + aDottedIdRegexpResult[0] + ') leads to unexpected results. Paraphrase with [id="' + aDottedIdRegexpResult[1] + '"] instead', "DomUtil.js(156): querySelectorAll");
            }
            ;
        }

        if (typeof document["querySelectorAll"] === 'function') {
            return document["querySelectorAll"](sSelector);
        } else {
            oStyle = document["createElement"]('style');
            aElements = [];
            UCF_DomUtil["append"](document["documentElement"]["firstChild"], oStyle);
            document["_qsa"] = [];

            oStyle["styleSheet"]["cssText"] = sSelector +
                '{x-qsa:expression(document._qsa && document._qsa.push(this))}';
            window["scrollBy"](0, 0); // force style calculation
            oStyle["parentNode"]["removeChild"](oStyle);

            while (document["_qsa"]["length"]) {
                oElement = document["_qsa"]["shift"]();
                oElement["style"]["removeAttribute"]('x-qsa');
                aElements["push"](oElement);
            }

            document["_qsa"] = null;

            return aElements;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["querySelectorAll"] = 0;
    }
    ;

    /**
     * library function for document.querySelector(sSelector),
     * uses polyfill if native function not available.
     *
     * based on public domain licensed polyfill.js project:
     * https://github.com/inexorabletash/polyfill/blob/85f2c88e2e324cdfd786985285d79af5b925d141/polyfill.js#L4441-L4446
     *
     * @param {string} sSelector the selector to find in the dom
     * @return {Element} the first element in the dom that matches the sSelector
     */
    UCF_DomUtil["querySelector"] = function (sSelector) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["querySelector"]++;
        }
        ;
        /** @type {NodeList|Array<Element>} */
        var oResults;

        if (typeof document["querySelector"] === 'function') {
            return document["querySelector"](sSelector);
        } else {
            oResults = UCF_DomUtil["querySelectorAll"](sSelector);

            return oResults && oResults[0];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["querySelector"] = 0;
    }
    ;

    /**
     * gets (read-only) the dataset of a given element, which is
     * the set of all data- prefixed attributes, e.g.:
     *
     *     <html id="hugo" data-name="hugo" data-age="27"/>
     *
     *     UCF_DomUtil.dataset(document.getElementById('hugo'))
     *     // => {name: 'hugo', age: '27'}
     *
     * based on simplified public-domain licensed polyfill if needed:
     * https://github.com/inexorabletash/polyfill/blob/85f2c88e2e324cdfd786985285d79af5b925d141/polyfill.js#L4292-L4316
     *
     * @param {Node} oElement the element to get the dataset for
     * @return {Object<string,string>} the set of all data- attributes
     * (camelCased, without the data- prefix) mapped to their corresponding values
     */
    UCF_DomUtil["dataset"] = function (oElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["dataset"]++;
        }
        ;
        /** @type {Object<string,string>} */
        var result;
        /** @type {number} */
        var i;
        /** @type {string} */
        var attr;
        /** @type {string} */
        var name;

        if ('dataset' in oElement) {
            return oElement["dataset"];
        }

        result = {};

        for (i = 0; i < oElement["attributes"]["length"]; i += 1) {
            attr = oElement["attributes"][i];
            if (attr["specified"] && attr["name"]["substring"](0, 'data-'["length"]) === 'data-') {
                name = attr["name"]["substring"]('data-'["length"]);
                result[UCF_StringUtil["sCamelize"](name)] = oElement["getAttribute"]('data-' + name);
            }
        }

        return result;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["dataset"] = 0;
    }
    ;

    /**
     * Attaches an event handler to a DOM object.
     * Controls should not use this, but use the central event handling instead
     * @param {Element} oDomRef the DOM reference, where the event should be attached to
     * @param {string} sName the name of the event to attach (e.g. "click")
     * @param {function} fHandler the function that handles the event
     * @param {boolean} [bUseCapture=false] `true` to attach to capture phase
     * @private
     */
    UCF_DomUtil["attachEvent"] = function (oDomRef, sName, fHandler, bUseCapture) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["attachEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(260): attachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(261): attachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName, "sName", "DomUtil.js(262): attachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === "string", "typeof sName === \"string\"", "DomUtil.js(263): attachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(fHandler, "fHandler", "DomUtil.js(264): attachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof fHandler === "function", "typeof fHandler === \"function\"", "DomUtil.js(265): attachEvent");
        }
        ;

        if (sName === "dragover" || sName === "dragend" || sName === "drop") {
            if (oDomRef["addEventListener"]) {
                oDomRef["addEventListener"](sName, fHandler, bUseCapture);
            } else if (oDomRef["attachEvent"]) {
                oDomRef["attachEvent"]("on" + sName, fHandler);
            }
            return;
        }

        if (oDomRef["attachEvent"]) {
            oDomRef["attachEvent"]("on" + sName, fHandler);
        } else if (oDomRef["addEventListener"]) {
            // as of Chrome 56 (and Safari, too), touch event listeners added to the document and above default to passive==true; as
            // we need to call  preventDefault() in certain situations (e.g. to prevent the page from scrolling), we change this back
            // to passive==false; as of Chrome 73, this is also true for mousewheel listeners.
            oDomRef["addEventListener"](sName, fHandler, sName["indexOf"]("touch") === 0 || sName["indexOf"]("mousewheel") === 0 ? {
                "capture": bUseCapture,
                "passive": false
            } : bUseCapture);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["attachEvent"] = 0;
    }
    ;

    /**
     * Detaches an event handler from a DOM object.
     * Controls should not use this, but rely on the central event handling instead
     * @param {Element} oDomRef the DOM reference, where the event should be detached form
     * @param {string} sName the name of the event to attach (e.g. "click")
     * @param {function} fHandler the function that handles the event
     * @param {boolean} [bUseCapture=false] `true` to attach to capture phase
     * @private
     */
    UCF_DomUtil["detachEvent"] = function (oDomRef, sName, fHandler, bUseCapture) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["detachEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(297): detachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(298): detachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName, "sName", "DomUtil.js(299): detachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === "string", "typeof sName === \"string\"", "DomUtil.js(300): detachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(fHandler, "fHandler", "DomUtil.js(301): detachEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof fHandler === "function", "typeof fHandler === \"function\"", "DomUtil.js(302): detachEvent");
        }
        ;

        if (sName === "dragover" || sName === "dragend" || sName === "drop") {
            if (oDomRef["removeEventListener"]) {
                oDomRef["removeEventListener"](sName, fHandler, bUseCapture);
            } else if (oDomRef["detachEvent"]) {
                oDomRef["detachEvent"]("on" + sName, fHandler);
            }
            return;
        }

        if (oDomRef["detachEvent"]) {
            oDomRef["detachEvent"]("on" + sName, fHandler);
        } else if (oDomRef["removeEventListener"]) {
            // cf. comment in attachEvent
            oDomRef["removeEventListener"](sName, fHandler, sName["indexOf"]("touch") === 0 ? {
                "capture": bUseCapture,
                "passive": false
            } : bUseCapture);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["detachEvent"] = 0;
    }
    ;

    /**
     * @public
     * @param {Event} oDomEvent the event to cancel
     */
    UCF_DomUtil["cancelEvent"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["cancelEvent"]++;
        }
        ;
        oDomEvent["cancelBubble"] = true;
        if (oDomEvent["keyCode"] !== 0) {
            try {
                oDomEvent["keyCode"] = 0;
            } catch (ignored) {
            }
        }

        oDomEvent["returnValue"] = false;
        if (oDomEvent["preventDefault"]) {
            oDomEvent["preventDefault"]();
        }
        if (oDomEvent["stopPropagation"]) {
            oDomEvent["stopPropagation"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["cancelEvent"] = 0;
    }
    ;

    /**
     * @param {FocusEvent} oEvent the blur/focusout
     * @return {HTMLElement}
     */
    UCF_DomUtil["oGetRelatedTarget"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetRelatedTarget"]++;
        }
        ;
        return oEvent["relatedTarget"]
            || oEvent["toElement"]
            || (oEvent["rangeParent"] && oEvent["rangeParent"]["parentNode"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetRelatedTarget"] = 0;
    }
    ;

    /**
     * @param {Element} oDomRef the element to get the parentElement for
     * @return {Element} the parentElement of oDomRef
     */
    UCF_DomUtil["oGetParentElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetParentElement"]++;
        }
        ;
        if (oDomRef["parentElement"]) {
            return oDomRef["parentElement"];
        } else {
            return oDomRef["parentNode"] && (oDomRef["parentNode"]["nodeType"] === 1
                ? oDomRef["parentNode"]
                : UCF_DomUtil["oGetParentElement"](oDomRef["parentNode"]));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetParentElement"] = 0;
    }
    ;

    /**
     * Gets the next parent element with a given tagName starting with oDomRef
     *
     * @param {Element} oDomRef DOM reference where the function start to look for the tagName
     * @param {string} sTagName tagName that needs to be found.
     * @return {Element} null or the DOM reference
     * @private
     */
    UCF_DomUtil["oGetParentByTagName"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetParentByTagName"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(376): oGetParentByTagName");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(377): oGetParentByTagName");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sTagName === "string", "typeof sTagName === \"string\"", "DomUtil.js(378): oGetParentByTagName");
        }
        ;

        while (oDomRef && oDomRef["tagName"] !== "BODY") {
            if (oDomRef["tagName"] === sTagName) {
                return oDomRef;
            }
            oDomRef = oDomRef["parentNode"];
        }
        return null;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetParentByTagName"] = 0;
    }
    ;

    /**
     * Gets the next parent element with a given attribute and attributes value starting with oDomRef
     *
     * @param {Element} oDomRef DOM reference where the function start to look for the tagName
     * @param {string} sAttribute name of the attribute.
     * @param {string} [sValue] value of the attribute - optional
     * @return {Element} null or the DOM reference
     * @private
     */
    UCF_DomUtil["oGetParentByAttribute"] = function (oDomRef, sAttribute, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetParentByAttribute"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(400): oGetParentByAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(401): oGetParentByAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAttribute === "string", "typeof sAttribute === \"string\"", "DomUtil.js(402): oGetParentByAttribute");
        }
        ;

        while (oDomRef && oDomRef["tagName"] !== "BODY") {
            if (!oDomRef["getAttribute"]) {
                return null;
            }

            if ((oDomRef["getAttribute"](sAttribute) && !sValue)
                || (oDomRef["getAttribute"](sAttribute) && oDomRef["getAttribute"](sAttribute) === sValue)) {
                return oDomRef;
            }
            oDomRef = oDomRef["parentNode"];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetParentByAttribute"] = 0;
    }
    ;

    /**
     * @param {Element} oOldRef the element to be replaced
     * @param {Element} oNewRef the element to replace with
     */
    UCF_DomUtil["replaceElement"] = function (oOldRef, oNewRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["replaceElement"]++;
        }
        ;
        // Element.replaceChild does not work in IE 11 with SVGElements...
        oOldRef["parentNode"]["insertBefore"](oNewRef, oOldRef);
        UCF_DomUtil["removeFromDom"](oOldRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["replaceElement"] = 0;
    }
    ;

    /**
     * @protected
     * @param {Element} oRef
     * @param {string} sAttribute
     * @return {string}
     */
    UCF_DomUtil["sGetAttribute"] = function (oRef, sAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetAttribute"]++;
        }
        ;
        return oRef["getAttribute"](sAttribute);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetAttribute"] = 0;
    }
    ;

    /**
     * Sets a CSS class to a DOM object
     *
     * FIXME: this will remove all other classes from the element.
     * Is this intended? Otherwise use oDomRef.classList.add().
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} sClassName the class to set to the object
     * @private
     */
    UCF_DomUtil["setClass"] = function (oDomRef, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(449): setClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(450): setClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === "string", "typeof sClassName === \"string\"", "DomUtil.js(451): setClass");
        }
        ;

        if (typeof oDomRef["className"] === "string") {
            oDomRef["className"] = sClassName;
        } else {
            oDomRef["setAttribute"]("class", sClassName);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setClass"] = 0;
    }
    ;

    /**
     * Gets the CSS class of a DOM object
     *
     * @param {Element} oDomRef the DOM reference
     * @return {string} sClassName the class to set to the object
     * @private
     */
    UCF_DomUtil["sGetClass"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(468): sGetClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(469): sGetClass");
        }
        ;

        if (typeof oDomRef["className"] === "string") {
            return oDomRef["className"];
        } else {
            return oDomRef["getAttribute"]("class");
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetClass"] = 0;
    }
    ;

    /**
     * Adds a CSS class to existing classes on a DOM object
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} [sClassName=''] space-separated classes to add to oDomRef
     * @private
     */
    UCF_DomUtil["addClass"] = function (oDomRef, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["addClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(486): addClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(487): addClass");
        }
        ;

        /** @type {function(string): void} */
        var add;
        /** @type {string} */
        var _sClassName;

        if (oDomRef["classList"]) {
            add = function (classname) {
                oDomRef["classList"]["add"](classname);
            };
        } else {
            add = function (classname) {
                if (typeof oDomRef["className"] === "string") {
                    if (!UCF_JsUtil["contains"](oDomRef["className"]["split"](' '), classname)) {
                        oDomRef["className"] = UCF_JsUtil["filter"]([oDomRef["className"], classname], function (truthy) {
                            return truthy;
                        })["join"](' ');
                    }
                } else {
                    if (!UCF_JsUtil["contains"](oDomRef["getAttribute"]("class")["split"](' '), classname)) {
                        _sClassName = UCF_JsUtil["filter"]([oDomRef["getAttribute"]("class"), classname], function (truthy) {
                            return truthy;
                        })["join"](' ');
                        oDomRef["setAttribute"]("class", _sClassName);
                    }
                }
            };
        }

        UCF_JsUtil["forEach"](UCF_JsUtil["filter"](UCF_StringUtil["sTrim"]((sClassName || '')["replace"](/\s{2,}/g, ' '))["split"](' '), function (str) {
            return str !== '';
        }), add);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["addClass"] = 0;
    }
    ;

    /**
     * Removes a CSS class from existing classes on a DOM object
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} [sRemoveClassNames=''] space-separated classnames to remove from oDomRef
     * @private
     */
    UCF_DomUtil["removeClass"] = function (oDomRef, sRemoveClassNames) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(524): removeClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(525): removeClass");
        }
        ;

        /**
         * @param {string} sClassName the classname to remove sClass from
         * @param {string} sClass the class to remove from sClassName
         * @return {string} sClass without sClassName
         */
        function sRemoved(sClassName, sClass) {
            return UCF_StringUtil["sTrim"](sClassName)
                ["replace"](new RegExp('^' + sClass + '$', 'g'), '')
                ["replace"](new RegExp('(^' + sClass + '\\s+|\\s+' + sClass + '$)', 'g'), '')
                ["replace"](new RegExp('\\s+' + sClass + '\\s+', 'g'), ' ');
        }

        /**
         * @param {string} sString the string to check
         * @return {boolean} `true` if sString !== ''
         */
        function bIsNotEmptystring(sString) {
            return sString !== '';
        }

        /** @param {string} classname the classname to remove from oDomRef */
        var remove = oDomRef["classList"]
            ? function (classname) {
                oDomRef["classList"]["remove"](classname);
            }
            : function (classname) {
                if (typeof oDomRef["className"] === "string") {
                    oDomRef["className"] = sRemoved(oDomRef["className"], classname);
                } else {
                    oDomRef["setAttribute"]("class", sRemoved(oDomRef["getAttribute"]("class"), classname));
                }
            };

        UCF_JsUtil["forEach"](
            UCF_JsUtil["filter"](
                UCF_StringUtil["sTrim"](sRemoveClassNames)
                    ["replace"](/\s{2,}/g, ' ')
                    ["split"](' '),
                bIsNotEmptystring
            ),
            remove
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeClass"] = 0;
    }
    ;

    /**
     * Checks if a CSS class is part of the existing classes on a DOM object
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} sClassName the class that should be found
     * @return {boolean} true id the given class is in the DOM object
     * @private
     */
    UCF_DomUtil["bHasClass"] = function (oDomRef, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bHasClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(578): bHasClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(579): bHasClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === "string", "typeof sClassName === \"string\"", "DomUtil.js(580): bHasClass");
        }
        ;

        /**
         * @param {string} sName the class to be found
         * @return {boolean} `true` if sName in oDomRef.classList, otherwise `false`
         */
        function bHasClass(sName) {
            return oDomRef["classList"]
                ? oDomRef["classList"]["contains"](sName)
                : (typeof oDomRef["className"] === 'string' ? oDomRef["className"] : oDomRef["getAttribute"]('class'))["match"](new RegExp('(^| )' + sName + '( |$)'));
        };

        return UCF_JsUtil["every"](sClassName["split"](' '), bHasClass);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bHasClass"] = 0;
    }
    ;

    /**
     * Replaces a CSS class of the existing classes on a DOM object
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} sReplaceClassName the class that should be replaced
     * @param {string} sClassName the class that replaces the old class
     * @private
     */
    UCF_DomUtil["replaceClass"] = function (oDomRef, sReplaceClassName, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["replaceClass"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(604): replaceClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(605): replaceClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sReplaceClassName === "string", "typeof sReplaceClassName === \"string\"", "DomUtil.js(606): replaceClass");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === "string", "typeof sClassName === \"string\"", "DomUtil.js(607): replaceClass");
        }
        ;

        if (sReplaceClassName === ""
            || sReplaceClassName === " "
            || !UCF_DomUtil["bHasClass"](oDomRef, sReplaceClassName)) {
            return;
        }

        UCF_DomUtil["removeClass"](oDomRef, sReplaceClassName);
        UCF_DomUtil["addClass"](oDomRef, sClassName);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["replaceClass"] = 0;
    }
    ;

    /**
     * Sets the background color of an DOM element in a performance optimized way.
     * When styles are set in a complicate screen IE has a lack of performance.
     * The method setBackgroundColor and resetBackgroundColor tries to apply the background color directly
     * by style or style text to avoid the performance problem. When no cache object is passed
     * there is no performance optimization. The cache object can be used globally.
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} sClassName the class to add to the object
     * @param {Object} oCache the object which stores values to optimize the process
     * @private
     */
    UCF_DomUtil["setBackgroundColor"] = function (oDomRef, sClassName, oCache) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setBackgroundColor"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(632): setBackgroundColor");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(633): setBackgroundColor");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sClassName) === "string", "typeof(sClassName) === \"string\"", "DomUtil.js(634): setBackgroundColor");
        }
        ;

        var bCanRuntimeStyles = oDomRef["runtimeStyle"] ? true : false;

        // Already set
        if (oDomRef["sFastBgAppliedBy"] === sClassName || oDomRef["sStdBgAppliedBy"] === sClassName)
            return;

        // Cleanup when the same DomRef was already involved
        if (oDomRef["sFastBgAppliedBy"] || oDomRef["sStdBgAppliedBy"])
            UCF_DomUtil["resetBackgroundColor"](oDomRef, oDomRef["sFastBgAppliedBy"] ? oDomRef["sFastBgAppliedBy"] : oDomRef["sStdBgAppliedBy"], oCache);

        if (bCanRuntimeStyles && oCache && oCache[sClassName]) {

            oDomRef["sFastBgAppliedBy"] = sClassName;

            oDomRef["sFastBgMode"] = "STYLE"; //Fastest mode
            oDomRef["sFastBgTextCache"] = oDomRef["style"]["backgroundColor"];
            oDomRef["style"]["backgroundColor"] = oCache[sClassName];

            if (oDomRef["currentStyle"]["backgroundColor"] !== oCache[sClassName]) { //Not successful? Try next level
                //First of all revert change from above
                oDomRef["style"]["backgroundColor"] = oDomRef["sFastBgTextCache"];

                oDomRef["sFastBgMode"] = "STYLETEXT"; //At least faster than class
                oDomRef["sFastBgTextCache"] = oDomRef["runtimeStyle"]["cssText"];
                oDomRef["runtimeStyle"]["cssText"] = "background-color:" + oCache[sClassName] + " !important;" + oDomRef["runtimeStyle"]["cssText"];
            }

        } else {
            var sBgBefore = (bCanRuntimeStyles && oCache) ? oDomRef["currentStyle"]["backgroundColor"] : null;

            UCF_DomUtil["addClass"](oDomRef, sClassName);
            oDomRef["sStdBgAppliedBy"] = sClassName;

            if (bCanRuntimeStyles && oCache && oDomRef["currentStyle"]["backgroundColor"] !== sBgBefore) {
                oCache[sClassName] = oDomRef["currentStyle"]["backgroundColor"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setBackgroundColor"] = 0;
    }
    ;

    /**
     * Resets the background color of an DOM element in a performance optimized way.
     *
     * @param {Element} oDomRef the DOM reference
     * @param {string} sClassName the class to add to the object
     * @param {Object} oCache the object which stores values to optimize the process
     * @private
     */
    UCF_DomUtil["resetBackgroundColor"] = function (oDomRef, sClassName, oCache) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["resetBackgroundColor"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(684): resetBackgroundColor");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(685): resetBackgroundColor");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sClassName) === "string", "typeof(sClassName) === \"string\"", "DomUtil.js(686): resetBackgroundColor");
        }
        ;

        if (oDomRef["sFastBgAppliedBy"] && sClassName === oDomRef["sFastBgAppliedBy"]) {
            if (oDomRef["sFastBgMode"] === "STYLE") {
                oDomRef["style"]["backgroundColor"] = oDomRef["sFastBgTextCache"];
            } else if (oDomRef["sFastBgMode"] === "STYLETEXT") {
                oDomRef["runtimeStyle"]["cssText"] = oDomRef["sFastBgTextCache"];
            }

            oDomRef["sFastBgAppliedBy"] = "";
            oDomRef["sFastBgTextCache"] = "";
            oDomRef["sFastBgMode"] = "";
        } else if (oDomRef["sStdBgAppliedBy"] && oDomRef["className"]["indexOf"](sClassName) !== -1) {
            UCF_DomUtil["removeClass"](oDomRef, sClassName);
            oDomRef["sStdBgAppliedBy"] = "";
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["resetBackgroundColor"] = 0;
    }
    ;

    /**
     * Returns the document of a given oDomRef or the document of the current frameworks window
     *
     * @param {Element} oDomRef the DOM reference (optional)
     * @return {Document} the document reference
     * @private
     */
    UCF_DomUtil["oGetDocument"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetDocument"]++;
        }
        ;
        if (oDomRef) {
            return oDomRef["ownerDocument"];
        } else {
            return window["document"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetDocument"] = 0;
    }
    ;

    /**
     * Returns the DOM element at a given x,y position
     *
     * @param {number} iX position
     * @param {number} iY position
     * @return {Element} null or the DOM reference
     * @private
     */
    UCF_DomUtil["oGetElementFromPoint"] = function (iX, iY) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetElementFromPoint"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iX === "number", "typeof iX === \"number\"", "DomUtil.js(728): oGetElementFromPoint");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iY === "number", "typeof iY === \"number\"", "DomUtil.js(729): oGetElementFromPoint");
        }
        ;

        if (UCF_DomUtil["oGetDocument"]()["elementFromPoint"]) {
            return UCF_DomUtil["oGetDocument"]()["elementFromPoint"](iX, iY);
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetElementFromPoint"] = 0;
    }
    ;

    /**
     * Returns the amount of pixels the page in the window has been scrolled.
     * Note: If the offset values are used to calculate the position of a DOM element,
     * it is recommended to use <code>UCF_LS.oGetPageScrollOffset()</code> instead.
     * @param {window} oWindow the window to get the scrollOffset from
     * @return {{x: number, y: number}} x and y
     * @private
     */
    UCF_DomUtil["oGetScrollOffset"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetScrollOffset"]++;
        }
        ;
        oWindow = oWindow || window;

        var x, y, doc = oWindow["document"];

        if (UCF_UserAgent["bIsAndroid"]()) {
            // Android
            x = window["visualViewport"]["offsetLeft"];
            y = window["visualViewport"]["offsetTop"];
        } else if (oWindow["pageYOffset"]) {
            // all except Internet Explorer
            x = oWindow["pageXOffset"];
            y = oWindow["pageYOffset"];
        } else if (doc["documentElement"] && (doc["documentElement"]["scrollTop"] || doc["documentElement"]["scrollLeft"])) {
            // IE 6 Strict
            x = doc["documentElement"]["scrollLeft"];
            y = doc["documentElement"]["scrollTop"];
        } else if (doc["body"]) {
            // all other Internet Explorers
            x = doc["body"]["scrollLeft"];
            y = doc["body"]["scrollTop"];
        }

        return {
            "x": x,
            "y": y
        };

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetScrollOffset"] = 0;
    }
    ;

    /**
     * Returns the inner size of the window
     *
     * @param {Window} oWindow the window to get the inner size from
     * @return {{width: number, height: number}} inner width+height of window / visible document
     * @private
     */
    UCF_DomUtil["oGetInnerSize"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetInnerSize"]++;
        }
        ;
        return {
            "width": UCF_DomUtil["iClientWidth"](oWindow),
            "height": UCF_DomUtil["iClientHeight"](oWindow)
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetInnerSize"] = 0;
    }
    ;

    /**
     * Sets the tabIndex for the given DOM element oDomRef
     *
     * @param {Element} oDomRef the DOM element
     * @param {number} iValue the new tabIndex
     * @private
     */
    UCF_DomUtil["setTabIndex"] = function (oDomRef, iValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setTabIndex"]++;
        }
        ;
        if (!oDomRef) return;
        oDomRef["tabIndex"] = iValue;
        oDomRef["setAttribute"]("ti", iValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setTabIndex"] = 0;
    }
    ;

    /**
     * Resets the tabIndex for the given DOM element oDomRef
     *
     * @param {Element} oDomRef the element to reset the tabindex on
     * @private
     */
    UCF_DomUtil["resetTabIndex"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["resetTabIndex"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(810): resetTabIndex");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(811): resetTabIndex");
        }
        ;
        UCF_DomUtil["setTabIndex"](oDomRef, -1);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["resetTabIndex"] = 0;
    }
    ;

    /**
     * Returns true if the given DOM element has a set tabIndex
     *
     * @param {Element} oDomRef the element to check
     * @return {boolean} true if the DOM element has a tabindex >=0
     * @private
     */
    UCF_DomUtil["bHasTabIndex"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bHasTabIndex"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(823): bHasTabIndex");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(824): bHasTabIndex");
        }
        ;

        var iTabIndex = UCF_DomUtil["iGetTabIndex"](oDomRef);
        return !isNaN(iTabIndex) && iTabIndex >= 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bHasTabIndex"] = 0;
    }
    ;

    /**
     * Returns the tabIndex for the given DOM element oDomRef
     *
     * @param {HTMLElement} oDomRef the element to get the tabindex from
     * @return {number} the integer value of the DOM elements tab index attribute
     * @private
     */
    UCF_DomUtil["iGetTabIndex"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetTabIndex"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(838): iGetTabIndex");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(839): iGetTabIndex");
        }
        ;

        // CSN 1680045765: might get called with a non-Element
        // node (i.e. getAttribute is undefined) => return NaN
        // (same as parseInt(null))
        if (oDomRef["getAttribute"]("ti")) {
            return parseInt(oDomRef["getAttribute"]('ti'), 10);
        } else {
            return NaN;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetTabIndex"] = 0;
    }
    ;

    /**
     * Sets the accessKey for the given DOM element oDomRef
     *
     * @param {Element} oDomRef the DOM element
     * @param {string} sValue the new accessKey
     * @private
     */
    UCF_DomUtil["setAccessKey"] = function (oDomRef, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setAccessKey"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(859): setAccessKey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(860): setAccessKey");
        }
        ;
        if (sValue !== "d" && sValue !== "D")
            oDomRef["setAttribute"]("accessKey", sValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setAccessKey"] = 0;
    }
    ;

    /**
     * @param {Element} oDomRef the element to focus
     * @private
     */
    UCF_DomUtil["focusDomElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["focusDomElement"]++;
        }
        ;
        if (!oDomRef) return;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(871): focusDomElement");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(872): focusDomElement");
        }
        ;

        try {
            oDomRef["focus"]();
        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(877): focusDomElement");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["focusDomElement"] = 0;
    }
    ;

    /**
     * Focuses a given DOM element delayed.
     * @param {Element} oDomRef the element to focus
     * @param {boolean} bDirect `true` to focus immediately, `false` to trigger
     * delayed call
     * @private
     */
    UCF_DomUtil["moveFocusDomElement"] = function (oDomRef, bDirect) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["moveFocusDomElement"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(889): moveFocusDomElement");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(890): moveFocusDomElement");
        }
        ;

        if (bDirect) {
            try {
                oDomRef["focus"]();
            } catch (oException) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(896): moveFocusDomElement");
                }
                ;
            }
        } else UCF_JsUtil["delayedCall"](0, this, "moveFocusDomElement", [oDomRef, true]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["moveFocusDomElement"] = 0;
    }
    ;

    /**
     * Focuses a given DOM element.
     * Returns true if focusing could be performed.
     * False if not, because the element was invisible for example.
     *
     * @param {Element} oDomRef the element to focus
     * @return {boolean} `true` if focusing could be performed.
     * @private
     */
    UCF_DomUtil["bDomElementFocused"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bDomElementFocused"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(911): bDomElementFocused");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(912): bDomElementFocused");
        }
        ;

        //CSN: 772609
        // For skipping it must be possible to know whether an element is focusable or not, i.e. whether it
        // has received the focus or not. Hidden elements, that have been placed in a container
        // with diplay:none or visibility hidden are not recognized as not focusable by the skipping functionality.
        // These elements do not expose the visibility of their parent. Therefore we can not ask for their own visibility
        // to know if they can receive the focus. Skipping breaks here and the focus gets lost.
        // Therefore the function has been enhanced by a boolean return value that tells us if focusing
        // an element was successful.
        //
        try {
            oDomRef["focus"]();
            // return true;
            if (document["activeElement"] && document["activeElement"] === oDomRef) {
                return true;
            } else {
                return false;
            }
        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(932): bDomElementFocused");
            }
            ;
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bDomElementFocused"] = 0;
    }
    ;

    /**
     * Focusses a given dom element
     *
     * @param {Element} oDomRef the element to focus
     * @return {boolean} true if the element was succefully focussed.
     * @private
     */
    UCF_DomUtil["bFocusDomElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bFocusDomElement"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(945): bFocusDomElement");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(946): bFocusDomElement");
        }
        ;

        try {
            oDomRef["focus"]();
        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(951): bFocusDomElement");
            }
            ;
            return false;
        }
        if (document["activeElement"] && document["activeElement"] !== oDomRef) return false;
        //for firefox and safari we guess that the focus was set correctly
        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bFocusDomElement"] = 0;
    }
    ;

    /**
     * Refocuses a given DOM element
     *
     * @param {Element} oDomRef the element to focus
     * @private
     */
    UCF_DomUtil["refocusDomElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["refocusDomElement"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(966): refocusDomElement");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(967): refocusDomElement");
        }
        ;

        try {
            oDomRef["blur"]();
            oDomRef["focus"]();
        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(973): refocusDomElement");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["refocusDomElement"] = 0;
    }
    ;

    /**
     * Blur the active element
     *
     * @param {boolean} bSkipDocument `true` to blur() should not be called on the
     * document
     * @private
     */
    UCF_DomUtil["blurActiveElement"] = function (bSkipDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["blurActiveElement"]++;
        }
        ;
        var oActiveElement = UCF_DomUtil["oGetActiveElement"]();
        if (oActiveElement && oActiveElement["blur"]) {
            if (bSkipDocument) {
                if (oActiveElement !== document && oActiveElement !== document["body"]) {
                    oActiveElement["blur"]();
                }
            } else {
                oActiveElement["blur"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["blurActiveElement"] = 0;
    }
    ;

    /**
     * Get the active element of the document (if any)
     * @return {Element} The currently active element if any.
     * @private
     */
    UCF_DomUtil["oGetActiveElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetActiveElement"]++;
        }
        ;
        var o = null;
        try { // sometimes the access to active element was denied.
            if (document["activeElement"] || document["activeElement"] === null)
                o = document["activeElement"];
            else
                o = UCF_DomUtil["oActiveElement"];

        } catch (exception) {
            o = UCF_DomUtil["oActiveElement"];
        }

        // CSN 1670038527: IE11 sometimes returns an empty object {} as activeElement from an iFrame
        // eslint-disable-next-line no-magic-numbers
        if (o && UCF_UserAgent["bIsIE"](11) && !o["nodeName"]) {
            o = null;
        }

        if (UCF_UserAgent["bIsFirefox"]()) {
            // Firefox morphes DOM references (sounds strange, is strange) which do not allow attribute access
            // (e.g. causes exceptions in FileUpload)
            // Only return active element when it is valid and accessible.
            try {
                if (o && (o === document || o["tagName"])) return o;
                else return null;
            } catch (ex) {
                return null;
            }
        }

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetActiveElement"] = 0;
    }
    ;

    /**
     * Sets the active element of the page which is taken as alternative if
     * document.activeElement is not supported by browser
     * @param {HTMLElement} oDomRef the element to set as the active element
     * @private
     */
    UCF_DomUtil["setActiveElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setActiveElement"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(1042): setActiveElement");
        }
        ;
        UCF_DomUtil["oActiveElement"] = oDomRef; //will be removed in LS.destroy and UCF_LS.prototype.purgeControls
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setActiveElement"] = 0;
    }
    ;

    /**
     * Checks if alternative active element reference is valid and
     * if not tries to correct or remove it
     * @private
     */
    UCF_DomUtil["purgeActiveElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["purgeActiveElement"]++;
        }
        ;
        if (UCF_DomUtil["oActiveElement"]) {
            //IE Check
            try { // sometimes the access to active element was denied.
                if (document["activeElement"]) {
                    UCF_DomUtil["oActiveElement"] = document["activeElement"];
                    return;
                }
            } catch (exception) {
            }

            // Fallback
            if (!UCF_DomUtil["bIsInActiveDom"](UCF_DomUtil["oActiveElement"])) {
                var sId = null;
                try {
                    sId = UCF_DomUtil["oActiveElement"]["getAttribute"]("id");
                } catch (e) {
                    // UCF_DomUtil.oActiveElement.getAttribute in IE 10, 11 sometimes throws "Object expected" ...
                }
                try {
                    if (!sId) {
                        sId = UCF_DomUtil["oActiveElement"]["id"];
                    }
                } catch (e) {
                }

                if (sId) {
                    //Reference correction
                    UCF_DomUtil["oActiveElement"] = UCF_DomUtil["$"](sId);
                } else {
                    //Remove
                    UCF_DomUtil["oActiveElement"] = null;
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["purgeActiveElement"] = 0;
    }
    ;

    /**
     * Checks if the passed DOM reference is nested in the active DOM of the document
     * @param {HTMLElement} oDomRef the element to check
     * @return {boolean} true if the DOM element is in the active dom, else false
     * @private
     */
    UCF_DomUtil["bIsInActiveDom"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bIsInActiveDom"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(1093): bIsInActiveDom");
        }
        ;

        var oCurrDomRef = oDomRef;
        while (oCurrDomRef) {
            if (oCurrDomRef === document) return true;
            oCurrDomRef = oCurrDomRef["parentNode"];
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bIsInActiveDom"] = 0;
    }
    ;

    /**
     * Returns whether oDomRefChild is oDomRefContainer or is contained in oDomRefContainer
     * This is the browser independent version of the .contains method of Internet Explorer
     * for compatibility it returns true if oDomRefContainer and oDomRefChild are equal.
     * @param {HTMLElement} oDomRefContainer the element that should contain
     * @param {HTMLElement} oDomRefChild the element that should be contained
     * @return {boolean} true if the oDomRefChild is the oDomRefContainer or is contained in oDomRefContainer
     * @private
     */
    UCF_DomUtil["bContains"] = function (oDomRefContainer, oDomRefChild) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bContains"]++;
        }
        ;

        if (!oDomRefChild || !oDomRefContainer || typeof oDomRefChild["nodeType"] !== "number") return false;

        // browser supports contains on nodes...
        if (oDomRefContainer["contains"]) {
            return oDomRefContainer["contains"](oDomRefChild);
        }

        // browser does not support contains, do it manually...
        if (oDomRefContainer === oDomRefChild) return true;

        while (oDomRefChild != null) {
            if (oDomRefChild === oDomRefContainer) return true;
            oDomRefChild = oDomRefChild["parentNode"];
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bContains"] = 0;
    }
    ;

    /**
     * Returns the first element of a DOM element
     *
     * @param {Element} oDomRefNode the DOM element to get the first element from
     * @return {Element} The first element of a DOM element
     * @private
     */
    UCF_DomUtil["oGetFirstElement"] = function (oDomRefNode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetFirstElement"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefNode) === "object", "typeof(oDomRefNode) === \"object\"", "DomUtil.js(1140): oGetFirstElement");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRefNode != null, "oDomRefNode != null", "DomUtil.js(1141): oGetFirstElement");
        }
        ;

        //TODO firstElementChild http://www.w3.org/TR/ElementTraversal/#attribute-firstElementChild
        var ELEMENT_NODE = 1;
        if (oDomRefNode["firstChild"] && oDomRefNode["firstChild"]["nodeType"] === ELEMENT_NODE) {
            return oDomRefNode["firstChild"];
        } else {
            if (!oDomRefNode["childNodes"]) return null;
            for (var i = 0; i < oDomRefNode["childNodes"]["length"]; i++) {
                if (oDomRefNode["childNodes"][i]["nodeType"] === ELEMENT_NODE) {
                    return oDomRefNode["childNodes"][i];
                }
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetFirstElement"] = 0;
    }
    ;

    /**
     * Returns the first child of a DOM node that is not a comment
     *
     * @param {Element} oDomRefNode the DOM element to get the first child from
     * @return {Element} The first child of a DOM node that is not a comment
     * @private
     */
    UCF_DomUtil["oGetFirstChild"] = function (oDomRefNode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetFirstChild"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefNode) === "object", "typeof(oDomRefNode) === \"object\"", "DomUtil.js(1166): oGetFirstChild");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRefNode != null, "oDomRefNode != null", "DomUtil.js(1167): oGetFirstChild");
        }
        ;

        var oChildren = oDomRefNode["childNodes"];
        for (var i = 0; i < oDomRefNode["childNodes"]["length"]; i++) {
            var c = oChildren[i];
            if (c["tagName"] !== "!" && c["nodeName"] !== "#comment") return c;
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetFirstChild"] = 0;
    }
    ;

    /**
     * Returns the last child of a DOM element that is not a comment
     *
     * @param {Element} oDomRefNode the DOM element to get the last child from
     * @return {Element} The last child of a DOM element that is not a comment
     * @private
     */
    UCF_DomUtil["oGetLastChild"] = function (oDomRefNode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetLastChild"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefNode) === "object", "typeof(oDomRefNode) === \"object\"", "DomUtil.js(1185): oGetLastChild");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRefNode != null, "oDomRefNode != null", "DomUtil.js(1186): oGetLastChild");
        }
        ;

        var oChildren = oDomRefNode["childNodes"];
        for (var i = oChildren["length"] - 1; i >= 0; i--) {
            var c = oChildren[i];
            if (c["tagName"] !== "!" && c["nodeName"] !== "#comment") return c;
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetLastChild"] = 0;
    }
    ;

    /**
     * Returns the first child of a DOM node that has a given attribute set.
     * Optionally this attribute can be checked for a value.
     *
     * @param {Element} oDomRefNode the DOM element to get the first child by
     * attribute from
     * @param {string} sAttribute the name of the attribute
     * @param {string} sValue optional value of the attribute
     * @return {Element} The first child of a DOM node that has a given attribute
     * set or null
     * @private
     */
    UCF_DomUtil["oGetFirstChildByAttribute"] = function (oDomRefNode, sAttribute, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetFirstChildByAttribute"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefNode) === "object", "typeof(oDomRefNode) === \"object\"", "DomUtil.js(1210): oGetFirstChildByAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRefNode != null, "oDomRefNode != null", "DomUtil.js(1211): oGetFirstChildByAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sAttribute) === "string", "typeof(sAttribute) === \"string\"", "DomUtil.js(1212): oGetFirstChildByAttribute");
        }
        ;

        if (!oDomRefNode) return null;

        var oChildren = oDomRefNode["childNodes"];
        for (var i = 0; i < oChildren["length"]; i++) {
            var c = oChildren[i];
            if (c["nodeType"] === 1) {
                if ((!sValue && c["getAttribute"](sAttribute)) || (c["getAttribute"](sAttribute) === sValue)) {
                    return c;
                } else {
                    var result = UCF_DomUtil["oGetFirstChildByAttribute"](c, sAttribute, sValue);
                    if (result) {
                        return result;
                    }
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetFirstChildByAttribute"] = 0;
    }
    ;

    /**
     * Returns the last child of a DOM node that has a given attribute set.
     * Optionally this attribute can be checked for a value.
     *
     * @param {DOMElement} oDomRefNode the DOM element to get the last child
     * attribute from
     * @param {string} sAttribute the name of the attribute
     * @param {string} sValue optional value of the attribute
     * @return {Element} The last child of a DOM node that has a given attribute set or null
     *
     * @private
     */
    UCF_DomUtil["oGetLastChildByAttribute"] = function (oDomRefNode, sAttribute, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetLastChildByAttribute"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRefNode) === "object", "typeof(oDomRefNode) === \"object\"", "DomUtil.js(1247): oGetLastChildByAttribute");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sAttribute) === "string", "typeof(sAttribute) === \"string\"", "DomUtil.js(1248): oGetLastChildByAttribute");
        }
        ;

        if (!oDomRefNode) return null;

        var oChildren = oDomRefNode["childNodes"];
        for (var i = oChildren["length"] - 1; i >= 0; i--) {
            var c = oChildren[i];
            if (c["nodeType"] === 1) {
                if ((!sValue && c["getAttribute"](sAttribute)) || (c["getAttribute"](sAttribute) === sValue)) {
                    return c;
                } else {
                    return UCF_DomUtil["oGetLastChildByAttribute"](c, sAttribute, sValue); //TODO: asymetric to oGetFirstChildByAttribute()
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetLastChildByAttribute"] = 0;
    }
    ;

    /**
     * @typedef {Object} _ObjectRect
     * @property {number} top
     * @property {number} left
     * @property {number} width
     * @property {number} height
     */
    /**
     * Returns a rectangle of the given DOM object
     *
     * @private
     * @param {HTMLElement} oDomRef the DOM object which position should be
     * determined
     * @param {HTMLElement} [oContainerRef] the container
     * @return {_ObjectRect} The rectangle of the given DOM object as
     */
    UCF_DomUtil["oGetObjectRect"] = function (oDomRef, oContainerRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetObjectRect"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(1284): oGetObjectRect");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(1285): oGetObjectRect");
        }
        ;

        var oOffsetParent, bAbort, oRect;

        // Some special elements in a HTML page (e.g. SVG) are no instance of HTM elements and do therfore not support offset positions
        // We can simulate the needed attributes by oDomRef.getBoundingClientRect ... I'm sorry :-(
        // IE raises exception when just checking "HTMLElement" therfore we need to use ("HTMLElement" in window) do not change
        if (("HTMLElement" in window) && oDomRef && !(oDomRef instanceof HTMLElement) && oDomRef["parentNode"] && oDomRef["getBoundingClientRect"] && oDomRef["parentNode"]["getBoundingClientRect"]) {
            var oBoundingRect = oDomRef["getBoundingClientRect"](),
                oParentBoundingRect = oDomRef["parentNode"]["getBoundingClientRect"]();

            oDomRef["offsetParent"] = oDomRef["parentNode"];
            oDomRef["offsetTop"] = oBoundingRect["top"] - oParentBoundingRect["top"];
            oDomRef["offsetLeft"] = oBoundingRect["left"] - oParentBoundingRect["left"];
            oDomRef["offsetWidth"] = oBoundingRect["width"];
            oDomRef["offsetHeight"] = oBoundingRect["height"];
            oDomRef["clientTop"] = 0;
            oDomRef["clientLeft"] = 0;
            oDomRef["scrollLeft"] = 0;
        }

        oOffsetParent = oDomRef["offsetParent"];

        bAbort = oOffsetParent ? false : true;

        oRect = {
            "top": oDomRef["offsetTop"],
            "left": oDomRef["offsetLeft"],
            "width": oDomRef["offsetWidth"],
            "height": oDomRef["offsetHeight"]
        };

        // border-correction (see also comment below in the if (!bAbort) section...)
        var bBorderCorr = (oDomRef["clientTop"] || oDomRef["clientLeft"]) && (oDomRef["tagName"] === "DIV" || oDomRef["tagName"] === "TD");
        // if (bBorderCorr) {
        // 	if (oDomRef.clientTop) oRect.top += oDomRef.clientTop;
        // 	if (!UCF_DomUtil.bIsRTL && oDomRef.clientLeft) oRect.left += oDomRef.clientLeft;
        // }

        // Container checks
        if (oContainerRef) {

            //Check if container reached?
            if (oOffsetParent) {

                if (oOffsetParent === oContainerRef) {
                    // Container found !!
                    bAbort = true;
                } else if (oOffsetParent["firstChild"] === oContainerRef) {
                    //Jumped over oContainerRef
                    //TODO: better check of missed/passed container. This one is too specific
                    oRect["top"] = oDomRef["offsetTop"] - oContainerRef["offsetTop"];
                    oRect["left"] = oDomRef["offsetLeft"] - oContainerRef["offsetLeft"];

                    bAbort = true;
                }
                ;

                // RTL: When scollcontainer is refernce container return inner content rect without scroll pos like we are doing it in LTR
                if (bAbort && UCF_DomUtil["bIsRTL"] && UCF_DomUtil["bCanScroll"](oContainerRef, false)) {
                    oRect["left"] = UCF_DomUtil["iCalculateRtlOffsetLeft"](oDomRef, oContainerRef) + UCF_DomUtil["iGetScrollLeft"](oContainerRef) - UCF_DomUtil["iGetVerticalScrollbarOffset"](oContainerRef);
                }
            }

            //Reached TOP but container not found though a container DOM reference is passed
            if (oDomRef["tagName"] === "BODY" && oContainerRef["tagName"] !== "BODY") {
                //Fall back: Calculate container rect and subtract it (take its scroll position into account)
                var oContainerRect = UCF_DomUtil["oGetObjectRect"](oContainerRef);

                oRect["top"] = -oContainerRect["top"] + oContainerRef["scrollTop"];
                oRect["left"] = -oContainerRect["left"] + UCF_DomUtil["iGetScrollLeft"](oContainerRef);

                //RTL reference container correction when it is a scrollconatiner
                if (UCF_DomUtil["bIsRTL"] && UCF_DomUtil["bCanScroll"](oContainerRef, false)) {
                    //Add Scrollbar handle width
                    oRect["left"] -= UCF_DomUtil["iGetVerticalScrollbarOffset"](oContainerRef);

                    // Correct Standards bug in IE which calculates scroll left like in LTR instead of RTL
                    if ((UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) && UCF_UserAgent["bIsStandardsMode"]()) {
                        oRect["left"] += oContainerRef["scrollLeft"];
                    }
                }

                bAbort = true;
            }
        }

        //Leave recursion or not?
        if (!bAbort) {
            //Process another recursion

            var oParentRect = UCF_DomUtil["oGetObjectRect"](oOffsetParent, oContainerRef),
                oCurDomRef = null;

            oRect["top"] = oParentRect["top"] + oDomRef["offsetTop"];
            oRect["left"] = oParentRect["left"] + oDomRef["offsetLeft"];

            //When the current offsetParent node has borders set, the offset is not reflected in offsetLeft/Top but in
            //clientLeft/Top. Unfortunatelly this is only for some tags correct.
            if (bBorderCorr) {
                if (oDomRef["clientTop"]) oRect["top"] += oDomRef["clientTop"];
                if (!UCF_DomUtil["bIsRTL"] && oDomRef["clientLeft"]) oRect["left"] += oDomRef["clientLeft"];
            }
            // In Chrome borders of TABLE element must be conisdered, but only for contained nodes
            var bTableBorderCorrChrome = UCF_UserAgent["bIsWebKit"]() && oOffsetParent["tagName"] === "TABLE" && (oOffsetParent["clientTop"] || oOffsetParent["clientLeft"]);
            if (bTableBorderCorrChrome) {
                if (oOffsetParent["clientTop"]) oRect["top"] += oOffsetParent["clientTop"];
                if (!UCF_DomUtil["bIsRTL"] && oOffsetParent["clientLeft"]) oRect["left"] += oOffsetParent["clientLeft"];
            }
            // also get scroll positions of elements which are not offsetparent
            // but not for the body
            oCurDomRef = oDomRef;
            do {
                oCurDomRef = oCurDomRef["parentNode"];
                if (oCurDomRef === document["body"]) continue;
                oRect["top"] -= oCurDomRef["scrollTop"];
                oRect["left"] -= UCF_DomUtil["iGetScrollLeft"](oCurDomRef);
            } while (oCurDomRef !== oOffsetParent);

            if (UCF_DomUtil["bIsRTL"]) {
                oRect["left"] = oParentRect["left"] + UCF_DomUtil["iCalculateRtlOffsetLeft"](oDomRef, oOffsetParent);
            }

        }

        return oRect;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetObjectRect"] = 0;
    }
    ;

    /**
     * Returns true if the given dom ref is able to scroll. Currently only used in RTL rect calculation
     *
     * @param {Object} oDomRef the DOM object
     * @param {boolean} [bVertical=false] `true` if vertical scrolling should be
     * checked, `false` for horizontal scrolling
     * @return {boolean} `true` if scrolling is possible, otherwise `false`
     * @private
     */
    UCF_DomUtil["bCanScroll"] = function (oDomRef, bVertical) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bCanScroll"]++;
        }
        ;
        if (bVertical) {
            return oDomRef["scrollTop"]
                || (UCF_DomUtil["sGetCurrentStyle"](oDomRef, "overflowY") !== "visible");
        } else {
            return oDomRef["scrollLeft"]
                || (UCF_DomUtil["sGetCurrentStyle"](oDomRef, "overflowX") !== "visible");
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bCanScroll"] = 0;
    }
    ;

    /**
     * Returns the scroll left attribute and resolves incorrect browser calculations
     *
     * scrollLeft behaves (especially in RTL case) totally different in different
     * browsers. It is therefore normalized to the behavior in WebKit, where it
     * denotes the offset to the (physically) left border (in px) of the given
     * scrollContainer.
     *
     * the following example shows how IE/Firefox/Chrome compute scrollLeft **in RTL**:
     *
     * ```
     * + - - - - - +---------+
     * |   400px   |  200px  |
     * + - - - - - +---------+
     *   scrolled    visible
     * ```
     *
     * | Browser | scrollLeft |
     * |---------|------------|
     * |      IE |          0 |
     * | Firefox |          0 |
     * | Safari  |          0 |
     * | Chrome  |       	 	0	|
     * | Edge    |  			400 |
     *
     * ```
     * +---------+ - - - - - +
     * |  200px  |   400px   |
     * +---------+ - - - - - +
     *   visible    scrolled
     * ```
     *
     * | Browser | scrollLeft |
     * |---------|------------|
     * |      IE |        400 |
     * | Firefox |       -400 |
     * | Safari  |       -400 |
     * | Chrome  |       -400 |
     * | Edge 	 | 					0 |
     *
     * (it should be noted that the Chrome interpretation makes sense, because even
     * in RTL, "left" is still physically left; other APIs, like display:flex, have
     * the special "start"/"end" wording to overcome this -- "start" becomes "end"
     * in RTL and vice versa)
     *
     * @private
     * @param {HTMLElement} [oDomRef] the DOM node
     * @return {number} the number of pixels scrolled to the physically left edge
     */
    UCF_DomUtil["iGetScrollLeft"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetScrollLeft"]++;
        }
        ;
        if (!oDomRef) {
            return 0;
        }
        if (oDomRef["tagName"] && oDomRef["tagName"] === "BODY") {
            return UCF_DomUtil["oGetScrollOffset"]()["x"];
        }
        if (UCF_DomUtil["bIsRTL"] && (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) && UCF_UserAgent["bIsStandardsMode"]()) {
            return oDomRef["scrollWidth"] - oDomRef["clientWidth"] - oDomRef["scrollLeft"];
        } else if (UCF_DomUtil["bIsRTL"] && (UCF_UserAgent["bIsFirefox"]() || UCF_UserAgent["bIsWebKit"]())) {
            return oDomRef["scrollLeft"] + oDomRef["scrollWidth"] - oDomRef["clientWidth"];
        } else {
            return oDomRef["scrollLeft"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetScrollLeft"] = 0;
    }
    ;

    /**
     * Returns the scroll top attribute
     *
     * @param {Element} oDomRef the DOM node
     * @return {number} the scrollTop
     * @private
     */
    UCF_DomUtil["iGetScrollTop"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetScrollTop"]++;
        }
        ;
        if (!oDomRef) {
            return 0;
        }
        if (oDomRef["tagName"] && oDomRef["tagName"] === "BODY") {
            return UCF_DomUtil["oGetScrollOffset"]()["y"];
        }
        return oDomRef["scrollTop"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetScrollTop"] = 0;
    }
    ;

    /**
     *
     * Returns an calculated left offset value for RTL mode
     *
     * @param {Element} oDomRef the DOM object which position should be determined
     * @param {Element} oOffsetParent the offset parent to base the calculation on
     * @return {number} the offsetLeft in RTL
     * @private
     */
    UCF_DomUtil["iCalculateRtlOffsetLeft"] = function (oDomRef, oOffsetParent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iCalculateRtlOffsetLeft"]++;
        }
        ;
        //RTL correction
        //This seems to be fixed and the workaround is not needed anymore.
        //Please check: https://connect.microsoft.com/IE/feedback/details/410735/ie-v8-0-block-formatting-contexts-in-rtl-containing-blocks-next-to-floats-causing-margin-miscalculation
        //Updated 2013/07/25 -> some IE bugs still exists therfore reactivated the RTL special handling for IE (see 2563940 2013)

        /** @type {number} */
        var iOffsetLeft = oDomRef["offsetLeft"];
        /** @type {Object.<string,number>} */
        var CALCULATION_MODES = {
            "BEGIN": 0,
            "CENTER": 1,
            "END": 2
        };

        //OffsetLeft correction
        if (oOffsetParent !== document["body"]) {

            //RTL correction for position container
            if (oDomRef["offsetLeft"] <= 0 && UCF_DomUtil["sGetCurrentStyle"](oDomRef, "position") !== "relative" &&
                UCF_DomUtil["sGetCurrentStyle"](oDomRef, "position") !== "absolute") {
                // OffsetLeft is not propagated correctly. Try to calculate offsetLeft in another way
                var sTextAlign = UCF_DomUtil["sGetCurrentStyle"](oOffsetParent, "textAlign"),
                    iCalculationMode = CALCULATION_MODES["BEGIN"], //0=begin, 1=center, 2=end
                    iPaddingCorrection = 0;
                if (UCF_UserAgent["bIsWebKit"]()) {
                    sTextAlign = sTextAlign["replace"]("-webkit-", "");
                }
                if (!sTextAlign || sTextAlign === "right") {
                    iCalculationMode = CALCULATION_MODES["BEGIN"]; // standard alignment = right or begin of line
                } else if (sTextAlign === "center") {
                    iCalculationMode = CALCULATION_MODES["CENTER"]; // centered alignment
                } else if (sTextAlign === "left") {
                    iCalculationMode = CALCULATION_MODES["END"]; // left alignment or end of line.
                }

                if (UCF_DomUtil["bCanScroll"](oOffsetParent, false)) {
                    //Scrollable container
                    iOffsetLeft = -UCF_DomUtil["iGetScrollLeft"](oOffsetParent); //Only correct for one child in scrollcontainer which is in 99% the case
                } else {
                    // Try to calculate the offsetLeft by width of the offsetParent and the width of its children
                    // The alignment of the children has to be taken into account (see iCalculationMode)
                    var iSiblingsWidth = 0;

                    // For inline elements and table cells take the widths of the siblings into account
                    if (UCF_DomUtil["sGetCurrentStyle"](oDomRef, "display") === "inline" || oDomRef["tagName"] === "TD" || oDomRef["tagName"] === "TH") {
                        var oCurDomRef = oDomRef;

                        // Loop over siblings and collect their widths
                        while (oCurDomRef) {
                            if (iCalculationMode === CALCULATION_MODES["END"]) oCurDomRef = UCF_DomUtil["nextSibling"](oCurDomRef);
                            else oCurDomRef = UCF_DomUtil["previousSibling"](oCurDomRef);

                            if (oCurDomRef) iSiblingsWidth += oCurDomRef["offsetWidth"];
                        }
                    }

                    {
                        var sPadding = UCF_DomUtil["sGetCurrentStyle"](oOffsetParent, "padding" + (iCalculationMode === CALCULATION_MODES["END"] ? "Left" : "Right"));
                        if (sPadding && sPadding["indexOf"]("px") !== -1) iPaddingCorrection = parseInt(sPadding, 10);
                    }

                    // Set offsetLeft according to calculated sibling widths
                    if (iCalculationMode === CALCULATION_MODES["BEGIN"]) {
                        iOffsetLeft = oOffsetParent["offsetWidth"] - (iSiblingsWidth + oDomRef["offsetWidth"] + iPaddingCorrection);
                    } else if (iCalculationMode === CALCULATION_MODES["CENTER"]) {
                        // eslint-disable-next-line no-magic-numbers
                        iOffsetLeft = (oOffsetParent["offsetWidth"] / 2) - ((iSiblingsWidth + oDomRef["offsetWidth"]) / 2);
                    } else if (iCalculationMode === CALCULATION_MODES["END"]) {
                        iOffsetLeft = iSiblingsWidth + iPaddingCorrection;
                    }
                }

                //Padding correction for
                if (iPaddingCorrection === 0 // No padding correction applied so far
                    && oDomRef["offsetWidth"] < oOffsetParent["offsetWidth"]
                    && oDomRef["offsetLeft"] === oDomRef["offsetWidth"] - oOffsetParent["offsetWidth"]
                ) {
                    iPaddingCorrection = oOffsetParent["offsetWidth"] - oDomRef["offsetWidth"];

                    iOffsetLeft -= iPaddingCorrection;
                }
            }

            //Scrollbar correction
            if (!UCF_UserAgent["bIsWebKit"]()) {
                iOffsetLeft += UCF_DomUtil["iGetVerticalScrollbarOffset"](oOffsetParent);
            }
        }
        return iOffsetLeft;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iCalculateRtlOffsetLeft"] = 0;
    }
    ;

    /**
     * Returns a rectangle of the visible part of the given DOM element within many scroll containers ignoring the body scrolling
     * @param {HTMLElement} oDomRef A DOM refernece
     * @param {HTMLElement} [oContainerRef] Optional container
     * @return {UCF_Rectangle} The rectangle of the visible part of the given DOM element
     * @private
     */
    UCF_DomUtil["oGetViewPort"] = function (oDomRef, oContainerRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetViewPort"]++;
        }
        ;
        /** @type {UCF_Rectangle} */
        var oRect;
        /** @type {UCF_Rectangle} */
        var oOriginalRect;
        /** @type {HTMLElement} */
        var oScrollRef;
        /** @type {UCF_Rectangle} */
        var oScrollRect;
        /** @type {number} */
        var dtop;
        /** @type {number} */
        var dbottom;
        /** @type {number} */
        var dleft;
        /** @type {number} */
        var dright;

        if (UCF_DomUtil["oGetParentScrollContainer"](oDomRef["parentNode"]) === document["body"]) {
            oRect = UCF_DomUtil["oGetObjectRect"](oDomRef, oContainerRef);
            oRect["_original"] = oRect;

            return oRect;
        } else {
            oRect = UCF_DomUtil["oGetObjectRect"](oDomRef, oContainerRef);
            oOriginalRect = {
                "top": oRect["top"],
                "left": oRect["left"],
                "width": oRect["width"],
                "height": oRect["height"]
            };
            oScrollRef = UCF_DomUtil["oGetParentScrollContainer"](oDomRef["parentNode"]);

            var checkContainer = function (oScrollRef) {
                return oContainerRef ? UCF_DomUtil["bContains"](oContainerRef, oScrollRef) : true;
            };

            while (oScrollRef && checkContainer(oScrollRef)) {
                oScrollRect = UCF_DomUtil["oGetObjectRect"](oScrollRef, oContainerRef);
                oScrollRect["height"] = oScrollRef["clientHeight"];
                oScrollRect["width"] = oScrollRef["clientWidth"];

                // introduced by CL164118 to fix something not known anymore in standards mode - leads to JS error in chrome and FF
                // oScrollRect.height = UCF_DomUtil.iClientHeight ( oScrollRef ) ;
                // oScrollRect.width = UCF_DomUtil.iClientWidth ( oScrollRef ) ;

                dtop = oScrollRect["top"] - oRect["top"];
                dbottom = (oRect["top"] + oRect["height"]) - (oScrollRect["top"] + oScrollRect["height"]);
                dleft = oScrollRect["left"] - oRect["left"];
                dright = (oRect["left"] + oRect["width"]) - (oScrollRect["left"] + oScrollRect["width"]);

                if (dtop > 0) {
                    oRect["height"] -= dtop;
                    oRect["top"] += dtop;
                }
                if (dbottom > 0) {
                    oRect["height"] -= dbottom;
                }

                if (dleft > 0) {
                    oRect["width"] -= dleft;
                    oRect["left"] += dleft;
                }
                if (dright > 0) {
                    oRect["width"] -= dright;
                }
                if (oScrollRef === document["body"]) {
                    oScrollRef = null;
                } else {
                    oScrollRef = UCF_DomUtil["oGetParentScrollContainer"](oScrollRef["parentNode"]);
                }
            }

            if (oRect["height"] <= 0) {
                oRect["height"] = 0;
            }
            if (oRect["width"] <= 0) {
                oRect["width"] = 0;
            }
            oRect["_original"] = oOriginalRect;

            return oRect;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetViewPort"] = 0;
    }
    ;

    /**
     * Returns the vertical scrollbar offset of a given DOM object
     *
     * @param {Element} oDomRef the element to get the vertical scrollbar offset
     * from
     * @return {number} the offset in pixel; 0 when no scrollbar is visible
     * @private
     */
    UCF_DomUtil["iGetVerticalScrollbarOffset"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetVerticalScrollbarOffset"]++;
        }
        ;
        /** @type {CSSStyleDeclaration} */
        var oComputedStyle;
        /** @type {string} */
        var sBorderLeft;
        /** @type {string} */
        var sBorderRight;
        /** @type {number} */
        var iBorders;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "DomUtil.js(1719): iGetVerticalScrollbarOffset");
        }
        ;

        if (oDomRef["offsetWidth"] === oDomRef["clientWidth"]) {
            return 0;
        } else if (UCF_UserAgent["bIsIE"]() && !UCF_UserAgent["bIsStandardsMode"]()) {
            oComputedStyle = UCF_DomUtil["oGetComputedStyle"](oDomRef);
            sBorderLeft = oComputedStyle["borderLeftWidth"];
            sBorderRight = oComputedStyle["borderRightWidth"];
            iBorders = 0;

            if (UCF_StringUtil["bContains"](sBorderLeft, "px")) {
                iBorders += parseInt(sBorderLeft, 10);
            }
            if (UCF_StringUtil["bContains"](sBorderRight, "px")) {
                iBorders += parseInt(sBorderRight, 10);
            }

            return oDomRef["offsetWidth"] - oDomRef["clientWidth"] - (iBorders || 0);
        } else {
            oComputedStyle = UCF_DomUtil["oGetComputedStyle"](oDomRef);

            // if display:inline, clientWidth is always 0 (per CSSOM specification)
            // => if we don't return 0 we think the scrollbar is as wide as the
            // offsetWidth
            return oComputedStyle["display"] === 'inline'
                ? 0
                : oDomRef["offsetWidth"] - oDomRef["clientWidth"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetVerticalScrollbarOffset"] = 0;
    }
    ;

    /**
     * @see UCF_DomUtil#iGetScrollbarWidth
     * @type {number} internal cache for the scrollbar width
     */
    UCF_DomUtil["iScrollbarWidth"] = null;

    /**
     * @static
     * @param {Node} oNewParent the parent
     * @param {Node} oChild the child to insert before the first child of oNewParent
     */
    UCF_DomUtil["prepend"] = function (oNewParent, oChild) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["prepend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oNewParent, "oNewParent", "DomUtil.js(1761): prepend");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oChild, "oChild", "DomUtil.js(1762): prepend");
        }
        ;

        /** @type {Node} */
        var oFirstChild = oNewParent["firstChild"];

        if (oFirstChild) {
            oNewParent["insertBefore"](oChild, oFirstChild);
        } else {
            UCF_DomUtil["append"](oNewParent, oChild);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["prepend"] = 0;
    }
    ;

    /**
     * @static
     * @param {Node} oNewParent the parent
     * @param {Node} oChild the child to append at the end of oNewParent.childNodes
     */
    UCF_DomUtil["append"] = function (oNewParent, oChild) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["append"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oNewParent, "oNewParent", "DomUtil.js(1780): append");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oChild, "oChild", "DomUtil.js(1781): append");
        }
        ;

        oNewParent["appendChild"](oChild);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["append"] = 0;
    }
    ;

    /**
     * @protected
     * @return {number} the width of native scrollbars in the current instance
     * (i.e. offsetWidth - clientWidth of an overflow:scroll div)
     */
    UCF_DomUtil["iGetScrollbarWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetScrollbarWidth"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oDummyRef;

        if (UCF_DomUtil["iScrollbarWidth"] === null) {
            oDummyRef = document["createElement"]('div');

            UCF_DomUtil["setStyle"](oDummyRef, {
                "position": 'absolute',
                "top": '-99999px',
                "overflow": 'scroll',
                "width": '100px',
                "height": '100px'
            });

            UCF_DomUtil["prepend"](document["body"], oDummyRef);

            UCF_DomUtil["iScrollbarWidth"] = oDummyRef["offsetWidth"] - oDummyRef["clientWidth"];

            UCF_DomUtil["removeFromDom"](oDummyRef);
        }

        return UCF_DomUtil["iScrollbarWidth"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetScrollbarWidth"] = 0;
    }
    ;

    /**
     * Returns the size of the given DOM object
     *
     * @param {Element} oDomRef the element to get the object size from
     * @return {UCF_Size} The size of the given DOM object
     * @private
     */
    UCF_DomUtil["oGetObjectSize"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetObjectSize"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(1825): oGetObjectSize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(1826): oGetObjectSize");
        }
        ;

        return new UCF_Size(oDomRef["offsetWidth"], oDomRef["offsetHeight"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetObjectSize"] = 0;
    }
    ;

    /**
     * Checks if X and Y is in a given rect
     *
     * @param {UCF_Rectangle} oRect the bounding rectangle
     * @param {number} iPosX the x coordinate
     * @param {number} iPosY the y coordinate
     * @return {boolean} whether X and Y is in a given rect.
     * @private
     */
    UCF_DomUtil["bIsInRect"] = function (oRect, iPosX, iPosY) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bIsInRect"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oRect != null, "oRect != null", "DomUtil.js(1841): bIsInRect");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(!isNaN(iPosX), "!isNaN(iPosX)", "DomUtil.js(1842): bIsInRect");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(!isNaN(iPosY), "!isNaN(iPosY)", "DomUtil.js(1843): bIsInRect");
        }
        ;

        return iPosX >= oRect["left"]
            && iPosX <= oRect["left"] + oRect["width"]
            && iPosY >= oRect["top"]
            && iPosY <= oRect["top"] + oRect["height"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bIsInRect"] = 0;
    }
    ;

    /**
     * Returns the next parent scroll container
     *
     * @param {Element} oDomRef the element to get the parent scroll container for
     * @param {bool} [bIgnoreBody=false] Ignores body of document as scroll container
     * @param {bool} [bIgnoreTables=false] `true` ignores tables
     * @param {bool} [bIgnoreNonScrollingAuto=false] true ignores containers
     * with ScrollingMode=AUTO which do not actually scroll
     * @return {HTMLElement} The next parent scroll container
     * @private
     */
    UCF_DomUtil["oGetParentScrollContainer"] = function (oDomRef, bIgnoreBody, bIgnoreTables, bIgnoreNonScrollingAuto) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetParentScrollContainer"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(1863): oGetParentScrollContainer");
        }
        ;

        while (oDomRef != null) {
            if (oDomRef === document["body"]) {
                return bIgnoreBody ? null : oDomRef;
            } else {
                var sOverflow = UCF_DomUtil["sGetCurrentStyle"](oDomRef, "overflow");

                if (bIgnoreNonScrollingAuto) {
                    if ((sOverflow === 'auto' && oDomRef["scrollHeight"] > oDomRef["clientHeight"]) ||
                        (sOverflow !== 'auto' && sOverflow !== "visible" && sOverflow !== "hidden" &&
                            (!bIgnoreTables ||
                                (bIgnoreTables && oDomRef["tagName"] !== "TABLE")
                            )
                        )) {
                        return oDomRef;
                    }
                } else {
                    if (sOverflow !== "visible" && sOverflow !== "hidden" && (!bIgnoreTables || (bIgnoreTables && oDomRef["tagName"] !== "TABLE"))) {
                        return oDomRef;
                    }
                }
            }
            oDomRef = oDomRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetParentScrollContainer"] = 0;
    }
    ;

    /**
     * Returns the next parent container which is used by the browsers as reference
     * for absolute positioning. Takes into account expicit attributes
     * `bUseAsPosRefContainer` and `bNoPosRefContainer`.
     * @param {Element} oDomRef the element to get the position reference container
     * for
     * @param {bool} bIgnoreBody Ignores body of document as scroll container
     * @param {Element} oStopAtDomRef Stops iteration at this container reference
     * @return {HTMLElement} The next parent container which is used by the
     * browsers as reference for absolute positioning
     * @private
     */
    UCF_DomUtil["oGetParentPositionReferenceContainer"] = function (oDomRef, bIgnoreBody, oStopAtDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetParentPositionReferenceContainer"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(1905): oGetParentPositionReferenceContainer");
        }
        ;
        var bHiddenHasEffect = (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]());

        while (oDomRef != null) {
            if (oStopAtDomRef && oDomRef === oStopAtDomRef) return null;

            if (oDomRef === document["body"]) {
                return bIgnoreBody ? null : oDomRef;
            } else {
                var sOverflow = UCF_DomUtil["sGetCurrentStyle"](oDomRef, "overflow");

                // for IE "hidden" is relevant, for other browsers not.
                if (oDomRef["getAttribute"]("bNoPosRefContainer") == null &&
                    (sOverflow !== "visible" && !(!bHiddenHasEffect && sOverflow === "hidden")) || oDomRef["getAttribute"]("bUseAsPosRefContainer")) {
                    return oDomRef;
                } else {
                    var sPosition = UCF_DomUtil["sGetCurrentStyle"](oDomRef, "position");
                    if (sPosition === "absolute" || sPosition === "relative") {
                        return oDomRef;
                    }
                }
            }
            oDomRef = oDomRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetParentPositionReferenceContainer"] = 0;
    }
    ;

    /**
     * Returns the first child with the tag name; replaces the JS DOM API that ignore comments
     * @param {Element} oDomRef parent DOMElement
     * @param {string} sTagName the tagname to match
     * @return {Element} DOMElement or null if no element is available
     * @private
     */
    UCF_DomUtil["firstChild"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["firstChild"]++;
        }
        ;
        if (oDomRef != null) {
            var oFirstChild = oDomRef["firstChild"];
            while (oFirstChild) {
                //TODO firstElementChild http://www.w3.org/TR/ElementTraversal/#attribute-firstElementChild
                if (sTagName == null && oFirstChild["nodeType"] === 1) break;
                if (sTagName && oFirstChild["nodeName"] === sTagName) break;
                oFirstChild = oFirstChild["nextSibling"];
            }
            return oFirstChild;
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["firstChild"] = 0;
    }
    ;

    /**
     * Returns the last child with the tag name; replaces the JS DOM API that ignore comments
     * @param {Element} oDomRef parent DOMElement
     * @param {string} sTagName the tagname to match
     * @return {Element} DOMElement or null if no element is available
     * @private
     */
    UCF_DomUtil["lastChild"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["lastChild"]++;
        }
        ;
        if (oDomRef != null) {
            var oLastChild = oDomRef["lastChild"];
            while (oLastChild) {

                //TODO: lastElementChild http://www.w3.org/TR/ElementTraversal/#attribute-lastElementChild
                if (sTagName == null && oLastChild["nodeType"] === 1) break;
                if (sTagName && oLastChild["nodeName"] === sTagName) break;
                oLastChild = oLastChild["previousSibling"];
            }
            return oLastChild;
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["lastChild"] = 0;
    }
    ;

    /**
     * Returns the next sibling with the tag name; replaces the JS DOM API that ignore comments
     * @param {Element} oDomRef parent DOMElement
     * @param {string} sTagName the tagname to match
     * @return {Element} DOMElement or null if no element is available
     * @private
     */
    UCF_DomUtil["nextSibling"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["nextSibling"]++;
        }
        ;
        if (oDomRef != null) {

            //TODO: nextElementSibling http://www.w3.org/TR/ElementTraversal/#attribute-nextElementSibling
            var oUntestedNode = oDomRef["nextSibling"];
            while (oUntestedNode != null) {
                if ((sTagName != null && oUntestedNode["nodeName"] === sTagName) || (sTagName == null && oUntestedNode["nodeType"] === 1)) {
                    return oUntestedNode;
                }
                oUntestedNode = oUntestedNode["nextSibling"];
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["nextSibling"] = 0;
    }
    ;

    /**
     * Returns the previous sibling with the tag name; replaces the JS DOM API that ignore comments
     * @param {Element} oDomRef DOMElement
     * @param {string} sTagName the tagname to match
     * @return {Element} DOMElement or null if no element is available
     * @private
     */
    UCF_DomUtil["previousSibling"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["previousSibling"]++;
        }
        ;
        if (oDomRef != null) {

            //TODO: previousElementSibling http://www.w3.org/TR/ElementTraversal/#attribute-previousElementSibling
            var oUntestedNode = oDomRef["previousSibling"];
            while (oUntestedNode != null) {
                if ((sTagName != null && oUntestedNode["nodeName"] === sTagName) || (sTagName == null && oUntestedNode["nodeType"] === 1)) {
                    return oUntestedNode;
                }
                oUntestedNode = oUntestedNode["previousSibling"];
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["previousSibling"] = 0;
    }
    ;

    /**
     * Returns the type of the parent TP element
     *
     * @param {Element} oDomRef DOMElement
     * @return {Element} the element with the tp attribute
     * @private
     */
    UCF_DomUtil["oGetTPElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTPElement"]++;
        }
        ;
        var element = oDomRef;
        while (element != null && element["nodeType"] === 1 && !(element["getAttribute"]("tp") || element["getAttribute"]("ct"))) {
            element = element["parentNode"];
        }
        if (element == null || element["nodeType"] !== 1 || element["getAttribute"]("ct")) {
            //_trace(DEBUG, "ERROR: Missing attribute 'tp' in element " + oDomRef.id);
            return null;
        }
        return element;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTPElement"] = 0;
    }
    ;

    /**
     * Returns the type of the parent TP element
     *
     * @param {Element} oDomRef DOMElement
     * @return {Element} the element with the tp attribute
     * @private
     */
    UCF_DomUtil["oGetCTElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetCTElement"]++;
        }
        ;
        var element = oDomRef;
        while (element != null && element["nodeType"] === 1 && !(element["getAttribute"]("ct"))) {
            element = element["parentNode"];
        }
        if (element == null || element["nodeType"] !== 1) {
            //_trace(DEBUG, "ERROR: Missing attribute 'ct' in element " + oDomRef.id);
            return null;
        }
        return element;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetCTElement"] = 0;
    }
    ;

    /**
     * Rerieves the first child DOM reference with ct attribute
     * @param {HTMLElement} oDomRef The DOM reference
     * @return {HTMLElement} - the DOM Reference with ct attribute
     * @private
     */
    UCF_DomUtil["oGetFirstChildCTElement"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetFirstChildCTElement"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oCurrDomRef;
        /** @type {HTMLElement} */
        var oDomRefFound;
        oCurrDomRef = oDomRef["firstChild"];
        oDomRefFound = null;

        while (oCurrDomRef) {
            if (oCurrDomRef["nodeType"] === 1) {
                if (oCurrDomRef["getAttribute"] && oCurrDomRef["getAttribute"]("ct")) {
                    return oCurrDomRef;
                }

                if (oCurrDomRef["childNodes"]) {
                    oDomRefFound = UCF_DomUtil["oGetFirstChildCTElement"](oCurrDomRef);
                    if (oDomRefFound) return oDomRefFound;
                }
            }
            oCurrDomRef = oCurrDomRef["nextSibling"];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetFirstChildCTElement"] = 0;
    }
    ;

    /**
     * Compares the type of the parent TP element
     *
     * @param {Object} oDomRef the dom reference
     * @param {string} sType the ct element name
     * @return {boolean} true if the parent is the type
     * @private
     */
    UCF_DomUtil["bIsCTInstanceOf"] = function (oDomRef, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bIsCTInstanceOf"]++;
        }
        ;
        var element = UCF_DomUtil["oGetCTElement"](oDomRef);
        if (element != null && element["nodeType"] === 1 && element["getAttribute"]("ct")) {
            var tp = element["getAttribute"]("ct");
            if (tp === sType) {
                return true;
            }
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bIsCTInstanceOf"] = 0;
    }
    ;

    /**
     * Returns all children with the tag name; replaces the JS DOM API that ignore comments
     * @param {Element} oDomRef the parent
     * @param {string} sTagName the tagname to match
     * @return {Array.<Element>} the child nodes of oDomRef that match sTagName
     * @private
     */
    UCF_DomUtil["childNodes"] = function (oDomRef, sTagName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["childNodes"]++;
        }
        ;
        var aChildren = new Array();
        if (oDomRef != null) {
            var oUntestedNode = oDomRef["childNodes"],
                iLen = oUntestedNode["length"];
            for (var i = iLen; i--;) {
                var oArrayItem = oUntestedNode[i];
                if ((sTagName != null && oArrayItem["nodeName"] === sTagName) || (sTagName == null && oArrayItem["nodeType"] === 1)) {
                    aChildren["unshift"](oArrayItem);
                }
            }
        }
        return aChildren;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["childNodes"] = 0;
    }
    ;

    /**
     * Sets the caret position
     *
     * @param {Element} oDomRef  the domRef of an HTML element which has caret data
     * @param {number} iPos the cursor position
     * @private
     */
    UCF_DomUtil["setCursorPos"] = function (oDomRef, iPos) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setCursorPos"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2137): setCursorPos");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(!isNaN(iPos), "!isNaN(iPos)", "DomUtil.js(2138): setCursorPos");
        }
        ;

        try { // IE8

            if ((oDomRef && oDomRef["tagName"] === "INPUT" && (oDomRef["type"] && (oDomRef["type"]["toLowerCase"]() === "text"
                    || oDomRef["type"]["toLowerCase"]() === "password")))
                || oDomRef && oDomRef["tagName"] === "TEXTAREA"
            ) {
                if (oDomRef["createTextRange"]) {
                    var oTextRange = oDomRef["createTextRange"](),
                        iMaxLength = oDomRef["value"]["length"];

                    if (iPos < 0 || iPos > iMaxLength) iPos = iMaxLength;
                    if (oTextRange) {
                        oTextRange["collapse"]();
                        oTextRange["moveStart"]("character", iPos);
                        oTextRange["select"]();
                    }
                } else if (typeof (oDomRef["selectionStart"]) === "number") {
                    oDomRef["focus"]();
                    oDomRef["selectionStart"] = iPos;
                    oDomRef["selectionEnd"] = iPos;
                }
            }

        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, oException + " ", "DomUtil.js(2164): setCursorPos");
            }
            ;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setCursorPos"] = 0;
    }
    ;

    /**
     * Focuses the given element if not already focussed (IMPORTANT!!!) and returns
     * the current caret position.
     *
     * @param {Element} oDomRef  the domRef of an HTML element which has caret data
     * @return {number} the cursor position
     * @private
     */
    UCF_DomUtil["iGetCursorPos"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetCursorPos"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2178): iGetCursorPos");
        }
        ;

        if ((oDomRef && oDomRef["tagName"] === "INPUT" && (oDomRef["type"] && (oDomRef["type"]["toLowerCase"]() === "text"
                || oDomRef["type"]["toLowerCase"]() === "password")))
            || oDomRef && oDomRef["tagName"] === "TEXTAREA"
        ) {

            var curPos = -1;
            try {
                if (oDomRef["curPos"]) {
                    return oDomRef["curPos"];
                }

                if (document["selection"] && !UCF_UserAgent["bIsStandardsMode"]()) {
                    //CSN 132688 2013: IMEMode may be changed as soon as inputfield is refocused
                    if (UCF_DomUtil["oGetActiveElement"]() !== oDomRef) {
                        oDomRef["focus"]();
                    }
                    var oSel = document["selection"]["createRange"]();
                    if (oSel) {
                        oSel["moveStart"]('character', -oDomRef["value"]["length"]);
                        curPos = oSel["text"]["length"];
                    }
                } else if (typeof (oDomRef["selectionStart"]) === "number") {
                    return oDomRef["selectionStart"];
                }
            } catch (e) {
            }
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, "curPos=" + curPos, "DomUtil.js(2205): iGetCursorPos");
            }
            ;
            return curPos;

        }
        return -1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetCursorPos"] = 0;
    }
    ;

    /**
     * Gets the selection text
     *
     * @param {Element} oDomRef  the domRef of an HTML element which has selection data
     * @return {string} selection text
     * @private
     */
    UCF_DomUtil["sGetSelectionText"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetSelectionText"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2220): sGetSelectionText");
        }
        ;

        var sSelectionText = null;
        var oActiveElement = null;

        if (oDomRef["createTextRange"] && document["selection"]) { //IE11 check also for document.selection because it does not exist anymore for IE11
            try {
                var oSelectionRange = document["selection"]["createRange"]()["duplicate"]();
                sSelectionText = oSelectionRange["text"];
            } catch (e) {
            }
        } else if (typeof (oDomRef["selectionStart"]) === "number") {
            sSelectionText = oDomRef["value"]["slice"](oDomRef["selectionStart"], oDomRef["selectionEnd"]);
        } else if (window["getSelection"] && window["getSelection"]()) {
            sSelectionText = window["getSelection"]()["toString"]();
            //IE11 and Edge only return text selection reliably for SPAN tags!!!
            if (UCF_UserAgent["bIsIE"]() && UCF_UserAgent["bIsStandardsMode"] || UCF_UserAgent["bIsMSEdge"]()) {
                //proposal from Microsoft: use document.activeElement.selectionStart, document.activeElement.selectionEnd
                oActiveElement = UCF_DomUtil["oGetActiveElement"]();
                if (oActiveElement &&
                    (oActiveElement["tagName"]["toUpperCase"]() === "TEXTAREA" || oActiveElement["tagName"]["toUpperCase"]() === "INPUT") &&
                    oActiveElement["value"] && oActiveElement["selectionStart"] >= 0 && oActiveElement["selectionEnd"] >= 0) {
                    if (oActiveElement["value"]["length"] === oActiveElement["selectionEnd"] - oActiveElement["selectionStart"]) {
                        sSelectionText = oActiveElement["value"];
                    } else {
                        sSelectionText = oActiveElement["value"]["substring"](oActiveElement["selectionStart"], oActiveElement["selectionEnd"]);
                    }
                }
            }
        }
        return sSelectionText;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetSelectionText"] = 0;
    }
    ;

    /**
     * Get start of selection
     *
     * @param {Element} oDomRef  the domRef of an HTML element which has caret data
     * @return {number} start of selection
     * @private
     */
    UCF_DomUtil["iGetSelectionStart"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetSelectionStart"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2260): iGetSelectionStart");
        }
        ;

        if (oDomRef["selStart"]) {
            return oDomRef["selStart"];
        }

        var iSelectionStart = -1;
        if (oDomRef["createTextRange"] && document["selection"]) { //IE11 check also for document.selection because it does not exist anymore for IE11
            try {
                var oSelectionRange = document["selection"]["createRange"]()["duplicate"]();
                var iSelectionLength = oSelectionRange["text"]["length"];
                var iLength = oDomRef["value"]["length"];

                if (iSelectionLength > 0) {
                    for (var i = 0; i < iLength; i++) {
                        oSelectionRange["moveStart"]('character', -1);
                        if (oSelectionRange["htmlText"] !== oSelectionRange["text"]) break;
                    }
                    iSelectionStart = oSelectionRange["text"]["length"] - iSelectionLength;
                }
            } catch (e) {
            }
        } else if (typeof (oDomRef["selectionStart"]) === "number") {
            iSelectionStart = oDomRef["selectionStart"];
        }
        return iSelectionStart;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetSelectionStart"] = 0;
    }
    ;

    /**
     * Get end of selection
     *
     * @param {Element} oDomRef the domRef of an HTML element which has caret data
     * @return {number} end of selection
     * @private
     */
    UCF_DomUtil["iGetSelectionEnd"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetSelectionEnd"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2295): iGetSelectionEnd");
        }
        ;

        if (oDomRef["selEnd"]) {
            return oDomRef["selEnd"];
        }

        var iSelectionEnd = -1;
        if (oDomRef["createTextRange"] && document["selection"]) { //IE11 check also for document.selection because it does not exist anymore for IE11
            try {
                var oSelectionRange = document["selection"]["createRange"]()["duplicate"]();
                var iSelectionLength = oSelectionRange["text"]["length"];
                var iLength = oDomRef["value"]["length"];

                if (iSelectionLength > 0) {
                    for (var i = 0; i < iLength; i++) {
                        oSelectionRange["moveStart"]('character', -1);
                        if (oSelectionRange["htmlText"] !== oSelectionRange["text"]) break;
                    }
                    iSelectionEnd = oSelectionRange["text"]["length"];
                }
            } catch (e) {
            }
        } else if (typeof (oDomRef["selectionEnd"]) === "number") {
            iSelectionEnd = oDomRef["selectionEnd"];
        }
        return iSelectionEnd;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetSelectionEnd"] = 0;
    }
    ;

    /**
     * Set selection
     *
     * @param {Element} oDomRef  the domRef of an HTML element which has caret data
     * @param {number} iStart  start of selection
     * @param {number} iEnd    end of selection
     * @private
     */
    UCF_DomUtil["setSelection"] = function (oDomRef, iStart, iEnd) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setSelection"]++;
        }
        ;
        /** @type {TextRange} */
        var oTextRange;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2334): setSelection");
        }
        ;

        if (oDomRef["createTextRange"]) {
            oTextRange = oDomRef["createTextRange"]();
            oTextRange["collapse"]();
            oTextRange["moveStart"]('character', iStart);
            oTextRange["moveEnd"]('character', iEnd - iStart);
            oTextRange["select"]();
        } else if (typeof oDomRef["selectionStart"] === 'number') {
            oDomRef["selectionStart"] = iStart;
            oDomRef["selectionEnd"] = iEnd;
            UCF_DomUtil["moveFocusDomElement"](oDomRef, true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setSelection"] = 0;
    }
    ;

    /**
     * Removes the selection
     * Note: The implementation ignores the oDomRef argument(!)
     * @param {HTMLElement} oDomRef the element to remove the selection from
     * @private
     */
    UCF_DomUtil["removeSelection"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeSelection"]++;
        }
        ;
        //_assert(oDomRef != null);

        if (document["selection"]) {
            try {
                document["selection"]["empty"]();
            } catch (e) {
                //nice try!
            }
        } else if (window["getSelection"]) {
            try {
                window["getSelection"]()["removeAllRanges"]();
            } catch (e) {
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeSelection"] = 0;
    }
    ;

    /**
     * Removes the current selection of the current window.document.
     * Optional: Remove only if the selection is contained inside the given DOM element
     * @param {HTMLElement} [oDomRef] Optional element
     * @private
     */
    UCF_DomUtil["removeSelectionFrom"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeSelectionFrom"]++;
        }
        ;
        /** @type {Selection} */
        var oSelection = window["getSelection"]();
        var bCheckElement = oDomRef ? oSelection["containsNode"](oDomRef, true) : true;
        if (oSelection["rangeCount"] > 0 && bCheckElement) {
            try {
                oSelection["removeAllRanges"]();
            } catch (e) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "Caught error from removeAllRanges():" + e["message"], "DomUtil.js(2385): removeSelectionFrom");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeSelectionFrom"] = 0;
    }
    ;

    /**
     * Check whether the give element is part of the current selection of window.document.
     * @return {boolean}
     * @param {HTMLElement} oDomRef
     * @private
     */
    UCF_DomUtil["bHasSelection"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bHasSelection"]++;
        }
        ;

        if (UCF_UserAgent["bIsIE"]()) {
            var oContainer = UCF_DomUtil["oGetSelectionNode"]();
            return oContainer !== null && oContainer === oDomRef;
        } else {
            /** @type {Selection} */
            var oSelection = window["getSelection"]();
            return !oSelection["isCollapsed"] && oSelection["rangeCount"] > 0 && oSelection["containsNode"](oDomRef, true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bHasSelection"] = 0;
    }
    ;

    /**
     * Get element which contains the current selection of window.document.
     * @return { HTMLElement } contains selection
     * @private
     */
    UCF_DomUtil["oGetSelectionNode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetSelectionNode"]++;
        }
        ;
        /** @type {Range} */
        var oRange,
            oContainer;
        if (__UCF_IE6__) {
            oRange = document["selection"]["createRange"]();
            var sSelectionText = oRange["text"];

            return sSelectionText !== '' ? oRange["parentElement"]() : null;

        } else {
            /** @type {Selection} */
            var oSelection = window["getSelection"]();
            if (oSelection["rangeCount"] > 0 && !oSelection["isCollapsed"]) {
                oRange = oSelection["getRangeAt"](0);
                if (oRange) {
                    oContainer = oRange["commonAncestorContainer"];
                }
                return oContainer["nodeType"] === Node["TEXT_NODE"] ? oContainer["parentNode"] : oContainer;
            } else {
                return null;
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetSelectionNode"] = 0;
    }
    ;

    /**
     * polyfills window.getComputedStyle
     *
     * @param {Element} oDomRef the dom element whose computed syle should be retrieved
     * @param {string} sPseudoElement an optional string specifying the pseudo-element to match
     * @return {CSSStyleDefinition|Object} the computed style for oDomRef
     * @private
     */
    UCF_DomUtil["oGetComputedStyle"] = function (oDomRef, sPseudoElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetComputedStyle"]++;
        }
        ;
        /** @type {DispHTMLCurrentStyle} */
        var oCurrentStyle;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(2451): oGetComputedStyle");
        }
        ;

        if (typeof getComputedStyle === 'function') {
            return getComputedStyle(oDomRef, sPseudoElement);
        } else {
            // currentStyle only used in IE Quirks => replacing string values with
            // computed ones
            oCurrentStyle = oDomRef["currentStyle"];
            if (oCurrentStyle) {
                return UCF_JsUtil["extend"]({},
                    oCurrentStyle,
                    oCurrentStyle["borderTopWidth"] === 'thin' ? {"borderTopWidth": '1px'} : {},
                    oCurrentStyle["borderTopWidth"] === 'medium' ? {"borderTopWidth": '3px'} : {},
                    oCurrentStyle["borderTopWidth"] === 'thick' ? {"borderTopWidth": '5px'} : {},
                    oCurrentStyle["borderRightWidth"] === 'thin' ? {"borderRightWidth": '1px'} : {},
                    oCurrentStyle["borderRightWidth"] === 'medium' ? {"borderRightWidth": '3px'} : {},
                    oCurrentStyle["borderRightWidth"] === 'thick' ? {"borderRightWidth": '5px'} : {},
                    oCurrentStyle["borderBottomWidth"] === 'thin' ? {"borderBottomWidth": '1px'} : {},
                    oCurrentStyle["borderBottomWidth"] === 'medium' ? {"borderBottomWidth": '3px'} : {},
                    oCurrentStyle["borderBottomWidth"] === 'thick' ? {"borderBottomWidth": '5px'} : {},
                    oCurrentStyle["borderLeftWidth"] === 'thin' ? {"borderLeftWidth": '1px'} : {},
                    oCurrentStyle["borderLeftWidth"] === 'medium' ? {"borderLeftWidth": '3px'} : {},
                    oCurrentStyle["borderLeftWidth"] === 'thick' ? {"borderLeftWidth": '5px'} : {},
                    oCurrentStyle["borderWidth"] === 'thin' ? {"borderWidth": '1px'} : {},
                    oCurrentStyle["borderWidth"] === 'medium' ? {"borderWidth": '3px'} : {},
                    oCurrentStyle["borderWidth"] === 'thick' ? {"borderWidth": '5px'} : {}
                );
            } else {
                return {};
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetComputedStyle"] = 0;
    }
    ;

    /**
     * Gets the current style object for a DOM element position
     *
     * @param {Element} oDomRef  the domRef of an HTML element for the current style
     * @param {string} sStyleAttribute the style attribute
     * @return {string} the current style
     * @private
     */
    UCF_DomUtil["sGetCurrentStyle"] = function (oDomRef, sStyleAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetCurrentStyle"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(2493): sGetCurrentStyle");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sStyleAttribute === "string", "typeof sStyleAttribute === \"string\"", "DomUtil.js(2494): sGetCurrentStyle");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sStyleAttribute !== "", "sStyleAttribute !== \"\"", "DomUtil.js(2495): sGetCurrentStyle");
        }
        ;

        return UCF_DomUtil["oGetComputedStyle"](oDomRef)[sStyleAttribute];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetCurrentStyle"] = 0;
    }
    ;

    /**
     * Sets the CSS 'opacity' of an DOM element. Applies a fallback for IE11 Quirks mode ('filter:alpha').
     *
     * @param {HTMLElement} oDomRef  the domRef of an HTML element.
     * @param {number} iOpacity the opacity from 100 (not transparent) to 0 (completely transparent).
     * @private
     */
    UCF_DomUtil["setOpacityStyle"] = function (oDomRef, iOpacity) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setOpacityStyle"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2508): setOpacityStyle");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (iOpacity) === "number", "typeof(iOpacity) === \"number\"", "DomUtil.js(2509): setOpacityStyle");
        }
        ;

        if (UCF_UserAgent["bIsIE"]() && !UCF_UserAgent["bIsStandardsMode"]()) {
            // eslint-disable-next-line no-magic-numbers
            oDomRef["style"]["filter"] = (iOpacity === 100 ? "" : "alpha(opacity=" + (iOpacity < 10 ? "0" : "") + iOpacity + ")");
        } else {
            // eslint-disable-next-line no-magic-numbers
            oDomRef["style"]["opacity"] = (iOpacity / 100);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setOpacityStyle"] = 0;
    }
    ;

    /**
     * Removes the opacity of an DOM element.
     *
     * @param {Element} oDomRef  the domRef of an HTML element.
     * @private
     */
    UCF_DomUtil["removeOpacityStyle"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeOpacityStyle"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2527): removeOpacityStyle");
        }
        ;
        if (UCF_UserAgent["bIsIE"]() && !UCF_UserAgent["bIsStandardsMode"]()) {
            oDomRef["style"]["filter"] = "";
        } else {
            oDomRef["style"]["opacity"] = "";
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeOpacityStyle"] = 0;
    }
    ;

    /**
     * Returns the visible text content of a dom element including input value, textarea value, select value
     *
     * @param {Element} oDomRef  the domRef of an HTML element for the current style
     * @return {string} visible text content of the given element
     * @private
     */
    UCF_DomUtil["sGetVisibleTextContent"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetVisibleTextContent"]++;
        }
        ;
        if (!UCF_DomUtil["bIsVisible"](oDomRef)) return "";
        var aContent = oDomRef["childNodes"],
            sText = "";
        if (oDomRef["tagName"] === "INPUT" || oDomRef["tagName"] === "TEXTAREA") {
            sText += oDomRef["value"];
            return sText;
        } else if (oDomRef["tagName"] === "SELECT") {
            sText += oDomRef["options"][oDomRef["selectedIndex"]]["text"];
            return sText;
        }
        for (var i = 0; i < aContent["length"]; i++) {
            var oNode = aContent[i];
            if (oNode["nodeType"] === 1 && UCF_DomUtil["bIsVisible"](oNode)) {
                if (oNode["tagName"] === "INPUT" || oNode["tagName"] === "TEXTAREA") {
                    sText += oNode["value"];
                } else if (oNode["tagName"] === "SELECT") {
                    sText += oNode["options"][oNode["selectedIndex"]]["text"];
                } else {
                    sText += UCF_DomUtil["sGetVisibleTextContent"](oNode);
                }
            }
            // eslint-disable-next-line no-magic-numbers
            else if (oNode["nodeType"] === 3) {
                sText += UCF_StringUtil["sTrim"](oNode["nodeValue"]);
            }
        }
        return sText;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetVisibleTextContent"] = 0;
    }
    ;

    /**
     * Gets all text content of the given element
     *
     * @param {Element} oDomRef  the domRef of an HTML element for the current style
     * @return {string} Text content of the given element
     * @private
     */
    UCF_DomUtil["sGetInnerText"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetInnerText"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2580): sGetInnerText");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(2581): sGetInnerText");
        }
        ;

        var sText = oDomRef["innerText"] || UCF_StringUtil["sTrim"](oDomRef["textContent"]);
        if (typeof (sText) !== "string") sText = "";
        return sText;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetInnerText"] = 0;
    }
    ;

    /**
     * Sets the content of the element to the given text
     *
     * @param {Element} oDomRef  the domRef of an HTML element for the current style
     * @param {string} sText the text to set as textContent of oDomRef
     * @private
     */
    UCF_DomUtil["setInnerText"] = function (oDomRef, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setInnerText"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2596): setInnerText");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "DomUtil.js(2597): setInnerText");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sText) === "string", "typeof(sText) === \"string\"", "DomUtil.js(2598): setInnerText");
        }
        ;

        oDomRef["innerHTML"] = "";
        // Use a textnode to avoid HTML to be interpreted by the browser
        UCF_DomUtil["append"](oDomRef, document["createTextNode"](sText));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setInnerText"] = 0;
    }
    ;

    /**
     * Returns whether the dom element is visible
     * @param {HTMLElement} oDomRef the element that's visibility should be checked
     * @param {boolean} bIncludeParents flag to take parents into concern
     * @param {HTMLElement} oStopAtDomRef Stops iteration at this container reference.
     * the stop ref itself is not tested
     * @return {boolean} true if the dom element is visible
     * @private
     */
    UCF_DomUtil["bIsVisible"] = function (oDomRef, bIncludeParents, oStopAtDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bIsVisible"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2615): bIsVisible");
        }
        ;

        /** @type {CSSStyleDeclaration} */
        var oComputedStyle;

        //Reached stop DOM reference which means it is visible
        if (oStopAtDomRef && oDomRef === oStopAtDomRef) return true;

        //Check if the element is in the active dom and has the right type.
        if (UCF_DomUtil["bIsInActiveDom"](oDomRef) && oDomRef["nodeType"] === 1) {
            oComputedStyle = UCF_DomUtil["oGetComputedStyle"](oDomRef);
            var bVisible = oComputedStyle["visibility"] !== "hidden" && oComputedStyle["display"] !== "none";
            // Immediately exit if the dom ref is invisible
            if (!bVisible) return false;

            //If the body was not reached in parent mode go up, otherwise element is visible
            if (bIncludeParents && oDomRef["tagName"] && oDomRef["tagName"] !== "BODY" && oDomRef["parentNode"]) {
                return UCF_DomUtil["bIsVisible"](oDomRef["parentNode"], true, oStopAtDomRef);
            } else {
                return true;
            }
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bIsVisible"] = 0;
    }
    ;

    /**
     * Sets the visiblity of a given DOM element to the given sVisibility
     * @param {Element} oDomRef the element to set the visibility
     * @param {string} sVisibility the visibility to set
     * @private
     */
    UCF_DomUtil["setVisibility"] = function (oDomRef, sVisibility) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setVisibility"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2647): setVisibility");
        }
        ;

        var oStyle = oDomRef["style"];
        switch (sVisibility) {
            case "NONE":
                oStyle["display"] = "none";
                oStyle["visibility"] = "";
                break;
            case "VISIBLE":
                oStyle["display"] = "";
                oStyle["visibility"] = "";
                break;
            case "BLANK":
                oStyle["display"] = "";
                oStyle["visibility"] = "hidden";
                break;
            default:
                var sId = oDomRef["id"];
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "The value " + sVisibility + " cannot applied to the DomRef " + sId, "DomUtil.js(2665): setVisibility");
                }
                ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setVisibility"] = 0;
    }
    ;

    /**
     * Returns the top most window which is scriptable
     * and does not contain a frameset
     * @return {Window} the window object
     * @private
     */
    UCF_DomUtil["oGetTopWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTopWindow"]++;
        }
        ;
        /** @type {any} used to test accesses to elements of other windows */
            // oIgnored must not be removed by the closure compiler
        var oIgnored = {}; // eslint-disable-line no-unused-vars

        if (UCF_DomUtil["oTopWindow"]) {
            return UCF_DomUtil["oTopWindow"];
        }

        var aWindows = new Array();
        var oWindow = window;
        var oParentWindow = null;
        var bFirstParentAccess = true;
        aWindows[0] = oWindow;

        //test first window.parent access
        try {
            oParentWindow = oWindow["parent"];
        } catch (e) {
            bFirstParentAccess = false;
        }

        if (bFirstParentAccess) {
            while (oWindow !== oParentWindow) {
                oWindow = oParentWindow;
                aWindows[aWindows["length"]] = oWindow;

                //test window.parent access
                try {
                    oParentWindow = oWindow["parent"];
                } catch (e) {
                    break;
                }
            }
        }

        for (var x = aWindows["length"] - 1; x >= 0; x--) {
            var oTopWindow = aWindows[x];

            //test document access
            try {
                oIgnored['ignored'] = oTopWindow["document"]["domain"];
                // Additional check for Firefox: domain access may work but IFrame inserted there for PopupWindow will not be loaded (without JS error) !!
                if (UCF_UserAgent["bIsFirefox"]()) oIgnored['ignored'] = oTopWindow["location"]["href"];
            } catch (e) {
                continue;
            }

            UCF_DomUtil["oIgnored"] = oIgnored;

            //has window a framset?
            var iBs = oTopWindow["document"]["getElementsByTagName"]("frameset")["length"];
            if (iBs > 0) {
                continue;
            }

            return UCF_DomUtil["oTopWindow"] = oTopWindow;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTopWindow"] = 0;
    }
    ;

    /**
     * @example
     * UCF_DomUtil.setStyle(oDomRef, 'line-height', '-2px')
     * // => would throw in IE Quirks, would now just log a warning
     * UCF_DomUtil.setStyle(oDomRef, {
     *   height: '26px',
     *   lineHeight: '26px'
     * })
     * // => object-based interface
     *
     * @param {HTMLElement} oDomRef the element to style
     * @param {string|Object.<string,string>} sAttribute the css attribute to set,
     * or an object of attribute:value pairs
     * @param {string} [sValue] the value to set sAttribute to
     */
    UCF_DomUtil["setStyle"] = function (oDomRef, sAttribute, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setStyle"]++;
        }
        ;
        try {
            if (typeof sAttribute === 'string' && sValue !== undefined) {
                oDomRef["style"][sAttribute] = sValue;
            } else if (typeof sAttribute === 'object') {
                UCF_JsUtil["forEach"](UCF_JsUtil["entries"](sAttribute), function (aEntry) {
                    oDomRef["style"][aEntry[0]] = aEntry[1];
                });
            }
        } catch (oError) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, oError["message"], "DomUtil.js(2760): setStyle");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setStyle"] = 0;
    }
    ;

    /**
     * Tries to retrieve {{#ls-styleelement}} from oDocument,
     * creates a new style element in the head of oDocument
     * if it does not find it.
     *
     * @param {Document} [oDocument=document] the document to use
     * defaults to window.document
     * @return {HTMLStyleElement} the {{#ls-styleelement}}
     * @private
     */
    UCF_DomUtil["oCreateOrGetStyleElement"] = function (oDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oCreateOrGetStyleElement"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oStyleElement;

        if (!oDocument) {
            oDocument = document;
        }

        oStyleElement = oDocument["getElementById"]('ls-styleelement');

        if (!oStyleElement) {
            oStyleElement = oDocument["createElement"]('style');
            oStyleElement["setAttribute"]('id', 'ls-styleelement');
            oStyleElement["setAttribute"]('type', 'text/css');
            UCF_DomUtil["append"](
                oDocument["getElementsByTagName"]('head')[0],
                oStyleElement
            );
        }

        return oStyleElement;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oCreateOrGetStyleElement"] = 0;
    }
    ;

    /**
     * Sets the {{innerHTML}} of {{#ls-styleelement}}
     * (with polyfill for IE8-)
     *
     * @param {string} sCss the innerHTML to set
     * @param {Document} oDocument the document to use, defaults
     * to window.document
     * @private
     * @see UCF_DomUtil.oCreateOrGetStyleElement(Document): HTMLStyleElement
     */
    UCF_DomUtil["setStyleElementContent"] = function (sCss, oDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setStyleElementContent"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oStyleElement;

        if (!oDocument) {
            oDocument = document;
        }

        oStyleElement = UCF_DomUtil["oCreateOrGetStyleElement"](oDocument);

        if (oStyleElement["styleSheet"] && !oStyleElement["sheet"]) {
            oStyleElement["styleSheet"]["cssText"] = sCss;
        } else {
            while (oStyleElement["firstChild"]) {
                oStyleElement["removeChild"](oStyleElement["firstChild"]);
            }

            UCF_DomUtil["append"](oStyleElement, oDocument["createTextNode"](sCss));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setStyleElementContent"] = 0;
    }
    ;

    /**
     * Returns the first focusable DOM element in a given container
     *
     * @param {Element} oContainerDomRef the parent
     * @param {bool} bIncludeInvisible include the invisible elements in the search scan
     * @return {Element} the first focusable DOM element in a given container
     * @private
     */
    UCF_DomUtil["oGetFirstFocusableDomRef"] = function (oContainerDomRef, bIncludeInvisible) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetFirstFocusableDomRef"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oContainerDomRef != null, "oContainerDomRef != null", "DomUtil.js(2837): oGetFirstFocusableDomRef");
        }
        ;

        if (!oContainerDomRef || !(bIncludeInvisible || UCF_DomUtil["bIsVisible"](oContainerDomRef))) return null;

        //TODO firstElementChild http://www.w3.org/TR/ElementTraversal/#attribute-firstElementChild
        var oCurrDomRef = oContainerDomRef["firstChild"],
            oDomRefFound = null;

        while (oCurrDomRef) {
            if (oCurrDomRef["nodeType"] === 1 && (bIncludeInvisible || UCF_DomUtil["bIsVisible"](oCurrDomRef))) {
                if (UCF_DomUtil["bHasTabIndex"](oCurrDomRef)) {
                    return oCurrDomRef;
                }

                if (oCurrDomRef["childNodes"]) {
                    oDomRefFound = UCF_DomUtil["oGetFirstFocusableDomRef"](oCurrDomRef, bIncludeInvisible);
                    if (oDomRefFound) return oDomRefFound;
                }
            }
            oCurrDomRef = oCurrDomRef["nextSibling"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetFirstFocusableDomRef"] = 0;
    }
    ;

    /**
     * Returns the last focusable domRef in a given container
     *
     * @param {Element} oContainerDomRef the parent
     * @param {bool} bIncludeInvisible include the invisible elements in the search scan
     * @return {Element} The last focusable domRef in a given container
     * @private
     */
    UCF_DomUtil["oGetLastFocusableDomRef"] = function (oContainerDomRef, bIncludeInvisible) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetLastFocusableDomRef"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oContainerDomRef != null, "oContainerDomRef != null", "DomUtil.js(2871): oGetLastFocusableDomRef");
        }
        ;

        if (!oContainerDomRef || !(bIncludeInvisible || UCF_DomUtil["bIsVisible"](oContainerDomRef))) return null;

        //TODO: lastElementChild http://www.w3.org/TR/ElementTraversal/#attribute-lastElementChild
        var oCurrDomRef = oContainerDomRef["lastChild"],
            oDomRefFound = null;

        while (oCurrDomRef) {
            if (oCurrDomRef["nodeType"] === 1 && (bIncludeInvisible || UCF_DomUtil["bIsVisible"](oCurrDomRef))) {
                if (oCurrDomRef["childNodes"]) {
                    oDomRefFound = UCF_DomUtil["oGetLastFocusableDomRef"](oCurrDomRef, bIncludeInvisible);
                    if (oDomRefFound) return oDomRefFound;
                }

                if (UCF_DomUtil["bHasTabIndex"](oCurrDomRef)) {
                    return oCurrDomRef;
                }
            }

            //TODO: previousElementSibling http://www.w3.org/TR/ElementTraversal/#attribute-nextElementSibling
            oCurrDomRef = oCurrDomRef["previousSibling"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetLastFocusableDomRef"] = 0;
    }
    ;

    /**
     * Convenience method for removing a DOM element from the DOM
     *
     * @param {Element} oDomRef The DOM element to be removed
     * @private
     */
    UCF_DomUtil["removeFromDom"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeFromDom"]++;
        }
        ;

        if (oDomRef && oDomRef["parentNode"])
            oDomRef["parentNode"]["removeChild"](oDomRef);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeFromDom"] = 0;
    }
    ;

    /**
     * Removes all DOM references in the previous DOM tree which have
     * the same id as the passed DOM reference
     *
     * @param {Element} oDomRef the element to remove duplicate ids from
     * @private
     */
    UCF_DomUtil["removePreviousIdDuplicates"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removePreviousIdDuplicates"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(2919): removePreviousIdDuplicates");
        }
        ;

        var sDomRefId = oDomRef["getAttribute"]("id");

        if (sDomRefId) {
            var oFoundDomRef = UCF_DomUtil["$"](sDomRefId),
                oLastFoundDomRef = null;

            while (oFoundDomRef
            && oFoundDomRef !== oDomRef
            && oFoundDomRef !== oLastFoundDomRef //safety check
                ) {
                if (oFoundDomRef["parentNode"]) oFoundDomRef["parentNode"]["removeChild"](oFoundDomRef);
                oLastFoundDomRef = oFoundDomRef;
                oFoundDomRef = UCF_DomUtil["$"](sDomRefId);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removePreviousIdDuplicates"] = 0;
    }
    ;

    /**
     * Returns the next tabbable element
     *
     * @param {Element} oDomRef The element to start from
     * @param {boolean} bAscending if {{false}} only the subtree below {{oDomRef}} will be searched
     * @return {Element|null} The next tabbable element or null if no element is found.
     * @private
     */
    UCF_DomUtil["oGetTabbableElementForward"] = function (oDomRef, bAscending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTabbableElementForward"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(2947): oGetTabbableElementForward");
        }
        ;

        var oResult;

        while (oDomRef) {
            // CSN 1670017598: Node is undefined in IE Quirks mode
            if (oDomRef["nodeType"] === 1 /* === Node.ELEMENT_NODE */) {
                if (UCF_DomUtil["bHasTabIndex"](oDomRef) && oDomRef["offsetParent"]) return oDomRef;

                // TODO firstElementChild http://www.w3.org/TR/ElementTraversal/#attribute-firstElementChild
                if (oDomRef["firstChild"]) {
                    oResult = UCF_DomUtil["oGetTabbableElementForward"](oDomRef["firstChild"], false);
                }

                if (oResult) {
                    return oResult;
                }
            }

            oDomRef = UCF_DomUtil["oGetNextSibling"](oDomRef, bAscending);
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTabbableElementForward"] = 0;
    }
    ;

    /**
     * Returns the previous tabbable element
     * @param {HTMLElement} oDomRef The element to start from
     * @param {boolean} bAscending if {{false}} only the subtree below {{oDomRef}} will be searched
     * @return {HTMLElement} the previous tabbable element or null if no element is found.
     * @private
     */
    UCF_DomUtil["oGetTabbableElementBackward"] = function (oDomRef, bAscending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTabbableElementBackward"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "DomUtil.js(2980): oGetTabbableElementBackward");
        }
        ;

        var oResult;

        while (oDomRef) {
            if (oDomRef["nodeType"] === 1 /* === Node.ELEMENT_NODE */) {
                if (oDomRef["lastChild"]) {
                    oResult = UCF_DomUtil["oGetTabbableElementBackward"](oDomRef["lastChild"], false);
                }

                if (oResult) {
                    return oResult;
                }

                if (UCF_DomUtil["bHasTabIndex"](oDomRef) && oDomRef["offsetParent"]) {
                    return oDomRef;
                }
            }

            if (!bAscending) {
                oDomRef = oDomRef["previousSibling"];
            } else {
                // In opposite to the forward function we need to check the parent chain for tabbable elements when traversing backwards
                while (oDomRef) {
                    // CSN 1680045765: selecting oDomRef.parentNode traverses the DOM
                    // all the way up to <!doctype> if there is no backward tabbable
                    // element => stop traversing at the <body> tag
                    if (oDomRef["nodeName"]["toLowerCase"]() === 'body') {
                        return null;
                    }

                    if (oDomRef["previousSibling"]) {
                        oDomRef = oDomRef["previousSibling"];
                        break;
                    } else if (oDomRef["parentNode"]) {
                        if (UCF_DomUtil["bHasTabIndex"](oDomRef["parentNode"]) && oDomRef["parentNode"]["offsetParent"]) {
                            return oDomRef["parentNode"];
                        }
                        oDomRef = oDomRef["parentNode"];
                    }
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTabbableElementBackward"] = 0;
    }
    ;

    /**
     * Returns the next sibling of a given DOM element
     * @param {Element} oDomRef The DOM element
     * @param {boolean} [bAscending=false] `true` to search up in the DOM tree
     * @return {Element} The next sibling of a given DOM element
     * @private
     */
    UCF_DomUtil["oGetNextSibling"] = function (oDomRef, bAscending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetNextSibling"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(3035): oGetNextSibling");
        }
        ;

        if (!bAscending) return oDomRef["nextSibling"];

        while (oDomRef != null) {
            if (oDomRef["nextSibling"]) return oDomRef["nextSibling"];
            oDomRef = oDomRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetNextSibling"] = 0;
    }
    ;

    /**
     * Retunrs the previous sibling of a given DOM element
     * @param {Element} oDomRef The DOM element
     * @param {boolean} [bAscending=false] `true` to search up in the DOM tree
     * @return {Element} The previous sibling of a given DOM element
     * @private
     */
    UCF_DomUtil["oGetPreviousSibling"] = function (oDomRef, bAscending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetPreviousSibling"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(3055): oGetPreviousSibling");
        }
        ;

        if (!bAscending) return oDomRef["previousSibling"];

        while (oDomRef != null) {
            if (oDomRef["previousSibling"]) return oDomRef["previousSibling"];
            oDomRef = oDomRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetPreviousSibling"] = 0;
    }
    ;

    /**
     * Removes the caret from the given DOM element
     * @param {Element} oDomRef The DOM element
     * @private
     */
    UCF_DomUtil["removeCaret"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeCaret"]++;
        }
        ;
        if (!oDomRef) return;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(3074): removeCaret");
        }
        ;
        try {
            if (document["selection"]) {
                if (oDomRef) {
                    if (oDomRef["tagName"] === "INPUT") {
                        try {
                            document["selection"]["empty"]();
                        } catch (e) {
                            //nice try!
                        }
                    }
                }
            }
        } catch (ex) {

        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeCaret"] = 0;
    }
    ;

    /**
     * Returns the pixes size integer for a given css size
     * In case of percent values the inner size of the window is used.
     * @param {string} sSize The css value of a size (e.g. 4ex, 5em 78%)
     * @param {string} sFontSize the fontSize to use for the computation
     * @return {number} The pixel integer value for a given css size
     * @private
     */
    UCF_DomUtil["iConvertAnySizeToPixel"] = function (sSize, sFontSize) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iConvertAnySizeToPixel"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oDiv;
        /** @type {number} */
        var iPixelWidth;

        if (typeof sSize === 'string' && sSize["indexOf"]('%') > 0) {
            // eslint-disable-next-line no-magic-numbers
            return UCF_DomUtil["oGetInnerSize"](window)["width"] * parseInt(sSize) / 100;
        }

        oDiv = document["createElement"]('div');
        UCF_DomUtil["setStyle"](oDiv, UCF_JsUtil["extend"]({
            "position": 'absolute',
            "left": '0px',
            "top": '-5000px',
            // only work with width (CSS) because IE doesn't calculate height correctly
            "width": sSize
        }, sFontSize ? {"fontSize": sFontSize} : {}));

        UCF_DomUtil["prepend"](document["body"], oDiv);

        iPixelWidth = oDiv["scrollWidth"];

        UCF_DomUtil["removeFromDom"](oDiv);

        return parseInt(iPixelWidth);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iConvertAnySizeToPixel"] = 0;
    }
    ;

    /**
     * Checks whether the attribute of a DOM element is not empty
     * @param {Element} oRef The DOM element
     * @param {string} sAttributeName The name of the attribute to check
     * @return {boolean} true if the attribute is not empty for the oRef
     * @private
     */
    UCF_DomUtil["bNotEmpty"] = function (oRef, sAttributeName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bNotEmpty"]++;
        }
        ;
        try {
            if (oRef["nodeType"] === 1) {
                if (typeof (oRef["getAttribute"](sAttributeName)) !== 'undefined'
                    && oRef["getAttribute"](sAttributeName) !== ""
                    && oRef["getAttribute"](sAttributeName) != null
                ) {
                    return true;
                } else {
                    return false;
                }
            }
        } catch (e) {
        } // suppress any errors
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bNotEmpty"] = 0;
    }
    ;

    /**
     * @param {Element} oDomRef the element to get aria info for
     * @return {string} the aria info
     * @private
     */
    UCF_DomUtil["sGetARIAInfo"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetARIAInfo"]++;
        }
        ;
        var sStatic = "";
        var SEP = " - ";

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "DomUtil.js(3160): sGetARIAInfo");
        }
        ;

        if (oDomRef && oDomRef["nodeType"] === 1) {
            var el = oDomRef;

            // add always role first
            if (el["attributes"] && el["attributes"]["length"] > 0) {
                for (var i = 0; i < el["attributes"]["length"]; i++) {
                    if (el["attributes"][i]["name"]["indexOf"]("role") !== -1) {
                        sStatic = el["attributes"][i]["value"]["toUpperCase"]();
                        break;
                    }
                }
            }

            // if no role has been assigned, must be native HTML element
            if (sStatic === "") sStatic = "[" + el["nodeName"] + "]";

            // scan for states + properties, skip empty (default) values
            if (el["attributes"] && el["attributes"]["length"] > 0) {
                for (var j = 0; j < el["attributes"]["length"]; j++) {
                    //NOTE: this filter only works in IE Quirks mode, in Standard mode you ALWAYS get ALL boolean property strings
                    if (el["attributes"][j]["name"]["indexOf"]("aria") !== -1) {
                        if (UCF_DomUtil["bNotEmpty"](el, el["attributes"][j]["name"])) {
                            if (el["attributes"][j]["name"]["indexOf"]("labelledby") !== -1) {
                                var labelled_ids = new Array();
                                var txt1 = "";
                                labelled_ids = (el["getAttribute"](el["attributes"][j]["name"]))["toString"]()["split"](' ');
                                for (var k = 0; k < labelled_ids["length"]; k++) {
                                    //_trace(INFO, "labelled_ids = " + (UCF_DomUtil.$(labelled_ids[k])).innerHTML);
                                    var obj1 = UCF_DomUtil["$"](labelled_ids[k]);
                                    if (obj1 != null && UCF_DomUtil["sGetInnerText"](obj1) !== "") txt1 += UCF_DomUtil["sGetInnerText"](obj1) + " ";
                                }
                                if (txt1 !== "" && txt1 !== " ") sStatic += SEP + "|" + UCF_StringUtil["sTrim"](txt1) + "|";
                            } else if (el["attributes"][j]["name"]["indexOf"]("describedby") !== -1) {
                                var described_ids = new Array();
                                var txt2 = "";
                                described_ids = (el["getAttribute"](el["attributes"][j]["name"]))["toString"]()["split"](' ');
                                for (var l = 0; l < described_ids["length"]; l++) {
                                    var obj2 = UCF_DomUtil["$"](described_ids[l]);
                                    if (obj2 != null && UCF_DomUtil["sGetInnerText"](obj2) !== "") txt2 += UCF_DomUtil["sGetInnerText"](obj2) + " ";
                                }
                                if (txt2 !== "" && txt2 !== " ") sStatic += SEP + "{" + UCF_StringUtil["sTrim"](txt2) + "}";
                            } else {
                                sStatic += SEP + el["attributes"][j]["name"]["substr"]('aria-'["length"]) + "=" + el["attributes"][j]["value"];
                            }
                        }
                    }
                }
            }

            //finally, if title attribute is not empty, add it at the very end
            if (UCF_DomUtil["bNotEmpty"](el, "title")) sStatic += SEP + el["getAttribute"]("title");

        }
        return sStatic;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetARIAInfo"] = 0;
    }
    ;

    /**
     * Positioning of floating or layered elements in e.g. scrollable areas can be
     * achieved by
     * 1) nesting the element in the in the scrollable area itself or
     * 2) nesting the element in the most top container and then recalculating the
     *    position with every scroll event occurred in the page
     *
     * In approach 1) the element will be truncated by its containers. In approach
     * 2) the floating element can overlap. Approach 1) is faster than approach 2).
     *
     * Use this method for applying layered elements in such containers regardless
     * if you chose 1) or 2). It checks if a reference container (e.g. a scroll,
     * absolute, relative container) is involved
     * - if true it creates lazy a collector container to avoid layout conflicts
     * - if false it uses the passed top layered container as fallback
     * It sets the necessary HTML attributes of the passed layered element and adds
     * it to the calculated container
     *
     * @private
     * @param {Element} oDomRefLayered The reference to the HTML element which is
     * used as layered element
     * @param {Element} oDomRefTopLayerArea The reference to a common static area
     * which is used as fallback when no scroll area is used
     * @param {Element} [oDomRefReferenceContainer] The reference container to
     * which the positioning is calculated from
     * @param {boolean} [bInitialSize] Whether the layered DIV needs to
     * get an initial width/height
     * @return {Element} The reference to the DOM node which is actually used to
     * nest the layered element
     */
    UCF_DomUtil["oAddLayeredElement"] = function (oDomRefLayered, oDomRefTopLayerArea, oDomRefReferenceContainer, bInitialSize) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oAddLayeredElement"]++;
        }
        ;
        /** @type {Element} */
        var oAddTo;
        /** @type {HTMLDivElement} */
        var oInsertAfter;
        /** @type {HTMLDivElement} */
        var oDummyContent;

        if (oDomRefReferenceContainer) {
            oInsertAfter = null;
            oAddTo = UCF_DomUtil["oGetFirstElement"](oDomRefReferenceContainer);

            while (oAddTo
                && UCF_DomUtil["sGetCurrentStyle"](oAddTo, "position") === "absolute"
                ) {
                oInsertAfter = oAddTo;
                oAddTo = UCF_DomUtil["nextSibling"](oAddTo);
            }

            if (!oAddTo || !oAddTo["bIsCollectorContainer"]) {
                oAddTo = document["createElement"]("div");
                UCF_DomUtil["setStyle"](oAddTo, {
                    "height": '0',
                    "width": UCF_DomUtil["bIsRTL"] ? '100%' : '0',
                    "position": 'relative'
                });
                oAddTo["bIsCollectorContainer"] = true;
                UCF_DomUtil["setClass"](oAddTo, "lsLayeredElement");

                // IE causes in a visual gap of collector container when added layeyered
                // element is removed again. It pushes to line height -> Create dummy
                // content which stays always in the collector container.
                if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
                    oDummyContent = document["createElement"]("div");

                    UCF_DomUtil["setStyle"](oDummyContent, {
                        "height": '0',
                        "width": '0',
                        "hidden": 'hidden',
                        "fontSize": '0.1pt',
                        "position": 'absolute'
                    });

                    UCF_DomUtil["append"](oAddTo, oDummyContent);
                }

                if (!UCF_DomUtil["oGetFirstChild"](oDomRefReferenceContainer)) {
                    // No children at all
                    UCF_DomUtil["append"](oDomRefReferenceContainer, oAddTo);
                } else {
                    if (oInsertAfter) {
                        if (UCF_DomUtil["oGetLastChild"](oDomRefReferenceContainer) === oInsertAfter) {
                            UCF_DomUtil["append"](oDomRefReferenceContainer, oAddTo);
                        } else {
                            oDomRefReferenceContainer["insertBefore"](
                                oAddTo,
                                UCF_DomUtil["oGetNextSibling"](oInsertAfter)
                            );
                        }
                    } else {
                        // set at first position when oInsertAfter==null
                        oDomRefReferenceContainer["insertBefore"](
                            oAddTo,
                            UCF_DomUtil["oGetFirstChild"](oDomRefReferenceContainer)
                        );
                    }
                }

                // If the collector container is in a scrolled container in RTL mode the
                // position of the relative element is set relative to the outer
                // boundaries instead of inner content. This IE bug is corrected here.
                // Update that when the container width has changed
                if (
                    window["UCF_System"]["sDevice"] === "ie6" &&
                    window["UCF_System"]["bIsRTL"] &&
                    (oDomRefReferenceContainer["scrollLeft"] || UCF_DomUtil["sGetCurrentStyle"](oDomRefReferenceContainer, "overflowX") !== "visible")
                ) {
                    if (!oAddTo["iLsLastWidth"] || oAddTo["iLsLastWidth"] !== oDomRefReferenceContainer["offsetWidth"]) {
                        oAddTo["iLsLastWidth"] = oDomRefReferenceContainer["offsetWidth"];
                        oAddTo["style"]["left"] = 0;
                        oAddTo["style"]["left"] = -(oDomRefReferenceContainer["scrollWidth"] - oDomRefReferenceContainer["clientWidth"]) + "px";
                    }
                }
            }
        } else if (oDomRefTopLayerArea) {
            oAddTo = oDomRefTopLayerArea;
        }

        if (oDomRefLayered && oAddTo) {
            UCF_DomUtil["setStyle"](oDomRefLayered, UCF_JsUtil["extend"]({
                "top": '-10000px',
                "position": 'absolute'
            }, bInitialSize ? {"height": '1px', "width": '1px'} : {}));

            UCF_DomUtil["append"](oAddTo, oDomRefLayered);
        }

        return oAddTo;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oAddLayeredElement"] = 0;
    }
    ;

    /**
     * Returns the screen width
     * @return {number} the screen width
     * @private
     */
    UCF_DomUtil["iScreenWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iScreenWidth"]++;
        }
        ;
        return Math["max"](0, screen["width"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iScreenWidth"] = 0;
    }
    ;

    /**
     * Returns the screen height
     * @return {number} the screen height
     * @private
     */
    UCF_DomUtil["iScreenHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iScreenHeight"]++;
        }
        ;
        return Math["max"](0, screen["height"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iScreenHeight"] = 0;
    }
    ;

    /**
     * Returns the screen orientation
     * @return {string} The screen orientation
     * @private
     */
    UCF_DomUtil["sScreenOrientation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sScreenOrientation"]++;
        }
        ;
        if ("orientation" in window) {
            switch (window["orientation"]) {
                case 0:
                case 180:
                case -180:
                    return "portrait";
            }
        }
        ;

        return "landscape";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sScreenOrientation"] = 0;
    }
    ;

    /**
     * Returns the client width of a given window or the client width of window
     * when no window has been passed
     * @param {Window} [oWindow=window] the window to get the client width from
     * @return {number} the window's client width
     * @private
     */

    UCF_DomUtil["iClientWidth"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iClientWidth"]++;
        }
        ;
        oWindow = oWindow || window;

        return oWindow["document"]["body"]["clientWidth"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iClientWidth"] = 0;
    }
    ;

    /**
     * Returns the client height of a given window or the client height of window
     * when no window has been passed
     * @param {Window} [oWindow=window] the window to get the client height from
     * @return {number} the window's client height
     * @private
     */
    UCF_DomUtil["iClientHeight"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iClientHeight"]++;
        }
        ;
        oWindow = oWindow || window;

        return oWindow["document"]["body"]["clientHeight"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iClientHeight"] = 0;
    }
    ;

    /**
     * Returns the current zoom-factor of the body or null.
     * Currently supports only iOS Safari and Android.
     * @return {number|null} The zoom factor in % or null if platform is not iOS or Android
     */
    UCF_DomUtil["iGetBodyZoom"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetBodyZoom"]++;
        }
        ;
        if (UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsSafari"]()) {
            return window["document"]["documentElement"]["clientWidth"] / window["innerWidth"] * 100;
        } else if (UCF_UserAgent["bIsAndroid"]()) {
            return window["visualViewport"]["scale"] * 100;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetBodyZoom"] = 0;
    }
    ;

    /**
     * Returns the scroll width of a given window or the scroll width of window
     * when no window has been passed
     * @param {Window} [oWindow=window] the window to get the scrollwidth from
     * @return {number} the window's scroll width
     * @private
     */
    UCF_DomUtil["iWindowScrollWidth"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iWindowScrollWidth"]++;
        }
        ;
        oWindow = oWindow || window;

        return oWindow["document"]["body"]["scrollWidth"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iWindowScrollWidth"] = 0;
    }
    ;

    /**
     * Returns the scroll size of a given window or the scroll size of window
     * when no window has been passed
     * @param {Object} oWindow The window object
     * @return {{width: number, height: number}} the window's scroll size
     *
     * @private
     */
    UCF_DomUtil["oScrollSize"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oScrollSize"]++;
        }
        ;
        oWindow = oWindow || window;

        if (oWindow["document"]["body"]["scrollHeight"] > oWindow["document"]["body"]["offsetHeight"])
            return {
                "width": oWindow["document"]["body"]["scrollWidth"],
                "height": oWindow["document"]["body"]["scrollHeight"]
            };
        else
            return {
                "width": oWindow["document"]["body"]["offsetWidth"],
                "height": oWindow["document"]["body"]["offsetHeight"]
            };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oScrollSize"] = 0;
    }
    ;

// ===== Functions to correct HTML tables in IE9 Standards Mode ===============

    /**
     * Checks if IE9 and higher runs ins standards mode
     * @return {boolean} true if IE9 and higher runs ins standards mode
     * @private
     */
    UCF_DomUtil["bCheckStandardsCorrection"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bCheckStandardsCorrection"]++;
        }
        ;
        // eslint-disable-next-line no-magic-numbers
        return document["documentMode"] && parseInt(document["documentMode"]) >= 8 && parseInt(document["documentMode"]) <= 10
            && UCF_UserAgent["bIsStandardsMode"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bCheckStandardsCorrection"] = 0;
    }
    ;

    /**
     * Checks if browser and table are configured in a way that the correction is necessary
     * and prepares the table for furher processing
     * @param {Element} oTable HTML table element
     * @private
     */
    UCF_DomUtil["initHtmlTableCorrection"] = function (oTable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["initHtmlTableCorrection"]++;
        }
        ;

        if (oTable && UCF_DomUtil["bCheckStandardsCorrection"]()) {

            /* PROCEDURES
		 * P1: Analyze the row heights for fixed and non fixed heights and set the table heigt to a derived % value
		 *   to compensate calculation error
		 * P2: Analyze the row heights for fixed and non fixed heights and set the table heigt to a derived fixed px value
		 *   to compensate calculation error
		 */

            var sCorrProcedure = "",
                bNeedsResizeHandling = false,
                bForceCorrection = false,
                sTableHeight = oTable["currentStyle"]["height"],
                iTableAdd = 0,
                iRelatedParentAdd = 0,
                oRelatedParent = UCF_DomUtil["oGetHtmlTableCorrectionRelatedParent"](oTable),
                iRelatedParentHeight = 0,
                sRelatedParentHeight = null;

            oTable["removeAttribute"]("lsTableCorrProcedure");
            oTable["removeAttribute"]("lsTableCorrAdd");
            oTable["removeAttribute"]("lsTableCorrParentAdd");

            if (oRelatedParent) { // Determine the parent which defines the target height
                iRelatedParentHeight = oRelatedParent["clientHeight"];
                sRelatedParentHeight = oRelatedParent["currentStyle"]["height"];
            }

            if (sTableHeight) { //Has set height
                var bRelatedParentHeightFixed = sRelatedParentHeight["indexOf"]("%") === -1,
                    bTableHeightFixed = sTableHeight["indexOf"]("%") === -1;

                //Need Resize handler when dimension is flexible
                bNeedsResizeHandling = !bTableHeightFixed;

                bForceCorrection = bTableHeightFixed || (!bTableHeightFixed && bRelatedParentHeightFixed);

                if (bTableHeightFixed) { //Fixed height
                    sCorrProcedure = "P2"; //Table has % and fixed rows while having fixed height set -> use procedure 2
                } else if (sRelatedParentHeight) { //Percentage height in combination with a set parent height
                    sCorrProcedure = "P1"; //Table has % and fixed rows while having % height set -> use procedure 1
                }
            } // else No height set -> no correction necessary

            if (sCorrProcedure) { //First Processing -> analyze and prepare HTML table
                var aRows = oTable["rows"],
                    oRow = null,
                    aCells = null,
                    oReferenceCell = null,
                    bHasFixedRows = false,
                    iROF = 0 /*Rest Of Fragment*/,
                    bHasPercentContent = false,
                    sCellSpacing = oTable["getAttribute"]("cellspacing");

                if (sCellSpacing) iTableAdd += parseInt(sCellSpacing) * (aRows["length"] + 1);

                if (oRelatedParent) {
                    var oDomRef = oTable["parentNode"];

                    // The target height has to be minimized by all gaps in between related parent and table
                    // This static gap is reflected in the "lsTableCorrAdd" attribute on the table element
                    while (oDomRef) {
                        iRelatedParentAdd -= UCF_DomUtil["iGetHtmlTableCorrectionHeightOffset"](oDomRef);

                        if (oDomRef === oRelatedParent) break;
                        oDomRef = oDomRef["parentNode"];
                    }
                }

                for (var iRowIndex = 0; iRowIndex < aRows["length"]; iRowIndex++) {
                    oRow = aRows[iRowIndex];
                    aCells = oRow["cells"];

                    for (var iCellIndex = 0; iCellIndex < aCells["length"]; iCellIndex++) {
                        oReferenceCell = aCells[iCellIndex];
                        if (oReferenceCell["firstChild"]) break;
                    }

                    oRow["removeAttribute"]("lsTableCorrROF");
                    oRow["removeAttribute"]("lsTableCorrAdd");

                    if (oRow["currentStyle"]["height"]["indexOf"]("%") !== -1) iROF = parseInt(oRow["currentStyle"]["height"]);
                    else if (oReferenceCell["currentStyle"]["height"]["indexOf"]("%") !== -1) iROF = parseInt(oReferenceCell["currentStyle"]["height"]);
                    else iROF = 0;

                    if (iROF) {
                        var oContent = UCF_DomUtil["oGetFirstElement"](oReferenceCell);

                        if (oContent && oContent["currentStyle"]["height"] === "100%") { //Only when a 100% height content is nested the effect can be seen
                            // eslint-disable-next-line no-magic-numbers
                            var iAdd = (iRelatedParentHeight > 500) ? 4 : 0;

                            bHasPercentContent = true;

                            //Add padding. In IE only block elements push padding
                            if (oContent["currentStyle"]["display"] !== "inline") iAdd += UCF_DomUtil["iGetHtmlTableCorrectionHeightOffset"](oReferenceCell);

                            oRow["setAttribute"]("lsTableCorrROF", iROF);
                            oRow["setAttribute"]("lsTableCorrAdd", iAdd);
                        }
                    } else bHasFixedRows = true;
                }

                // No procedure necessary because every row is defined in %
                if (!bHasFixedRows || !bHasPercentContent) sCorrProcedure = "";
            }

            oTable["setAttribute"]("lsTableCorrProcedure", sCorrProcedure);
            oTable["setAttribute"]("lsTableCorrAdd", iTableAdd);
            oTable["setAttribute"]("lsTableCorrParentAdd", iRelatedParentAdd);

            if (sCorrProcedure) { //attach and execute correction procedure
                UCF_DomUtil["updateHtmlTableCorrection"](oTable, bForceCorrection);

                if (bNeedsResizeHandling) {
                    //Unfortunatelly in IE9 the resize events are not fired properly -> therfore additionally add the handler on parent
                    //see I-3817034 2012
                    UCF_DomUtil["attachEvent"](oTable, "resize", UCF_DomUtil["fGetHtmlTableCorrectionHandler"](oTable));

                    if (oRelatedParent) {
                        UCF_DomUtil["attachEvent"](oRelatedParent, "resize", UCF_DomUtil["fGetHtmlTableCorrectionHandler"](oTable));

                        /* This section would avoid overlays and some unnecessary scollbars.
					 * Unfortunatelly we were forced th remove this section because the pushing of content in the
					 * F4 PopupWindow is prevented I-1248005 2013
					 * If this section becomes again relevant we have to provide a solution for the F4 help popup

					if (UCF_DomUtil.sGetCurrentStyle(oRelatedParent, "overflowY") == "visible" && UCF_DomUtil.sGetCurrentStyle(oRelatedParent, "overflow") == "visible") {
						// Rumpfuschen in DOM as last chance
						oRelatedParent.style.overflowY = "hidden";
					}

					*/
                    }

                }
            }

        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["initHtmlTableCorrection"] = 0;
    }
    ;

    /**
     * Retunrs the correction height offset
     * @param {Element} oDomRef the element
     * @return {number} the height offset correction
     * @private
     */
    UCF_DomUtil["iGetHtmlTableCorrectionHeightOffset"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetHtmlTableCorrectionHeightOffset"]++;
        }
        ;
        var iOffset = 0,
            oStyle = oDomRef["currentStyle"];

        //Todo support also non-PX padding
        if (oStyle["paddingTop"]) iOffset += parseInt(oStyle["paddingTop"]);
        if (oStyle["paddingBottom"]) iOffset += parseInt(oStyle["paddingBottom"]);
        //TODO what about border?

        return iOffset;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetHtmlTableCorrectionHeightOffset"] = 0;
    }
    ;

    /**
     * Find related container which defines the wanted height. Table elements are influenced by the table to be corrected.
     * Therefore we need to skip them
     * @param {Element} oTable HTML table element
     * @return {Element} null or the DOM reference of the related element
     * @private
     */
    UCF_DomUtil["oGetHtmlTableCorrectionRelatedParent"] = function (oTable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetHtmlTableCorrectionRelatedParent"]++;
        }
        ;
        var oRelatedParent = oTable["parentNode"];

        while (oRelatedParent
        && oRelatedParent !== document["body"]
        && oRelatedParent["tagName"]["charAt"](0) === "T" /*TD, TH, TR, TBODY, TABLE, ?*/
            ) {
            oRelatedParent = oRelatedParent["parentNode"];
        }

        return oRelatedParent;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetHtmlTableCorrectionRelatedParent"] = 0;
    }
    ;

    /**
     * Returns a closure for a resize handler
     *
     * @param {Element} oTarget the element
     * @return {function} a reference to a function
     * @private
     */
    UCF_DomUtil["fGetHtmlTableCorrectionHandler"] = function (oTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["fGetHtmlTableCorrectionHandler"]++;
        }
        ;
        var fHandler = function () {
            if (UCF_DomUtil["bIsInActiveDom"](oTarget)) {
                UCF_DomUtil["updateHtmlTableCorrection"](oTarget, false);
            } else {
                //CleanUp closure when there is an inactive element refered
                UCF_DomUtil["detachEvent"](window["event"]["srcElement"], "resize", fHandler);
                fHandler = null;
                oTarget = null;
            }
        };

        return fHandler;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["fGetHtmlTableCorrectionHandler"] = 0;
    }
    ;

    /**
     * The method which is called on resize to correct the table dimensions if
     * necessary
     * @param {HTMLTableElement} oTable the table
     * @param {boolean} bForceCorrection If true do not use threshold to reduce
     * execution steps (performance)
     * @private
     */
    UCF_DomUtil["updateHtmlTableCorrection"] = function (oTable, bForceCorrection) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["updateHtmlTableCorrection"]++;
        }
        ;
        var iTableHeight = oTable["offsetHeight"],
            iRelatedParentHeight = iTableHeight,
            oRelatedParent = UCF_DomUtil["oGetHtmlTableCorrectionRelatedParent"](oTable),
            sCorrProcedure = oTable["getAttribute"]("lsTableCorrProcedure");

        if (!iTableHeight && !UCF_DomUtil["bIsVisible"](oTable, true)) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, "HTML table correction algorithm for IE bug does not support \"display=none\" content. Skipping correction.", "DomUtil.js(3699): updateHtmlTableCorrection");
            }
            ;
            return;
        }

        if (oRelatedParent) {
            iRelatedParentHeight = oRelatedParent["clientHeight"] + parseInt(oTable["getAttribute"]("lsTableCorrParentAdd"));
        }

        // eslint-disable-next-line no-magic-numbers
        if (bForceCorrection || Math["abs"](iTableHeight - iRelatedParentHeight) > 5 || iTableHeight > iRelatedParentHeight) { //Is correction necessary?
            var aRows = oTable["rows"],
                oRow = null,
                iFixHeight = parseInt(oTable["getAttribute"]("lsTableCorrAdd"));

            for (var i = 0; i < aRows["length"]; i++) {
                oRow = aRows[i];

                iFixHeight += (oRow["getAttribute"]("lsTableCorrROF") ?
                    parseInt(oRow["getAttribute"]("lsTableCorrAdd")) :
                    oRow["offsetHeight"]);
            }

            if (sCorrProcedure === "P1") { //Correction for procedure P1
                // eslint-disable-next-line no-magic-numbers
                oTable["style"]["height"] = Math["max"](2, Math["floor"](((iRelatedParentHeight - iFixHeight) * 100 / iRelatedParentHeight))) + "%";
            } else if (sCorrProcedure === "P2") { //Correction for procedure P2
                var sCssTableHeight = oTable["currentStyle"]["height"],
                    // eslint-disable-next-line no-magic-numbers
                    sUnit = sCssTableHeight["substring"](sCssTableHeight["length"] - 2),
                    fCorrectedValue = parseFloat(sCssTableHeight) * (1.0 - ((iTableHeight / (iTableHeight - iFixHeight)) - 1.0));

                if (sUnit === "px") {
                    // eslint-disable-next-line no-magic-numbers
                    oTable["style"]["height"] = Math["max"](10, Math["floor"](fCorrectedValue)) + sUnit;
                } else {
                    oTable["style"]["height"] = fCorrectedValue + sUnit;
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["updateHtmlTableCorrection"] = 0;
    }
    ;

    /**
     * Returns the dimension of a text, based on a given class or the browsers
     * default font size;
     * @param {string} sText The text to measure
     * @param {string} sClassName The class name to apply
     * @return {{width: number, height: number}} The pixel height and width of the
     * text
     * @private
     */
    UCF_DomUtil["oGetTextSize"] = function (sText, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTextSize"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oSpan = document["createElement"]("span");
        /** @type {number} */
        var iHeight;
        /** @type {number} */
        var iWidth;

        UCF_DomUtil["setClass"](oSpan, sClassName);
        UCF_DomUtil["setStyle"](oSpan, {
            "border": 'none',
            "padding": '0',
            "width": 'auto',
            "position": 'absolute',
            "top": '-1000'
        });
        UCF_DomUtil["setInnerText"](oSpan, sText);

        UCF_DomUtil["prepend"](document["body"], oSpan);

        iHeight = oSpan["clientHeight"];
        iWidth = oSpan["clientWidth"];

        UCF_DomUtil["removeFromDom"](oSpan);
        oSpan = null;

        return {
            "width": iWidth,
            "height": iHeight
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTextSize"] = 0;
    }
    ;

// eslint-disable-next-line jsdoc/check-param-names
    /**
     * @example
     * ```javascript
     * UCF_DomUtil.sCreateTooltipText('a title')
     * // => 'a title'
     * UCF_DomUtil.sCreateTooltipText('a title', 'a tooltip')
     * // => 'a title - a tooltip'
     * UCF_DomUtil.sCreateTooltipText(false, 'a tooltip')
     * // => 'a tooltip'
     * UCF_DomUtil.sCreateTooltipText('a title', false, 'something', 'else', false, 'and', false', 'more')
     * // => 'a title - something - else - and - more'
     * ```
     * aSections list of sections for the tooltip text
     * @return {string} the text for a tooltip
     */
    UCF_DomUtil["sCreateTooltipText"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sCreateTooltipText"]++;
        }
        ;
        return UCF_JsUtil["filter"](UCF_JsUtil["arrayFrom"](arguments), function (s) {
            return s;
        })["join"](' - ');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sCreateTooltipText"] = 0;
    }
    ;

    /**
     * Checks if the given oDomRef has ellipsis and set the text as tooltip
     *
     * @param {HTMLElement} oDomRef the domRef of an HTML element for the current style
     * @param {string} sTooltip the tooltip
     * @param {HTMLElement} oDomRefOvfl the overflow domref
     * @param {string} [sControlText] the control text
     * @private
     */
    UCF_DomUtil["checkTooltip"] = function (oDomRef, sTooltip, oDomRefOvfl, sControlText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["checkTooltip"]++;
        }
        ;
        /** @type {{sDomRef: string, sDomRefOvfl: string}} */
        var oTooltip = UCF_DomUtil["oGetTooltip"](oDomRef, sTooltip, oDomRefOvfl, sControlText);

        if ('sDomRef' in oTooltip) {
            UCF_DomUtil["setTooltip"](oDomRef, oTooltip["sDomRef"]);
        }
        if ('sDomRefOvfl' in oTooltip) {
            UCF_DomUtil["setTooltip"](oDomRefOvfl, oTooltip["sDomRefOvfl"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["checkTooltip"] = 0;
    }
    ;

    /**
     * @return {{sDomRef: string, sDomRefOvfl: string}}
     * @param {HTMLElement} oDomRef the dom element
     * @param {string} sTooltip the tooltip
     * @param {HTMLElement} oDomRefOvfl the overflow element
     * @param {string} [sControlText] the control text
     */
    UCF_DomUtil["oGetTooltip"] = function (oDomRef, sTooltip, oDomRefOvfl, sControlText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oGetTooltip"]++;
        }
        ;
        /** @type {string} */
        var sText;
        var oTooltip = {};

        if (oDomRef) {
            if (oDomRefOvfl) {
                // oDomRef.clientWidth returns always 0 in FF, so I'm using offsetwidth
                //if (oDomRefOvfl.scrollWidth > oDomRefOvfl.clientWidth ||  oDomRef.scrollWidth > oDomRef.offsetWidth) {
                // IE has sometimes the difference from 1px
                if (oDomRefOvfl["offsetWidth"] > oDomRef["offsetWidth"]
                    || Math["floor"](oDomRef["scrollWidth"] - oDomRef["offsetWidth"]) > 1
                    || Math["floor"](oDomRefOvfl["scrollWidth"] - oDomRefOvfl["offsetWidth"]) > 1) {
                    sText = (!sControlText ? UCF_DomUtil["removeColon"](UCF_DomUtil["sGetInnerText"](oDomRefOvfl)) : sControlText);

                    // if no text is set then no tooltip is set
                    if (sText !== '' && sText !== UCF_StringUtil["sTrim"](sTooltip)) {
                        oTooltip["sDomRef"] = UCF_DomUtil["sCreateTooltipText"](sText, sTooltip);
                        oTooltip["sDomRefOvfl"] = UCF_DomUtil["sCreateTooltipText"](sText, sTooltip);
                    }
                } else {
                    oTooltip["sDomRef"] = UCF_DomUtil["sCreateTooltipText"](sTooltip);
                    oTooltip["sDomRefOvfl"] = UCF_DomUtil["sCreateTooltipText"](sTooltip);
                }
            } else {
                //search the parent dom
                var oParentDomRef = UCF_DomUtil["oGetParentByAttribute"](oDomRef, "ctv", "C"),
                    oDirectParentDomRef = oDomRef["parentNode"],
                    oRootDomRef = UCF_DomUtil["$"](oDomRef["id"] + '-r'),
                    bHasEllipsis = false;
                // direct parent should not be its root
                if (oRootDomRef && oDirectParentDomRef === oRootDomRef) {
                    oDirectParentDomRef = oRootDomRef["parentNode"];
                }
                var bIsDirectParent = (oParentDomRef === oDirectParentDomRef);
                var bIsIEBrowser = (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]());
                if (oParentDomRef) {
                    if (__UCF_IE6__) {
                        // The Quirks mode checking is ignored, if the ellipsis are not by the
                        // direct parent required
                        var iItemWidth = oDomRef["offsetWidth"],
                            iRightPadding = parseInt(UCF_DomUtil["sGetCurrentStyle"](oParentDomRef, "padding-right")),
                            iLeftPadding = parseInt(UCF_DomUtil["sGetCurrentStyle"](oParentDomRef, "padding-left")),
                            iPaddingSum = bIsDirectParent ? (window["UCF_System"]["bIsRTL"] ? 0 : oDomRef["offsetLeft"]) : ((!isNaN(iLeftPadding) ? iLeftPadding : 0) + (!isNaN(iRightPadding) ? iRightPadding : 0));

                        bHasEllipsis = ((oParentDomRef["scrollWidth"] - oParentDomRef["clientWidth"]) > 1) || ((oDomRef["scrollWidth"] - oDomRef["offsetWidth"]) > 1);
                        if (!bHasEllipsis) {
                            bHasEllipsis = (iItemWidth >= (oParentDomRef["clientWidth"] - iPaddingSum));
                        }
                    }
                    if (!__UCF_IE6__) {
                        iItemWidth = oDomRef["offsetWidth"];
                        if (bIsIEBrowser && (Math["abs"](oParentDomRef["scrollWidth"] - oParentDomRef["clientWidth"]) <= 1)) {
                            // In IE standards mode, The ellipsis are not included in the offsetWidth
                            var sOldDisplay = oDomRef["style"]["display"];
                            oDomRef["style"]["display"] = "inline-block";
                            iItemWidth = oDomRef["offsetWidth"];
                            oDomRef["style"]["display"] = sOldDisplay;
                        }
                        bHasEllipsis = ((oParentDomRef["scrollWidth"] - oParentDomRef["clientWidth"]) > 1)
                            || ((oDomRef["scrollWidth"] - oDomRef["offsetWidth"]) > 1)
                            || (bIsIEBrowser && oDomRef["offsetWidth"] < iItemWidth)
                            || (!bIsDirectParent && !bIsIEBrowser && ((oDirectParentDomRef["scrollWidth"] - oDirectParentDomRef["offsetWidth"]) > 1));
                    }

                    if (bHasEllipsis) {
                        sText = (!sControlText ? UCF_DomUtil["removeColon"](UCF_DomUtil["sGetInnerText"](oDomRef)) : sControlText);
                        if (sText !== UCF_StringUtil["sTrim"](sTooltip)) {
                            oTooltip["sDomRef"] = UCF_DomUtil["sCreateTooltipText"](sText, sTooltip);
                        }
                    } else {
                        oTooltip["sDomRef"] = UCF_DomUtil["sCreateTooltipText"](sTooltip);
                    }
                }
            }
        }

        return oTooltip;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oGetTooltip"] = 0;
    }
    ;

    /**
     * @return {{sDomRef: string, sDomRefOvfl: string}}
     * @param {HTMLElement} oDomRef the dom element
     * @param {HTMLElement} oDomRefOvfl the overflow element
     */
    UCF_DomUtil["bHasTextEllipsis"] = function (oDomRef, oDomRefOvfl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bHasTextEllipsis"]++;
        }
        ;
        /** @type {string} */
        var bHasTextEllipsis = false;

        if (oDomRef) {
            if (oDomRefOvfl) {
                // oDomRef.clientWidth returns always 0 in FF, so I'm using offsetwidth
                //if (oDomRefOvfl.scrollWidth > oDomRefOvfl.clientWidth ||  oDomRef.scrollWidth > oDomRef.offsetWidth) {
                if (oDomRefOvfl["offsetWidth"] > oDomRef["offsetWidth"]
                    || oDomRef["scrollWidth"] > oDomRef["offsetWidth"]
                    || Math["floor"](oDomRefOvfl["scrollWidth"] - oDomRefOvfl["offsetWidth"]) > 1) {
                    bHasTextEllipsis = true;
                } else {
                    bHasTextEllipsis = false;
                }
            } else {
                // Check te parentContainer
                var oParentDomRef = UCF_DomUtil["oGetParentByAttribute"](oDomRef, "ctv", "C");
                if (oParentDomRef) {
                    var iItemWidth = oDomRef["offsetWidth"],
                        iRightPadding = parseInt(UCF_DomUtil["sGetCurrentStyle"](oParentDomRef, "padding-right")),
                        iLeftPadding = parseInt(UCF_DomUtil["sGetCurrentStyle"](oParentDomRef, "padding-left")),
                        iPaddingSum = ((!isNaN(iLeftPadding) ? iLeftPadding : 0) + (!isNaN(iRightPadding) ? iRightPadding : 0));
                    if ((oParentDomRef["scrollWidth"] - oParentDomRef["clientWidth"]) > 1
                        || iItemWidth >= (oParentDomRef["clientWidth"] - iPaddingSum)) {
                        bHasTextEllipsis = true;
                    } else {
                        bHasTextEllipsis = false;
                    }
                }
            }
        }
        return bHasTextEllipsis;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bHasTextEllipsis"] = 0;
    }
    ;

    /**
     * Removes a colon and spaces
     * @param {string} sString Input
     * @return {string} Input but removed the colon.
     * @private
     */
    UCF_DomUtil["removeColon"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["removeColon"]++;
        }
        ;
        var sStringValue = sString;
        if (sStringValue != null && sStringValue !== "") {
            if (UCF_StringUtil["bEndsWith"](sStringValue, ":")) {
                return UCF_StringUtil["sTrim"](sStringValue["substring"](0, sStringValue["length"] - 1));
            }
        }
        return UCF_StringUtil["sTrim"](sStringValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["removeColon"] = 0;
    }
    ;

    /**
     * Set the Tooltip to the given domRef
     *
     * @param {Element} oDomRef the domRef of an HTML element for the current style
     * @param {string} sTooltip the tooltip
     * @private
     */
    UCF_DomUtil["setTooltip"] = function (oDomRef, sTooltip) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setTooltip"]++;
        }
        ;
        oDomRef["title"] = sTooltip;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setTooltip"] = 0;
    }
    ;

    /**
     * Set the text-align style property to the given domRef
     * for value matrix compare UrBase.renderer - UrBase_sTextAlign
     *
     * @param {Element} oDomRef  the domRef of an HTML element for the current style
     * @param {Element} sTextAlign  textAlign enumeration
     * @param {Element} sTextDirection  textDirection enumeration
     * @private
     */
    UCF_DomUtil["setTextAlign"] = function (oDomRef, sTextAlign, sTextDirection) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["setTextAlign"]++;
        }
        ;
        var mSystemDirection = {
                "LTR": 0,
                "RTL": 1

            },
            mTextAlignStates = {
                "FORCEDLEFT": [{"LTR": "left", "RTL": "left", "INHERIT": "left"}, {
                    "LTR": "left",
                    "RTL": "left",
                    "INHERIT": "left"
                }],
                "LEFT": [{"LTR": "left", "RTL": "right", "INHERIT": ""}, {"LTR": "", "RTL": "", "INHERIT": ""}],
                "CENTER": [{"LTR": "center", "RTL": "center", "INHERIT": "center"}, {
                    "LTR": "center",
                    "RTL": "center",
                    "INHERIT": "center"
                }],
                "RIGHT": [{"LTR": "right", "RTL": "right", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "",
                    "INHERIT": ""
                }],
                "ENDOFLINE": [{"LTR": "right", "RTL": "left", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "left",
                    "INHERIT": "left"
                }],
                "FORCEDRIGHT": [{"LTR": "right", "RTL": "right", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "right",
                    "INHERIT": "right"
                }],
                "BEGINOFLINE": [{"LTR": "left", "RTL": "right", "INHERIT": "left"}, {
                    "LTR": "left",
                    "RTL": "right",
                    "INHERIT": "right"
                }]
            },
            oTextAlignState = mTextAlignStates[sTextAlign],
            iLayoutDirection = UCF_DomUtil["bIsRTL"] ? mSystemDirection["RTL"] : mSystemDirection["LTR"],
            oTextAlignStateSD = oTextAlignState[iLayoutDirection],
            sTextAlignStyle = oTextAlignStateSD[sTextDirection];

        oDomRef["style"]["textAlign"] = sTextAlignStyle;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["setTextAlign"] = 0;
    }
    ;

    /**
     * CSS is implementing a style property "cursor" which provides the possibility to define a custom cursor file as an URI.
     * The URI is specified to be relative to the StyleSheet path. Unfortunately IE does this relative to the HTML document by default
     * while all other browsers are doing it like specified.
     * To simulate a CSS dependent custom cursor this  method has been implemented.
     * It extracts the CSS rule with the  cursor information from the style sheet, modifies its path and applies it to an dynamically created style tag.
     *
     * The control which uses the custom cursor has to apply the rule once for all instances.
     *
     * @param {string} sRuleName  the rule to be extrated and applied
     * @private
     */

    UCF_DomUtil["applyIECssCursorRule"] = function (sRuleName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["applyIECssCursorRule"]++;
        }
        ;
        /** @type {number} */
        var i;

        /**
         *  It turned out, that correction "UCF_Page.prototype.workaroundIE10StylesheetInIFrameBug" is not sufficient, as the issue
         *  described below is not only related to PopupWindows. The problem also occurs, when two applications, which are using the same style sheet,
         *  run in two parallel iFrames, which is very often the case in the Enterprise Portal. Hence there are only two options for a work-around:
         *  a) not to cache the stylesheet anymore
         *  b) remove the read access to 'document.styleSheets'
         *  It was decided to follow option b).
         *  Problem Description:
         *  If the same style sheet is used in several iFrames IE10 and IE11) has weird rendering problems (quirks and standards)
         *  when the stylesheet is read (DOM access). This happens as soon as a read access to 'document.styleSheet' happens (by JS
         *  or by the F12 tools).
         *  See also http://www.devexpress.com/Support/Center/Question/Details/Q526492
         * ***********************************************************************************************************************************
         *  Update: According to note 1985414 IE issue has been fixed in the meantime -> restriction for Trident(6) not needed anymore
         * ***********************************************************************************************************************************
         */

        //	if (UCF_UserAgent.bIsTrident(6)) {
        //		_trace( WARNING, "Skipped UCF_DomUtil.applyIECssCursorRule, see note 1985414");
        //		return;
        //	}

        if (sRuleName && UCF_UserAgent["bIsIE"]() && !UCF_DomUtil["mAppliedIECursorRules"][sRuleName]) {
            var oStyleSheet = null,
                sCssRuleText = null,
                sStyleSheetLocation = null,
                sTargetRuleName = sRuleName,
                aMatch = sTargetRuleName["match"](/^([\.\w_]+)_(ie6)_$/);

            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(START, "ApplyIECssCursorRule");
            }
            ;

            if (aMatch && aMatch["length"]) sTargetRuleName = aMatch[1];

            try {
                for (i = 0; i < document["styleSheets"]["length"]; i++) {
                    var aRules = null;

                    oStyleSheet = document["styleSheets"][i];
                    aRules = oStyleSheet["cssRules"] || oStyleSheet["rules"];

                    for (var j = 0; j < aRules["length"]; j++) { // Looping over rules is much faster than indexOf cssText
                        var oRule = aRules[j];

                        if (oRule["selectorText"] === sRuleName) {
                            sCssRuleText = " " + oRule["selectorText"] + "{" + oRule["style"]["cssText"] + "}";
                            break;
                        }
                    }

                    if (sCssRuleText) {
                        sStyleSheetLocation = oStyleSheet["href"]["substring"](0, oStyleSheet["href"]["lastIndexOf"]("/") + 1);
                        break;
                    }
                }

                if (sCssRuleText && sStyleSheetLocation) {
                    var sStyleId = "AppliedIECursorRules",
                        oDomRefLink = oStyleSheet["ownerNode"],
                        oDocument = null,
                        oDomRefStyle = null;

                    if (!oDomRefLink) { // Again a fallback for IE in Quirks when owner document is not available
                        var aDomRefLinks = document["getElementsByTagName"]("link");

                        for (i = 0; i < aDomRefLinks["length"]; i++) {
                            oDomRefLink = aDomRefLinks[i];
                            if (oDomRefLink["styleSheet"] === oStyleSheet) break;
                        }
                    }

                    oDocument = oDomRefLink["ownerDocument"];
                    oDomRefStyle = oDocument["getElementById"](sStyleId);

                    if (!oDomRefStyle) {
                        oDomRefStyle = oDocument["createElement"]("style");
                        oDomRefStyle["setAttribute"]("id", sStyleId);

                        if (oDomRefLink["nextSibling"]) {
                            oDomRefLink["parentNode"]["insertBefore"](
                                oDomRefStyle,
                                oDomRefLink["nextSibling"]
                            );
                        } else {
                            UCF_DomUtil["append"](oDomRefLink["parentNode"], oDomRefStyle);
                        }
                    }

                    if (sTargetRuleName !== sRuleName) sCssRuleText = sCssRuleText["replace"](sRuleName, sTargetRuleName);

                    if (oDomRefStyle["styleSheet"]) {
                        oDomRefStyle["styleSheet"]["cssText"] += sCssRuleText["replace"]("url(", "url(" + sStyleSheetLocation);
                    } else if (oDomRefStyle["sheet"]) {
                        oDomRefStyle["sheet"]["cssText"] += sCssRuleText["replace"]("url(", "url(" + sStyleSheetLocation);
                    }

                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(WARNING, "Applying IECursorRule failed. Did not find CSS rule: " + sRuleName, "DomUtil.js(4122): applyIECssCursorRule");
                    }
                    ;
                }

            } catch (oException) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, "Applying IECursorRule failed. " + oException, "DomUtil.js(4126): applyIECssCursorRule");
                }
                ;
            }

            UCF_DomUtil["mAppliedIECursorRules"][sRuleName] = true;

            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, "ApplyIECssCursorRule", sRuleName + " applied ");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["applyIECssCursorRule"] = 0;
    }
    ;
    UCF_DomUtil["mAppliedIECursorRules"] = {};

    /**
     * Returns a object url for a blob containing sHTML, falls back to a
     * javascript url that encodes sHTML and sets document.domain to the
     * correct value.
     *
     * @param {string} sHTML the HTML to be added to and iframe content as src.
     * @return {string} the src for the iframe
     * @private
     */
    UCF_DomUtil["sGetIframeJSSource"] = function (sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetIframeJSSource"]++;
        }
        ;
        /** @type {string} */
        var sDomain = (document["domain"] !== location["hostname"])
            ? document["domain"]
            : undefined;

        /** @return {string} javascript-based iframe src */
        function fallback() {
            return 'javascript:(function() {document.open();' +
                ((sDomain && sDomain["indexOf"](".") > -1 && !(/^(\d|\.)+$/["test"](sDomain))) ?
                    'document.domain="' + UCF_XSSEncoder["encodeJS"](sDomain) + '";' :
                    '') +
                'document.write("' + UCF_XSSEncoder["encodeJS"](sHTML) +
                '");document.close();if (window.frameElement) {window.frameElement.doc=document;}})(document)';
        }

        if (UCF_UserAgent["bIsIE"]()) {
            return fallback();
        }

        try {
            // TODO:
            // This caused issue in RichTextEdit: <base> tag must be  BEFORE the
            // relative <link> for out stylesheet. Find another way to prevent CSP
            // warning ins browsers in the LS testsuite
            // RTE: sBoilerplate = sHTML.replace('</head>', '<base href="' + sBase + '"/>' + sDomainrelax + '</head>');
            return URL["createObjectURL"](new Blob([(
                UCF_StringUtil["bContains"](sHTML, '<html><head>')
                    ? sHTML["replace"]('<html><head>', '<html><head><base href="' + location["protocol"] + '//' + location["host"] + '/"/>')
                    : sHTML
            ) + (
                sDomain
                    ? '<script nonce="' + window["UCF_System"]["sNonce"] + '">document.domain="' + sDomain + '"</script>'
                    : ''
            )
            ], {"type": 'text/html'}));
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, e, "DomUtil.js(4182): sGetIframeJSSource");
            }
            ;
            return fallback();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetIframeJSSource"] = 0;
    }
    ;

    /**
     * Checks whether DOM of the given document contains an 'active component' (e.g. Adobe PDF/Flash, Java Applet).
     * @param {HTMLDocument} [oDocument] Optional document reference. Default is window.document
     * @return {boolean} true if a tag was found that renders an active component.
     */
    UCF_DomUtil["bContainsActiveComponent"] = function (oDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["bContainsActiveComponent"]++;
        }
        ;
        var oDoc = oDocument || window["document"];
        return oDoc["getElementsByTagName"]("object")["length"] > 0 || oDoc["getElementsByTagName"]("embed")["length"] > 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["bContainsActiveComponent"] = 0;
    }
    ;

    /**
     * Convert a CSS rem value to px for the current window.document.documentElement
     * @param {number} iRem
     * @return {number} The px value
     */
    UCF_DomUtil["iRem2px"] = function (iRem) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iRem2px"]++;
        }
        ;
        UCF_DomUtil["sCachedDocumentFontSize"] =
            UCF_DomUtil["sCachedDocumentFontSize"] ||
            UCF_DomUtil["sGetCurrentStyle"](window["document"]["documentElement"], 'fontSize');
        return Math["round"](iRem * parseFloat(UCF_DomUtil["sCachedDocumentFontSize"]));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iRem2px"] = 0;
    }
    ;

// #region   sGetPerceivedBackgroundColor -------------------------------------
    /**
     * @private
     * @static
     * @param {HTMLElement} oDomRef reference to element in DOM
     * @return {string} the color
     */
    UCF_DomUtil["sGetPerceivedBackgroundColor"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["sGetPerceivedBackgroundColor"]++;
        }
        ;
        /** @type {Array<_Color>} */
        var aBGs = [];
        /** @type {_Rgba} */
        var sCurrentColor;
        /** @type {_Rgba} */
        var sColor;
        /** @type {number} */
        var i;

        while (oDomRef) {
            aBGs["push"](UCF_ColorUtil["sColor"](
                UCF_DomUtil["sGetCurrentStyle"](oDomRef, 'backgroundColor')
            ));

            if (UCF_ColorUtil["fAlpha"](aBGs[aBGs["length"] - 1]) === 1) {
                break;
            } else {
                oDomRef = UCF_DomUtil["oGetParentElement"](oDomRef);
            }
        }

        for (i = aBGs["length"] - 1; i > -1; i--) {
            sCurrentColor = aBGs[i];
            if (sColor) {
                sColor = UCF_ColorUtil["sMix"](
                    sColor,
                    UCF_ColorUtil["sFade"](sCurrentColor, 1),
                    1 - UCF_ColorUtil["fAlpha"](sCurrentColor)
                );
            } else {
                sColor = sCurrentColor;
            }
        }

        return UCF_ColorUtil["sHex"](sColor);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["sGetPerceivedBackgroundColor"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------

// #region   iGetVirtualKeyboardHeight ----------------------------------------
    /**
     * @package
     * @return {number}
     */
    UCF_DomUtil["iGetVirtualKeyboardHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["iGetVirtualKeyboardHeight"]++;
        }
        ;
        if (UCF_UserAgent["bIsPhone"]()) {
            // TODO measure the right heights
            return window["matchMedia"]('(orientation: landscape)')["matches"]
                ? 398
                : 314;
        } else if (UCF_UserAgent["bIsTablet"]()) {
            return window["matchMedia"]('(orientation: landscape)')["matches"]
                ? 398
                : 314;
        } else {
            return 0;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["iGetVirtualKeyboardHeight"] = 0;
    }
    ;
// #endregion

// #region oHtmlToElement -----------------------------------------------------
    /**
     * @protected
     * @param {string} sHtml
     * @return {Element|Element[]}
     */
    UCF_DomUtil["oHtmlToElement"] = function (sHtml) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DomUtil["_"]["oHtmlToElement"]++;
        }
        ;
        /** @type {string} */
        var sTrimmedHtml;
        /** @type {HTMLTemplateElement|HTMLDivElement} */
        var oRef;
        /** @type {boolean} */
        var bTd;
        /** @type {Element} */
        var oResultRef;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHtml === 'string', "typeof sHtml === 'string'", "DomUtil.js(4292): oHtmlToElement");
        }
        ;

        sTrimmedHtml = UCF_StringUtil["sTrim"](sHtml);

        if ('HTMLTemplateElement' in window) {
            oRef = document["createElement"]('template');
            // Fortify ignore this line
            // eslint-disable-next-line no-unsanitized/property
            oRef["innerHTML"] = sTrimmedHtml;

            return oRef["content"]["childNodes"]["length"] > 1
                ? UCF_JsUtil["arrayFrom"](oRef["content"]["childNodes"])
                : oRef["content"]["firstChild"];
        } else {
            bTd = UCF_StringUtil["bStartsWith"](sTrimmedHtml, '<td');
            oRef = document["createElement"]('div');

            if (bTd) {
                sTrimmedHtml = '<table><tbody><tr>' + sTrimmedHtml + '</tr></tbody></table>';
            }
            // Fortify ignore this line
            // eslint-disable-next-line no-unsanitized/property
            oRef["innerHTML"] = sTrimmedHtml;

            oResultRef = bTd ? oRef["firstChild"]["firstChild"]["firstChild"] : oRef;

            return oResultRef["childNodes"]["length"] > 1
                ? UCF_JsUtil["arrayFrom"](oResultRef["childNodes"])
                : oResultRef["firstChild"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DomUtil["_"]["oHtmlToElement"] = 0;
    }
    ;
// #endregion -----------------------------------------------------------------

// #region sSerializeDomRef ---------------------------------------------------
    /**
     * @static
     * @param {Element} oDomRef
     * @return {string}
     */
    UCF_DomUtil["sSerializeDomRef"] = __UCF_IE6__
        ? function (oDomRef) {
            /** @type {string} */
            var sSerialized = '';
            /** @type {number} */
            var iChildCount = 0;

            while (oDomRef) {
                if (oDomRef["getAttribute"] && oDomRef["getAttribute"]('id') && iChildCount === 0) {
                    sSerialized = "UCF_DomUtil.$('" + oDomRef["getAttribute"]('id') + "')" + sSerialized;
                    oDomRef = null;
                } else if (oDomRef["tagName"] && oDomRef["tagName"] === 'BODY') {
                    sSerialized = 'document.body' + sSerialized;
                    oDomRef = null;
                } else if (oDomRef === document) {
                    sSerialized = 'document' + sSerialized;
                    oDomRef = null;
                } else if (oDomRef === window) {
                    sSerialized = 'window' + sSerialized;
                    oDomRef = null;
                } else if (oDomRef["previousSibling"]) {
                    iChildCount++;
                    oDomRef = oDomRef["previousSibling"];
                } else if (oDomRef["parentNode"]) {
                    sSerialized = '.childNodes[' + iChildCount + ']' + sSerialized;
                    iChildCount = 0;
                    oDomRef = oDomRef["parentNode"];
                }

            }

            return sSerialized ? sSerialized : 'null';
        }
        : function (oDomRef) {
            /** @type {string} */
            var sSelector = '';
            /** @type {number} */
            var iChildCount = 1;

            while (oDomRef) {
                if (oDomRef["getAttribute"] && oDomRef["getAttribute"]('id') && iChildCount === 1) {
                    sSelector = "[id='" + oDomRef["getAttribute"]('id') + "']" + sSelector;
                    oDomRef = null;
                } else if (oDomRef["tagName"] && oDomRef["tagName"] === 'BODY') {
                    sSelector = 'body' + sSelector;
                    oDomRef = null;
                } else if (oDomRef === document) {
                    sSelector = 'document';
                    oDomRef = null;
                } else if (oDomRef === window) {
                    sSelector = 'window';
                    oDomRef = null;
                } else if (oDomRef["previousSibling"]) {
                    iChildCount++;
                    oDomRef = oDomRef["previousSibling"];
                } else if (oDomRef["parentNode"]) {
                    sSelector = ' :nth-child(' + iChildCount + ')' + sSelector;
                    iChildCount = 1;
                    oDomRef = oDomRef["parentNode"];
                }
            }
            return sSelector;
        };
// #endregion
// #region oDeserializeDomRef -------------------------------------------------
    /**
     * @static
     * @param {string} sSerializedDomRef
     * @return {Element}
     */
    UCF_DomUtil["oDeserializeDomRef"] = __UCF_IE6__
        ? function (sSerializedDomRef) {
            return UCF_JsUtil["eval"]('return ' + sSerializedDomRef);
        }
        : function (sSerializedDomRef) {
            return sSerializedDomRef === 'window'
                ? window
                : sSerializedDomRef === 'document'
                    ? document
                    : UCF_DomUtil["querySelector"](sSerializedDomRef);
        };
// #endregion

    UCF_DomUtil.prototype["aPublicMethods"] = ["destroyStatic", "cancelEvent"].concat(UCF_DomUtil.prototype.aPublicMethods || []);
    /* global _trace, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_SystemPopup */

/// <reference path="./SystemPopup.js"/>

    /**
     * Error Message
     * Creates an Error Message that is displayed to the user.
     * Call UCF_ErrorMessage.show with an iErrorNumber to dis
     * TODO: Translate the error messages
     *
     * @class
     * @version
     */
    function UCF_ErrorMessage() {
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["UCF_ErrorMessage"]++;
        }
        ;
    };window["UCF_ErrorMessage"] = UCF_ErrorMessage;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ErrorMessage");
        UCF_ErrorMessage["_"] = {UCF_ErrorMessage: 0};
    }
    ;
    ;

    UCF_ErrorMessage["E_TYPE"] = {
        "FATAL": 0,
        "NETWORK": 1,
        "UNAUTHORIZED": 2
    };

    UCF_ErrorMessage[UCF_ErrorMessage["E_TYPE"]["FATAL"]] = {
        "sTitle": "Fatal Error",
        "aItems": ["The browser failed to download files.", "The server is not responding", "The server was temporary not available."],
        "aIssues": ["Internet connectivity has been lost.", "The website is temporarily unavailable.", "The Domain Name Server (DNS) is not reachable.", "The Domain Name Server (DNS) does not have a listing for the website's domain.", "If this is an HTTPS (secure) address, click tools, click Internet Options, click Advanced, and check the protocols setting under the security section."],
        "aTryTo": ["Retype the address.", "Try visiting another website to make sure you are connected.", "Restart the application."],
        "bDestroy": true,
        "sInternalMessage": "SAP HTML Rendering: Error 0"
    };

    UCF_ErrorMessage[UCF_ErrorMessage["E_TYPE"]["NETWORK"]] = {
        "sTitle": "Server connection not available",
        "aItems": ["You are not connected to the Internet.", "The server is not responding", "The server was temporary not available."],
        "aIssues": ["Internet connectivity has been lost.", "The website is temporarily unavailable.", "The Domain Name Server (DNS) is not reachable.", "The Domain Name Server (DNS) does not have a listing for the website's domain.", "If this is an HTTPS (secure) address, click tools, click Internet Options, click Advanced, and check the protocols setting under the security section."],
        "aTryTo": ["Reconnect to the server.", "Retype the address.", "Try visiting another website to make sure you are connected.", "Restart the application."],
        "bDestroy": true,
        "sInternalMessage": "SAP HTML Rendering: Error 1"
    };

    UCF_ErrorMessage[UCF_ErrorMessage["E_TYPE"]["UNAUTHORIZED"]] = {
        "sTitle": "Unauthorized Error ",
        "aItems": ["Your session has expired.", "Your session has been deleted.", "Your session could not be assigned."],
        "aIssues": ["Your session has expired.", "Your session has been deleted.", "Your session could not be assigned."],
        "aTryTo": ["Restart the application."],
        "bDestroy": true,
        "sInternalMessage": "SAP HTML Rendering: Error 2"
    };

    /**
     * List of objects to be informed is a message is shown
     */
//eslint-disable-next-line ur/no-memory-leaks
    UCF_ErrorMessage["aDestroyObjects"] = []; //used only in attachDestroyHandler - ensure to call destroyAttachHandler (used only in LS)

    /**
     * System popup instance for display of the error message
     */
    UCF_ErrorMessage["oSystemPopup"] = null;

    /**
     * Attaches an handler that is called if the message is shown
     *
     * @param {Object} oObject Object to be used to call the handling function
     * @param {string} sFunction Name of the method called on oObject
     * @private
     */
    UCF_ErrorMessage["attachDestroyHandler"] = function (oObject, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["attachDestroyHandler"]++;
        }
        ;
        var bAttachedAlready = false;
        for (var i = 0; i < UCF_ErrorMessage["aDestroyObjects"]["length"]; i++) {
            var oDestroyObject = UCF_ErrorMessage["aDestroyObjects"][i];
            if (oDestroyObject["oObject"] === oObject) {
                bAttachedAlready = true;
            }
        }
        if (!bAttachedAlready) {
            UCF_ErrorMessage["aDestroyObjects"]["push"]({
                "oObject": oObject,
                "sFunction": sFunction
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ErrorMessage["_"]["attachDestroyHandler"] = 0;
    }
    ;

    /**
     * Detaches the handler that is called if the message is shown
     *
     * @param {Object} oObject Object to be used to call the handling function
     * @param {string} sFunction Name of the method called on oObject
     *
     * @private
     */
    UCF_ErrorMessage["detachDestroyHandler"] = function (oObject, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["detachDestroyHandler"]++;
        }
        ;
        for (var i = 0; i < UCF_ErrorMessage["aDestroyObjects"]["length"]; i++) {
            var oDestroyObject = UCF_ErrorMessage["aDestroyObjects"][i];
            if (oDestroyObject["oObject"] === oObject && oDestroyObject["sFunction"] === sFunction) {
                UCF_ErrorMessage["aDestroyObjects"][i] = null;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ErrorMessage["_"]["detachDestroyHandler"] = 0;
    }
    ;

    /**
     * Shows an error message for the user and blocks all interaction with the document
     *
     * @param {integer} iErrorNumber Object to be used to call the handling function
     *
     * @private
     */
    UCF_ErrorMessage["show"] = function (iErrorNumber) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["show"]++;
        }
        ;
        var i;

        if (!iErrorNumber) iErrorNumber = 0;
        var oError = UCF_ErrorMessage[iErrorNumber];

        if (oError["bDestroy"]) {
            for (i = 0; i < UCF_ErrorMessage["aDestroyObjects"]["length"]; i++) {
                var oDestroyObject = UCF_ErrorMessage["aDestroyObjects"][i];
                if (oDestroyObject) {
                    oDestroyObject["oObject"][oDestroyObject["sFunction"]]();
                }
            }
        }
        document["body"]["style"]["overflow"] = "hidden";

        var sHTML = [];
        sHTML["push"]("<div style=\"width:100%;height:" + Math["floor"](document["body"]["offsetHeight"] / 2) + "px;overflow:auto\" class=\"urBdyStd\"><table width=\"100%\" cellpadding=\"2\" cellspacing=\"4\" border=\"0\" style=\"font-size:8pt\"><tr><td align=\"left\"><b style=\"font-size:8pt\">Most likely causes:</b><br><ul>");
        for (i = 0; i < oError["aItems"]["length"]; i++) sHTML["push"]("<li style=\"font-size:8pt\">" + oError["aItems"][i] + "</li>");
        sHTML["push"]("</ul></td></tr><tr><td align=\"left\"><b style=\"font-size:8pt\">What you can try:</b><br><ul>");
        for (i = 0; i < oError["aTryTo"]["length"]; i++) sHTML["push"]("<li >" + oError["aTryTo"][i] + "</li>");
        sHTML["push"]("</ul></td></tr><tr><td align=\"left\"><b style=\"font-size:8pt\">This problem can be caused by a variety of issues, including:</b><br><ul>");
        for (i = 0; i < oError["aIssues"]["length"]; i++) sHTML["push"]("<li style=\"font-size:8pt\">" + oError["aIssues"][i] + "</li>");
        sHTML["push"]("</ul></td></tr></table></div>");

        if (!UCF_ErrorMessage["oSystemPopup"]) {
            //this could be a memeory leak but in an error case we destroy lightspeed but still show the error popup delayed
            //eslint-disable-next-line ur/no-memory-leaks
            UCF_ErrorMessage["oSystemPopup"] = new UCF_SystemPopup();
        }

        UCF_ErrorMessage["oSystemPopup"]["setTitle"](oError["sTitle"] + "&nbsp;&nbsp;-&nbsp;&nbsp;<span>(Click here to close)</span>");
        UCF_ErrorMessage["oSystemPopup"]["setContent"](sHTML["join"](""));
        UCF_JsUtil["delayedCall"](500, UCF_ErrorMessage["oSystemPopup"], "show");
        window["onclick"] = UCF_ErrorMessage["hide"];

        //catches all errors for IE and
        window["onerror"] = UCF_ErrorMessage["handleError"];
        //TODO: find an alternative for firefox.
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ErrorMessage["_"]["show"] = 0;
    }
    ;

    /**
     * Handles an js error tracing a Message, URL and line number if ClientDebug is enabled
     * @param {string} sMsg The message to display
     * @param {string} sUrl The url that produced the error
     * @param {integer} iLineNumber The line number of the error
     * @return {boolean} true
     * @private
     */
    UCF_ErrorMessage["handleError"] = function (sMsg, sUrl, iLineNumber) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["handleError"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(ERROR, "JavaScript: Message:" + sMsg + " , Url:" + sUrl + ", Linenumber:" + iLineNumber, "ErrorMessage.js(162): handleError");
        }
        ;
        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ErrorMessage["_"]["handleError"] = 0;
    }
    ;

    /**
     * Hides the error message
     * @private
     */
    UCF_ErrorMessage["hide"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ErrorMessage["_"]["hide"]++;
        }
        ;
        UCF_ErrorMessage["oSystemPopup"]["hide"]();

        //gray out the main page...to signalize the page is destroyed
        //"filter", "invert(.2)" and "filter", "grayscale(1)" works only for Chrome
        UCF_DomUtil["setStyle"](document["documentElement"], "opacity", "0.6");


    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ErrorMessage["_"]["hide"] = 0;
    }
    ;

    /* global UCF_FesrUtil*/

    /**
     * @typedef {Object} UCF_FesrData_Roundtrip
     * @property {number} T0 navigation start timestamp
     * @property {number} T1 request trigger timestamp
     * @property {number} T2 send request timestamp
     * @property {number} T3 get response timestamp
     * @property {number} T4 input ready timestamp
     * @property {number} iServerTime time spent on the server
     * @property {number} iCntLngReq length of the request content
     * @property {number} iCntLngResp length of the response content
     */
    /**
     * @class UCF_FesrUtil
     * @param {string} sAppName name of application used as prevAppName for
     * FESRec_opt e.g. ITS Transaction
     * @param {string} sCompName component name used for passport generation e.g.
     * ITS transaction + dynpro name name
     * @param {string} sStepName stepname used as prevSteName for FESRec_optITS:
     * <id of UIElement>_<eventtype> e.g. webguiPage0_F8 (for hotkey event the key
     * is used instead of hotkey)
     * @param {string} sAction Action used for passport generation: ITS:
     * <dynpro nummer>_<id of UIElement>_<eventtype> e.g. 0100_webguiPage0_F8 (for
     * hotkey event the key is used instead of hotkey)
     * @param {string} sTransID For each XHR one transaction_id is generated (JS
     * GUID). If a FESR header is sent, the first generated transaction_id since
     * the last complete interaction is included.n and PerfFESRec
     * @param {Object} oFrameWorkStart Framework start method
     * started
     * @param {number} iStepCounter current counter of user interaction step
     * @param {number} iInteractionType current InteractionType
     *
     * @see UCF_FesrUtil
     */
    function UCF_FesrData(sAppName, sCompName, sStepName, sAction, sTransID, oFrameWorkStart, iStepCounter, iInteractionType) {
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["UCF_FesrData"]++;
        }
        ;
        /** @type {string} */
        this["sAppName"] = sAppName; //eslint-disable-line ur/no-memory-leaks
        /** @type {string} */
        this["sCompName"] = sCompName; //eslint-disable-line ur/no-memory-leaks
        //component name used for passport generation e.g. ITS transaction + dynpro name name
        /** @type {string} */
        this["sStepName"] = sStepName; //eslint-disable-line ur/no-memory-leaks
        /** @type {string} */
        this["sAction"] = sAction; //eslint-disable-line ur/no-memory-leaks
        /** @type {string} */
        this["sTransID"] = sTransID; //eslint-disable-line ur/no-memory-leaks
        /** @type {boolean} */
        if (oFrameWorkStart) {
            this["oFrameWorkStart"] = oFrameWorkStart; //eslint-disable-line ur/no-memory-leaks
        } else {
            this["oFrameWorkStart"] = UCF_FesrUtil["oFrameWorkStartType"]["No"]; //no start request as default setting
        }
        /** @type {number} */
        this["iStepCounter"] = iStepCounter; //eslint-disable-line ur/no-memory-leaks

        /** @type {Array<UCF_FesrData_Roundtrip>} */
        this["aRoundtrips"] = []; //eslint-disable-line ur/no-memory-leaks
        /** @type {boolean} */
        this["bIsDialogStepEnd"] = false;
        /** @type {number} */
        this["iRoundtrips"] = 0;
        /** @type {number} */
        this["iInitialTriggerTime"] = 0;
        /** @type {string} */
        this["logFrameworkInfo"] = ""; //used to trace extra information given by framework at time T1 until T4.
        /** @type {number} */
        this["iInteractionType"] = iInteractionType || 2; //eslint-disable-line ur/no-memory-leaks
    };window["UCF_FesrData"] = UCF_FesrData;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_FesrData");
        UCF_FesrData["_"] = {UCF_FesrData: 0};
    }
    ;
    ;

    /**
     * Provides the action name of the currently recorded roundtrip
     *
     * @private
     * @return {string} action name of the roundtrip
     */
    UCF_FesrData["prototype"]["sGetAction"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["sGetAction"]++;
        }
        ;
        return this["sAction"] ? this["sAction"] : this["sStepName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["sGetAction"] = 0;
    }
    ;

    /**
     * Provides the step name of the currently recorded roundtrip
     *
     * @private
     * @return {string} step name of the roundtrip
     */
    UCF_FesrData["prototype"]["sGetStepName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["sGetStepName"]++;
        }
        ;
        return this["sStepName"] ? this["sStepName"] : this["sAction"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["sGetStepName"] = 0;
    }
    ;

    /**
     * Provides the component name of the currently recorded roundtrip
     *
     * @private
     * @return {string} application name of the roundtrip
     */
    UCF_FesrData["prototype"]["sGetAppName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["sGetAppName"]++;
        }
        ;
        return this["sAppName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["sGetAppName"] = 0;
    }
    ;

    /**
     * Provides the component name of the currently recorded roundtrip
     *
     * @private
     * @return {string} component name of the roundtrip
     */
    UCF_FesrData["prototype"]["sGetCompName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["sGetCompName"]++;
        }
        ;
        return this["sCompName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["sGetCompName"] = 0;
    }
    ;

    /**
     * Provides the transaction ID of the currently recorded roundtrip
     *
     * @private
     * @return {string} transaction ID of the roundtrip
     */
    UCF_FesrData["prototype"]["sGetTransID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["sGetTransID"]++;
        }
        ;
        return this["sTransID"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["sGetTransID"] = 0;
    }
    ;

    /**
     * Provides inital framework start method
     *
     * @private
     * @return {boolean} framework start
     */
    UCF_FesrData["prototype"]["oGetFrameworkStart"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["oGetFrameworkStart"]++;
        }
        ;
        return this["oFrameWorkStart"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["oGetFrameworkStart"] = 0;
    }
    ;

    /**
     * Provides whether the roundtrip is the last roundtrip of a dialog step
     *
     * @private
     * @return {boolean} last roundtrip of the dialog step
     */
    UCF_FesrData["prototype"]["bGetDialogStepEnd"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["bGetDialogStepEnd"]++;
        }
        ;
        return this["bIsDialogStepEnd"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["bGetDialogStepEnd"] = 0;
    }
    ;

    /**
     * Provides the couter of current step
     *
     * @private
     * @return {number} current counter of user interaction step
     */
    UCF_FesrData["prototype"]["iGetStepCounter"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["iGetStepCounter"]++;
        }
        ;
        return this["iStepCounter"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["iGetStepCounter"] = 0;
    }
    ;

    /**
     * Provides type of interaction: 0 = not implemented, 1 = app start, 2 = follow up step, 3 = unknown
     *
     * @private
     * @return {number} current type of interaction
     */
    UCF_FesrData["prototype"]["iGetInteractionType"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["iGetInteractionType"]++;
        }
        ;
        return this["iInteractionType"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["iGetInteractionType"] = 0;
    }
    ;


    /**
     * Destructor
     */
    UCF_FesrData["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrData["_"]["destroy"]++;
        }
        ;

        undefined.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrData["_"]["destroy"] = 0;
    }
    ;

    /* global UCF_Performance */
/// <reference path="../../ls/core/Performance.js"/>
    /* global _trace, DEBUG, INFO, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_FesrData */
/// <reference path="./FesrData.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>
    /* eslint-disable max-len */

    /**
     *
     * Calculates client side timing figures for each dialog step and transfered it to the server
     * Can be checked with backend transaction stats
     *
     * @class UCF_FesrUtil
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     * @see UCF_FesrData
     */
    function UCF_FesrUtil() {
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["UCF_FesrUtil"]++;
        }
        ;
    };window["UCF_FesrUtil"] = UCF_FesrUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_FesrUtil");
        UCF_FesrUtil["_"] = {UCF_FesrUtil: 0};
    }
    ;
    ;

    UCF_FesrUtil["oFrameWorkStartType"] = {
        "No": 0, //not a framework start used for normal roundtrips
        "OneRountrip": 1, //assuming start of the framework with one roundtrip
        "TwoRoundtrip": 2, //assuming start of the framework with two roundtrips
        "SessionReuse": 3 //assuming the LS session will be reused e.g. in the FLP session caching scenario
    };

    UCF_FesrUtil["oCurrentDialogStep"] = null; // stores the information of the current roundtrip
    UCF_FesrUtil["oPreviousRoundtrip"] = null; // stores the information of the previous roundtrip. Will be sent to server with next roundtrip.

    UCF_FesrUtil["sRootCtxtID"] = ''; // generated GUID of 32 characters, which is generated once per client and session.
    UCF_FesrUtil["sPassportPrefix"] = 'SAP_E2E_TA_URLIB'; // prefix of the framework e.g. SAP_E2E_TA_ITSLIB  or SAP_E2E_TA_WDALIB used by passport generation. Must be overwitten by framework
    UCF_FesrUtil["sClientType"] = 'SAP_UR'; // name of the framework e.g. SAP_ITS or SAP_WDA.

    UCF_FesrUtil["sClientOS"] = ''; // name of the operation system
    UCF_FesrUtil["sClientModel"] = ''; // name of browser and browser version

    UCF_FesrUtil["bCompressed"] = true; // whether the reponse is compressed or not

    UCF_FesrUtil["bNavTimeSupp"] = (performance && performance["timing"]); // is timing API supported

    UCF_FesrUtil["bFESRHandledByFramework"] = false; // set to true if all FESR methods are called from the framework instead of from UCF_Performance
    UCF_FesrUtil["bFESREnabled"] = null; // null is not set yet. will be set by framework or LS to true/false
    UCF_FesrUtil["bFESRDebugOnly"] = false; //used only for debug tracer. data are not send to server
    UCF_FesrUtil["bValidRoundtrip"] = true; // defines whether the roundtrip should be recorded or not

    UCF_FesrUtil["notifyFESRTimes"] = null; //callback function to report FESR Times to outer framework

    UCF_FesrUtil["sDebugMode"] = INFO; //use debug mode "INFO" for the first roundtrip to ensure to trace the start as only INFO are traced. After the first roundtrip it is possible to switch the debugger to debug mode

    UCF_FesrUtil["bUseBeacon"] = false; //whether beacon request or piggyback using next HTTPRequest should be used
    UCF_FesrUtil["sBeaconUrl"] = ""; //the url for the beacon request
    UCF_FesrUtil["iBeaconCount"] = 10; //amount of roundtrips before beacon should be send
    UCF_FesrUtil["oBeacon"] = null; //the beacon object
    UCF_FesrUtil["sBeaconIdentifer"] = ";sap-fesr-only"; //used as segmented URL part to identify the FESR Beacon request by ICF
    UCF_FesrUtil["bBeaconInitialized"] = false;

    UCF_FesrUtil["iStepCounter"] = 0; // counts FESR interaction steps

    /**
     * Initializes the FESR with meta data which must be called by the frameworks at the earlist point in time
     *
     * @public
     * @param {Object} oMetadata inital meta data set by the framework
     * @param {boolean} bDebugOnly optional whether FESR runs in DebugOnly mode - no FESR data are sent to server
     * @see setMetadata

     clientType:'SAP_ITS',
     sPassportPrefix:'SAP_E2E_TA_ITSLIB',
     sAppName: 'SE38'
     sCompName:'SE38_SAPLWBABAP' [optional if need],
     sAction:'start'
     sStepName [optional]
     bHandeledByFramework [optional] set to true if all FESR logs are cause by explicit aclls of the framework
     */
    UCF_FesrUtil["initFESR"] = function (oMetadata, bDebugOnly) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["initFESR"]++;
        }
        ;

        var sCompName = "",
            sAppName = "",
            sStepName = "",
            sAction = 'START',
            sTransID = UCF_FesrUtil["createGUID"]()["substr"](-26, 26) + '000000', // eslint-disable-line no-magic-numbers,
            sPlatform = UCF_UserAgent["sGetPlatformAppreviation"](),
            sPlatformVersion = UCF_UserAgent["sGetPlatformVersion"](),
            oFrameWorkStart = UCF_FesrUtil["oFrameWorkStartType"]["TwoRoundtrip"];

        UCF_FesrUtil["bFESRDebugOnly"] = bDebugOnly ? true : false; //init is only called by a framework once they want FESR --> debug mode not necessary

        if (UCF_FesrUtil["bFESREnabled"] == null) {
            UCF_FesrUtil["bFESREnabled"] = true; // assume FESR should be enabled as init
        }

        if (oMetadata) {

            if (oMetadata["hasOwnProperty"]('sCompName')) {
                sCompName = oMetadata["sCompName"];
            }

            if (oMetadata["hasOwnProperty"]('sAction')) {
                sAction = oMetadata["sAction"];
            }

            if (oMetadata["hasOwnProperty"]('sStepName')) {
                sStepName = oMetadata["sStepName"];
            }

            if (oMetadata["hasOwnProperty"]('sAppName')) {
                sAppName = oMetadata["sAppName"];
            }

            if (oMetadata["hasOwnProperty"]('oFrameWorkStart')) {
                oFrameWorkStart = oMetadata["oFrameWorkStart"];
            }

            if (oMetadata["hasOwnProperty"]('bFESREnabled')) {
                UCF_FesrUtil["bFESREnabled"] = oMetadata["bFESREnabled"];
            }

            if (oMetadata["hasOwnProperty"]('bFESRHandledByFramework')) {
                UCF_FesrUtil["bFESRHandledByFramework"] = oMetadata["bFESRHandledByFramework"];
            }

            if (oMetadata["hasOwnProperty"]('bUseBeacon')) {
                UCF_FesrUtil["bUseBeacon"] = oMetadata["bUseBeacon"];
            }

            if (oMetadata["hasOwnProperty"]('sBeaconUrl')) {
                UCF_FesrUtil["sBeaconUrl"] = oMetadata["sBeaconUrl"];
            }

            if (oMetadata["hasOwnProperty"]('sClientType')) {
                UCF_FesrUtil["sClientType"] = oMetadata["sClientType"];
            }

            if (oMetadata["hasOwnProperty"]('sPassportPrefix')) {
                UCF_FesrUtil["sPassportPrefix"] = oMetadata["sPassportPrefix"];
            }
        }

        if (!UCF_FesrUtil["bNavTimeSupp"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Performance: no Navigation Time support - disable FESR', "FesrUtil.js(144): initFESR");
            }
            ;
            UCF_FesrUtil["bFESREnabled"] = false;

            return;
        }

        if (!UCF_FesrUtil["bFESREnabled"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Performance: FESR is disabled - enable FESR to get FESR figures', "FesrUtil.js(151): initFESR");
            }
            ;

            return;
        }

        if (oFrameWorkStart === UCF_FesrUtil["oFrameWorkStartType"]["SessionReuse"]) {
            UCF_FesrUtil["flushBeacon"]();
        }

        //reset bBeaconInitialized as it could be a session resue with different URLs etc.
        UCF_FesrUtil["bBeaconInitialized"] = false;

        if (!sCompName || sCompName === '') {
            sCompName = sAppName;
        }

        if (!sStepName || sStepName === '') {
            sStepName = sAction;
        }

        if (sPlatform && sPlatformVersion) {
            UCF_FesrUtil["sClientOS"] = sPlatform + '_' + sPlatformVersion;
        } else {
            UCF_FesrUtil["sClientOS"] = sPlatform + sPlatformVersion;
        }

        UCF_FesrUtil["sClientModel"] = UCF_UserAgent["sGetBrowserNameAppreviation"]() + '_' + UCF_UserAgent["iGetBrowserVersion"]();

        UCF_FesrUtil["iStepCounter"] = 0; //reset counter


        if (UCF_FesrUtil["oCurrentDialogStep"]) delete UCF_FesrUtil["oCurrentDialogStep"];
        UCF_FesrUtil["oCurrentDialogStep"] = new UCF_FesrData(sAppName, sCompName, sStepName, sAction, sTransID, oFrameWorkStart, UCF_FesrUtil["iStepCounter"], 1);

        UCF_FesrUtil["sRootCtxtID"] = UCF_FesrUtil["createGUID"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Performance: FESR enabled: Debug Only:' + UCF_FesrUtil["bFESRDebugOnly"], "FesrUtil.js(187): initFESR");
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["initFESR"] = 0;
    }
    ;

    /**
     * Updates general meta data information
     *
     * @public
     * @param {Object} oMetadata the metadata
     */
    UCF_FesrUtil["setMetadata"] = function (oMetadata) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["setMetadata"]++;
        }
        ;
        if (!oMetadata) {
            return;
        }

        if (UCF_FesrUtil["oCurrentDialogStep"]) {
            UCF_JsUtil["extend"](UCF_FesrUtil["oCurrentDialogStep"], oMetadata);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["setMetadata"] = 0;
    }
    ;

    /**
     * Updates general meta data information
     *
     * @public
     * @param {Object} oBeacon the BeaconRequest Object
     * @param {string} [sUrl] optional the Beacon URL
     */
    UCF_FesrUtil["setBeacon"] = function (oBeacon, sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["setBeacon"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'FESR: set beacon request object ', "FesrUtil.js(215): setBeacon");
        }
        ;

        if (UCF_FesrUtil["oBeacon"]) {
            //ensure to cleanup old beacon before delete
            UCF_FesrUtil["oBeacon"]["destroy"]();
        }
        UCF_FesrUtil["oBeacon"] = oBeacon;

        if (sUrl) {
            UCF_FesrUtil["sBeaconUrl"] = sUrl;
        }
        UCF_FesrUtil["bBeaconInitialized"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["setBeacon"] = 0;
    }
    ;

    /**
     * Check if BeaconRequest should be used and initialize it laszy.
     *
     * @return { boolean } whether BeaconRequest can be used
     * @private
     */
    UCF_FesrUtil["bUseBeaconRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["bUseBeaconRequest"]++;
        }
        ;
        /** @type {Array<string>} */
        var sPathName = location["pathname"];

        /** @type {Array<string>} */
        var aPathSegments;

        if (UCF_FesrUtil["bBeaconInitialized"]) {
            return true;
        } else if (!UCF_FesrUtil["bUseBeacon"]) {
            if (UCF_FesrUtil["oBeacon"]) {
                UCF_FesrUtil["oBeacon"]["destroy"]();
                UCF_FesrUtil["oBeacon"] = null;
            }
            return false;
        }

        if (UCF_FesrUtil["sBeaconUrl"] === "") {
            //Use either the given sBeaconUrl or derive the URL from location but need to check for mangled URL

            //remove mangled part of URL as the ICF would not recognize the beacon request correctly
            //and forward it to the application directly. Without session id it works.
            //only needed for ITS
            //client should not be part of mangled URL but if we must not sent ebacon reuest - coding was removed see CL 311600 in DEV
            sPathName = UCF_JsUtil["sRemoveMangledPartFromURL"](sPathName);

            aPathSegments = sPathName["split"]('/');

            if (aPathSegments["length"] >= 2) {
                if (aPathSegments["length"] === 2) {
                    //first aPathSegments is always empty as the URL start with /
                    aPathSegments[aPathSegments["length"] - 2] = "/" + UCF_FesrUtil["sBeaconIdentifer"];
                } else {
                    aPathSegments[aPathSegments["length"] - 2] = aPathSegments[aPathSegments["length"] - 2] + UCF_FesrUtil["sBeaconIdentifer"];
                }
                UCF_FesrUtil["sBeaconUrl"] = aPathSegments["join"]('/');

            } else {
                return UCF_FesrUtil["bUseBeacon"] = false;
            }
        }

        if (UCF_FesrUtil["oBeacon"]) {

            UCF_FesrUtil["oBeacon"]["setBeaconUrl"](UCF_FesrUtil["sBeaconUrl"]);
            UCF_FesrUtil["oBeacon"]["setFixBeaconData"]({"sap-fesr-only": "1"}); //version number of current FESR implementaion used by ICF

            if (!(('navigator' in window) && ('sendBeacon' in window["navigator"]) && ('Blob' in window))) {
                //Beacon can not beused --> send the Data per XHR very time
                //IE11 only case
                UCF_FesrUtil["iBeaconCount"] = 1;
            }
            UCF_FesrUtil["oBeacon"]["setBeaconEntryCount"](UCF_FesrUtil["iBeaconCount"]);

            UCF_FesrUtil["bBeaconInitialized"] = true;
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'FESR: Use BeaconRequest and initialization', "FesrUtil.js(290): bUseBeaconRequest");
            }
            ;
        } else {
            UCF_FesrUtil["bUseBeacon"] = false;
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'FESR: Beacon request missing - fallback to PiggyBack', "FesrUtil.js(293): bUseBeaconRequest");
            }
            ;
            return false;
        }
        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["bUseBeaconRequest"] = 0;
    }
    ;

    /**
     * Flush the beacon queue and send all data to server.
     * Doesn't influence the Piggy-Back
     *
     * @public
     */
    UCF_FesrUtil["flushBeacon"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["flushBeacon"]++;
        }
        ;

        if (UCF_FesrUtil["bUseBeacon"] && UCF_FesrUtil["oBeacon"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'FESR: flush beacon request by FESR ', "FesrUtil.js(308): flushBeacon");
            }
            ;
            UCF_FesrUtil["oBeacon"]["flush"]();
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["flushBeacon"] = 0;
    }
    ;

    /**
     * Sets a callback function to provide FESR times of current roundtrip
     *
     * @public
     * @param {function} fCallback The callback function to be called
     */
    UCF_FesrUtil["setFESRTimesCallBack"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["setFESRTimesCallBack"]++;
        }
        ;
        if (!fCallback) {
            return;
        }

        UCF_FesrUtil["notifyFESRTimes"] = fCallback;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["setFESRTimesCallBack"] = 0;
    }
    ;

    /**
     * Called from the framework to set the FESR data at the XMLHttpRequest
     *
     * @public
     * @param {XMLHttpRequest} oRequest the request
     * @param {int} iRequestHeaderLength bytes of the request so far
     */
    UCF_FesrUtil["notifyRequest"] = function (oRequest, iRequestHeaderLength) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["notifyRequest"]++;
        }
        ;

        if (!UCF_FesrUtil["bFESREnabled"] || !UCF_FesrUtil["oCurrentDialogStep"] || !UCF_FesrUtil["bValidRoundtrip"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: Notify Request not processed as either bValidRoundtrip is false or FESR not eanbled:  bValidRoundtrip is:' + UCF_FesrUtil["bValidRoundtrip"], "FesrUtil.js(338): notifyRequest");
            }
            ;
            return;
        }

        iRequestHeaderLength += UCF_FesrUtil["iSetRequestHeaders"](oRequest);

        if (oRequest["requestText"]) {
            // not sure if we need to multiplicate the value with 2: double string length for byte length as in js characters are stored as 16 bit ints
            iRequestHeaderLength += oRequest["requestText"]["length"]; // eslint-disable-line no-magic-numbers
        }

        if (UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] > 0 && iRequestHeaderLength > 0) {
            UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"][UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] - 1]["iCntLngReq"] = iRequestHeaderLength;
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: Set HTTP request header; Content length request: ' + iRequestHeaderLength, "FesrUtil.js(353): notifyRequest");
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["notifyRequest"] = 0;
    }
    ;

    /**
     * Calculates FESR data and passport and writes it into the request header
     *
     * @private
     * @param {XMLHttpRequest} oRequest the request
     * @return {int} length of the added request parameters
     */
    UCF_FesrUtil["iSetRequestHeaders"] = function (oRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["iSetRequestHeaders"]++;
        }
        ;

        /* Test data
			UCF_FesrUtil.sRootCtxtID='2150E05C671742B992A6D4AE1489B4B2',
			UCF_FesrUtil.sTransID='9B89194406AEF30A6CC52598C8000000',
			UCF_FesrUtil.sCompName='SMEN',
			UCF_FesrUtil.iRoundtrips=0,
			UCF_FesrUtil.sAction='SMEN_start'+ '_' + nwRoundTrips;
			var resultShouldBe='2A54482A0300E60000534D454E2020202020202020202020202020202020202020202020202020202000005341505F4532455F54415F557365722020202020202020202020202020202020534D454E5F73746172745F30202020202020202020202020202020202020202020202020202020200005534D454E20202020202020202020202020202020202020202020202020202020394238393139343430364145463330413643433532353938433830303030303020202000072150E05C671742B992A6D4AE1489B4B20000000000000000000000000000000000000000000000E22A54482A';
			if (UCF_FesrUtil.sGetPassport(l,UCF_FesrUtil.sRootCtxtID,UCF_FesrUtil.sTransID,UCF_FesrUtil.sCompName,UCF_FesrUtil.sAction,UCF_FesrUtil.sPassportPrefix) == resultShouldBe) alert('Test Successfull');
	*/

        var sCompName = UCF_FesrUtil["oCurrentDialogStep"]["sGetCompName"]() ? UCF_FesrUtil["oCurrentDialogStep"]["sGetCompName"]() : UCF_FesrUtil["oCurrentDialogStep"]["sGetAppName"](),
            perf_fesrec = '',
            perf_fesrec_opt = '',
            iRequestHeaderLength = 0,
            lvl = UCF_FesrUtil["traceFlags"]('low'), // ToDo: ITS uses per default trace level low - clarify why?
            //old: passport = UCF_FesrUtil.sGetPassport(lvl, UCF_FesrUtil.sRootCtxtID, UCF_FesrUtil.oCurrentDialogStep.sTransID, sCompName, UCF_FesrUtil.oCurrentDialogStep.sGetAction() + '_' + UCF_FesrUtil.iStepCounter, UCF_FesrUtil.sPassportPrefix),
            passport = UCF_FesrUtil["sGetPassport"](
                lvl,
                UCF_FesrUtil["sRootCtxtID"],
                UCF_FesrUtil["oCurrentDialogStep"]["sTransID"],
                UCF_FesrUtil["sReplaceReservedCharacters"](sCompName),
                UCF_FesrUtil["sGetUISID"](
                    UCF_FesrUtil["sReplaceReservedCharacters"](UCF_FesrUtil["oCurrentDialogStep"]["sGetStepName"]()),
                    UCF_FesrUtil["oCurrentDialogStep"]["iGetStepCounter"]()),
                UCF_FesrUtil["sPassportPrefix"]),

            oCalculated = null;

        iRequestHeaderLength += UCF_FesrUtil["iSetRequestHeader"](oRequest, 'SAP-PASSPORT', passport);

        if (!UCF_FesrUtil["bUseBeaconRequest"]() && UCF_FesrUtil["oPreviousRoundtrip"] && UCF_FesrUtil["oPreviousRoundtrip"]["oCalculated"]) {

            oCalculated = UCF_FesrUtil["oPreviousRoundtrip"]["oCalculated"];

            perf_fesrec = UCF_FesrUtil["sGetPerfFESRec"](oCalculated);
            iRequestHeaderLength += UCF_FesrUtil["iSetRequestHeader"](oRequest, 'SAP-Perf-FESRec', perf_fesrec);

            perf_fesrec_opt = UCF_FesrUtil["sGetPerfFESRecOpt"](oCalculated);
            iRequestHeaderLength += UCF_FesrUtil["iSetRequestHeader"](oRequest, 'SAP-Perf-FESRec-opt', perf_fesrec_opt);

            delete UCF_FesrUtil["oPreviousRoundtrip"];
        }

        return iRequestHeaderLength;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["iSetRequestHeaders"] = 0;
    }
    ;

    /**
     * Called from the framework after the repsonse the derive FESR data transfered from the server
     *
     * @public
     * @param {XMLHttpRequest} oResponse the HTTP response
     */
    UCF_FesrUtil["notifyResponse"] = function (oResponse) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["notifyResponse"]++;
        }
        ;  // eslint-disable-line complexity

        var iContentLengthResponse = 0,
            sContentEncoding = '',
            iServerTime = 0,
            oLastRoundtrip = null;

        if (!UCF_FesrUtil["bFESREnabled"] || !UCF_FesrUtil["oCurrentDialogStep"] || !UCF_FesrUtil["bValidRoundtrip"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: Notify Response not processed as either bValidRoundtrip is false or FESR not eanbled:  bValidRoundtrip is:' + UCF_FesrUtil["bValidRoundtrip"], "FesrUtil.js(426): notifyResponse");
            }
            ;
            return;
        }

        // calculate the resonse length
        iContentLengthResponse = oResponse["getResponseHeader"]('content-length');
        if (iContentLengthResponse) {
            // UI5 uses oResponse.getAllResponseHeaders().length * 2 due to double string length for byte length as in js characters are stored as 16 bit ints: According HTTPWatch this is wrong
            iContentLengthResponse = parseInt(iContentLengthResponse) + oResponse["getAllResponseHeaders"]()["length"]; // eslint-disable-line no-magic-numbers
        } else {
            iContentLengthResponse = 0;
        }

        // calculate if compressed
        sContentEncoding = oResponse["getResponseHeader"]('content-encoding');
        UCF_FesrUtil["bCompressed"] = (sContentEncoding && (sContentEncoding === 'gzip' || sContentEncoding === 'br'));

        iServerTime = UCF_FesrUtil["iGetServerTime"](oResponse);

        if (UCF_FesrUtil["oCurrentDialogStep"] && UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"] && UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] > 0) {
            oLastRoundtrip = UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"][UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] - 1];
            oLastRoundtrip["iServerTime"] = iServerTime;
            oLastRoundtrip["iCntLngResp"] += iContentLengthResponse;
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: Receive HTTP response; server time: ' + iServerTime + '; Content length response: ' + iContentLengthResponse, "FesrUtil.js(451): notifyResponse");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["notifyResponse"] = 0;
    }
    ;

    /**
     * Called from the UCF_Performance in the onBeforeSemanticEvent.
     * Calculate whether the semantic event is relevant for FESR
     * and derive the metadata from the event
     *
     * @public
     * @param {UCF_Event} oEvent the Before Semantic Event occurs
     * @param {boolean} bIsStartupRoundtrip is startup roundtrip
     */
    UCF_FesrUtil["calculateOnBeforeSemanticEvent"] = function (oEvent, bIsStartupRoundtrip) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["calculateOnBeforeSemanticEvent"]++;
        }
        ;  // eslint-disable-line complexity

        var oSemanticEvent = oEvent["mParameters"]["oSemanticEvent"],
            mUcfParameters = oSemanticEvent["mUcfParameters"],
            sStepName = '';

        if (!UCF_FesrUtil["bIsFESREnabled"]() ||
            UCF_FesrUtil["bGetFESRHandledByFramework"]() ||
            !(oEvent["mParameters"] && oEvent["mParameters"]["oSemanticEvent"] && oEvent["mParameters"]["oSemanticEvent"]["mUcfParameters"])) {
            return;
        }

        if (mUcfParameters["ClientAction"] === 'submitAsync' ||
            oSemanticEvent["sControl"] === "TimeTrigger") {

            //ignore folllowing requests:
            //async requests: record only sync request with the exception. Special case: during a normal roundtrip occurs a async requestand therefore consider the unlock e.g. SAPTableCS is requests data during the page update per async
            //time trigger: is fired without user interaction therefore no anyEvent occurs which can be used for the start time of FESR.
            UCF_FesrUtil["setValidRoundtrip"](false);

        } else {
            // only submit events are recorded. Assuming that async e.g. suggest or table scroll must not be recorded to reduce amount of entries in stats
            if (mUcfParameters["ClientAction"] === 'submit') {
                // step name calculation
                sStepName = UCF_JsUtil["filter"](
                    [oSemanticEvent["mParameters"]["Id"], oSemanticEvent["sControl"], oSemanticEvent["sName"]],
                    function (i) {
                        return i;
                    }
                )["join"]('-');

                if (bIsStartupRoundtrip) {
                    sStepName = 'START';
                }

                UCF_FesrUtil["setValidRoundtrip"](true);
                UCF_FesrUtil["setMetadata"]({"sStepName": sStepName, "sAction": sStepName});
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["calculateOnBeforeSemanticEvent"] = 0;
    }
    ;


    /**
     * Called from the framework to log the differnt steps.
     *
     * @public
     * @param {string} sType the type of the step ('DialogStepStart'; 'SendReq', 'GetResp' 'DialogStepEnd')
     * @param {Object} oMetadata meta data which should be updated
     */
    UCF_FesrUtil["logEvent"] = function (sType, oMetadata) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["logEvent"]++;
        }
        ;  // eslint-disable-line complexity

        var iCurTime = 0,
            sTransID = '';

        if (!UCF_FesrUtil["bFESREnabled"] || !UCF_FesrUtil["oCurrentDialogStep"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: LogEvent not processed as FESR not eanbled', "FesrUtil.js(516): logEvent");
            }
            ;
            return;
        }

        if (!UCF_FesrUtil["bValidRoundtrip"] && !(oMetadata && oMetadata["bIsDialogStepEnd"] && sType === 'DialogStepEnd')) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: logEvent not processed as bValidRoundtrip is false and it is not a DialogEndStep', "FesrUtil.js(521): logEvent");
            }
            ;
            // special handling - record the dialog step end (=unlock) even a async request occurs and therefore bValidRoundtrip is false. E.G SAP TableCS sends a async during page update
            return;
        }

        if (oMetadata) {

            if (UCF_FesrUtil["oCurrentDialogStep"] && oMetadata["hasOwnProperty"]('sAppName') && (oMetadata["sAppName"] !== UCF_FesrUtil["oCurrentDialogStep"]["sGetAppName"]())) {
                UCF_FesrUtil["oCurrentDialogStep"]["iInteractionType"] = 1; //AppName has changed in WebGUI --> new transaction
            }

            UCF_FesrUtil["setMetadata"](oMetadata);
        }

        iCurTime = UCF_Performance["iNow"](); // (new Date()).getTime();
        if (oMetadata && oMetadata["iEventTriggerTime"]) {
            iCurTime = oMetadata["iEventTriggerTime"];
        }

        switch (sType) {
            case 'DialogStepStart':
                UCF_FesrUtil["logTriggerReq"](iCurTime, UCF_FesrUtil["oCurrentDialogStep"]["oGetFrameworkStart"]());
                break;
            case 'SendReq':
                UCF_FesrUtil["logSendReq"](iCurTime);
                break;
            case 'GetResp':
                UCF_FesrUtil["logGetResp"](iCurTime);
                break;
            case 'DialogStepEnd':
                UCF_FesrUtil["logInpReady"](iCurTime);
                break;
            default:
                // no action
                break;
        }

        if (UCF_FesrUtil["oCurrentDialogStep"]["bGetDialogStepEnd"]()) {
            //End of dialog step.
            //Calculated data and send either via Beacon Request or
            //using Piggy-Back.

            if (UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] > 0) {
                UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"] = UCF_FesrUtil["oGetCalcFesr"](UCF_FesrUtil["oCurrentDialogStep"]);

                if (UCF_FesrUtil["notifyFESRTimes"]) {
                    UCF_FesrUtil["notifyFESRTimes"](
                        UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"],
                        UCF_FesrUtil["oCurrentDialogStep"]["sAppName"],
                        UCF_FesrUtil["oCurrentDialogStep"]["sStepName"],
                        UCF_FesrUtil["oCurrentDialogStep"]["sCompName"],
                        UCF_FesrUtil["oCurrentDialogStep"]["sAction"],
                        UCF_FesrUtil["sGetUISID"](UCF_FesrUtil["oCurrentDialogStep"]["sGetStepName"](), UCF_FesrUtil["oCurrentDialogStep"]["iGetStepCounter"]()), //clientId
                        UCF_FesrUtil["sRootCtxtID"],
                        UCF_FesrUtil["oCurrentDialogStep"]["sTransID"],
                        UCF_FesrUtil["bCompressed"],
                        UCF_FesrUtil["sClientOS"],
                        UCF_FesrUtil["sClientType"],
                        UCF_FesrUtil["sClientModel"]
                    );
                }

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'FESR: End Step calculated: ' + UCF_FesrUtil["oCurrentDialogStep"]["sGetStepName"]() +
                        ': E2ETime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iE2ETime"] +
                        ': ClientTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iClientTime"] +
                        ': ServerTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iServerTime"] +
                        ': NetworkTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iNetworkTime"] +
                        ': RoundtripTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iRoundtripTime"] +
                        ': RequestTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iRequestTime"] +
                        ': InteractionType=' + UCF_FesrUtil["oCurrentDialogStep"]["iInteractionType"] +
                        ': StepCounter=' + UCF_FesrUtil["oCurrentDialogStep"]["iStepCounter"] +
                        ': ClientNavigationTime(Handshake)=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iClientNavigationTime"] +
                        ': BeforeRequestTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iBeforeRequestTime"] +
                        ': AfterRequestTime=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iAfterRequestTime"] +
                        ': Roundtrip=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iRoundtrips"] +
                        ': DataSent=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iClientDataSent"] +
                        ': DataReceive=' + UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"]["iClientDataReceived"], "FesrUtil.js(583): logEvent");
                }
                ;

                if (!UCF_FesrUtil["bFESRDebugOnly"]) {
                    //transfer data only to server if DebuOnly is false -> don't send beacon, don't create oPreviousRoundtrip
                    if (UCF_FesrUtil["bUseBeaconRequest"]()) {
                        //Enqueue data for Beaconrequest
                        //definition is to send using name "SAP-Perf-FESRec" and to concenate without separator "SAP-Perf-FESRec-opt" and corresponsing data
                        UCF_FesrUtil["oBeacon"]["enqueueParameter"](
                            "SAP-Perf-FESRec",
                            UCF_FesrUtil["sGetPerfFESRec"](UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"])
                            + "SAP-Perf-FESRec-opt"
                            + UCF_FesrUtil["sGetPerfFESRecOpt"](UCF_FesrUtil["oCurrentDialogStep"]["oCalculated"])
                        );
                    } else {
                        //Move data to oPreviousRoundtrip to be able to record new dialog steps and sent it with nex roundtrip (Piggy-Back)
                        UCF_FesrUtil["oPreviousRoundtrip"] = UCF_FesrUtil["oCurrentDialogStep"];
                    }
                }
            }

            if (UCF_FesrUtil["sDebugMode"] === INFO) { //first roundtrip is done use DEBUG as trace level
                UCF_FesrUtil["sDebugMode"] = DEBUG;
            }

            //ToDo: once counter reaches 9999 reset to to 0 and generate a new sRootCtxtID
            UCF_FesrUtil["iStepCounter"]++; //increase counter

            sTransID = UCF_FesrUtil["sUpdateTransactionID"](UCF_FesrUtil["oCurrentDialogStep"]["sGetTransID"]());
            UCF_FesrUtil["oCurrentDialogStep"] = new UCF_FesrData(
                UCF_FesrUtil["oCurrentDialogStep"]["sGetAppName"](),
                UCF_FesrUtil["oCurrentDialogStep"]["sGetCompName"](),
                '',
                '',
                sTransID,
                UCF_FesrUtil["oFrameWorkStartType"]["No"],
                UCF_FesrUtil["iStepCounter"],
                2 //iInteraction type - followup rountrip
            );
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["logEvent"] = 0;
    }
    ;

    /**
     * Logs the user interaction which causes the roundtrip
     *
     * @private
     *
     * @see UCF_FesrUtil.logEvent
     * @param {int} iCurTime time stamp of the user interaction
     * @param {boolean} oFrameWorkStart framework start method
     */
    UCF_FesrUtil["logTriggerReq"] = function (iCurTime, oFrameWorkStart) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["logTriggerReq"]++;
        }
        ;

        //webgui calls this for every HTML/UR event and therefore it can be called several times until the real roundtrip occurs.

        var iRequestStart = window["performance"]["timing"]["requestStart"],
            iNavigationStart = window["performance"]["timing"]["navigationStart"],
            iResponseEnd = window["performance"]["timing"]["responseEnd"],
            aRoundtrips = null;

        aRoundtrips = UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"];

        if (oFrameWorkStart === UCF_FesrUtil["oFrameWorkStartType"]["TwoRoundtrip"] && aRoundtrips["length"] === 0) {
            // used only for start roundtrips
            // initial request is not recorded therefore record and create aRoundtrips here
            // ensure to write the inital request only once in case of method is called several times
            UCF_FesrUtil["oCurrentDialogStep"]["iRoundtrips"]++;
            aRoundtrips["push"]({
                "T0": iNavigationStart,
                "T1": iRequestStart,
                "T2": iRequestStart,
                "T3": iResponseEnd,
                "T4": 0,
                "iServerTime": 0,
                "iCntLngReq": 0,
                "iCntLngResp": 0
            });
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: Start: Log trigger request framework initial request time (Start request); NavigationStart T0:' + iNavigationStart + '; RequestStart T1: ' + iRequestStart + '; ResponseEnd T3: ' + iResponseEnd, "FesrUtil.js(665): logTriggerReq");
            }
            ;
        }
        //could be possible that more than one TriggerRequest occur, save always the latest and use this T1 time in logSendReq.
        //therefore create aRoundtrips not here but in logSendReq
        //in case of the framework start it is the T1 of the second roundtrip
        UCF_FesrUtil["oCurrentDialogStep"]["iInitialTriggerTime"] = iCurTime;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: T1: Log trigger request event time T1:' + iCurTime + ((UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] && UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] !== "") ? " Framework Info: " + UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] : ""), "FesrUtil.js(672): logTriggerReq");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["logTriggerReq"] = 0;
    }
    ;

    /**
     * Logs the time the request is sent to the server
     *
     * @private
     *
     * @see UCF_FesrUtil.logEvent
     * @param {int} iCurTime time stamp of the request
     */
    UCF_FesrUtil["logSendReq"] = function (iCurTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["logSendReq"]++;
        }
        ;

        var aRoundtrips = UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"];

        if (UCF_FesrUtil["oCurrentDialogStep"]["iInitialTriggerTime"] > 0) {
            //assume this is the first SendRequest --> create a new aRoundtrip entry with this values
            //or assume it is the initial framework start and create a new aRoundtrip entry with this values for the second start rountrip
            aRoundtrips["push"]({
                "T0": 0,
                "T1": UCF_FesrUtil["oCurrentDialogStep"]["iInitialTriggerTime"],
                "T2": iCurTime,
                "T3": 0,
                "T4": 0,
                "iServerTime": 0,
                "iCntLngReq": 0,
                "iCntLngResp": 0
            });
            UCF_FesrUtil["oCurrentDialogStep"]["iInitialTriggerTime"] = 0; //reset variable
        } else {
            //assume this is a follow up request of a user interaction step (more roundtrips for one user interaction)
            aRoundtrips["push"]({
                "T0": 0,
                "T1": 0,
                "T2": iCurTime,
                "T3": 0,
                "T4": 0,
                "iServerTime": 0,
                "iCntLngReq": 0,
                "iCntLngResp": 0
            });
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: T2: Log send request time T2:' + iCurTime + ((UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] && UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] !== "") ? " Framework Info: " + UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] : ""), "FesrUtil.js(697): logSendReq");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["logSendReq"] = 0;
    }
    ;

    /**
     * Logs the time of the response received from server
     *
     * @private
     *
     * @see UCF_FesrUtil.logEvent
     * @param {int} iCurTime time stamp of the response
     */
    UCF_FesrUtil["logGetResp"] = function (iCurTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["logGetResp"]++;
        }
        ;
        if (UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] > 0) {
            UCF_FesrUtil["oCurrentDialogStep"]["iRoundtrips"]++;
            UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"][UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] - 1]["T3"] = iCurTime;

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: T3: Log receive time T3: ' + iCurTime + ((UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] && UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] !== "") ? " Framework Info: " + UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] : ""), "FesrUtil.js(713): logGetResp");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["logGetResp"] = 0;
    }
    ;

    /**
     * Logs the time once the user interface is ready and accessible for the user
     *
     * @private
     *
     * @see UCF_FesrUtil.logEvent
     * @param {int} iCurTime time stamp of the unlock
     */
    UCF_FesrUtil["logInpReady"] = function (iCurTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["logInpReady"]++;
        }
        ;
        if (UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] > 0) {
            UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"][UCF_FesrUtil["oCurrentDialogStep"]["aRoundtrips"]["length"] - 1]["T4"] = iCurTime;

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(UCF_FesrUtil["sDebugMode"], 'FESR: T4: Log unlock time (ready to interact) T4:' + iCurTime + ((UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] && UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] !== "") ? " Framework Info: " + UCF_FesrUtil["oCurrentDialogStep"]["logFrameworkInfo"] : ""), "FesrUtil.js(729): logInpReady");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["logInpReady"] = 0;
    }
    ;

    /**
     * Calculates the values for FESR using oData
     *
     * @private
     * @param {Object} oData conatining all collected metadata
     * @return {Object} calculated meta data
     */
    UCF_FesrUtil["oGetCalcFesr"] = function (oData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["oGetCalcFesr"]++;
        }
        ;  // eslint-disable-line complexity

        var iServerTime = 0,
            iClientTime = 0,
            iNetworkTime = 0,
            iE2ETime = 0,
            iRequestTime = 0,
            iClientDataReceived = 0,
            iClientDataSent = 0,
            iClientNavigationTime = 0, //time for the very first handshake which is T1-T0 (e.g. SSL handshake etc). For follow up request it is always 0
            iRequestStartTime = 0, //time stamp of the first request send via extension_5 field
            bTimeCalcError = false,
            bServerTimeError = false,
            bClientDataReceivedError = false,
            bClientDataSentError = false,
            aItem = null,
            iBeforeRequestTime = 0, // not used by FESR only for Tracer
            aRoundtripTime = [],
            iRoundtripTime = 0, //time of roundtrips (non overlapping)
            i,
            j = 0;

        if (oData["aRoundtrips"]["length"] < 1) {
            return false;
        }

        /*
	Add for each roundtrip belonging to one user action the times. A user interaction might exists of one or more Roundtrips.
	T0 navigation start timestamp
  T1 request trigger timestamp
	T2 send request timestamp
	T3 get response timestamp
	T4 input ready timestamp

	Server time S: must be transfered from Server via sap-perf-fesrec or the sap-statistic->icmtotal
	Single rountrip time R: Time of a single roundtrip including the network time + server time  = T3-T2
	Request time:  (T3-T2) + (T3-T2) + (T3-T2) ... in case of parallel calls this could be larger than E2E
	Rountrip time: Considers overlapping roundtrips. R1+R2+R3 running in parallel and R4 after the end of R3. Roundtrip time = (T3 of R3 - T2 of R1) + (T3 of R4 - T2 of R4) which means: (End of R3 - Start of R1) + (End of R4 - Start of R4)
	Networt time: Sum of (R1-S1) - what is about overlapping networt time

	End-to-end time is-defined as T4 of last roundtrip - T1 of first roundtrip (in the very first roundtrip it is T0 which is considered in HandShaekTime)
	Client time: is E2E - Roundtrip time

	In case of WDA and ITS normally Rountrip Time = Request Time

	Test data: oData["aRoundtrips"]=[{T0: 0, T1: 20, T2: 30, T3: 100, T4: 110},{T0: 0, T1: 20, T2: 40, T3: 130, T4: 140},{T0: 0, T1: 20, T2: 35, T3: 120, T4: 130},{T0: 0, T1: 150, T2: 160, T3: 200, T4: 210}]

	*/

        for (i = 0; i < oData["aRoundtrips"]["length"]; i++) {
            aItem = oData["aRoundtrips"][i];

            if (aItem["T2"] === 0 || aItem["T3"] === 0) {
                bTimeCalcError = true;
            }
            iRequestTime += oData["aRoundtrips"][i]["T3"] - oData["aRoundtrips"][i]["T2"];

            //Calculate the roundtrip time considreing parallel roundtrips. R1+R2+R3 running in parallel and R4 after the end of R3.
            //aRoundtripTime[0] = max(T3 of R1-R3) - min(T2 of R1-R3)
            //aRoundtripTime[1] = (T3 of R4 - T2 of R4)
            if (aRoundtripTime["length"] <= j) {
                aRoundtripTime["push"]({"start": aItem["T2"], "end": aItem["T3"]});
            } else {
                aRoundtripTime[j]["end"] = Math["max"](aRoundtripTime[j]["end"], aItem["T3"]);
                aRoundtripTime[j]["start"] = Math["min"](aRoundtripTime[j]["start"], aItem["T2"]);
            }

            if (!((i + 1 < oData["aRoundtrips"]["length"]) && (Math["max"](aRoundtripTime[j]["end"], aItem["T3"]) > oData["aRoundtrips"][i + 1]["T2"]))) {
                //next rountrip (if exists) does not run in parallel to previous roundtrips ( maximal end time T3 of previous roundtrips < start time T2 )
                iRoundtripTime += aRoundtripTime[j]["end"] - aRoundtripTime[j]["start"];
                j++;
            }

            //Adjust server time for first roundtrip and caclulate it
            if (aItem["iServerTime"] === 0) {
                if (oData["oFrameWorkStart"] === UCF_FesrUtil["oFrameWorkStartType"]["TwoRoundtrip"]) {
                    aItem["iServerTime"] = iRequestTime; //in the first roundtrip we can't access HTTP response and therfore server time is always 0 --> use RequestTime as ServerTime even this isn't 100% correct
                } else {
                    bServerTimeError = true;
                }

            }
            iServerTime += aItem["iServerTime"];

            //calculate sent data
            if (aItem["iCntLngReq"] === 0) {
                bClientDataSentError = true;
            }
            iClientDataSent += aItem["iCntLngReq"];

            if (aItem["iCntLngResp"] === 0) {
                bClientDataReceivedError = true;
            }
            iClientDataReceived += aItem["iCntLngResp"];
        }

        iRequestStartTime = oData["aRoundtrips"][0]["T1"];
        //used oly in tracer. Assuming the iBeforeRequestTime is only of the first roundtrip all others requests are without user interaction and time counts to iAfterRequestTime
        iBeforeRequestTime = oData["aRoundtrips"][0]["T2"] - oData["aRoundtrips"][0]["T1"]; // used only in tracer

        //caclulate iClientNavigationTime (handshake time) - time betwen T1-T0 is the time used for hand shaking, redirect etc in the very first roundtrip. It will be transfered separatly and not part of network time. Consider it for E2ETime
        if (oData["oFrameWorkStart"] === UCF_FesrUtil["oFrameWorkStartType"]["TwoRoundtrip"]) {
            iClientNavigationTime = oData["aRoundtrips"][0]["T1"] - oData["aRoundtrips"][0]["T0"];
            if (iClientNavigationTime <= 0) iClientNavigationTime = 0;

            iRequestStartTime = oData["aRoundtrips"][0]["T0"]; //first roundtrip use T0 insetad of T1;
        }

        //defintion is to tranfer the ISO Time (with timezone 0 without T or Z delimeter) in Compact UTC DateTime YYYYMMDDHHMMSSFFFFFF
        try {
            iRequestStartTime = new Date(iRequestStartTime)["toISOString"]()["replace"](/\.|:|-|T|Z/g, "");
        } catch (e) {
            iRequestStartTime = 0;
        }

        if (oData["aRoundtrips"][oData["aRoundtrips"]["length"] - 1]["T4"] === 0 || oData["aRoundtrips"][0]["T1"] === 0) {
            bTimeCalcError = true;
        } else {
            iE2ETime = (oData["aRoundtrips"][oData["aRoundtrips"]["length"] - 1]["T4"] - oData["aRoundtrips"][0]["T1"]) + iClientNavigationTime;
        }

        if (bTimeCalcError) {
            iClientTime = iNetworkTime = iE2ETime = iBeforeRequestTime = iRequestTime = 0;
        } else {
            iClientTime = iE2ETime - iRoundtripTime - iClientNavigationTime; //ClientTime is E2ETime - Rountriptime - iClientNavigationTime. ClientNavigationTime is not added to ClientTime but transfered separatly

            if (!bServerTimeError) {
                iNetworkTime = iRequestTime - iServerTime;
            }
        }

        if (bClientDataReceivedError) {
            iClientDataReceived = 0;
        }
        if (bClientDataSentError) {
            iClientDataSent = 0;
        }
        if (bServerTimeError) {
            iServerTime = 0;
        }

        return {
            "iNetworkTime": iNetworkTime,
            "iServerTime": iServerTime,
            "iClientTime": iClientTime,
            "iE2ETime": iE2ETime,
            "iClientNavigationTime": iClientNavigationTime,
            "iClientDataSent": iClientDataSent,
            "iClientDataReceived": iClientDataReceived,
            "iRoundtrips": oData["iRoundtrips"],
            "iRequestTime": iRequestTime,
            "iRoundtripTime": iRoundtripTime,
            "iBeforeRequestTime": iBeforeRequestTime,
            "iAfterRequestTime": iClientTime - iBeforeRequestTime,
            "iRequestStartTime": iRequestStartTime,
            "sTransID": oData["sGetTransID"](),
            "sAppName": oData["sGetAppName"](),
            "sStepName": oData["sGetStepName"](),
            "iStepCounter": oData["iGetStepCounter"](),
            "iInteractionType": oData["iGetInteractionType"]()
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["oGetCalcFesr"] = 0;
    }
    ;

    /* eslint-disable no-magic-numbers */

    /**
     * Recalculates the transaction ID
     *
     * @private
     * @param {string} sTransID previous transaction ID
     * @return {string} recalculated transaction ID
     */
    UCF_FesrUtil["sUpdateTransactionID"] = function (sTransID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sUpdateTransactionID"]++;
        }
        ;
        var iLength = sTransID["length"],
            iSubPart = parseInt(sTransID["substr"](iLength - 6), 10) + Math["floor"](Math["random"]() * 8) + 1,
            sTransPart = '000000' + iSubPart;

        return sTransID["substr"](0, iLength - 6) + sTransPart["substr"](sTransPart["length"] - 6);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sUpdateTransactionID"] = 0;
    }
    ;

    /**
     * Provides the UISID (user-interaction-step-ID)
     *
     * @private
     * @param {string} sStepName Step Name
     * @param {integer} iStepCounter Step counter
     * @return {string} UISID with max length of 40
     */
    UCF_FesrUtil["sGetUISID"] = function (sStepName, iStepCounter) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sGetUISID"]++;
        }
        ;
        return UCF_FesrUtil["format"](sStepName, 34, false, true) + "_" + iStepCounter;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sGetUISID"] = 0;
    }
    ;

    /**
     * Calculates the server time
     *
     * @private
     * @param {XMLHttpRequest} oResponse the HTTP response
     * @return {int} server time
     */
    UCF_FesrUtil["iGetServerTime"] = function (oResponse) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["iGetServerTime"]++;
        }
        ;
        // eslint-disable-next-line no-magic-numbers
        var iServerTime = 0;

        //use ICMTotal od sap-statistics instead of sap-perf-fesrec as in certain cases with ITS type ahead the sap-perf-fesrec is to high because of ABAP compiling.
        iServerTime = UCF_FesrUtil["iGetICMTotal"](oResponse["getResponseHeader"]('sap-statistics'));

        //old using sap-sap-perf-fesrec (fallback)
        if (iServerTime <= 0) {
            iServerTime = UCF_FesrUtil["iGetPerfFESRec"](oResponse["getResponseHeader"]('sap-perf-fesrec'));
        }

        return iServerTime;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["iGetServerTime"] = 0;
    }
    ;

    /**
     * Calculates the server time according sap-statistics and ICM Total
     *
     * @private
     * @param {string} sSapStatistic the sapStatistic header
     * @return {int} server time
     */
    UCF_FesrUtil["iGetICMTotal"] = function (sSapStatistic) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["iGetICMTotal"]++;
        }
        ;

        var iPos1 = 0;
        var iPos2 = 0;
        var iServerTime = 0;
        var sToken = "icmext=";

        try {
            if (!sSapStatistic || sSapStatistic === "") return iServerTime;

            iPos1 = sSapStatistic["indexOf"](sToken);
            iPos2 = sSapStatistic["indexOf"](",", iPos1);
            if (iPos1 < iPos2) {
                iServerTime = parseInt(sSapStatistic["substring"](iPos1 + sToken["length"], iPos2));
            }
        } catch (e) {
            iServerTime = 0;
        }

        return iServerTime;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["iGetICMTotal"] = 0;
    }
    ;

    /**
     * Calculates the server time according sap-perf-fesrec
     *
     * @private
     * @param {string} sServerTime the sap-perf-fesrec header
     * @return {int} server time
     */
    UCF_FesrUtil["iGetPerfFESRec"] = function (sServerTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["iGetPerfFESRec"]++;
        }
        ;
        // eslint-disable-next-line no-magic-numbers
        return sServerTime ? Math["round"](parseInt(sServerTime) / 1000) : 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["iGetPerfFESRec"] = 0;
    }
    ;

    /**
     * Set a request header and returns the length of the header/value pair
     * successful, the text and the XML document
     *
     *  @private
     * @param {XMLHttpRequest} oXmlHttp Object
     * @param {string} sHeader header name of the request header
     * @param {string} sValue value of the request header
     *
     * @return {int} Length of the header/value pair
     */
    UCF_FesrUtil["iSetRequestHeader"] = function (oXmlHttp, sHeader, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["iSetRequestHeader"]++;
        }
        ;

        var iLength = 0;
        if (!UCF_FesrUtil["bFESRDebugOnly"]) {
            //transfer data only to server if DebuOnly is false
            oXmlHttp["setRequestHeader"](sHeader, sValue);

            // UI5 uses "(sHeader.length + sValue.length + 3) * 2" due to double string length for byte length as in js characters are stored as 16 bit ints: According HTTPWatch this is wrong
            // sHeader + ': ' + sValue + ' '   --  means two blank and one colon === 3
            iLength = sHeader["length"] + sValue["length"] + 3;
        }

        return iLength;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["iSetRequestHeader"] = 0;
    }
    ;

    UCF_FesrUtil["bGetFESRHandledByFramework"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["bGetFESRHandledByFramework"]++;
        }
        ;
        return UCF_FesrUtil["bFESRHandledByFramework"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["bGetFESRHandledByFramework"] = 0;
    }
    ;

    UCF_FesrUtil["bIsFESREnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["bIsFESREnabled"]++;
        }
        ;
        return UCF_FesrUtil["bFESREnabled"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["bIsFESREnabled"] = 0;
    }
    ;

    /**
     * Sets whether FESR is enabled or not
     *
     * @public
     * @param {boolean} bFESREnabled whether FESR is enabled or not
     */
    UCF_FesrUtil["setFESREnabled"] = function (bFESREnabled) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["setFESREnabled"]++;
        }
        ;
        UCF_FesrUtil["bFESREnabled"] = bFESREnabled;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["setFESREnabled"] = 0;
    }
    ;

    /**
     * Sets whether the step should be recorded or not
     *
     * @public
     * @param {boolean} bValidRoundtrip whether the roundtrip should be recorded or not
     */
    UCF_FesrUtil["setValidRoundtrip"] = function (bValidRoundtrip) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["setValidRoundtrip"]++;
        }
        ;
        UCF_FesrUtil["bValidRoundtrip"] = bValidRoundtrip;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["setValidRoundtrip"] = 0;
    }
    ;

    /* ***************** SAP UI 5 copied and adjusted coding */

    /**
     * Returns the Perf FESR Rec Header
     *
     * @private
     * @see https://wiki.wdf.sap.corp/wiki/pages/viewpage.action?pageId=1882160234
     * @param {Object} oCalculatedData calulacted fata of the FESR dialog step
     * @return {string} the SAP-Perf-FESRec header
     */
    UCF_FesrUtil["sGetPerfFESRec"] = function (oCalculatedData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sGetPerfFESRec"]++;
        }
        ;

        return [
            UCF_FesrUtil["format"](UCF_FesrUtil["sRootCtxtID"], 32), // root_context_id
            UCF_FesrUtil["format"](oCalculatedData["sTransID"], 32), // transaction_id
            UCF_FesrUtil["formatInt"](oCalculatedData["iClientNavigationTime"], 4), // client_navigation_time (w3c_navigation_time)
            UCF_FesrUtil["formatInt"](oCalculatedData["iRoundtripTime"], 4), //client_round_trip_time
            UCF_FesrUtil["formatInt"](oCalculatedData["iE2ETime"], 4), // end_to_end_time
            UCF_FesrUtil["formatInt"](oCalculatedData["iRoundtrips"], 2), // completed network_round_trips
            UCF_FesrUtil["format"](UCF_FesrUtil["sGetUISID"](oCalculatedData["sStepName"], oCalculatedData["iStepCounter"]), 40), // former client_id - UISID (user-interaction-step-ID)
            UCF_FesrUtil["formatInt"](oCalculatedData["iNetworkTime"], 4), // network_time
            UCF_FesrUtil["formatInt"](oCalculatedData["iRequestTime"], 4), // request_time
            UCF_FesrUtil["format"](UCF_FesrUtil["sClientOS"], 20), // client_os
            UCF_FesrUtil["format"](UCF_FesrUtil["sClientType"], 10) // client_type
        ]["join"](',');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sGetPerfFESRec"] = 0;
    }
    ;

    /**
     * Returns the Perf FESR Rec Option Header
     *
     * @private
     * @see https://wiki.wdf.sap.corp/wiki/pages/viewpage.action?pageId=1882160234
     * @param {Object} oCalculatedData calulacted fata of the FESR dialog step
     * @return {string} the SAP-Perf-FESRecOpt header
     */
    UCF_FesrUtil["sGetPerfFESRecOpt"] = function (oCalculatedData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sGetPerfFESRecOpt"]++;
        }
        ;
        return [
            !UCF_FesrUtil["isASCII"](oCalculatedData["sAppName"]) ? "invalid_appname" : UCF_FesrUtil["format"](oCalculatedData["sAppName"], 20, true), // application_name
            !UCF_FesrUtil["isASCII"](oCalculatedData["sStepName"]) ? "invalid_stepname" : UCF_FesrUtil["format"](oCalculatedData["sStepName"], 20, true), // step_name
            '', // not assigned
            UCF_FesrUtil["format"](UCF_FesrUtil["sClientModel"], 20), // client_model
            UCF_FesrUtil["formatInt"](oCalculatedData["iClientDataSent"], 4), // client_data_sent(not available because of possible compression)
            UCF_FesrUtil["formatInt"](oCalculatedData["iClientDataReceived"], 4), // client_data_received(not available because of possible compression)
            '', // network_protocol
            '', // network_provider
            UCF_FesrUtil["formatInt"](oCalculatedData["iClientTime"], 4), // client_processing_time (w3c_response_time)
            UCF_FesrUtil["bCompressed"] ? 'X' : '', // compressed
            '', // not assigned
            '', // persistency_accesses
            '', // persistency_time
            '', // persistency_data_transferred
            '', // extension_1 - - busy duration ???
            UCF_FesrUtil["formatInt"](oCalculatedData["iInteractionType"] || 2, 4), // extension_2 type of interaction: 0 = not implemented, 1 = app start, 2 = follow up step, 3 = unknown
            UCF_FesrUtil["format"](UCF_UserAgent["iGetDeviceType"](), 10), // extension_3 used for DeviceType
            '', // extension_4
            UCF_FesrUtil["format"](oCalculatedData["iRequestStartTime"], 20), // extension_5 used for RequestTime in CompactUTCTime
            !UCF_FesrUtil["isASCII"](oCalculatedData["sAppName"]) ? "" : UCF_FesrUtil["format"](oCalculatedData["sAppName"], 70, true) // application_name with 70 characters, trimmed from left
        ]["join"](',');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sGetPerfFESRecOpt"] = 0;
    }
    ;

    /**
     * Calculates Passport aligned to SAP UI5 implementation
     *
     * @private
     * @return {string} the SAP-PASSPORT header
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     */

    UCF_FesrUtil["sGetPassport"] = function (trcLvl, RootID, TransID, sComponent, sAction, sPassportPrefix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sGetPassport"]++;
        }
        ;

        var SAPEPPTemplateLow = [
            0x2A, 0x54, 0x48, 0x2A, 0x03, 0x00, 0xE6, 0x00, 0x00, 0x53, 0x41, 0x50, 0x5F, 0x45, 0x32, 0x45, 0x5F, 0x54, 0x41, 0x5F, 0x50, 0x6C, 0x75, 0x67,
            0x49, 0x6E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x53, 0x41, 0x50, 0x5F, 0x45,
            0x32, 0x45, 0x5F, 0x54, 0x41, 0x5F, 0x55, 0x73, 0x65, 0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x53, 0x41, 0x50, 0x5F, 0x45, 0x32, 0x45, 0x5F, 0x54, 0x41, 0x5F, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x05, 0x53, 0x41, 0x50,
            0x5F, 0x45, 0x32, 0x45, 0x5F, 0x54, 0x41, 0x5F, 0x50, 0x6C, 0x75, 0x67, 0x49, 0x6E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
            0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x36, 0x33, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x33, 0x31, 0x31, 0x45, 0x45, 0x30, 0x41, 0x35, 0x44,
            0x32, 0x35, 0x30, 0x39, 0x39, 0x39, 0x43, 0x33, 0x39, 0x32, 0x42, 0x36, 0x38, 0x20, 0x20, 0x20, 0x00, 0x07, 0x46, 0x35, 0x00, 0x00, 0x00, 0x31,
            0x1E, 0xE0, 0xA5, 0xD2, 0x4E, 0xDB, 0xB2, 0xE4, 0x4B, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE2, 0x2A, 0x54, 0x48, 0x2A
        ];

        var RootIDPosLen = [372, 32],
            TransIDPosLen = [149, 32],
            CompNamePosLEn = [9, 32],
            PreCompNamePosLEn = [117, 32],
            actionOffset = [75, 40],
            traceFlgsOffset = [7, 2],
            prefix = UCF_JsUtil["aGetCharCodeFromString"](sPassportPrefix),
            retVal = '';

        prefix = prefix["concat"](UCF_JsUtil["aGetCharCodeFromString"](UCF_JsUtil["aGetCharArray"](32 + 1 - prefix["length"], ' ')));

        if (sComponent) {
            sComponent = (UCF_JsUtil["aGetCharCodeFromString"](sComponent["substr"](-32, 32)));
            sComponent = sComponent["concat"](UCF_JsUtil["aGetCharCodeFromString"](UCF_JsUtil["aGetCharArray"](32 + 1 - sComponent["length"], ' ')));
            SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, CompNamePosLEn["concat"](sComponent));
            SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, PreCompNamePosLEn["concat"](sComponent));
        } else {
            SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, CompNamePosLEn["concat"](prefix));
            SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, PreCompNamePosLEn["concat"](prefix));
        }
        SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, TransIDPosLen["concat"](UCF_JsUtil["aGetCharCodeFromString"](TransID)));
        SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, traceFlgsOffset["concat"](trcLvl));
        if (sAction) {
            sAction = UCF_JsUtil["aGetCharCodeFromString"](sAction["substr"](-40, 40));
            sAction = sAction["concat"](UCF_JsUtil["aGetCharCodeFromString"](UCF_JsUtil["aGetCharArray"](40 + 1 - sAction["length"], ' ')));
            SAPEPPTemplateLow["splice"]["apply"](SAPEPPTemplateLow, actionOffset["concat"](sAction));
        }
        retVal = UCF_FesrUtil["createHexString"](SAPEPPTemplateLow)["toUpperCase"]();

        return retVal["substring"](0, RootIDPosLen[0])["concat"](RootID) + retVal["substring"](RootIDPosLen[0] + RootIDPosLen[1]);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sGetPassport"] = 0;
    }
    ;

    /**
     * Creates a HEX string of an string array: Aligned to SAP UI5 and ITS implementation
     *
     * @private
     * @param {Array} aArr arary to convert
     * @return {string} the converted string in hex
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     */
    UCF_FesrUtil["createHexString"] = function (aArr) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["createHexString"]++;
        }
        ;
        var s = '',
            u,
            l,
            i;

        for (i = 0; i < aArr["length"]; ++i) {
            u = '' + aArr[i] / 16;
            if (u["indexOf"]('.') > 0) {
                u = u["substr"](0, u["indexOf"]('.'));
            }
            l = aArr[i] % 16;
            s = s + '0123456789ABCDEF'["substr"](u, 1);
            s = s + '0123456789ABCDEF'["substr"](l, 1);
        }

        return s;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["createHexString"] = 0;
    }
    ;

    /**
     * Creates a GUID: Aligned to SAP UI5 implementation
     *
     * @private
     * @return {string} the GUID
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     */
    UCF_FesrUtil["createGUID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["createGUID"]++;
        }
        ;

        var retVal = '';

        var S4 = function () {
            var temp = Math["floor"](Math["random"]() * 0x10000);

            return UCF_JsUtil["aGetCharArray"](4 + 1 - temp["toString"](16)["length"], '0') + temp["toString"](16);
        };
        var S5 = function () {
            var temp = (Math["floor"](Math["random"]() * 0x10000) & 0x0fff) + 0x4000; // NOSONAR

            return UCF_JsUtil["aGetCharArray"](4 + 1 - temp["toString"](16)["length"], '0') + temp["toString"](16);
        };
        var S6 = function () {
            var temp = (Math["floor"](Math["random"]() * 0x10000) & 0x3fff) + 0x8000; // NOSONAR

            return UCF_JsUtil["aGetCharArray"](4 + 1 - temp["toString"](16)["length"], '0') + temp["toString"](16);
        };

        retVal = (S4() + S4() + // '-' +
            S4() + // '-' +
            S5() + // '-' +
            S6() + // '-' +
            S4() + S4() + S4());

        return retVal["toUpperCase"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["createGUID"] = 0;
    }
    ;

    /**
     * Provides the necessary Trace-Level for Passport.
     *
     * @private
     * @param {string} lvl level of tracing
     * @return {Array} Trace level used for Passprot
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     */
    UCF_FesrUtil["traceFlags"] = function (lvl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["traceFlags"]++;
        }
        ;
        var iE2eTraceLevel = [];

        switch (lvl) {
            case 'low':
                iE2eTraceLevel = [0x00, 0x00];
                break;
            case 'medium':
                iE2eTraceLevel = [0x89, 0x0A];
                break;
            case 'high':
                iE2eTraceLevel = [0x9F, 0x0D];
                break;
            default:
                iE2eTraceLevel["push"]((parseInt(lvl, 16) & 0xFF00) / 256);
                iE2eTraceLevel["push"]((parseInt(lvl, 16) & 0xFF));
        }

        return iE2eTraceLevel;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["traceFlags"] = 0;
    }
    ;

    /**
     * Format string to fesr compliant string
     *
     * @private
     * @param {Object} vField the value to format
     * @param {int} iLength maximum length
     * @param {boolean} bCutFromFront if the value should be cut from end or beginning
     * @param {boolean} bIgnoreEncoding if the string should not be encoded
     * @return {string} formated string
     * @see https://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/jquery.sap.trace.js
     */
    UCF_FesrUtil["format"] = function (vField, iLength, bCutFromFront, bIgnoreEncoding) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["format"]++;
        }
        ;

        if (!vField) {
            vField = vField === 0 ? '0' : '';
        } else if (typeof vField === 'number') {
            // Calculation of figures may be erroneous because incomplete performance entries lead to negative
            // numbers. Use 0 as the kernel field is a unsigned field
            vField = Math["max"](0, vField);
            vField = Math["round"](vField)["toString"]();

            if (vField["length"] > iLength) {
                vField = "0";
            }

        } else {
            vField = bCutFromFront ? vField["substr"](-iLength, iLength) : vField["substr"](0, iLength);
        }

        if (bIgnoreEncoding) {
            return vField;
        } else {
            return UCF_FesrUtil["sEnocdeReservedCharacters"](vField);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["format"] = 0;
    }
    ;


    /** Format a int number to fesr compliant specs considering the backend data types
     * If given number is negative or not compliant we format to -1.
     * Supports int1/2/4.
     * @private
     * @param {int} iNumber the value to format
     * @param {int} iBytes sap_int1/2/4
     * @return {string} formated value
     * @see https://git.wdf.sap.corp/plugins/gitiles/openui5/+/master/src/sap.ui.core/src/sap/ui/performance/trace/FESR.js
     */
    UCF_FesrUtil["formatInt"] = function (iNumber, iBytes) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["formatInt"]++;
        }
        ;
        var sNumber = "";
        if (typeof iNumber !== "number") {
            iNumber = "";
        } else {
            var max = Math["pow"](256, iBytes) / 2 - 1;
            iNumber = Math["round"](iNumber);
            sNumber = iNumber >= 0 && iNumber <= max ? iNumber["toString"]() : "-1";
        }
        return sNumber;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["formatInt"] = 0;
    }
    ;


    /**
     * Test whether the string contains only ASCII characters
     *
     * @private
     * @param {string} sStr String to test
     * @return {boolean} whether the string contains only ASCII characters
     */
    UCF_FesrUtil["isASCII"] = function (sStr) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["isASCII"]++;
        }
        ;
        return /^[\x20-\x7F]*$/["test"](sStr);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["isASCII"] = 0;
    }
    ;

    /**
     * Encode and replace reserved charcters
     *
     * @private
     * @param {string} sStr String to test
     * @return {string} encoded string
     */
    UCF_FesrUtil["sEnocdeReservedCharacters"] = function (sStr) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sEnocdeReservedCharacters"]++;
        }
        ;
        //Ensure to encode comma as it is a separator in the FESR strings

        //the beacon implementation on server doesn't support encoding - replace the FESR separator comma by underline
        //the old piggy-back implementation on server supports encoding of comma and backlash
        //    but decision was to relace _ in all case but need to ensure to encode backlash to be compliant in the piggy back case
        //todo: implement correct encoding / decoding on server side and then client side

        sStr = UCF_FesrUtil["sReplaceReservedCharacters"](sStr);

        if (!UCF_FesrUtil["bUseBeaconRequest"]()) {
            //the old piggy-back implementation on server supports encoding --> encode backlash to be compliant
            sStr = sStr["replace"](/\\/g, "\\\\"); //.replace(/,/g, "\\,");
        }

        return sStr;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sEnocdeReservedCharacters"] = 0;
    }
    ;

    /**
     * Replace reserved charcters
     *
     * @private
     * @param {string} sStr String to replace
     * @return {string} replaced string
     */
    UCF_FesrUtil["sReplaceReservedCharacters"] = function (sStr) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FesrUtil["_"]["sReplaceReservedCharacters"]++;
        }
        ;
        //the beacon implementation on server doesn't support encoding - replace the FESR separator comma by underline
        return sStr["replace"](/,/g, "_");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FesrUtil["_"]["sReplaceReservedCharacters"] = 0;
    }
    ;

    /* eslint-enable no-magic-numbers */


    UCF_FesrUtil.prototype["aPublicMethods"] = ["initFESR", "setMetadata", "setBeacon", "flushBeacon", "setFESRTimesCallBack", "notifyRequest", "notifyResponse", "calculateOnBeforeSemanticEvent", "logEvent", "setFESREnabled", "setValidRoundtrip"].concat(UCF_FesrUtil.prototype.aPublicMethods || []);
    /* global _assert, _trace, _tracedelayed, DEBUG, INFO, WARNING, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="./RequestUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="./StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>
    /* global UCF_System */
/// <reference path="../../ls/core/System.js"/>

    /**
     * @typedef {Object} UCF_JsUtil_DelayedCall
     * @property {Object} oObject
     * @property {string} sMethodName
     * @property {Array<any>} aParameters
     * @property {string} sTimeoutId
     * @property {string} sInfo
     */

    /**
     * @typedef {Object} UCF_JsUtil_IntervalCall
     * @property {Object} oObject
     * @property {string} sMethodName
     * @property {Array<any>} aParameters
     * @property {string} sIntervalId
     */

    /**
     * JS object/array utility functions
     *
     * @class
     *
     * @static
     * @version
     */
    function UCF_JsUtil() {
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["UCF_JsUtil"]++;
        }
        ;
    };window["UCF_JsUtil"] = UCF_JsUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_JsUtil");
        UCF_JsUtil["_"] = {UCF_JsUtil: 0};
    }
    ;
    ;

    /**
     * @type {Object<string, UCF_JsUtil_DelayedCall>}
     */
    UCF_JsUtil["mDelayedCalls"] = {};
    /**
     * @type {Object<string, UCF_JsUtil_IntervalCall>}
     */
    UCF_JsUtil["mIntervalCalls"] = {};
    /**
     * @type {number}
     */
    UCF_JsUtil["iIdCounter"] = 0;

    /**
     * Mangling URL pattern to remove the session id (hex64) from URL
     * Defined by Martin Z.
     *
     * matches /(<hex64 code>) | xyz(<hex64 code>) | ;sap-ext-sid=<hex64 code>
     *  /(<hex64 code>) will be removed e.g. /bc/(hex64)/test --> bc/test
     *  (<hex64 code>) will be replace e.g. /sap(hex64)/test --> /sap/test
     *  sap;sap-ext-sid=<hex64 code>? will be replcaed e.g. /sap?
     * @example
     * ```
     * https://server:port/(chm78zuiUiOp89ghghzt675gtzr54rtzhuzvjlfjvdnvlkdfhviudfvksnviudshvksjdnvksdvookknbbngzhjhggfgvgvhggcxhgg=)/bc/...
     * https://server:port/sap(chm78zuiUiOp89ghghzt675gtzr54rtzhuzvjlfjvdnvlkdfhviudfvksnviudshvksjdnvksdvookknbbngzhjhggfgvgvhggcxhgg=)/bc/...
     * https://server:port/sap;~sysid=AZY;sap-ext-sid=_VG__hm78zuiUiOp89ghh--_VG__hm78zuiUiOp89ghh--?sap-ep-version=7
     * ```
     * @constant {RegExp}
     */
    UCF_JsUtil["rManglingURLPattern"] = /\/\((?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?\)|\((?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?\)|;sap-ext-sid=([^;?#\/]+)/;

    /**
     * Used to save whether localStorage is supported or not
     * @type {boolean}
     */
    UCF_JsUtil["bLocalStorage"] = null;

    /** @typedef {0} UCF_JsUtil_NoneModifier */
    /** @typedef {1} UCF_JsUtil_ShiftModifier */
    /** @typedef {2} UCF_JsUtil_CtrlModifier */
    /** @typedef {4} UCF_JsUtil_AltModifier */
    /** @typedef {100} UCF_JsUtil_AllModifier */
    /** @typedef {101} UCF_JsUtil_NoneOrShiftModifier */
    /** @typedef {102} UCF_JsUtil_NoneOrCtrlModifier */
    /** @typedef {103} UCF_JsUtil_NoneOrShiftXorCtrlModifier */
    /** @typedef {UCF_JsUtil_NoneModifier|UCF_JsUtil_ShiftModifier|UCF_JsUtil_CtrlModifier|UCF_JsUtil_AltModifier|UCF_JsUtil_AllModifier|UCF_JsUtil_NoneOrShiftModifier|UCF_JsUtil_NoneOrCtrlModifier|UCF_JsUtil_NoneOrShiftXorCtrlModifier} UCF_JsUtil_Modifier */
    /**
     * @typedef {Object} UCF_JsUtil_ModifierEnum
     * @property {UCF_JsUtil_NoneModifier} NONE
     * @property {UCF_JsUtil_ShiftModifier} SHIFT
     * @property {UCF_JsUtil_CtrlModifier} CTRL
     * @property {UCF_JsUtil_AltModifier} ALT
     * @property {UCF_JsUtil_AllModifier} ALL
     * @property {UCF_JsUtil_NoneOrShiftModifier} NONE_OR_SHIFT
     * @property {UCF_JsUtil_NoneOrCtrlModifier} NONE_OR_CTRL
     * @property {UCF_JsUtil_NoneOrShiftXorCtrlModifier} NONE_OR_SHIFT_XOR_CTRL
     */
    /**
     * @type {UCF_JsUtil_ModifierEnum} Keyboard modifier. First three bits can be
     * used for map. Bit 4 is reserved. Everything above 15 can be used for special
     * conditional combinations.
     */
    UCF_JsUtil["MODIFIER"] = {
        "NONE": 0,
        "SHIFT": 1,
        "CTRL": 2,
        "ALT": 4,
        "ALL": 100,
        "NONE_OR_SHIFT": 101,
        "NONE_OR_CTRL": 102,
        "NONE_OR_SHIFT_XOR_CTRL": 103
    };

    /**
     * @static
     * @type {function(any, (function(string,any):any|Array<number,string>)?, (number|string)?): string}
     */
    UCF_JsUtil["_sJsonStringify"] = null;

    /**
     * Missing implementations for
     * - Objects implementing toJSON()
     * - Replacer on root level (key='', value=oValue)
     * - TypeError on circular references (!)
     *
     * @static
     * @param {any} oValue
     * @param {function(string,any):any|Array<number,string>} [oReplacer]
     * @param {number|string} [oSpace]
     * @param {string[]} [aBuffer=[]]
     * @param {string} [sIndent='']
     * @return {string}
     */
    UCF_JsUtil["sJsonStringifyFallback"] = function (oValue, oReplacer, oSpace, aBuffer, sIndent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sJsonStringifyFallback"]++;
        }
        ;
        /** @type {number} */
        var i;
        /** @type {string} */
        var sSpace = oSpace
            ? typeof oSpace === 'number'
                // eslint-disable-next-line no-magic-numbers
                ? '          '["slice"](-Math["max"](Math["min"](10, oSpace), 0))
                // eslint-disable-next-line no-magic-numbers
                : oSpace["slice"](0, 10)
            : '';
        /** @type {boolean} */
        var bFirst = true;
        /** @type {string} */
        var sInnerIndent;
        /** @type {string} */
        var sKey;
        /** @type {any} */
        var oReplacedValue;

        if (!aBuffer) {
            aBuffer = [];
        }

        if (typeof sIndent !== 'string') {
            sIndent = '';
        }

        sInnerIndent = sSpace + sIndent;

        switch (typeof oValue) {
            case 'object':
                if (oValue instanceof Array) {
                    aBuffer["push"]('[');
                    for (i = 0; i < oValue["length"]; i++) {
                        if (typeof oValue[i] === 'undefined') {
                            continue;
                        }

                        oReplacedValue = (oValue[i] && oValue[i]["toJSON"])
                            ? oValue[i]["toJSON"](i)
                            : oValue[i];
                        oReplacedValue = oReplacer
                            ? oReplacer instanceof Array
                                ? (UCF_JsUtil["contains"](oReplacer, i) ? oReplacedValue : null)
                                : oReplacer(i, oReplacedValue)
                            : oReplacedValue;

                        if (oReplacer && typeof oReplacedValue === 'undefined') {
                            oReplacedValue = null;
                        }

                        if (!bFirst) {
                            aBuffer["push"](',');
                        }
                        if (sInnerIndent) {
                            aBuffer["push"]('\n');
                        }
                        aBuffer["push"](sInnerIndent);
                        UCF_JsUtil["sJsonStringifyFallback"](oReplacedValue, oReplacer, oSpace, aBuffer, sInnerIndent);
                        bFirst = false;
                    }
                    if (sInnerIndent && !bFirst) {
                        aBuffer["push"]('\n');
                        aBuffer["push"](sIndent);
                    }
                    aBuffer["push"](']');
                } else {
                    aBuffer["push"]('{');
                    for (sKey in oValue) {
                        oReplacedValue = (oValue[sKey] && oValue[sKey]["toJSON"])
                            ? oValue[sKey]["toJSON"](sKey)
                            : oValue[sKey];
                        oReplacedValue = oReplacer
                            ? oReplacer instanceof Array
                                ? (UCF_JsUtil["contains"](oReplacer, sKey) ? oReplacedValue : undefined)
                                : oReplacer(sKey, oReplacedValue)
                            : oReplacedValue;

                        if (typeof oReplacedValue === 'undefined') {
                            continue;
                        }

                        if (!bFirst) {
                            aBuffer["push"](',');
                        }
                        if (sInnerIndent) {
                            aBuffer["push"]('\n');
                        }
                        aBuffer["push"](sInnerIndent);
                        UCF_JsUtil["sJsonStringifyFallback"](sKey, oReplacer, oSpace, aBuffer, sInnerIndent);
                        aBuffer["push"](':');
                        if (sSpace) {
                            aBuffer["push"](' ');
                        }
                        UCF_JsUtil["sJsonStringifyFallback"](oReplacedValue, oReplacer, oSpace, aBuffer, sInnerIndent);
                        bFirst = false;
                    }
                    if (sInnerIndent && !bFirst) {
                        aBuffer["push"]('\n');
                        aBuffer["push"](sIndent);
                    }
                    aBuffer["push"]('}');
                }
                break;
            case 'string':
                aBuffer["push"]('"');
                aBuffer["push"](oValue["replace"](/\\/g, '\\\\')["replace"](/"/g, '\\"'));
                aBuffer["push"]('"');
                break;
            default:
                aBuffer["push"](oValue);
                break;
        }

        return aBuffer["join"]('');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sJsonStringifyFallback"] = 0;
    }
    ;

    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}
     * @static
     * @param {any} oValue
     * @param {function(string,any):any | Array<number|string>} [oReplacer]
     * @param {number|string} [oSpace]
     * @return {string}
     */
    UCF_JsUtil["sJsonStringify"] = function (oValue, oReplacer, oSpace) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sJsonStringify"]++;
        }
        ;
        if (!UCF_JsUtil["_sJsonStringify"]) {
            UCF_JsUtil["_sJsonStringify"] = 'JSON' in window && 'stringify' in JSON
                ? JSON["stringify"]
                : UCF_JsUtil["sJsonStringifyFallback"];
        }

        return UCF_JsUtil["_sJsonStringify"](oValue, oReplacer, oSpace);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sJsonStringify"] = 0;
    }
    ;

    /**
     * Missing implementation for
     * - fReviver
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse}
     * @public
     * @static
     * @param {string} sValue
     * @return {any}
     */
    UCF_JsUtil["oJsonParse"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["oJsonParse"]++;
        }
        ;
        if (!UCF_JsUtil["_oJsonParse"]) {
            UCF_JsUtil["_oJsonParse"] = 'JSON' in window && 'parse' in JSON
                ? function (sValue_) {
                    if (sValue_ && typeof sValue_ === 'string') {
                        sValue_ = UCF_StringUtil["sTrim"](sValue_);

                        try {
                            return JSON["parse"](sValue_);
                        } catch (e) {
                            if (__UCF_TRACE__) {
                                UCF_Tracer.trace(WARNING, e["message"], "JsUtil.js(290): oJsonParse");
                            }
                            ;

                            // Fortify ignore this line
                            return UCF_JsUtil["eval"]('return ' + sValue_, {});
                        }
                    } else {
                        return null;
                    }
                }
                : function (sValue_) {
                    return sValue_ && typeof sValue_ === 'string'
                        // Fortify ignore this line
                        ? UCF_JsUtil["eval"]('return ' + UCF_StringUtil["sTrim"](sValue_), {})
                        : null;
                };
        }

        return UCF_JsUtil["_oJsonParse"](sValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["oJsonParse"] = 0;
    }
    ;

    /**
     * @deprecated use UCF_JsUtil.oJsonParse instead
     * @public
     * @static
     * @param {string} sValue
     * @return {any}
     */
    UCF_JsUtil["oParseJSON"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["oParseJSON"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(WARNING, 'UCF_JsUtil.oParseJSON is deprecated since Unified Rendering Cumulative Patch 2004. It may be removed in future versions of UR. Use UCF_JsUtil.oJsonParse() instead.', "JsUtil.js(318): oParseJSON");
        }
        ;

        return UCF_JsUtil["oJsonParse"](sValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["oParseJSON"] = 0;
    }
    ;

    /**
     * polyfill for window.requestAnimationFrame
     * @param {function} fCallback the callback to be executed in the animation frame
     * @return {number} the id of the animation frame/timeout
     */
    UCF_JsUtil["requestAnimationFrame"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["requestAnimationFrame"]++;
        }
        ;
        // can't cache window.requestAnimationFrame because the function seems to
        // belong to the animation frame requested (i.e. if you call the same fn
        // after the animation frame has been executed, strange things happen)
        var fRequestAF = window["requestAnimationFrame"] ||
            // eslint-disable-next-line no-magic-numbers
            function (f) {
                return window["setTimeout"](f, 16);
            };

        return fRequestAF(fCallback);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["requestAnimationFrame"] = 0;
    }
    ;

    /**
     * polyfill for window.cancelAnimationFrame
     * @param {number} iAnimationFrameId the id of the animation frame/timeout
     */
    UCF_JsUtil["cancelAnimationFrame"] = function (iAnimationFrameId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelAnimationFrame"]++;
        }
        ;
        /** @type {function(number): void} */
        var fCancelAF = window["cancelAnimationFrame"] || window["clearTimeout"];

        fCancelAF(iAnimationFrameId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelAnimationFrame"] = 0;
    }
    ;

    /**
     * @param {function({didTimeout: boolean, timeRemaining: function(): number}): void} fCallback the
     * function to perform in the idle callback
     * @param {{timeout: number}} [oOptions] options for the idle callback request
     * @return {number} the id of the idle callback
     * @see https://developers.google.com/web/updates/2015/08/using-requestidlecallback
     */
    UCF_JsUtil["requestIdleCallback"] = function (fCallback, oOptions) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["requestIdleCallback"]++;
        }
        ;
        /**
         * @param {function({didTimeout: boolean, timeRemaining: function(): number}): void} f the callback
         * @param {{timeout: number}} [o] options for the idle callback (currently
         * ignored by the shim)
         * @return {number}
         */
        var fRequestIC = window["requestIdleCallback"] ||
            function (f, o) {
                return setTimeout(function () {
                    /** @type {Date} */
                    var oStart = new Date();

                    fCallback({
                        "didTimeout": false,
                        "timeRemaining": function () {
                            // eslint-disable-next-line no-magic-numbers
                            return Math["max"](0, 50 - (new Date() - oStart));
                        }
                    });
                }, 1);
            };

        return fRequestIC(fCallback, oOptions);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["requestIdleCallback"] = 0;
    }
    ;

    /**
     * @param {number} iIdleCallbackId the id of the idle callback to cancel
     */
    UCF_JsUtil["cancelIdleCallback"] = function (iIdleCallbackId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelIdleCallback"]++;
        }
        ;
        var fCancelIC = window["cancelIdleCallback"] || window["clearTimeout"];

        fCancelIC(iIdleCallbackId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelIdleCallback"] = 0;
    }
    ;

// #region ===== setImmediate =================================================
    /** @type {Object<string, MutationObserver|function():void|HTMLScriptElement>} */
    UCF_JsUtil["mImmediates"] = {};
// #region ----- MutationObserver ---------------------------------------------
// #region ..... set ..........................................................
    /**
     * @static
     * @param {function(): void} fCallback
     * @return {string}
     */
    UCF_JsUtil["setImmediateMutationObserver"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["setImmediateMutationObserver"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oRef = document["createElement"]('div');
        /** @type {string} */
        var sId = UCF_JsUtil["sGetUID"]();

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert('MutationObserver' in window, "'MutationObserver' in window", "JsUtil.js(407): setImmediateMutationObserver");
        }
        ;

        UCF_JsUtil["mImmediates"][sId] = (new MutationObserver(function () {
            UCF_JsUtil["cancelImmediateMutationObserver"](sId);
            oRef = null;
            fCallback();
        }));

        UCF_JsUtil["mImmediates"][sId]["observe"](oRef, {"attributes": true});

        oRef["setAttribute"]('i', 1);

        return sId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["setImmediateMutationObserver"] = 0;
    }
    ;
// #endregion
// #region ..... cancel .......................................................
    /**
     * @static
     * @param {string} sId
     */
    UCF_JsUtil["cancelImmediateMutationObserver"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelImmediateMutationObserver"]++;
        }
        ;
        if (sId in UCF_JsUtil["mImmediates"]) {
            UCF_JsUtil["mImmediates"][sId]["disconnect"]();
            UCF_JsUtil["mImmediates"][sId] = undefined;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelImmediateMutationObserver"] = 0;
    }
    ;
// #endregion
// #endregion
// #region ----- PostMessage --------------------------------------------------
// #region ..... set ..........................................................
    /**
     * @static
     * @return {function(function(): void): void}
     */
    UCF_JsUtil["fCreateSetImmediatePostMessage"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["fCreateSetImmediatePostMessage"]++;
        }
        ;
        /** @type {'sap.ls.setImmediate.'} */
        var sMessagePrefix;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert('postMessage' in window, "'postMessage' in window", "JsUtil.js(445): fCreateSetImmediatePostMessage");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(!('importScripts' in window), "!('importScripts' in window)", "JsUtil.js(446): fCreateSetImmediatePostMessage");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert('addEventListener' in window, "'addEventListener' in window", "JsUtil.js(447): fCreateSetImmediatePostMessage");
        }
        ;

        sMessagePrefix = 'sap.ls.setImmediate.';

        window["addEventListener"]('message', function (event) {
            /** @type {string} */
            var sTargetId;
            /** @type {function(): void} */
            var fCallback;

            if (event["source"] === window && event["data"]["indexOf"](sMessagePrefix) === 0) {
                sTargetId = event["data"];

                if (sTargetId in UCF_JsUtil["mImmediates"]) {
                    fCallback = UCF_JsUtil["mImmediates"][sTargetId];

                    UCF_JsUtil["cancelImmediatePostMessage"](sTargetId);

                    fCallback();
                }
            }
        }, false);

        return function (fCallback) {
            /** @type {string} */
            var sMessageId = sMessagePrefix + UCF_JsUtil["sGetUID"]();

            UCF_JsUtil["mImmediates"][sMessageId] = fCallback;

            window["postMessage"](sMessageId, '*');

            return sMessageId;
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["fCreateSetImmediatePostMessage"] = 0;
    }
    ;
// #endregion
// #region ..... cancel .......................................................
    /**
     * @static
     * @param {string} sId
     */
    UCF_JsUtil["cancelImmediatePostMessage"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelImmediatePostMessage"]++;
        }
        ;
        if (sId in UCF_JsUtil["mImmediates"]) {
            UCF_JsUtil["mImmediates"][sId] = undefined;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelImmediatePostMessage"] = 0;
    }
    ;
// #endregion
// #endregion
// #region ----- readyStateChange ---------------------------------------------
// #region ..... set ..........................................................
    /**
     * @static
     * @param {function(): void} fCallback
     * @return {string}
     */
    UCF_JsUtil["setImmediateReadyStateChange"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["setImmediateReadyStateChange"]++;
        }
        ;
        /** @type {HTMLScriptElement} */
        var oRef = document["createElement"]('script');
        /** @type {string} */
        var sId = UCF_JsUtil["sGetUID"]();

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert('onreadystatechange' in oRef, "'onreadystatechange' in oRef", "JsUtil.js(507): onreadystatechange");
        }
        ;

        oRef["onreadystatechange"] = function () {
            UCF_JsUtil["cancelImmediateReadyStateChange"](sId);

            fCallback();
        };

        UCF_DomUtil["prepend"](document["body"], oRef);

        UCF_JsUtil["mImmediates"][sId] = oRef;

        return sId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["setImmediateReadyStateChange"] = 0;
    }
    ;
// #endregion
// #region ..... cancel .......................................................
    /**
     * @static
     * @param {string} sId
     */
    UCF_JsUtil["cancelImmediateReadyStateChange"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelImmediateReadyStateChange"]++;
        }
        ;
        /** @type {HTMLScriptElement} */
        var oRef;

        if (sId in UCF_JsUtil["mImmediates"]) {
            oRef = UCF_JsUtil["mImmediates"][sId];

            oRef["onreadystatechange"] = null;
            UCF_DomUtil["removeFromDom"](oRef);
            oRef = undefined;
            UCF_JsUtil["mImmediates"][sId] = undefined;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelImmediateReadyStateChange"] = 0;
    }
    ;
// #endregion
// #endregion
// #region ----- delayedCall --------------------------------------------------
// #region ..... set ..........................................................
    /**
     * @static
     * @param {function(): void} fCallback
     * @return {string}
     */
    UCF_JsUtil["setImmediateDelayedCall"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["setImmediateDelayedCall"]++;
        }
        ;
        return UCF_JsUtil["delayedCall"](0, {"o": fCallback}, 'o');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["setImmediateDelayedCall"] = 0;
    }
    ;
// #endregion
// #region ..... cancel .......................................................
    /**
     * @static
     * @param {string} sId
     */
    UCF_JsUtil["cancelImmediateDelayedCall"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelImmediateDelayedCall"]++;
        }
        ;
        UCF_JsUtil["clearDelayedCall"](sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelImmediateDelayedCall"] = 0;
    }
    ;
// #endregion
// #endregion
// #region ----- public interface ---------------------------------------------
// #region ..... set ..........................................................
    /**
     * @static
     * @type {function(function(): void): void}
     */
    UCF_JsUtil["_setImmediate"] = null;

    /**
     * @see {@link https://github.com/taylorhakes/setAsap}
     * @public
     * @static
     * @param {function(): void} fCallback
     * @return {string}
     */
    UCF_JsUtil["setImmediate"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["setImmediate"]++;
        }
        ;
        /** @type {boolean} */
        var bHasSetImmediate;

        if (!UCF_JsUtil["_setImmediate"]) {
            bHasSetImmediate = typeof window["setImmediate"] === 'function';

            UCF_JsUtil["_setImmediate"] = window["MutationObserver"]
                ? UCF_JsUtil["setImmediateMutationObserver"]
                : bHasSetImmediate
                    ? window["setImmediate"]
                    : (window["postMessage"] && !window["importScripts"] && window["addEventListener"])
                        ? UCF_JsUtil["fCreateSetImmediatePostMessage"]()
                        : ('onreadystatechange' in document["createElement"]('script'))
                            ? UCF_JsUtil["setImmediateReadyStateChange"]
                            : UCF_JsUtil["setImmediateDelayedCall"];
        }

        return UCF_JsUtil["_setImmediate"](fCallback);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["setImmediate"] = 0;
    }
    ;
// #endregion
// #region ..... cancel .......................................................
    /**
     * @static
     * @type {function(string): void}
     */
    UCF_JsUtil["_cancelImmediate"] = null;

    /**
     * @public
     * @static
     * @param {string} sId
     */
    UCF_JsUtil["cancelImmediate"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["cancelImmediate"]++;
        }
        ;
        /** @type {boolean} */
        var bHasCancelImmediate;

        if (!UCF_JsUtil["_cancelImmediate"]) {
            bHasCancelImmediate = typeof window["cancelImmediate"] === 'function';

            UCF_JsUtil["_cancelImmediate"] = window["MutationObserver"]
                ? UCF_JsUtil["cancelImmediateMutationObserver"]
                : bHasCancelImmediate
                    ? window["cancelImmediate"]
                    : (window["postMessage"] && !window["importScripts"] && window["addEventListener"])
                        ? UCF_JsUtil["fCreateCancelImmediatePostMessage"]()
                        : ('onreadystatechange' in document["createElement"]('script'))
                            ? UCF_JsUtil["cancelImmediateReadyStateChange"]
                            : UCF_JsUtil["cancelImmediateDelayedCall"];
        }

        UCF_JsUtil["_cancelImmediate"](sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["cancelImmediate"] = 0;
    }
    ;
// #endregion
// #endregion
// #endregion

    /**
     * Calls a method after a given delay and returns a id for this timer
     * @public
     * @param {number} iDelay delay time in milliseconds
     * @param {Object} oObject object from which the method should be called
     * @param {string} sMethodName name of the method
     * @param {Array<any>} [aParameters=[]] method parameters
     * @return {string} id which can be used to cancel the timer with
     * clearDelayedCall
     */
    UCF_JsUtil["delayedCall"] = function (iDelay, oObject, sMethodName, aParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["delayedCall"]++;
        }
        ;
        /** @type {string} */
        var sInfo = '';
        /** @type {string} */
        var sCallerName;
        /** @type {string} */
        var sClassName;
        /** @type {string} */
        var sDelayedCallId;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iDelay === 'number', "typeof iDelay === 'number'", "JsUtil.js(655): delayedCall");
        }
        ;
        // delayed call has to work with static access to e.g. UFC_DomUtil as well
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oObject === 'object' || typeof oObject === 'function', "typeof oObject === 'object' || typeof oObject === 'function'", "JsUtil.js(657): delayedCall");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oObject != null, "oObject != null", "JsUtil.js(658): delayedCall");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sMethodName === 'string', "typeof sMethodName === 'string'", "JsUtil.js(659): delayedCall");
        }
        ;

        sInfo = '';
        if (__UCF_DEBUG__) {
            sCallerName = UCF_JsUtil["sGetCaller"]();
            sClassName = oObject["sClassName"];
            if (typeof oObject === 'function') {
                sClassName = UCF_JsUtil["sExtractFunctionName"](oObject);
            }
            if (!sClassName) {
                sClassName = '???';
            }
            sInfo = sClassName + '.' + sMethodName +
                ' called by ' + sCallerName +
                ' after ' + iDelay + 'ms delay.';
        }

        sDelayedCallId = sMethodName + iDelay + UCF_JsUtil["sGetUID"]();

        UCF_JsUtil["mDelayedCalls"][sDelayedCallId] = {
            "oObject": oObject,
            "sMethodName": sMethodName,
            "aParameters": aParameters || [],
            "sTimeoutId": window["setTimeout"](__UCF_IE6__
                    // eslint-disable-line no-implied-eval
                    ? 'UCF_JsUtil.callDelayedCallRedirect("' + sDelayedCallId + '")'
                    : function () {
                        UCF_JsUtil["callDelayedCallRedirect"](sDelayedCallId);
                    },
                iDelay
            ),
            "sInfo": sInfo
        };

        return sDelayedCallId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["delayedCall"] = 0;
    }
    ;

    /** @return {string} */
    UCF_JsUtil["sGetCaller"] = __UCF_IE6__
        ? function () {
            return null;
        }
        : function () {
            /** @type {Error}*/
            var oError = new Error();

            if (typeof oError["stack"] === 'undefined') {
                return UCF_JsUtil["sGetCallerFromCaller"](arguments["callee"]["caller"]);
            } else {
                return UCF_JsUtil["sGetCallerFromErrorStack"](oError);
            }
        };

    /**
     * @param {function} fCaller the called function
     * @return {string} the name of the function that called `fCaller`
     */
    UCF_JsUtil["sGetCallerFromCaller"] = function (fCaller) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sGetCallerFromCaller"]++;
        }
        ;
        try {
            return fCaller
                && fCaller["caller"]
                && fCaller["caller"]["toString"]()["match"](/function ([^\(]+) ?\(/)[1];
        } catch (e) {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sGetCallerFromCaller"] = 0;
    }
    ;

    /**
     * @param {Error} oError the error to get the stack from
     * @return {string} the caller
     */
    UCF_JsUtil["sGetCallerFromErrorStack"] = function (oError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sGetCallerFromErrorStack"]++;
        }
        ;
        /** @type {string} */
        var aResult;

        try {
            throw oError;
        } catch (e) {
            aResult = /(?:Function.)?([^\(\[ ]+)@|at (?:Function.)?([^\(\[ ]+)/g["exec"](
                // eslint-disable-next-line no-magic-numbers
                e["stack"]["split"]('\n')[3]
            );

            // eslint-disable-next-line no-magic-numbers
            return aResult && aResult["length"] > 1 && (aResult[1] || aResult[2]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sGetCallerFromErrorStack"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sMethodName the method to check if there is a delayed call
     * for
     * @return {boolean} `true` if at least one delayed call for the given method
     * is currently in the queue
     */
    UCF_JsUtil["bDelayedCallExists"] = function (sMethodName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bDelayedCallExists"]++;
        }
        ;
        /** @type {string} */
        var sId;

        for (sId in UCF_JsUtil["mDelayedCalls"]) {
            if (UCF_JsUtil["mDelayedCalls"][sId]["sMethodName"] === sMethodName) {
                return true;
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bDelayedCallExists"] = 0;
    }
    ;

    /**
     * Stops the delayed call, so the function is never called
     * @public
     * @param {string} sDelayedCallId the ID returned, when calling delayedCall
     */
    UCF_JsUtil["clearDelayedCall"] = function (sDelayedCallId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["clearDelayedCall"]++;
        }
        ;
        /** @type {UCF_JsUtil_DelayedCall} */
        var oDelayedCall = UCF_JsUtil["mDelayedCalls"][sDelayedCallId];

        if (oDelayedCall) {
            clearTimeout(oDelayedCall["sTimeoutId"]);
            delete UCF_JsUtil["mDelayedCalls"][sDelayedCallId];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["clearDelayedCall"] = 0;
    }
    ;

    /**
     * Stops all delayed calls, registered for the given object
     * @public
     * @param {Object} oObject the reference of the object
     */
    UCF_JsUtil["clearDelayedCallsOfObject"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["clearDelayedCallsOfObject"]++;
        }
        ;
        /** @type {Object<string, UCF_JsUtil_DelayedCall>} */
        var mDelayedCalls = UCF_JsUtil["mDelayedCalls"];
        /** @type {string} */
        var sDelayedCallId;

        for (sDelayedCallId in mDelayedCalls) {
            if (mDelayedCalls[sDelayedCallId]["oObject"] === oObject) {
                UCF_JsUtil["clearDelayedCall"](sDelayedCallId);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["clearDelayedCallsOfObject"] = 0;
    }
    ;

    /**
     * This is a proxy method which is called after a certain delay from
     * delayedCall method. It calls the original method.
     *
     * Don't directly call this method !!!
     * @param {string} sDelayedCallId key of the reference to search in the
     * UCF_JsUtil.mDelayedCalls hashMap
     * @see delayedCall
     */
    UCF_JsUtil["callDelayedCallRedirect"] = function (sDelayedCallId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["callDelayedCallRedirect"]++;
        }
        ;
        /** @type {UCF_JsUtil_DelayedCall} */
        var oDelayedCall = UCF_JsUtil["mDelayedCalls"][sDelayedCallId];

        if (oDelayedCall) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, oDelayedCall["sInfo"], "JsUtil.js(810): callDelayedCallRedirect");
            }
            ;
            oDelayedCall["oObject"][oDelayedCall["sMethodName"]]["apply"](
                oDelayedCall["oObject"],
                oDelayedCall["aParameters"]
            );
            UCF_JsUtil["clearDelayedCall"](sDelayedCallId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["callDelayedCallRedirect"] = 0;
    }
    ;

    /**
     * Calls a method after a given interval and returns a id for this interval
     * @public
     * @param {int} iInterval interval time in milliseconds
     * @param {Object} oObject object from which the method should be called
     * @param {string} sMethodName name of the method
     * @param {Array} aParameters method parameters
     * @return {string} id which can be used to cancel the interval with
     * clearIntervalCall
     */
    UCF_JsUtil["intervalCall"] = function (iInterval, oObject, sMethodName, aParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["intervalCall"]++;
        }
        ;
        /** @type {string} */
        var sIntervalCallId;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iInterval === 'number', "typeof iInterval === 'number'", "JsUtil.js(833): intervalCall");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oObject === 'object', "typeof oObject === 'object'", "JsUtil.js(834): intervalCall");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oObject != null, "oObject != null", "JsUtil.js(835): intervalCall");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sMethodName === 'string', "typeof sMethodName === 'string'", "JsUtil.js(836): intervalCall");
        }
        ;

        sIntervalCallId = sMethodName + UCF_JsUtil["sGetUID"]();

        UCF_JsUtil["mIntervalCalls"][sIntervalCallId] = {
            "oObject": oObject,
            "sMethodName": sMethodName,
            "aParameters": aParameters || [],
            "sIntervalId": window["setInterval"](__UCF_IE6__
                    // eslint-disable-next-line no-implied-eval
                    ? 'UCF_JsUtil.callIntervalCallRedirect("' + sIntervalCallId + '")'
                    : function () {
                        UCF_JsUtil["callIntervalCallRedirect"](sIntervalCallId);
                    },
                iInterval
            )
        };

        return sIntervalCallId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["intervalCall"] = 0;
    }
    ;

    /**
     * Stops the interval call, so the function is never called
     * @public
     * @param {string} sIntervalCallId the ID returned, when calling intervalCall
     */
    UCF_JsUtil["clearIntervalCall"] = function (sIntervalCallId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["clearIntervalCall"]++;
        }
        ;
        /** @type {UCF_JsUtil_IntervalCall} */
        var oIntervalCall = UCF_JsUtil["mIntervalCalls"][sIntervalCallId];

        if (oIntervalCall) {
            clearInterval(oIntervalCall["sIntervalId"]);
            delete UCF_JsUtil["mIntervalCalls"][sIntervalCallId];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["clearIntervalCall"] = 0;
    }
    ;

    /**
     * This is a proxy method which is called after a certain delay from
     * intervalCall method. It calls the original method.
     *
     * Don't directly call this method !!!
     * @param {string} sIntervalCallId key of the reference to search in the
     * UCF_JsUtil.mIntervalCalls hashMap
     * @see intervalCall
     */
    UCF_JsUtil["callIntervalCallRedirect"] = function (sIntervalCallId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["callIntervalCallRedirect"]++;
        }
        ;
        /** @type {UCF_JsUtil_IntervalCall} */
        var oIntervalCall = UCF_JsUtil["mIntervalCalls"][sIntervalCallId];

        if (oIntervalCall) {
            oIntervalCall["oObject"][oIntervalCall["sMethodName"]]["apply"](
                oIntervalCall["oObject"],
                oIntervalCall["aParameters"]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["callIntervalCallRedirect"] = 0;
    }
    ;


    /**
     * This method can be used to filter a mass of method calls to one method call.
     * e.g. when resize of a control should lead to an update you can call the
     * update method redirected by UCF_JsUtil.massNotificationFilter(...) to grant
     * that only the last resize event leads to an update call
     *
     * @public
     * @param {int} iDelay delay time in milliseconds to identify the maximum gap
     * @param {Object} oCommon a common object to share the functionality
     * @param {Object} oCallInstance object from which the method should be called
     * @param {string} sCallMethod name of the method
     * @param {Array} [aCallParameters] method parameters
     */
    UCF_JsUtil["feedMassNotificationFilter"] = function (iDelay, oCommon, oCallInstance, sCallMethod, aCallParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["feedMassNotificationFilter"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iDelay === "number", "typeof iDelay === \"number\"", "JsUtil.js(906): feedMassNotificationFilter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oCommon === "object" || typeof oCommon === "function", "typeof oCommon === \"object\" || typeof oCommon === \"function\"", "JsUtil.js(907): feedMassNotificationFilter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oCallInstance === "object", "typeof oCallInstance === \"object\"", "JsUtil.js(908): feedMassNotificationFilter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sCallMethod === "string", "typeof sCallMethod === \"string\"", "JsUtil.js(909): feedMassNotificationFilter");
        }
        ;

        if (oCommon["sMassNotificationFilterTimerId"]) {
            UCF_JsUtil["clearDelayedCall"](oCommon["sMassNotificationFilterTimerId"]);
        }

        oCommon["sMassNotificationFilterTimerId"] = UCF_JsUtil["delayedCall"](
            iDelay,
            UCF_JsUtil,
            "timedMassNotificationFilter",
            [oCommon, oCallInstance, sCallMethod, aCallParameters]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["feedMassNotificationFilter"] = 0;
    }
    ;


    /**
     * Resets the mass notification process. If no common object is passed nothing
     * is processed
     *
     * @public
     * @param {Object} [oCommon] a common object to share the functionality
     */
    UCF_JsUtil["resetMassNotificationFilter"] = function (oCommon) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["resetMassNotificationFilter"]++;
        }
        ;
        if (oCommon) {
            if (oCommon["sMassNotificationFilterTimerId"]) {
                UCF_JsUtil["clearDelayedCall"](oCommon["sMassNotificationFilterTimerId"]);
            }
            if ("sMassNotificationFilterTimerId" in oCommon) {
                delete oCommon["sMassNotificationFilterTimerId"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["resetMassNotificationFilter"] = 0;
    }
    ;

    /**
     * Internal method of JSUtil. Do not use.
     * @see feedMassNotificationFilter
     * @param {Object} oCommon a common object to share the functionality
     * @param {Object} oCallInstance object from which the method should be called
     * @param {string} sCallMethod name of the method
     * @param {Array} [aCallParameters] method parameters
     */
    UCF_JsUtil["timedMassNotificationFilter"] = function (oCommon, oCallInstance, sCallMethod, aCallParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["timedMassNotificationFilter"]++;
        }
        ;
        UCF_JsUtil["resetMassNotificationFilter"](oCommon);
        oCallInstance[sCallMethod]["apply"](
            oCallInstance,
            aCallParameters ? aCallParameters : []
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["timedMassNotificationFilter"] = 0;
    }
    ;


    /**
     * Actual time in milliseconds
     * @return {number} the current time in milliseconds
     */
    UCF_JsUtil["iGetTimeStamp"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["iGetTimeStamp"]++;
        }
        ;
        return new Date()["getTime"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["iGetTimeStamp"] = 0;
    }
    ;

    /**
     * @return {string} a unique id
     */
    UCF_JsUtil["sGetUID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sGetUID"]++;
        }
        ;
        return "id" + UCF_JsUtil["iGetTimeStamp"]() + UCF_JsUtil["iIdCounter"]++;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sGetUID"] = 0;
    }
    ;

    /**
     * TODO beware of unicode domain names
     * @constant {RegExp}
     */
    UCF_JsUtil["R_ABSOLUTE_URL"] = /^([a-zA-Z]+:\/\/[a-zA-Z0-9._-]+(:[0-9]+)?)(\/([^\/?]+\/)*)?([^\/?]*)?(\?.*)?$/;

    /**
     * @param {string} sUrl the url
     * @return {boolean}
     */
    UCF_JsUtil["bIsAbsoluteUrl"] = function (sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsAbsoluteUrl"]++;
        }
        ;
        return UCF_JsUtil["R_ABSOLUTE_URL"]["test"](sUrl);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsAbsoluteUrl"] = 0;
    }
    ;

    /**
     * Resolves a URL relative to the given base URL
     *
     * @param {string} sUrl the URL to resolve
     * @param {string} sBaseUrl the base URL
     * @return {string} Resolved URL
     */
    UCF_JsUtil["sGetResolvedUrl"] = function (sUrl, sBaseUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sGetResolvedUrl"]++;
        }
        ;
        // if url is already an absolute URL, return it
        if (UCF_JsUtil["bIsAbsoluteUrl"](sUrl)) return sUrl;

        // split base URL into relevant parts
        // ATTENTION: this must be executed even in production mode, so that RegExp.$1
        // and RegExp.$3 reference the right groups
        var bIsAbsolute = UCF_JsUtil["bIsAbsoluteUrl"](sBaseUrl);
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bIsAbsolute, "bIsAbsolute", "JsUtil.js(1003): sGetResolvedUrl");
        }
        ;
        var sBaseHost = RegExp["$1"],
            sBasePath = RegExp["$3"];

        // if url starts with / append it to host part from base URL
        if (sUrl["charAt"](0) === "/") {
            return sBaseHost + sUrl;
        }

        // otherwise append to the base path of the base URL and canonicalize
        var sResolvedUrl = sBaseHost + sBasePath + sUrl,
            rSelfRef = /(\/\.\/)/,
            rParentRef = /(\/[^\/]+\/\.\.\/)/;
        while (rSelfRef["test"](sResolvedUrl)) {
            sResolvedUrl = sResolvedUrl["replace"](RegExp["$1"], "/");
        }
        while (rParentRef["test"](sResolvedUrl)) {
            sResolvedUrl = sResolvedUrl["replace"](RegExp["$1"], "/");
        }

        return sResolvedUrl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sGetResolvedUrl"] = 0;
    }
    ;

    /**
     * Removes the mangled part (session id parts) of an URL
     *
     * @public
     * @param {string} sUrl the url
     * @return {string} un-mangeled URL
     */
    UCF_JsUtil["sRemoveMangledPartFromURL"] = function (sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sRemoveMangledPartFromURL"]++;
        }
        ;
        /* search for the ManglingPattern 'xyz(<code>)' or (/<code>) or ;sap-ext-sid=<hex64 code>  <code> must be an base64 encoded string
		removes the (<code>) or ;sap-ext-sid=<hex64 code> if found else return the url unchanged:
		sManglingPattern is defined by Martin Z.

		Example: https://server:port/(chm78zuiUiOp89ghghzt675gtzr54rtzhuzvjlfjvdnvlkdfhviudfvksnviudshvksjdnvksdvookknbbngzhjhggfgvgvhggcxhgg=)/bc/...
		Example: https://server:port/sap(chm78zuiUiOp89ghghzt675gtzr54rtzhuzvjlfjvdnvlkdfhviudfvksnviudshvksjdnvksdvookknbbngzhjhggfgvgvhggcxhgg=)/bc/...
		Example: https://server:port/sap;~sysid=AZY;sap-ext-sid=_VG__hm78zuiUiOp89ghh--_VG__hm78zuiUiOp89ghh--?sap-ep-version=7

	matches / (<hex64 code>) | xyz(<hex64 code>) | ;sap-ext-sid=<hex64 code>
				  /(<hex64 code>) will be removed e.g. /bc/(hex64)/test --> bc/test
					(<hex64 code>) will be replace e.g. /sap(hex64)/test --> /sap/test
					sap;sap-ext-sid=<hex64 code>? will be replcaed e.g. /sap?

	*/
        return sUrl["replace"](UCF_JsUtil["rManglingURLPattern"], "");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sRemoveMangledPartFromURL"] = 0;
    }
    ;

    /**
     * Checks whether the object is an instance of the given className.
     * Use only for JavaScript objects with origin in the same window/frame.
     * @param {Object} oObject an object
     * @param {string} sClassName the class the oObject should have
     * @return {boolean} result of the check
     */
    UCF_JsUtil["bInstanceOf"] = function (oObject, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bInstanceOf"]++;
        }
        ;
        // Consider following issues !!
        // http://bytes.com/forum/thread91190.html
        // http://groups.google.com/group/comp.lang.javascript/browse_thread/thread/2fee4888edbb0389/102ab20c68aa738f

        var oClass = window[sClassName];
        if (!oClass) return false;
        return oObject instanceof oClass;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bInstanceOf"] = 0;
    }
    ;

// #region downloadBlob -------------------------------------------------------
    /**
     * @public
     * @static
     * @param {Blob} oBlob the blob to download
     * @param {string} sName the name for the blob
     * @param {boolean} [bSaveOnly=false] 'true' to attempt 'msSaveBlob'
     * 'false' to attempt 'msSaveOrOpenBlob'
     */
    UCF_JsUtil["downloadBlob"] = function (oBlob, sName, bSaveOnly) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadBlob"]++;
        }
        ;
        /** @type {string} */
        var sSaveMethod = bSaveOnly ? 'msSaveBlob' : 'msSaveOrOpenBlob';

        // the method msSaveBlob() in window.navigator is only for IE 10+
        if ('navigator' in window && sSaveMethod in window["navigator"]) {
            window["navigator"][sSaveMethod](oBlob, sName);
        } else if (URL) {
            UCF_JsUtil["downloadFile"](URL["createObjectURL"](oBlob), sName);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadBlob"] = 0;
    }
    ;
// #endregion

// #region downloadFile -------------------------------------------------------
    /**
     * @static
     * @type {number}
     */
    UCF_JsUtil["iConcurrentDownloads"] = 0;
    /**
     * Downloads the file specified by sUrl. The server behind this url has to
     * answer with a Content-Disposition: attachment header. If sName is specified
     * and no filename is sent in the Content-Disposition header, this name is
     * used for the downloaded file.
     *
     * Calling downloadFile() multiple times on cross-origin URLs might not work in
     * IE (it will only download the last file). This is due to IE not being able
     * to download a file with X-Frame-Options: SAMEORIGIN in a same origin iframe,
     * so we have to fall back to downloading the file with a direct link
     * (see `downloadFileSyncAnchor()`), which does allow only one simultaneous
     * download in IE.
     *
     * @public
     * @static
     * @param {string} sUrl the URL of the file to download
     * @param {string}[sName] the name the downloaded file should get
     * @param {number}[iTimeoutInMs=600000] the time( in ms) until the download
     * must be finished (i.e.then the downloading iframe is removed), defaults to
     * 600.000 ms (== 10 minutes)
     */
    UCF_JsUtil["downloadFile"] = function (sUrl, sName, iTimeoutInMs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadFile"]++;
        }
        ;
        UCF_JsUtil["delayedCall"](
            // eslint-disable-next-line no-magic-numbers
            (UCF_JsUtil["iConcurrentDownloads"]++) * 16,
            UCF_JsUtil,
            'downloadFileSync', [sUrl, sName, iTimeoutInMs]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadFile"] = 0;
    }
    ;

    /**
     * Helper function for file downloads triggered by the server
     * @static
     * @param {string} sUnsafeUrl the URL of the file to download
     * @param {string} [sName] the name the downloaded file should get
     * @param {number} [iTimeoutInMs=600000] the time (in ms) until the download
     * must be finished (i.e. then the downloading iframe is removed), defaults to
     * 600.000ms (== 10 minutes)
     */
    UCF_JsUtil["downloadFileSync"] = function (sUnsafeUrl, sName, iTimeoutInMs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadFileSync"]++;
        }
        ;
        /** @type {string} */
        var sUrl = /^blob:/["test"](sUnsafeUrl)
            ? sUnsafeUrl
            : UCF_JsUtil["sGetResolvedUrl"](sUnsafeUrl, location);

        if (UCF_UserAgent["bIsPhone"]() || UCF_UserAgent["bIsTablet"]()) {
            UCF_JsUtil["downloadFileSyncNewTab"](sUrl, sName, iTimeoutInMs);
        } else if (
            UCF_UserAgent["bIsFirefox"]() || UCF_UserAgent["bIsMSEdge"]() ||
            (
                UCF_UserAgent["bIsIE"]() &&
                UCF_JsUtil["bIsAbsoluteUrl"](sUnsafeUrl) &&
                !UCF_JsUtil["bIsSameHost"](sUnsafeUrl)
            )
        ) {
            UCF_JsUtil["downloadFileSyncAnchor"](sUrl, sName, iTimeoutInMs);
        } else {
            UCF_JsUtil["downloadFileSyncIframe"](sUrl, sName, iTimeoutInMs);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadFileSync"] = 0;
    }
    ;

    /**
     * @static
     * @param {string} sSafeUrl the url
     * @param {string} [sName] the filename
     * @param {number} [iTimeoutInMs]
     */
    UCF_JsUtil["downloadFileSyncNewTab"] = function (sSafeUrl, sName, iTimeoutInMs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadFileSyncNewTab"]++;
        }
        ;
        /** @type {function(): void} */
        var fOnWindowFocus;

        // CSN 1880616769: if multiple downloads are started in the same stack,
        // iOS Safari will only open the first in a new tab, because after that,
        // the window is no longer focused and additional window.open() won't be
        // executed.
        // => attach to window.onfocus if document has no focus, start download again
        if (document["hasFocus"]()) {
            window["open"](sSafeUrl, sName);
            UCF_JsUtil["iConcurrentDownloads"]--;
        } else {
            fOnWindowFocus = function () {
                UCF_DomUtil["detachEvent"](window, 'focus', fOnWindowFocus);
                // will be incremented in downloadFile() again
                UCF_JsUtil["iConcurrentDownloads"]--;
                UCF_JsUtil["downloadFile"](sSafeUrl, sName, iTimeoutInMs);
            };

            UCF_DomUtil["attachEvent"](window, 'focus', fOnWindowFocus);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadFileSyncNewTab"] = 0;
    }
    ;

    /**
     * @static
     * @param {string} sSafeUrl the url
     * @param {string} [sName] the filename
     * @param {number} [iTimeoutInMs=600000]
     */
    UCF_JsUtil["downloadFileSyncAnchor"] = function (sSafeUrl, sName, iTimeoutInMs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadFileSyncAnchor"]++;
        }
        ;
        /** @type {HTMLAnchorElement} */
        var oA = document["createElement"]('a');

        oA["href"] = sSafeUrl;
        oA["setAttribute"]('download', sName || '');
        UCF_DomUtil["setStyle"](oA, {
            "position": 'absolute',
            "top": '-10000px',
            "left": '10000px',
            "display": 'block',
            "height": 0,
            "width": 0
        });

        try {
            UCF_DomUtil["prepend"](document["body"], oA);
            oA["click"]();
            UCF_JsUtil["iConcurrentDownloads"]--;
            UCF_JsUtil["delayedCall"](
                typeof iTimeoutInMs === 'number' ? iTimeoutInMs : 600000,
                UCF_DomUtil,
                'removeFromDom', [oA]
            );
        } catch (ignored) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'downloading ' + sSafeUrl + (sName ? ' as ' + sName : ' ') + 'failed', "JsUtil.js(1218): downloadFileSyncAnchor");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadFileSyncAnchor"] = 0;
    }
    ;
    /**
     * @static
     * @param {string} sSafeUrl the url
     * @param {string} [sName] the filename
     * @param {number} [iTimeoutInMs=600000]
     */
    UCF_JsUtil["downloadFileSyncIframe"] = function (sSafeUrl, sName, iTimeoutInMs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["downloadFileSyncIframe"]++;
        }
        ;
        /** @type {HTMLIFrameElement} */
        var oIframe = document["createElement"]('iframe');

        UCF_DomUtil["setStyle"](oIframe, {"display": 'none'});
        oIframe["src"] = UCF_DomUtil["sGetIframeJSSource"](
            '<!doctype html><html><head></head><body><a id="d" href="' + sSafeUrl +
            '" download' + (sName ? '="' + sName + '"' : '') + '>d</a><script nonce="' +
            window["UCF_System"]["sNonce"] + '">document.getElementById("d").click()</script></body></html>'
        );

        UCF_DomUtil["prepend"](document["body"], oIframe);
        UCF_JsUtil["iConcurrentDownloads"]--;

        UCF_JsUtil["delayedCall"](
            // eslint-disable-next-line no-magic-numbers
            typeof iTimeoutInMs === 'number' ? iTimeoutInMs : 600000,
            UCF_DomUtil,
            'removeFromDom', [oIframe]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["downloadFileSyncIframe"] = 0;
    }
    ;
// #endregion

    /**
     * Helper function to send an unload request to the server in case
     * the browser window is closed or the user navigates to another page.
     * Depending on the browser a syncXHR is used or a async sendBeacon.
     *
     * @param {string} sUrl the termination url
     * @param {string} [mPostParameters] the request parameters (if any)
     * @param {string} [sSessioHandling=''] type of SessionHandling, DEFAULT, SYNC
     */
    UCF_JsUtil["sendUnloadRequest"] = function (sUrl, mPostParameters, sSessioHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sendUnloadRequest"]++;
        }
        ;
        //TODO: ITS still calls UCF_JsUtil.sendUnloadRequest --> discuss with ITS if we can remove the function from JsUtil
        UCF_RequestUtil["sendUnloadRequest"](sUrl, mPostParameters, sSessioHandling);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sendUnloadRequest"] = 0;
    }
    ;

    /**
     * Helper function to determine, whether the URL is pointing to the same host
     * as the current loaded document
     * @param {string} url the url to check window.location against
     * @return {boolean} `true` if window.location starts with `url`
     */
    UCF_JsUtil["bIsSameHost"] = function (url) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsSameHost"]++;
        }
        ;
        if (!/^https?:\/\//["test"](url)) return true;

        var urlTest = location["protocol"] + "//" + location["hostname"];
        return UCF_StringUtil["bStartsWith"](url, urlTest, true); //hosts are case insentive
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsSameHost"] = 0;
    }
    ;

    /**
     * creates a clone of an object
     * @param {Object} obj the object to clone
     * @param {bool} bRecursive true, to recurse subobjects (warning! objects may
     * have cross references->endless loop)
     * @return {Object} a clone of `obj`
     */
    UCF_JsUtil["oClone"] = function (obj, bRecursive) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["oClone"]++;
        }
        ;
        if (!obj || typeof obj !== 'object') {
            return obj;
        }

        var oClone = new Object();

        try {
            if (obj["constructor"]) {
                oClone = new obj["constructor"]();
            }
        } catch (e) {
        }
        ;

        for (var key in obj) {
            try {
                var oCopy = null;
                if (bRecursive)
                    oCopy = UCF_JsUtil["oClone"](obj[key], bRecursive);
                else
                    oCopy = obj[key];

                oClone[key] = oCopy;
            } catch (e) {
            }
            ;
        }
        return oClone;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["oClone"] = 0;
    }
    ;


    /**
     * Returns true if the environment allows instanciating of ActiveXObjects
     * @return {boolean} `true` if activeX can be used, otherwise `false`
     */
    UCF_JsUtil["bCanActiveX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bCanActiveX"]++;
        }
        ;
        // From IE1 on the window.ActiveXObject is not visible though instanciating
        // the object is possible
        // http://msdn.microsoft.com/en-us/library/ie/dn423948(v=vs.85).aspx
        if (UCF_UserAgent["bIsIE"]() &&
            !__UCF_IE6__ &&
            // eslint-disable-next-line no-magic-numbers
            parseInt(document["documentMode"]) >= 11
        ) {
            // assumption that the option is not disabled
            return true;
        } else {
            return window["ActiveXObject"] ? true : false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bCanActiveX"] = 0;
    }
    ;


    /**
     * Returns the parsed XML dom from the a given string.
     * @param {string} sXMLText The XML string to parse
     * @return {XMLDOM} A xml dom
     */
    UCF_JsUtil["oParseXMLDocument"] = function (sXMLText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["oParseXMLDocument"]++;
        }
        ;
        var oXMLDocument = null;

        if (window["DOMParser"]) {
            var oParser = new DOMParser();
            oXMLDocument = oParser["parseFromString"](sXMLText, "text/xml");
        } else if (UCF_JsUtil["bCanActiveX"]()) {
            // In case of disabled ActiveX use an XML data island rendered by the Page
            var oXMLRef = document["getElementById"]("UCF_XML");
            if (oXMLRef) {
                oXMLDocument = oXMLRef["XMLDocument"];
            } else {
                oXMLDocument = new window["ActiveXObject"]("Microsoft.XMLDOM");
            }
            oXMLDocument["async"] = false;
            oXMLDocument["loadXML"](sXMLText);
        }

        return oXMLDocument;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["oParseXMLDocument"] = 0;
    }
    ;

    /**
     * Retunrs a serialized XML string from a given XMLDOM
     * @param {XMLDOM} oXMLDocument The XMLDOM to serialize
     * @return {string} The serialized string
     */
    UCF_JsUtil["sSerializeXMLDocument"] = function (oXMLDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sSerializeXMLDocument"]++;
        }
        ;
        var sXMLString = "";

        if (window["XMLSerializer"]) {
            var serializer = new XMLSerializer();
            sXMLString = serializer["serializeToString"](oXMLDocument);
        } else if (UCF_JsUtil["bCanActiveX"]()) {
            sXMLString = oXMLDocument["xml"];
        }

        return sXMLString;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sSerializeXMLDocument"] = 0;
    }
    ;

    /**
     * internal
     * @param {HTMLElement} oElement the element thats comment childNodes should be
     * removed
     */
    UCF_JsUtil["removeComments"] = function (oElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["removeComments"]++;
        }
        ;
        var aChildNodes = oElement["childNodes"],
            oChildNode;
        for (var i = 0; i < aChildNodes["length"]; i++) {
            oChildNode = aChildNodes[i];
            switch (oChildNode["nodeType"]) {
                case 1: // ELEMENT_NODE
                    UCF_JsUtil["removeComments"](oChildNode);
                    break;
                // eslint-disable-next-line no-magic-numbers
                case 8: // COMMENT_NODE
                    oElement["removeChild"](oChildNode);
                    i--;
                    break;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["removeComments"] = 0;
    }
    ;

    /**
     * Decodes the URI parameters
     * @param {string} sParameters The query string to decode
     * @return {map} The map of parameters
     */
    UCF_JsUtil["mDecodeURIParameters"] = function (sParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["mDecodeURIParameters"]++;
        }
        ;
        var aParameters = sParameters["split"]("&"),
            mParameters = {},
            aParameter,
            sName = "",
            sValue = "";
        for (var i = 0; i < aParameters["length"]; i++) {
            aParameter = aParameters[i]["split"]("=");
            sName = decodeURIComponent(aParameter[0]);
            // eslint-disable-next-line no-magic-numbers
            sValue = aParameter["length"] === 2
                ? decodeURIComponent(aParameter[1])
                : "";
            if (!mParameters[sName]) {
                mParameters[sName] = sValue;
            } else {
                if (typeof mParameters[sName] === "string") {
                    mParameters[sName] = [mParameters[sName]];
                }
                mParameters[sName]["push"](sValue);
            }
        }
        return mParameters;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["mDecodeURIParameters"] = 0;
    }
    ;

    /**
     * Extracts the name of a function if not anonymous from the given function
     * pointer
     * @param {function} oFunction pointer to the function
     * @return {string} The name of the function
     */
    UCF_JsUtil["sExtractFunctionName"] = function (oFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sExtractFunctionName"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oFunction === "function", "typeof oFunction === \"function\"", "JsUtil.js(1439): sExtractFunctionName");
        }
        ;

        /** @type {string} */
        var sText = oFunction["toString"]();

        return sText["substr"]("function "["length"], UCF_JsUtil["indexOf"](sText, "(") - "function "["length"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sExtractFunctionName"] = 0;
    }
    ;

    /**
     * Checks if the object is empty
     * @param {Object} oObject The object to check
     * @return {boolean} true if the object is empty
     */
    UCF_JsUtil["bIsEmpty"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsEmpty"]++;
        }
        ;
        var _;

        switch (typeof oObject) {
            case 'object':
                for (_ in oObject) {
                    return false;
                }

                return true;
            default:
                return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsEmpty"] = 0;
    }
    ;

    /**
     * Checks whether the passed parameter is an Array ([]). Also instances from
     * other frames are detected correctly.
     *
     * @param {Object} o the object to check.
     * @return {boolean} true if a is an Array
     */
    UCF_JsUtil["bIsArray"] = function (o) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsArray"]++;
        }
        ;
        return o != null && Object["prototype"]["toString"]["call"](o) === "[object Array]";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsArray"] = 0;
    }
    ;

    /**
     * Checks whether the passed parameter is an Object ({}). Also instances from
     * other frames are detected correctly.
     *
     * @param {Object} o the object to check.
     * @return {boolean} true if a is an Object
     */
    UCF_JsUtil["bIsObject"] = function (o) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsObject"]++;
        }
        ;
        return o != null && Object["prototype"]["toString"]["call"](o) === "[object Object]";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsObject"] = 0;
    }
    ;

    /** @typedef {'undefined'|'object'|'boolean'|'number'|'bigint'|'string'|'symbol'|'function'} _TypeofResult */
    /**
     * Checks whether the passed oFunc object is a function pointer or not.
     * @param {Object} oFunc The object to check
     * @return {boolean} true it is a function pointer, else false
     */
    UCF_JsUtil["bIsFunction"] = function (oFunc) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsFunction"]++;
        }
        ;
        /** @type {_TypeofResult} */
        var sTypeof;

        if (oFunc) {
            sTypeof = typeof oFunc;

            return sTypeof === 'function'
                || (sTypeof === 'object' &&
                    oFunc["toString"] &&
                    UCF_StringUtil["bStartsWith"](oFunc["toString"](), 'function '));
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsFunction"] = 0;
    }
    ;

    /**
     * Checks whether two variables have equal content. For objects you can define
     * a depth (starting) and maxdepth(ending) the comparison.
     * @param {any} a a value
     * @param {any} b another value
     * @param {number} [maxDepth=10] The maximal depth to compare in objects or arrays
     * @param {number} [depth=0] The startinf depth in objects or arrays
     * @return {boolean} true if a and b are equal.
     */
    UCF_JsUtil["bEqual"] = function (a, b, maxDepth, depth) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bEqual"]++;
        }
        ;
        /** @type {(number|string)} */
        var i;

        if (!depth) depth = 0;
        if (!maxDepth) maxDepth = 10;
        if (depth > maxDepth) return false;
        if (a === b) return true;
        if (UCF_JsUtil["bIsArray"](a) && UCF_JsUtil["bIsArray"](b)) {
            if (a["length"] !== b["length"]) {
                return false;
            }
            for (i = 0; i < a["length"]; i++) {
                if (!UCF_JsUtil["bEqual"](a[i], b[i], maxDepth, depth + 1)) {
                    return false;
                }
            }
            return true;
        }
        if (typeof a === "object" && typeof b === "object") {
            if (!a || !b) {
                return false;
            }
            if (a["constructor"] !== b["constructor"]) {
                return false;
            }
            if (a instanceof Date) {
                return a["valueOf"]() === b["valueOf"]();
            }
            for (i in a) {
                if (!UCF_JsUtil["bEqual"](a[i], b[i], maxDepth, depth + 1)) {
                    return false;
                }
            }
            for (i in b) {
                if (a[i] === undefined) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bEqual"] = 0;
    }
    ;

    /**
     * Checks whether the given object o is a plain old js object without methods
     * @param {Object} o The object to check
     * @return {boolean}  true if the object is a POJS object
     */
    UCF_JsUtil["bIsPlainObject"] = function (o) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsPlainObject"]++;
        }
        ;
        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor
        // property. Make sure that DOM nodes and window objects don't pass through,
        // as well

        var getType = function (o) {
            return !o ? String(o) : "object";
        };

        if (!o || getType(o) !== "object") {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if (o["constructor"] &&
                !Object["prototype"]["hasOwnProperty"]["call"](o, "constructor") &&
                !Object["prototype"]["hasOwnProperty"]["call"](
                    o["constructor"]["prototype"],
                    "isPrototypeOf"
                )
            ) {
                return false;
            }
        } catch (e) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.

        var key;
        for (key in o) {
        }

        return key === undefined || Object["prototype"]["hasOwnProperty"]["call"](o, key);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsPlainObject"] = 0;
    }
    ;

    /**
     * Merges all objects in oMerge in oOriginal and returns them
     * Array entries need to be null for deletes otherwise they are kept
     * Array need to be nulled for delete.
     * @param {Object} oOriginal The original
     * @param {Object} oMerge The object to be merged
     * @return {Object} The merged instance of the oOriginal object.
     */
    UCF_JsUtil["oMergeObjects"] = function (oOriginal, oMerge) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["oMergeObjects"]++;
        }
        ;
        if (UCF_JsUtil["bIsPlainObject"](oMerge)) {
            for (var n in oMerge) {
                if (!oOriginal[n] ||
                    (!UCF_JsUtil["bIsPlainObject"](oMerge[n]) &&
                        !UCF_JsUtil["bIsArray"](oMerge[n])
                    )
                ) {
                    if (oMerge[n] === null) {
                        delete oOriginal[n];
                    } else {
                        oOriginal[n] = oMerge[n];
                    }
                } else {
                    if (!UCF_JsUtil["bIsPlainObject"](oMerge[n]) &&
                        !UCF_JsUtil["bIsArray"](oMerge[n])
                    ) {
                        if (oMerge[n] === null) {
                            delete oOriginal[n];
                        } else {
                            oOriginal[n] = oMerge[n];
                        }
                    } else {
                        oOriginal[n] = UCF_JsUtil["oMergeObjects"](oOriginal[n], oMerge[n]);
                    }
                }
            }
        } else if (UCF_JsUtil["bIsArray"](oMerge)) {
            //first update all entries that were originally in the array
            var i;
            for (i = 0; i < oOriginal["length"]; i++) {
                if (oMerge[i]) {
                    oOriginal[i] = UCF_JsUtil["oMergeObjects"](oOriginal[i], oMerge[i]);
                } else if (oMerge[i] === null) {
                    //delete
                    oOriginal[i] = null;
                }
            }
            for (; i < oMerge["length"]; i++) {
                oOriginal[i] = oMerge[i];
            }
            i = 0;
            while (true) {
                if (oOriginal[i] === null) {
                    oOriginal["splice"](i, 1);
                    if (i === oOriginal["length"]) {
                        break;
                    }
                    continue;
                }
                i++;
                if (i === oOriginal["length"]) {
                    break;
                }
            }
        }

        return oOriginal;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["oMergeObjects"] = 0;
    }
    ;

    /**
     * Checks if a given object o is contained in an array a
     * @param {Object} o Object
     * @param {Array} a Array
     * @return {integer} Returns the index of an object in an array
     */
    UCF_JsUtil["iObjectIndexInArray"] = function (o, a) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["iObjectIndexInArray"]++;
        }
        ;
        var len;
        var i = 0;
        if (a) {
            if (Array["prototype"]["indexOf"]) {
                return Array["prototype"]["indexOf"]["call"](a, o, i);
            }

            len = a["length"];
            i = i ? i < 0 ? Math["max"](0, len + i) : i : 0;

            for (; i < len; i++) {
                // Skip accessing in sparse arrays
                if (i in a && a[i] === o) {
                    return i;
                }
            }
        }

        return -1;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["iObjectIndexInArray"] = 0;
    }
    ;

    /**
     * Loops over all entries in oObject and calls the given callback method
     * passing the object, the index and the given arguments
     * @param {Object} object Object to loop
     * @param {function} callback The function to call
     * @param {any} args The be passed to the callback
     * @return {Object} null if object is not an object otherwise the object
     */
    UCF_JsUtil["each"] = function (object, callback, args) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["each"]++;
        }
        ;
        if (!object) return null;

        var name, i = 0,
            length = object["length"],
            isObj = length === undefined || typeof object === "function";

        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback["apply"](object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for (; i < length;) {
                    if (callback["apply"](object[i++], args) === false) {
                        break;
                    }
                }
            }

            // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback["call"](object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for (; i < length;) {
                    if (callback["call"](object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }

        return object;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["each"] = 0;
    }
    ;

    /**
     * Calls aItems.forEach(fCallback, thisArg).
     *
     * @param {Array.<T>} aItems the items to be iterated over
     * @param {function(T, number?, Array.<T>?): void} fCallback the callback to be
     * called on each item
     * @param {Object} [thisArg] context for `this` in the callback
     * @template T
     */
    UCF_JsUtil["forEach"] = function (aItems, fCallback, thisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["forEach"]++;
        }
        ;
        var T
            , k
            , O
            , len
            , kValue;

        if (typeof aItems["forEach"] === 'function') {
            aItems["forEach"](fCallback, thisArg);
        } else {
            if (!aItems) throw new TypeError('aItems is null or not defined');

            O = Object(aItems);
            len = O["length"] >>> 0;

            if (typeof fCallback !== 'function') {
                throw new TypeError(fCallback + ' is not a function');
            }
            if (arguments["length"] > 1) T = thisArg;

            k = 0;
            while (k < len) {
                if (k in O) {
                    kValue = O[k];
                    fCallback["call"](T, kValue, k, O);
                }
                k += 1;
            }

            // return undefined; is returned implicitly
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["forEach"] = 0;
    }
    ;

    /**
     * @example
     * UCF_JsUtil.map([1,2,3], function(i) { return [i*i]; })
     * // => [[1],[4],[9]]
     * @template T,U
     * @param {Array.<T>} aElements the elements to map
     * @param {function(T, number?, Array.<T>?): U} fFn function to be used
     * to translate
     * @param {Object} [oThisArg] this
     * @return {Array.<U>} The translated value, which will be mapped to the
     * resulting array
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill
     */
    UCF_JsUtil["map"] = function (aElements, fFn, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["map"]++;
        }
        ;
        /** @type {number} */
        var iLength;
        /** @type {Array.<U>} */
        var aResult;
        /** @type {number} */
        var i;

        if (typeof aElements["map"] === 'function') {
            return aElements["map"](fFn, oThisArg);
        } else {
            iLength = aElements["length"] >>> 0;
            if (typeof fFn !== 'function') {
                throw new TypeError(fFn + ' is not a function');
            }
            aResult = new Array(iLength);

            for (i = 0; i < iLength; i++) {
                if (i in aElements) {
                    aResult[i] = fFn["call"](oThisArg, aElements[i], i, aElements);
                }
            }

            return aResult;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["map"] = 0;
    }
    ;

    /**
     * Creates a new list of items that only contains those from aItems
     * that match fPredicate.
     *
     * @template T
     * @param {Array.<T>} aItems the items to be filtered
     * @param {function(T): boolean} fPredicate called with every item, return true
     * to include/false to exclude item
     * @param {Object} [oThisArg] context
     * @return {Array.<T>} a new list containing all items that match the predicate
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Polyfill
     */
    UCF_JsUtil["filter"] = function (aItems, fPredicate, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["filter"]++;
        }
        ;
        /** @type {Object} */
        var t;
        /** @type {number} */
        var len;
        /** @type {Array.<T>} */
        var res;
        /** @type {number} */
        var i;
        /** @type {T} */
        var val;

        if (__UCF_IE6__) {
            if (aItems === void 0 || aItems === null) {
                throw new TypeError('filter called with null list.');
            }

            t = Object(aItems);
            len = t["length"] >>> 0;
            if (typeof fPredicate !== 'function') {
                throw new TypeError('filter called with non-function predicate');
            }

            res = [];
            for (i = 0; i < len; i += 1) {
                if (i in t) {
                    val = t[i];
                    if (fPredicate["call"](oThisArg, val, i, t)) {
                        res["push"](val);
                    }
                }
            }

            return res;
        } else {
            return aItems["filter"](fPredicate, oThisArg);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["filter"] = 0;
    }
    ;

    /**
     * @template T
     * @param {Array.<T>} aItems a list of Items
     * @param {function(T): boolean} fPredicate predicate of the item to be found
     * @param {Object} [oThisArg] context
     * @return {T} first item to match `fPredicate` in `aItems`
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
     */
    UCF_JsUtil["find"] = function (aItems, fPredicate, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["find"]++;
        }
        ;
        /** @type {number} */
        var iLength;
        /** @type {T} */
        var oValue;
        /** @type {number} */
        var i;

        // IE11 has no [].find()
        if (typeof aItems["find"] === 'function') {
            return aItems["find"](fPredicate, oThisArg);
        } else {
            iLength = aItems["length"] >>> 0;
            for (i = 0; i < iLength; i++) {
                oValue = aItems[i];
                if (fPredicate["call"](oThisArg, oValue, i, aItems)) {
                    return oValue;
                }
            }

            return undefined;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["find"] = 0;
    }
    ;

    /**
     * @template T
     * @param {T[]} aItems a list of items
     * @param {function(T): boolean} fPredicate predicate of the item to be found
     * @param {Object} [oThisArg] context
     * @return {number} the index of the first item ti match `fPredicate` in `aItems`
     * @see https: //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
     */
    UCF_JsUtil["findIndex"] = function (aItems, fPredicate, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["findIndex"]++;
        }
        ;
        /** @type {number} */
        var iLength;
        /** @type {T} */
        var oValue;
        /** @type {number} */
        var i;

        if (typeof aItems["find"] === 'function') {
            return aItems["find"](fPredicate, oThisArg);
        } else {
            iLength = aItems["length"] >>> 0;
            for (i = 0; i < iLength; i++) {
                oValue = aItems[i];
                if (fPredicate["call"](oThisArg, oValue, i, aItems)) {
                    return i;
                }
            }

            return -1;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["findIndex"] = 0;
    }
    ;

    /**
     * @template T
     * @param {Array.<T>} aItems a list of items
     * @param {function(T): boolean} fPredicate predicate all items must match
     * @param {Object} [oThisArg] context
     * @return {boolean} `true` if all items match fPredicate, otherwise `false`
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
     */
    UCF_JsUtil["every"] = function (aItems, fPredicate, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["every"]++;
        }
        ;
        /** @type {number} */
        var iLength;
        /** @type {number} */
        var i;

        if (__UCF_IE6__) {
            if (aItems == null) {
                throw new TypeError('aItems is null or undefined');
            }
            iLength = aItems["length"] >>> 0;

            if (typeof fPredicate !== 'function') {
                throw new TypeError('fPredicate is not a function');
            }

            for (i = 0; i < iLength; i++) {
                if (i in aItems && !fPredicate["call"](oThisArg, aItems[i], i, aItems)) {
                    return false;
                }
            }

            return true;
        } else {
            return aItems["every"](fPredicate, oThisArg);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["every"] = 0;
    }
    ;

    /**
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/some
     * @param {Array.<T>} aItems a list of items
     * @param {function(T): boolean} fPredicate predicate an item must match
     * @param {Object} [oThisArg] context
     * @return {boolean} `true` if at least one item matches fPredicate, otherwise
     * `false`
     * @template T
     */
    UCF_JsUtil["some"] = function (aItems, fPredicate, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["some"]++;
        }
        ;
        /** @type {number} */
        var iLength;
        /** @type {number} */
        var i;

        if (__UCF_IE6__) {
            if (aItems == null) {
                throw new TypeError('aItems is null or undefined');
            }
            iLength = aItems["length"] >>> 0;

            if (typeof fPredicate !== 'function') {
                throw new TypeError();
            }

            for (i = 0; i < iLength; i++) {
                if (i in aItems && fPredicate["call"](oThisArg, aItems[i], i, aItems)) {
                    return true;
                }
            }

            return false;
        } else {
            return aItems["some"](fPredicate, oThisArg);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["some"] = 0;
    }
    ;

    /**
     * Build a single result from a list of values. Also known as
     * 'foldl' or 'inject'. E.g.
     *
     *     UCF_JsUtil.reduce([1,2,3,4], function(iSum, iCurrent, iIndex) {
     *       return iSum + iCurrent;
     *     }, 0)
     *     // => 10
     *
     * @template I, T
     * @param {Array.<T>} aItems the list of items to be reduced
     * @param {function(I, T, ?number, ?Array.<T>): I} fIteratee function called on
     * every element in aItems
     * @param {I} oInitial the initial value
     * @return {I} result of reducing `aItems`
     */
    UCF_JsUtil["reduce"] = function (aItems, fIteratee, oInitial) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["reduce"]++;
        }
        ;
        /** @type {T[]} */
        var t;
        /** @type {number} */
        var len;
        /** @type {number} */
        var k;
        /** @type {{length: 2, 0: T[], 1: I}} */
        var args;
        /** @type {I} */
        var accumulator;

        if (__UCF_IE6__) {
            args = Array["prototype"]["slice"]["call"](arguments, 1);

            if (!aItems) {
                throw new TypeError('.reduce called on null or undefined');
            }
            if (typeof fIteratee !== 'function') {
                throw new TypeError(fIteratee + ' is not a function');
            }

            t = Object(aItems);
            len = t["length"] >>> 0;
            k = 0;

            if (len === 0 && args["length"] === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            // eslint-disable-next-line no-magic-numbers
            if (args["length"] >= 2) {
                accumulator = args[1];
            } else {
                do {
                    if (k in t) {
                        accumulator = t[k += 1];
                        break;
                    }
                    if (k += 1 >= len) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }
            while (k < len) {
                if (k in t) {
                    accumulator = fIteratee["call"](undefined, accumulator, t[k], k, t);
                }
                k += 1;
            }

            return accumulator;
        } else {
            return aItems["reduce"](fIteratee, oInitial);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["reduce"] = 0;
    }
    ;

    /**
     * Finds the zero-based index of the first occurance
     * of oNeedle in aHaystack.
     *
     * @template T
     * @param {Array.<T>} aHaystack the list if items to find oNeedle in
     * @param {T} oNeedle the item to find in aHaystack
     * @param {number} [iFromIndex=0] the start index for searching
     * @return {number} the index of the first occurance of oNeedle in aHaystack
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
     */
    UCF_JsUtil["indexOf"] = function (aHaystack, oNeedle, iFromIndex) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["indexOf"]++;
        }
        ;
        var t
            , len
            , n
            , args = Array["prototype"]["slice"]["call"](arguments, 1)
            , k;

        if (typeof aHaystack["indexOf"] === 'function') {
            return aHaystack["indexOf"](oNeedle);
        } else {
            t = Object(aHaystack);
            len = t["length"] >>> 0;

            if (len === 0) {
                return -1;
            }

            n = 0;
            if (args["length"] > 0) {
                n = Number(args[1]);
                if (isNaN(n)) {
                    n = 0;
                } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                    n = (n > 0 || -1) * Math["floor"](Math["abs"](n));
                }
            }

            if (n >= len) {
                return -1;
            }

            k = n >= 0 ? n : Math["max"](len - Math["abs"](n), 0);

            for (; k < len; k += 1) {
                if (k in t && t[k] === oNeedle) {
                    return k;
                }
            }

            return -1;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["indexOf"] = 0;
    }
    ;

    /**
     * @template T
     * @param {Array.<T>} aHaystack the items to search oNeedle in
     * @param {T} oNeedle the item to be found in the aHaystack
     * @return {boolean} true if it is found, otherwise false
     */
    UCF_JsUtil["contains"] = function (aHaystack, oNeedle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["contains"]++;
        }
        ;
        return UCF_JsUtil["indexOf"](aHaystack, oNeedle) > -1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["contains"] = 0;
    }
    ;

    /**
     * Extend the first object with properties of all following. Modifies
     * the first object!
     *
     * @example
     * UCF_JsUtil.extend({foo: 'foo'}, {bar: 'bar'}, {baz: 'baz')})
     * => {foo: 'foo', bar: 'bar', baz: 'baz'}
     *
     * @example
     * var a = {foo: 'foo'}
     * UCF_JsUtil.extend(a, {foo: 'bar'})
     * a.foo === 'bar' // => true
     *
     * @param {Object} obj the object to be extended
     * @return {Object} modified version of `obj`, all other objects merged into it
     */
    UCF_JsUtil["extend"] = function (obj) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["extend"]++;
        }
        ;
        var length = arguments["length"];
        // eslint-disable-next-line no-magic-numbers
        if (length < 2 || !obj) return obj;
        for (var index = 1; index < length; index += 1) {
            var source = arguments[index];
            for (var key in source) {
                obj[key] = source[key];
            }
        }
        return obj;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["extend"] = 0;
    }
    ;

    /**
     * calls Object.keys(obj) (or uses polyfill to obtain the keys)
     *
     * @param {Object} obj the object that's keys should be retrieved
     * @return {Array<string>} list of keys of the object, equivalent to
     * Object.keys(obj)
     */
    UCF_JsUtil["keys"] = function (obj) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["keys"]++;
        }
        ;
        var hasOwnProperty
            , hasDontEnumBug
            , dontEnums
            , result
            , prop
            , i;

        if (__UCF_IE6__) {
            hasOwnProperty = Object["prototype"]["hasOwnProperty"];
            hasDontEnumBug = !({"toString": null})["propertyIsEnumerable"]('toString');
            dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumberable',
                'constructor'
            ];
            result = [];

            if (typeof obj !== 'object'
                && (typeof obj !== 'function' || obj === null)) {
                throw new TypeError('can not call Object.keys() on non-object');
            } else {
                for (prop in obj) {
                    if (hasOwnProperty["call"](obj, prop)) {
                        result["push"](prop);
                    }
                }
                if (hasDontEnumBug) {
                    for (i = 0; i < dontEnums["length"]; i += 1) {
                        if (hasOwnProperty["call"](obj, dontEnums[i])) {
                            result["push"](dontEnums[i]);
                        }
                    }
                }
                return result;
            }
        } else {
            return Object["keys"](obj);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["keys"] = 0;
    }
    ;

    /**
     * calls Object.values(oObject) (or uses polyfill to obtain the values)
     *
     * @example
     * ```javascript
     * UCF_JsUtil.values({foo: 1, bar: 2}) // => [1,2]
     * ```
     *
     * @param {Object} oObject the object to get the values from
     * @return {Array} a list with values of the given object
     */
    UCF_JsUtil["values"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["values"]++;
        }
        ;
        /** @type {Array} */
        var aResult;
        /** @type {Object} */
        var oKey;

        if (typeof Object["values"] === 'function') {
            return Object["values"](oObject);
        } else {
            // IE11 has no Object.values
            aResult = [];
            for (oKey in oObject) {
                if (oObject["hasOwnProperty"](oKey)) {
                    aResult["push"](oObject[oKey]);
                }
            }

            return aResult;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["values"] = 0;
    }
    ;

    /**
     * calls Object.entries(oObject) (or uses polyfill to obtain the values)
     *
     * @example
     * ```javascript
     * UCF_JsUtil.entries({foo: 1, bar: 2}) // => [['foo', 1], ['bar', 2]]
     * ```
     *
     * @param {Object} oObject the object to get the entries from
     * @return {Array} a list with entries of the given object
     */
    UCF_JsUtil["entries"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["entries"]++;
        }
        ;
        var aResult;
        var oKey;

        if (typeof Object["entries"] === 'function') {
            return Object["entries"](oObject);
        } else {
            aResult = [];
            for (oKey in oObject) {
                if (oObject["hasOwnProperty"](oKey)) {
                    aResult["push"]([oKey, oObject[oKey]]);
                }
            }

            return aResult;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["entries"] = 0;
    }
    ;

    /**
     * Creates an array from a json object where 0 becomes the first entry in the
     * array
     * @param {Object} oObject The object to be transformed to an array
     * @return {Array} The newly created array
     */
    UCF_JsUtil["arrayFromObject"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["arrayFromObject"]++;
        }
        ;
        var aArray = [];
        for (var n in oObject) {
            var i = parseInt(n);
            if (!isNaN(i)) {
                aArray[i] = oObject[n];
            }
        }
        return aArray;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["arrayFromObject"] = 0;
    }
    ;

    /**
     * polyfilled equivalent of Array.from()
     *
     * @public
     * @param {Object} oArraylike an array-like object (e.g. an iterator or a
     * nodelist)
     * @param {function} fMapFunction function mapped to all elements of the array
     * @param {Object} oThisArg contect for fMapFunction (will be `this` in it)
     * @return {Array} oArraylike turned into a real array
     */
    UCF_JsUtil["arrayFrom"] = function (oArraylike, fMapFunction, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["arrayFrom"]++;
        }
        ;
        if (typeof Array["from"] === 'function') {
            return Array["from"](oArraylike, fMapFunction, oThisArg);
        } else {
            // IE11 has no Array.from
            return UCF_JsUtil["arrayFromPolyfill"](oArraylike, fMapFunction, oThisArg);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["arrayFrom"] = 0;
    }
    ;

    /**
     * used by `UCF_JsUtil.arrayFrom` if native `Array.from` is not available
     *
     * @see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Polyfill
     * @param {Object} oArraylike an array-like object (e.g. an iterator or a
     * nodelist)
     * @param {function} fMapFunction function mapped to all elements of the array
     * @param {Object} oThisArg context for fMapFunction (will be `this` in it)
     * @return {Array} oArraylike turned into a real array
     */
    UCF_JsUtil["arrayFromPolyfill"] = function (oArraylike, fMapFunction, oThisArg) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["arrayFromPolyfill"]++;
        }
        ;

        /** @type {number} */
        var iMaxSafeInteger = Math["pow"](2, 53) - 1; // eslint-disable-line no-magic-numbers
        /** @type {Object} */
        var aItems = Object(oArraylike);
        /** @type {number} */
        var iLength;
        /** @type {Array} */
        var aResult;
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oItem;

        /**
         * @param {Object} f an object
         * @return {boolean} `true` if f is callable, otherwise `false`
         */
        function bIsCallable(f) {
            return typeof f === 'function'
                || Object["prototype"]["toString"]["call"](f) === '[object Function]';
        }

        /**
         * @param {Object} v an object
         * @return {number} the floored absolute value of v as a number
         */
        function iToInteger(v) {
            var iNumber = Number(v);
            if (isNaN(iNumber)) {
                return 0;
            }
            if (iNumber === 0 || !isFinite(iNumber)) {
                return iNumber;
            }
            return (iNumber > 0 ? 1 : -1) * Math["floor"](Math["abs"](iNumber));
        }

        /**
         * @param {Object} v an object
         * @return {number} the smaller of iMaxSafeInteger and iToInteger(v)
         */
        function iToLength(v) {
            var iLength = iToInteger(v);
            return Math["min"](iMaxSafeInteger, Math["max"](iLength, 0));
        }

        if (!oArraylike) {
            throw new TypeError(
                'Array.from requires an array-like object - not falsy'
            );
        }
        if (typeof fMapFunction !== 'undefined' && !bIsCallable(fMapFunction)) {
            throw new TypeError(
                'Array.from: when provided, the second argument be a function'
            );
        }
        iLength = iToLength(aItems["length"]);

        aResult = new Array(iLength);
        for (i = 0; i < iLength; i++) {
            oItem = aItems[i];
            aResult[i] = fMapFunction
                ? (typeof oThisArg === 'undefined' ?
                    fMapFunction(oItem, i) :
                    fMapFunction["call"](oThisArg, oItem, i))
                : oItem;
        }
        aResult["length"] = iLength;
        return aResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["arrayFromPolyfill"] = 0;
    }
    ;

    UCF_JsUtil["eActiveComponents"] = {
        "WORD": "word",
        "EXCEL": "excel",
        "FLASH": "flash",
        "ACROBAT": "acrobat",
        "SILVERLIGHT": "silverlight",
        "JAVA": "java(tm)"
    };

    UCF_JsUtil["mActiveComponentToActiveXMap"] = {
        "word": "Word.Application",
        "excel": "Excel.Application",
        "flash": "ShockwaveFlash.ShockwaveFlash.1",
        "acrobat": "AcroPDF.PDF",
        "silverlight": "AgControl.AgControl",
        "java(tm)": "JavaWebStart.isInstalled"
    };


    /**
     * Checks whether the passed active component is enabled on client side or not,
     *
     * @example
     * UCF_JsUtil.bIsActiveComponentEnabled(
     *     UCF_JsUtil.eActiveComponents.JAVA
     * );
     * @param {string} eActiveComponentKey passed with the
     * UCF_JsUtil.eActiveComponents enummeration
     * @return {boolean} true when active component is enabled
     */
    UCF_JsUtil["bIsActiveComponentEnabled"] = function (eActiveComponentKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsActiveComponentEnabled"]++;
        }
        ;
        if (UCF_JsUtil["bCanActiveX"]()) {
            try {
                new window["ActiveXObject"](
                    UCF_JsUtil["mActiveComponentToActiveXMap"][eActiveComponentKey]
                );
                return true;
            } catch (e) {
            }
            ;
        } else {
            if (eActiveComponentKey === UCF_JsUtil["eActiveComponents"]["JAVA"]) {
                if (UCF_JsUtil["sGetInstalledJavaVersion"]() !== "NOT_INSTALLED") {
                    return true;
                }
                return false;
            }
            for (var i = 0; i < navigator["plugins"]["length"]; i++) {
                if (UCF_StringUtil["bContains"](
                    navigator["plugins"][i]["name"]["toLowerCase"](),
                    eActiveComponentKey
                )) {
                    return true;
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsActiveComponentEnabled"] = 0;
    }
    ;


    /**
     * Checks which Java bversion is supported by the browser plugins
     * 'NOT_INSTALLED' if Java is not installed, 'UNKNOWN' if version unknown or
     * X.X depending on the java version e.g. '1.4'. Patch levels are not included
     *
     * @return {string} the version string or 'NOT_INSTALLED'|'UNKNOWN'
     */
    UCF_JsUtil["sGetInstalledJavaVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["sGetInstalledJavaVersion"]++;
        }
        ;
        /** @type {number} */
        var iVersion;
        /** @type {number} */
        var i;

        if (UCF_JsUtil["bCanActiveX"]()) {
            try {
                new window["ActiveXObject"]("JavaWebStart.isInstalled");
            } catch (e) {
                return "NOT_INSTALLED";
            }
            ;

            // eslint-disable-next-line no-magic-numbers
            for (iVersion = 9; iVersion >= 4; iVersion--) { // FIXME once java 1.10 is out...
                try {
                    new window["ActiveXObject"](
                        "JavaWebStart.isInstalled.1." + iVersion + ".0.0"
                    );
                    return "1." + iVersion;
                } catch (e) {
                }
                ;
            }

            return "UNKNOWN";
        } else {
            for (i = 0; i < navigator["mimeTypes"]["length"]; i++) {
                //according to http://docs.oracle.com/javase/7/docs/technotes/guides/jweb/otherFeatures/version.html
                var aMatch = navigator["mimeTypes"][i]["type"]["match"](
                    /application\/x-java-applet;jpi-version=(\d\.\d+).*/
                );
                if (aMatch && aMatch[1]) {
                    return aMatch[1];
                }
            }
            return "NOT_INSTALLED";
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["sGetInstalledJavaVersion"] = 0;
    }
    ;

    /**
     * Checks whether there are object references within oObject that were not
     * released correctly and might cause a memory leak.
     * @param {UCF_Object} oObject the object to inspect.
     * @param {string} sTracePath optional The call stack to the possible leak.
     *
     */
    UCF_JsUtil["checkPossibleLeaks"] = function (oObject, sTracePath) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["checkPossibleLeaks"]++;
        }
        ;
        if (!sTracePath) sTracePath = "";
        for (var n in oObject) {
            if (UCF_JsUtil["bIsPlainObject"](oObject[n])) {
                if (oObject["sClassName"]) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, "Possible memory leak for member " + n + " - " + oObject["sClassName"], "JsUtil.js(2533): checkPossibleLeaks");
                    }
                    ;
                } else {
                    var s = UCF_JsUtil["sGetCaller"]();
                    if (s) {
                        sTracePath += '<-' + s;
                    }
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, "Possible memory leak for member " + n + " - Stack is: " + sTracePath, "JsUtil.js(2539): checkPossibleLeaks");
                    }
                    ;
                }
                UCF_JsUtil["checkPossibleLeaks"](oObject[n]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["checkPossibleLeaks"] = 0;
    }
    ;

    /**
     * Checks whether localStorage is supported or not
     * @return {bool} `true` if the browser supports local storage
     */
    UCF_JsUtil["bSupportsLocalStorage"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bSupportsLocalStorage"]++;
        }
        ;
        if (UCF_JsUtil["bLocalStorage"] != null) return UCF_JsUtil["bLocalStorage"];

        // bug in IE11 on Windows 8.1: In Enhanced Protected Mode,
        // window.localStorage exists but you get an 'Access denied' error
        try {
            if (!window["localStorage"]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "Local storage not supported", "JsUtil.js(2557): bSupportsLocalStorage");
                }
                ;
                UCF_JsUtil["bLocalStorage"] = false;
            } else {
                UCF_JsUtil["bLocalStorage"] = true;

                if (UCF_UserAgent["bIsSafari"]()) {
                    // bug in Safari in-private browser mode. window.localStorage exists
                    // but you can't access setItem. Error message "QUOTA_EXCEEDED_ERR: DOM
                    // Exception 22: An attempt was made to add something to storage that
                    // exceeded the quota."
                    try {
                        window["localStorage"]["setItem"]("testLocalStorage", "0");
                    } catch (ex) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(INFO, "Local storage not supported in Safari (maybe private browsing)", "JsUtil.js(2570): bSupportsLocalStorage");
                        }
                        ;
                        UCF_JsUtil["bLocalStorage"] = false;
                    }
                }
                ;
            }

        } catch (ex) {
            UCF_JsUtil["bLocalStorage"] = false;
        }

        return UCF_JsUtil["bLocalStorage"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bSupportsLocalStorage"] = 0;
    }
    ;

    /**
     * BEWARE!!! this takes 50ish ms (in Chrome 62). Don't call this synchronously.
     *
     * @return {Array.<Object>} list of maps of css properties for all fonts
     * defined via @font-face in all stylesheets in the document
     */
    UCF_JsUtil["aGetThemeDefinedFonts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["aGetThemeDefinedFonts"]++;
        }
        ;
        return __UCF_IE6__
            // ie6 has .rules instead of .cssRules, and these rules don't have a
            // .cssText, but we don't support any theme with theme-defined fonts in ie6
            // so we are safe to default to []
            ? []
            : UCF_JsUtil["reduce"](
                UCF_JsUtil["map"](
                    UCF_JsUtil["arrayFrom"](document["styleSheets"]),
                    function (oStyleSheet) {
                        try {
                            return UCF_JsUtil["filter"](
                                UCF_JsUtil["arrayFrom"](oStyleSheet["cssRules"]),
                                function (oCssRule) {
                                    try {
                                        return UCF_StringUtil["bContains"](
                                            oCssRule["cssText"],
                                            '@font-face'
                                        );
                                    } catch (e) {
                                        // IE: @keyframes .cssText throws "Member not found" instead
                                        // of being undefined or null
                                        return false;
                                    }
                                }
                            );
                        } catch (e) {
                            // SecurityError might be thrown for css from different origin
                            // (would require <link crossorigin="anonymous|use-credentials">)
                            return [];
                        }
                    }
                ),
                function (aRules, aRulesInStyleSheet) {
                    return aRules["concat"](aRulesInStyleSheet["length"] > 0
                        ? UCF_JsUtil["map"](
                            aRulesInStyleSheet,
                            function (oRule) {
                                var oResult = {};

                                UCF_JsUtil["forEach"](
                                    UCF_JsUtil["arrayFrom"](oRule["style"]),
                                    function (sProperty) {
                                        if (sProperty !== 'src') {
                                            oResult[sProperty] = oRule["style"][sProperty];
                                        }
                                    }
                                );

                                return oResult;
                            }
                        )
                        : []);
                },
                []
            );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["aGetThemeDefinedFonts"] = 0;
    }
    ;

//FESR

    /**
     * Gets an array of a char
     *
     * @param {int} iLength length of the array
     * @param {string} sChr Character to add
     * @return {Array} created array of sChr
     */
    UCF_JsUtil["aGetCharArray"] = function (iLength, sChr) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["aGetCharArray"]++;
        }
        ;
        var aArray = [];
        aArray["length"] = iLength;
        return aArray["join"](sChr);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["aGetCharArray"] = 0;
    }
    ;

    /**
     * Gets an array of charCodes (UTF-16 code number) of a given string
     *
     * @param {string} sString given string
     * @return {Array} array of charCodes
     */
    UCF_JsUtil["aGetCharCodeFromString"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["aGetCharCodeFromString"]++;
        }
        ;
        var aArray = [];
        for (var i = 0; i < sString["length"]; ++i) {
            aArray["push"](sString["charCodeAt"](i));
        }
        return aArray;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["aGetCharCodeFromString"] = 0;
    }
    ;


    /**
     * @static
     * @template {Object} U
     * @template V
     * @param {string} sFunctionBody
     * @param {U} [oScope={}]
     * @return {V}
     */
    UCF_JsUtil["unsafeEval"] = function (sFunctionBody, oScope) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["unsafeEval"]++;
        }
        ;
        /** @type {string} */
        var sId = UCF_JsUtil["sGetUID"]();
        /** @type {{ls: {eval: Object<string, {oScope: U}>}}} */
        var sap = window["sap"] || {};
        /** @type {V} */
        var oValue;

        sap["ls"] = sap["ls"] || {};
        sap["ls"]["eval"] = sap["ls"]["eval"] || {};
        sap["ls"]["eval"][sId] = {"oScope": oScope};

        oValue = eval('(function() {\n' + // eslint-disable-line no-eval
            UCF_JsUtil["map"](UCF_JsUtil["keys"](oScope || {}), function (sKey) {
                return '\tvar ' + sKey + ' = sap.ls.eval.' + sId + '.oScope.' + sKey + ';';
            })["join"]('\n') +
            '\treturn (function() {\n' +
            '\t\t' + sFunctionBody["split"]('\n')["join"]('\t\t\n') + '\n' +
            '\t})();\n' +
            '})()');

        delete sap["ls"]["eval"][sId];

        return oValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["unsafeEval"] = 0;
    }
    ;

    /**
     * @static
     * @template {Object} U
     * @template V
     * @param {string} sFunctionBody
     * @param {U} [oScope={}]
     * @return {V}
     */
    UCF_JsUtil["safeEval"] = function (sFunctionBody, oScope) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["safeEval"]++;
        }
        ;
        /** @type {string} */
        var sId = UCF_JsUtil["sGetUID"]();
        /** @type {HTMLScriptElement} */
        var oScriptRef = document["createElement"]('script');
        /** @type {V} */
        var oValue;
        /** @type {0|1|2} */
        var eState;
        /** @type {{ls: {eval: Object<string, {oScope: U, eState: 0|1|2, oValue: V}>}}} */
        var sap = window["sap"] || {};

        sap["ls"] = sap["ls"] || {};
        sap["ls"]["eval"] = sap["ls"]["eval"] || {};
        sap["ls"]["eval"][sId] = {
            "oScope": oScope,
            "eState": 0/*Created*/,
            "oValue": null
        };

        oScriptRef["setAttribute"]('nonce', window["UCF_System"]["sNonce"]);
        oScriptRef["innerHTML"] = [ // eslint-disable-line no-unsanitized/property
            'var sap = window.sap || {};\n' +
            'sap.ls = sap.ls || {};\n' +
            'sap.ls.eval = sap.ls.eval || {};\n' +
            'sap.ls.eval.' + sId + ' = sap.ls.eval.' + sId + ' || {};',

            UCF_JsUtil["map"](UCF_JsUtil["keys"](oScope || {}), function (sKey) {
                return 'var ' + sKey + ' = sap.ls.eval.' + sId + '.oScope.' + sKey + ';';
            })["join"]('\n'),

            'try {\n' +
            '\tsap.ls.eval.' + sId + '.eState = 1/*Resolved*/;\n' +
            '\tsap.ls.eval.' + sId + '.oValue = (function() {\n' +
            '\t\t' + sFunctionBody["split"]('\n')["join"]('\t\t\n') + '\n' +
            '\t})();\n' +
            '} catch (e) {\n' +
            '\tsap.ls.eval.' + sId + '.eState = 2/*Rejected*/;\n' +
            '\tsap.ls.eval.' + sId + '.oValue = e;\n' +
            '}'
        ]["join"]('\n\n');

        UCF_DomUtil["prepend"](document["body"], oScriptRef);

        eState = sap["ls"]["eval"][sId]["eState"];
        oValue = sap["ls"]["eval"][sId]["oValue"];

        delete sap["ls"]["eval"][sId];
        UCF_DomUtil["removeFromDom"](oScriptRef);

        switch (eState) {
            case 1: // Resolved
                return oValue;
            // eslint-disable-next-line no-magic-numbers
            case 2: // Rejected
                throw oValue;
            default: // not Resolved/Rejected
                throw new Error('"' + sFunctionBody + '" not executed. Neither Resolved nor Rejected.');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["safeEval"] = 0;
    }
    ;

    /**
     * @static
     * @return {boolean}
     */
    UCF_JsUtil["bIsSafeEvalPossible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["bIsSafeEvalPossible"]++;
        }
        ;
        if (typeof UCF_JsUtil["bSafeEvalPossible"] !== 'boolean') {
            UCF_JsUtil["bSafeEvalPossible"] = UCF_System
                && typeof window["UCF_System"]["sNonce"] === 'string'
                && !UCF_UserAgent["bIsIE"]();
            //&& !UCF_UserAgent.bIsMSEdge();
        }

        return UCF_JsUtil["bSafeEvalPossible"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["bIsSafeEvalPossible"] = 0;
    }
    ;

    /**
     * Evals `sFunctionBody` in `oScope`. If UCF_System.sNonce is set and not
     * running in IE/MSEdge, `sFunctionBody` is created as a new script element.
     * Otherwise, `window.eval()` is used.
     *
     * @example <caption>Usage example: PrepareScripts</caption>
     * ```javascript
     * UCF_JsUtil.eval('return oLS.oGetControlById(oSemanticEvent.mGetParameters().ItemListBoxId).bIsOpen()', {
     *   oLS: this.oLS.oGetInterface(),
     *   oSemanticEvent: oSemanticEvent.oGetInterface()
     * });
     *
     * // roughly translates to
     *
     * (function() {
     *   var oLS = sap.ls.eval.<temporary id>.oLS;
     *   var oSemanticEvent = sap.ls.eval.<temporary id>.oSemanticEvent;
     *
     *   return (function() {
     *     return oLS.oGetControlById(oSemanticEvent.mGetParameters().ItemListBoxId).bIsOpen();
     *   })();
     * })();
     * ```
     *
     * @static
     * @template {Object} U
     * @template V
     * @param {string} sFunctionBody
     * @param {U} [oScope={}]
     * @return {V}
     */
    UCF_JsUtil["eval"] = function (sFunctionBody, oScope) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["eval"]++;
        }
        ;
        if (!UCF_JsUtil["_eval"]) {
            UCF_JsUtil["_eval"] = UCF_JsUtil["bIsSafeEvalPossible"]()
                ? UCF_JsUtil["safeEval"]
                : UCF_JsUtil["unsafeEval"];
        }

        return UCF_JsUtil["_eval"](sFunctionBody, oScope);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["eval"] = 0;
    }
    ;

    /**
     * @static
     * @param {string} sJS
     */
    UCF_JsUtil["unsafeRawEval"] = function (sJS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["unsafeRawEval"]++;
        }
        ;
        window["eval"](sJS); // eslint-disable-line no-eval
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["unsafeRawEval"] = 0;
    }
    ;

    /**
     * @static
     * @param {string} sJS
     */
    UCF_JsUtil["safeRawEval"] = function (sJS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["safeRawEval"]++;
        }
        ;
        /** @type {HTMLScriptElement} */
        var oScriptRef = document["createElement"]('script');

        if (UCF_System && window["UCF_System"]["sNonce"]) {
            oScriptRef["setAttribute"]('nonce', window["UCF_System"]["sNonce"]);
        }
        oScriptRef["innerHTML"] = sJS; // eslint-disable-line no-unsanitized/property

        UCF_DomUtil["prepend"](document["body"], oScriptRef);
        UCF_DomUtil["removeFromDom"](oScriptRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["safeRawEval"] = 0;
    }
    ;

    /**
     * Just evals `sJS` (in a new <script> element if running with CSP).
     *
     * @example <caption>difference between UCF_JsUtil#rawEval() and UCF_JsUtil#eval()</caption>
     * ```javascript
     * UCF_JsUtil.rawEval('function UCF_Hugo()')
     * // creates window.UCF_Hugo
     * // whereas
     * UCF_JsUtil.eval('function UCF_Hugo()')
     * // can't create window.UCF_Hugo, because it runs in an IIFE in the <script>
     * ```
     *
     * @static
     * @param {string} sJS
     */
    UCF_JsUtil["rawEval"] = function (sJS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["rawEval"]++;
        }
        ;
        if (!UCF_JsUtil["_rawEval"]) {
            UCF_JsUtil["_rawEval"] = UCF_JsUtil["bIsSafeEvalPossible"]()
                ? UCF_JsUtil["safeRawEval"]
                : UCF_JsUtil["unsafeRawEval"];
        }

        UCF_JsUtil["_rawEval"](sJS);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["rawEval"] = 0;
    }
    ;

    /**
     * Just post a message to the target.
     *
     * If the message data is not a string we try to stringify it
     * and post it to the target which can be an object or a string
     *
     * @static
     * @param {any} soData
     * @param {any} soTarget
     * @param {string} sDomain
     */
    UCF_JsUtil["postMessage"] = function (soData, soTarget, sDomain) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_JsUtil["_"]["postMessage"]++;
        }
        ;
        var oTarget;
        if (!sDomain)
            sDomain = '*';
        if (typeof (soTarget) === 'object')
            oTarget = soTarget;
        else {
            if (soTarget === 'top')
                oTarget = top;
            else if (soTarget === 'opener')
                oTarget = window["opener"];
            else if (soTarget === 'parent.parent')
                oTarget = window["parent"]["parent"];
            else
                oTarget = window["parent"];
        }
        try {
            if (typeof (soData) !== 'string')
                soData = UCF_JsUtil["sJsonStringify"](soData);
            if (oTarget !== window)
                oTarget["postMessage"](soData, sDomain);
        } catch (e) {
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_JsUtil["_"]["postMessage"] = 0;
    }
    ;

    UCF_JsUtil.prototype["aPublicMethods"] = ["oJsonParse", "oParseJSON", "setImmediate", "cancelImmediate", "delayedCall", "bDelayedCallExists", "clearDelayedCall", "clearDelayedCallsOfObject", "intervalCall", "clearIntervalCall", "feedMassNotificationFilter", "resetMassNotificationFilter", "sRemoveMangledPartFromURL", "downloadBlob", "downloadFile", "arrayFrom"].concat(UCF_JsUtil.prototype.aPublicMethods || []);
    /* global _assert, _trace, DEBUG, WARNING */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_Object */
/// <reference path="../Object.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* eslint consistent-this:0, no-magic-numbers:0 */
    /** @typedef {0} UCF_Promise_State_Created */
    /** @typedef {1} UCF_Promise_State_Resolved */
    /** @typedef {2} UCF_Promise_State_Rejected */
    /** @typedef {3} UCF_Promise_State_Chained */
    /** @typedef {UCF_Promise_State_Created|UCF_Promise_State_Resolved|UCF_Promise_State_Rejected|UCF_Promise_State_Chained} UCF_Promise_State  */
    /**
     * @template T
     * @typedef {function(...any?): T} UCF_Promise_Callback
     */
    /**
     * @template U, V
     * @typedef {Object} UCF_Promise_Deferred
     * @property {UCF_Promise_Callback<U>} fThen
     * @property {UCF_Promise_Callback<V>} fCatch
     * @property {UCF_Promise} oPromise
     */
    /**
     * @typedef {Object} UCF_Promise_AllSettledResolved
     * @property {'resolved'} status
     * @property {any} value
     */
    /**
     * @typedef {Object} UCF_Promise_AllSettledRejected
     * @property {'rejected'} status
     * @property {any} reason
     */

    /** @typedef {UCF_Promise_AllSettledResolved|UCF_Promise_AllSettledRejected} UCF_Promise_AllSettledResult */

    /**
     * Promise-like implemention
     *
     * @see {@link https://github.com/taylorhakes/promise-polyfill} (MIT-licensed)
     *
     * @example
     * ```javascript
     * function fMyPromiseFunction(oParam) {
     *        return new UCF_Promise(function (resolve, reject) {
     *            ...
     *            reject("error");
     *          ...
     *            resolve("successfully");
     *        });
     * };
     * ```
     *
     * @example
     * ```javascript
     * fMyPromiseFunction(oParam)
     *    .then(
     *        fMyCallback; //function called once Promise is resolved
     *    ).catch(function (err) {
     *        console.warn(err);
     *    });
     * ```
     *
     * @example
     * ```javascript
     * UCF_Promise.all(
     *    aPromises //array of UCF_promises
     * ).then(
     *    fMyCallback; //function called once all UCF_Promise are resolved
     * ).catch(function (err) {
     *    console.warn(err);
     * });
     * ```
     *
     * @example
     * ```javascript
     * UCF_Promise.allSettled(
     *    aPromises //array of UCF_promises
     * ).then(
     *    fMyCallback; //function called once all Promise are resolved or rejected
     * ));
     * ```
     *
     * @class
     *
     * @static
     * @template U, V
     * @param {function(UCF_Promise_Callback<U>, UCF_Promise_Callback<V>): void} fn
     */
    function UCF_Promise(fn) {
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["UCF_Promise"]++;
        }
        ;
        // for performance reasons we don't use utility functions as much as possible
        // (i.e. for-loops instead of UCF_JsUtil.forEach() etc.) and don't have a
        // UCF_Pronise.STATE enum (just numbers 0..3)

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bIsFunction"](fn), "UCF_JsUtil.bIsFunction(fn)", "Promise.js(94): UCF_Promise");
        }
        ;

        /** @type {UCF_Promise_State} */
        this["eState"] = 0 /*Created*/;
        /** @type {boolean} */
        this["bHandled"] = false;
        /** @type {UCF_Promise} */
        this["oValue"] = undefined; // eslint-disable-line ur/no-memory-leaks
        /** @type {UCF_Promise_Deferred[]} */
        this["aDeferreds"] = [];

        UCF_Promise["_doResolve"](this, fn);
    };window["UCF_Promise"] = UCF_Promise;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Promise");
        UCF_Promise["_"] = {UCF_Promise: 0};
    }
    ;
    ;
    UCF_Promise["prototype"] = new UCF_Object();
    UCF_Promise.prototype["sClassName"] = "UCF_Promise";

    /** @type {UCF_Promise_StateEnum} */
    UCF_Promise["STATE"] = {
        "Created": 0,
        "Resolved": 1,
        "Rejected": 2,
        "Chained": 3
    };

    /**
     * @private
     * @static
     * @param {UCF_Promise} self
     * @param {UCF_Promise_Run} fRun
     */
    UCF_Promise["_doResolve"] = function (self, fRun) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_doResolve"]++;
        }
        ;
        /** @type {boolean} */
        var bDone = false;

        try {
            fRun(function (oValue) {
                if (!bDone) {
                    bDone = true;
                    UCF_Promise["_resolve"](self, oValue);
                }
            }, function (oReason) {
                if (!bDone) {
                    bDone = true;
                    UCF_Promise["_reject"](self, oReason);
                }
            });
        } catch (oException) {
            if (!bDone) {
                bDone = true;
                UCF_Promise["_reject"](self, oException);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_doResolve"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_Promise} self
     * @param {U} oValue
     */
    UCF_Promise["_resolve"] = function (self, oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_resolve"]++;
        }
        ;
        var fThen;

        try {
            if (oValue === self) {
                throw new TypeError('A Promise cannot be resolved with itself.');
            }
            if (oValue && (typeof oValue === 'object' || typeof oValue === 'function')) {
                fThen = oValue["then"];

                if (oValue instanceof UCF_Promise) {
                    self["eState"] = 3 /*Chained*/;
                    self["oValue"] = oValue;
                    UCF_Promise["_finish"](self);

                    return;
                } else if (typeof fThen === 'function') {
                    UCF_Promise["_doResolve"](self, UCF_Promise["_bind"](oValue, fThen));

                    return;
                }
            }
            self["eState"] = 1 /*Resolved*/;
            self["oValue"] = oValue;
            UCF_Promise["_finish"](self);
        } catch (oException) {
            UCF_Promise["_reject"](self, oException);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_resolve"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_Promise} self
     * @param {V} oReason
     */
    UCF_Promise["_reject"] = function (self, oReason) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_reject"]++;
        }
        ;
        self["eState"] = 2 /*Rejected*/;
        self["oValue"] = oReason;
        UCF_Promise["_finish"](self);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_reject"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_Promise} self
     */
    UCF_Promise["_finish"] = function (self) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_finish"]++;
        }
        ;
        // it would be correct (spec-wise) to request a setImmediate for
        // if (!self.bHandled) { _trace(ERROR, 'Possible Unhandled Promise Rejection'); }
        // when self.eState===1(Resolved) && self.aDeferreds.length===0
        // but that case is so common in the lightspeed codebase that we skip this
        // for performance optimization of the "hotspots"
        /** @type {number} */
        var i;
        /** @type {number} */
        var iLen;

        for (i = 0, iLen = self["aDeferreds"]["length"]; i < iLen; i++) {
            UCF_Promise["_handle"](self, self["aDeferreds"][i]);
        }

        self["aDeferreds"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_finish"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Object} self
     * @param {function} fn
     * @return {function}
     */
    UCF_Promise["_bind"] = function (self, fn) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_bind"]++;
        }
        ;
        return function () {
            fn["apply"](self, arguments);
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_bind"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_Promise} self
     * @param {UCF_Promise_Deferred} oDeferred
     */
    UCF_Promise["_handle"] = function (self, oDeferred) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["_handle"]++;
        }
        ;
        while (self["eState"] === 3 /*Chained*/) {
            self = self["oValue"];
        }

        if (self["eState"] === 0 /*Created*/) {
            self["aDeferreds"]["push"](oDeferred);
        } else {
            self["bHandled"] = true;
            UCF_JsUtil["setImmediate"](function () {
                /** @type {UCF_Promise_Callback} */
                var fCallback = self["eState"] === 1 /*Resolved*/
                    ? oDeferred["fThen"]
                    : oDeferred["fCatch"];
                /** @type {Object} */
                var oResult;

                if (fCallback == null) {
                    if (self["eState"] === 1 /*Resolved*/) {
                        UCF_Promise["_resolve"](oDeferred["oPromise"], self["oValue"]);
                    } else {
                        UCF_Promise["_reject"](oDeferred["oPromise"], self["oValue"]);
                    }
                } else {
                    try {
                        oResult = fCallback(self["oValue"]);
                    } catch (oException) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(WARNING, 'Caught exception while executing promise callback. Exception was "' + oException["message"] + '" at\n' + oException["stack"], "Promise.js(262): _handle");
                        }
                        ;
                        UCF_Promise["_reject"](oDeferred["oPromise"], oException);

                        return;
                    }
                    UCF_Promise["_resolve"](oDeferred["oPromise"], oResult);
                }
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["_handle"] = 0;
    }
    ;

    /**
     * ATTENTION: 'catch' is a reserved word in IE Quirks, this throws a
     * "SCRIPT1010: Expected identifier":
     *
     * ```javascript
     * UCF_Promise.reject('wat').catch(function(err){})
     * ```
     *
     * You have to property-access the 'catch' in order to make IE Quirks happy:
     *
     * ```javascript
     * UCF_Promise.reject('wat')['catch'](function(err){})
     * ```
     *
     * @public
     * @param {UCF_Promise_Callback} fCatch
     * @return {UCF_Promise}
     */
    UCF_Promise["prototype"]['catch'] = function (fCatch) { // eslint-disable-line dot-notation
        return this["then"](null, fCatch);
    };

    /**
     * @public
     * @param {UCF_Promise_Callback} fThen
     * @param {UCF_Promise_Callback} fCatch
     * @return {UCF_Promise}
     */
    UCF_Promise["prototype"]["then"] = function (fThen, fCatch) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["then"]++;
        }
        ;
        /** @type {UCF_Promise} */
        var oEmptyPromise = new UCF_Promise(function () {
        });

        UCF_Promise["_handle"](this, {
            "fThen": fThen,
            "fCatch": fCatch,
            "oPromise": oEmptyPromise
        });

        return oEmptyPromise;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["then"] = 0;
    }
    ;

    /**
     * @public
     * @param {UCF_Promise_Callback} fFinally
     * @return {UCF_Promise}
     */
    UCF_Promise["prototype"]['finally'] = function (fFinally) { // eslint-disable-line dot-notation
        return this["then"](
            function (oValue) {
                return UCF_Promise["resolve"](fFinally())
                    ["then"](function () {
                    return oValue;
                });
            },
            function (oReason) {
                return UCF_Promise["resolve"](fFinally())
                    ["then"](function () {
                    return UCF_Promise["reject"](oReason);
                });
            }
        );
    };

    /**
     * @public
     * @static
     * @param {UCF_Promise[]} aPromises
     * @return {UCF_Promise}
     */
    UCF_Promise["all"] = function (aPromises) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["all"]++;
        }
        ;
        return new UCF_Promise(function (resolve, reject) {
            /** @type {number} */
            var iRemaining;
            /** @type {function(number, UCF_Promise): void} */
            var partialResolve;
            /** @type {number} */
            var i;
            /** @type {number} */
            var iLen;

            if (UCF_JsUtil["bIsArray"](aPromises)) {
                iRemaining = aPromises["length"];

                if (iRemaining === 0) {
                    resolve([]);
                } else {
                    // eslint-disable-next-line no-shadow
                    partialResolve = function (i, oValue) {
                        /** @type {UCF_Promise_Callback} */
                        var fThen;

                        try {
                            if (oValue && (typeof oValue === 'object' || typeof oValue === 'function')) {
                                fThen = oValue["then"];

                                if (typeof fThen === 'function') {
                                    fThen["call"](oValue, function (v) {
                                        partialResolve(i, v);
                                    }, reject);

                                    return;
                                }
                            }

                            aPromises[i] = oValue;
                            if (--iRemaining === 0) {
                                resolve(aPromises);
                            }
                        } catch (oException) {
                            reject(oException);
                        }
                    };

                    for (i = 0, iLen = aPromises["length"]; i < iLen; i++) {
                        partialResolve(i, aPromises[i]);
                    }
                }
            } else {
                reject(new TypeError('Promise.all accepts an array'));
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["all"] = 0;
    }
    ;

    /**
     * @public
     * @static
     * @template T
     * @param {T} [oValue]
     * @return {UCF_Promise<T, undefined>}
     */
    UCF_Promise["resolve"] = function (oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["resolve"]++;
        }
        ;
        return oValue instanceof UCF_Promise
            ? oValue
            : new UCF_Promise(function (resolve) {
                resolve(oValue);
            });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["resolve"] = 0;
    }
    ;

    /**
     * @public
     * @static
     * @template T
     * @param {T} oReason
     * @return {UCF_Promise<undefined, T>}
     */
    UCF_Promise["reject"] = function (oReason) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["reject"]++;
        }
        ;
        return new UCF_Promise(function (_, reject) {
            reject(oReason);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["reject"] = 0;
    }
    ;

    /**
     * @public
     * @static
     * @param {UCF_Promise[]} aPromises
     * @return {UCF_Promise}
     */
    UCF_Promise["race"] = function (aPromises) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["race"]++;
        }
        ;
        return new UCF_Promise(function (resolve, reject) {
            /** @type {number} */
            var i;
            /** @type {number} */
            var iLen;

            if (UCF_JsUtil["bIsArray"](aPromises)) {
                for (i = 0, iLen = aPromises["length"]; i < iLen; i++) {
                    UCF_Promise["resolve"](aPromises[i])["then"](resolve, reject);
                }
            } else {
                reject(new TypeError('Promise.race accepts an array'));
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["race"] = 0;
    }
    ;

    /**
     * @public
     * @static
     * @param {UCF_Promise[]} aPromises
     * @return {UCF_Promise<UCF_Promise_AllSettledResult[], undefined>}
     */
    UCF_Promise["allSettled"] = function (aPromises) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["allSettled"]++;
        }
        ;
        // this is almost a copy of UCF_Promise.all, but for performance reasons
        // it is a separate function (otherwise we'd have something like
        //  aPromises.map(_ => fulfilled|rejected)) and twice as much Promises.

        return new UCF_Promise(function (resolve, reject) {
            /** @type {number} */
            var iRemaining;
            /** @type {function(number, UCF_Promise): void} */
            var partialResolve;
            /** @type {number} */
            var i;
            /** @type {number} */
            var iLen;

            if (UCF_JsUtil["bIsArray"](aPromises)) {
                iRemaining = aPromises["length"];

                if (iRemaining === 0) {
                    resolve([]);
                } else {
                    // eslint-disable-next-line no-shadow
                    partialResolve = function (i, oValue) {
                        /** @type {UCF_Promise_Callback} */
                        var fThen;

                        try {
                            if (oValue && (typeof oValue === 'object' || typeof oValue === 'function')) {
                                fThen = oValue["then"];

                                if (typeof fThen === 'function') {
                                    fThen["call"](oValue, function (v) {
                                        partialResolve(i, v);
                                    }, function (oException) {
                                        aPromises[i] = {"status": 'rejected', "reason": oException};
                                        if (--iRemaining === 0) {
                                            resolve(aPromises);
                                        }
                                    });

                                    return;
                                }
                            }

                            aPromises[i] = {"status": 'fulfilled', "value": oValue};
                            if (--iRemaining === 0) {
                                resolve(aPromises);
                            }
                        } catch (oException) {
                            aPromises[i] = {"status": 'rejected', "reason": oException};
                            if (--iRemaining === 0) {
                                resolve(aPromises);
                            }
                        }
                    };

                    for (i = 0, iLen = aPromises["length"]; i < iLen; i++) {
                        partialResolve(i, aPromises[i]);
                    }
                }
            } else {
                reject(new TypeError('Promise.allSettled accepts an array'));
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["allSettled"] = 0;
    }
    ;

    /**
     * Destructor
     */
    UCF_Promise["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Promise["_"]["destroy"]++;
        }
        ;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Promise["_"]["destroy"] = 0;
    }
    ;

    UCF_Promise.prototype["aPublicMethods"] = ["", "then", "", "all", "resolve", "reject", "race", "allSettled"].concat(UCF_Promise.prototype.aPublicMethods || []);
    /* global UCF_Object */

/// <reference path="../Object.js"/>

    /**
     * Queue
     *
     *
     * @class
     * @version
     * @template T
     */
    function UCF_Queue() {
        if (__UCF_COVERAGE__) {
            UCF_Queue["_"]["UCF_Queue"]++;
        }
        ;
        /** @type {Array<T>} */
        this["aList"] = [];
    };window["UCF_Queue"] = UCF_Queue;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Queue");
        UCF_Queue["_"] = {UCF_Queue: 0};
    }
    ;
    ;
    UCF_Queue["prototype"] = new UCF_Object();
    UCF_Queue.prototype["sClassName"] = "UCF_Queue";

    /**
     * Destroy method
     *
     * @public
     */
    UCF_Queue["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Queue["_"]["destroy"]++;
        }
        ;
        this["aList"] = null;
        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Queue["_"]["destroy"] = 0;
    }
    ;

    /**
     * Pushes an object to the queue
     *
     * @public
     * @param {T} oObject The object to push
     */
    UCF_Queue["prototype"]["push"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Queue["_"]["push"]++;
        }
        ;
        this["aList"]["push"](oObject);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Queue["_"]["push"] = 0;
    }
    ;

    /**
     * Returns the first element of the queue and removes it
     *
     * @public
     * @return {T} The object
     */
    UCF_Queue["prototype"]["get"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Queue["_"]["get"]++;
        }
        ;
        /** @type {T} */
        var oObject = this["aList"][0];

        this["aList"]["splice"](0, 1);

        return oObject;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Queue["_"]["get"] = 0;
    }
    ;

    /**
     * Returns the first element of the queue without removing it
     *
     * @public
     * @return {T} The object
     */
    UCF_Queue["prototype"]["peek"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Queue["_"]["peek"]++;
        }
        ;
        return this["aList"][0];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Queue["_"]["peek"] = 0;
    }
    ;

    UCF_Queue.prototype["aPublicMethods"] = ["destroy", "push", "get", "peek"].concat(UCF_Queue.prototype.aPublicMethods || []);
    /* global _assert, _trace, INFO, ERROR, DEBUG */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_ErrorMessage */
/// <reference path="./ErrorMessage.js"/>
    /* global UCF_FesrUtil */
/// <reference path="./FesrUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_Promise */
/// <reference path="./Promise.js"/>
    /* global UCF_UserAgent */
/// <reference path="./UserAgent.js"/>

    /**
     * @typedef {Object} UCF_RequestUtil_Response
     * @property {boolean} bSuccess
     * @property {string} sStatusCode
     * @property {UCF_RequestUtil_ParseError} oParseError
     * @property {string} sText
     * @property {Object} [oJson]
     * @property {Object} oDocument
     */

    /**
     * @typedef {Object} UCF_RequestUtil_ParseError
     * @property {number} errorCode
     * @property {string} url
     * @property {string} reason
     * @property {string} srcText
     * @property {string} line
     * @property {string} linepos
     * @property {string} filepos
     */

    /**
     * This class provides functionality to manage the requests to the server.
     * It uses the XMLHttpRequest object for the communication with the server.
     * While doing asynchronous requests to the backend the class manages the requests.
     * Please use the sendSyncRequest, sendAsyncRequest  methods to comunicate with the
     * server. With asynchrounous calls you will be able to pass a method that is used as a callback
     * method after the response is finished.
     * The result object for the response that is returned by a synchronus call or is passed to the
     * callback method of an asynchonous call has 3 parameters
     *   bSuccess {boolean}
     *   sText    {string}
     *   oDocument{XMLDocument}
     *
     * <b>Example for an synchonous request</b>
     * var myResponse = UCF_RequestUtil.sendSyncRequest("mydataservlet","GET",["q":"test"]);
     * if (myResponse.bSuccess) {
     *    alert(myResponse.sText);
     *    alert(myResponse.oDocument.xml);
     * }
     *
     *
     * @class
     * @version
     */
    function UCF_RequestUtil() {
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["UCF_RequestUtil"]++;
        }
        ;

    };window["UCF_RequestUtil"] = UCF_RequestUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_RequestUtil");
        UCF_RequestUtil["_"] = {UCF_RequestUtil: 0};
    }
    ;
    ;

    UCF_RequestUtil["bUseXHR"] = true;
    UCF_RequestUtil["bUseActiveX"] = true;
    UCF_RequestUtil["retryCounter"] = 0;
    UCF_RequestUtil["bWaitingForServerResponse"] = false;

    /**
     * Check for failed (canceled) requests on Firefox
     *
     * @param {Object} oXmlHttp XMLHttp request
     * @return {boolean} true, if request failed, otherwise false
     */
    function _firefoxRequestFailed(oXmlHttp) {
        /** @type {boolean} */
        var bRequestFailed = false;

        try {
            bRequestFailed = (oXmlHttp["status"] === 0);
        } catch (e) {
            bRequestFailed = true;
        }

        if (bRequestFailed) {
            UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["NETWORK"]);

            return true;
        }

        return false;

    };

    /**
     * Forwards the the callback of the XMLHttpRequestObject to the defined handler.
     *
     * @private
     *
     * @param {XMLHttpRequest} oXmlHttp XMLHttpRequest Object
     * @param {Object} oCallbackObject Object that implements sMethosName for the callback
     * @param {string} sMethodName Name of the Method to all
     * @param {Object} oCachedRequest cached request to able to send it again in special error cases
     */
    function _forwardRequestCallback(oXmlHttp, oCallbackObject, sMethodName, oCachedRequest) {
        var oResponse;

        // eslint-disable-next-line no-magic-numbers
        if (oXmlHttp["readyState"] === 4) {
            // Special treatment to avoid problems with canceled requests in Firefox
            if (UCF_UserAgent["bIsFirefox"]() && _firefoxRequestFailed(oXmlHttp)) {
                return;
            } else if (
                (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) &&
                UCF_RequestUtil["_ieRequestFailed"](oXmlHttp, oCachedRequest)
            ) {
                return;
            }

            oResponse = UCF_RequestUtil["oCreateResponseObject"](oXmlHttp);
            UCF_FesrUtil["notifyResponse"](oXmlHttp);

            oCallbackObject[sMethodName](oResponse);
            delete oXmlHttp["onreadystatechange"];
        }
    };

    /**
     * Sends a synchronous request to the server
     *
     * @private
     * @param {string} sUrl
     * @param {string} [sMethod='GET']
     * @param {Object} [mParameters]
     * @param {string} [sBody] Post body if method = post
     * @param {boolean} [bSuppressErrorMessage=false]
     * @return {UCF_RequestUtil_Response} A response object
     */
    UCF_RequestUtil["sendSyncRequest"] = function (sUrl, sMethod, mParameters, sBody, bSuppressErrorMessage) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendSyncRequest"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sUrl === 'string', "typeof sUrl === 'string'", "RequestUtil.js(138): sendSyncRequest");
        }
        ;

        return UCF_RequestUtil["sendRequest"](sUrl, sMethod, false, mParameters, null, null, sBody, bSuppressErrorMessage);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendSyncRequest"] = 0;
    }
    ;

    /**
     * Sends an asynchronous request to the server
     *
     * @public
     * @param {string} sUrl URL
     * @param {string} [sMethod='GET']
     * @param {Object} [mParameters]
     * @param {UCF_Object} [oObject] the callback object
     * @param {string} [sMethodName] the name of the method to call
     * @param {string} [sBody] Post body if method = post
     * @param {boolean} [bSuppressErrorMessage=false]
     */
    UCF_RequestUtil["sendAsyncRequest"] = function (sUrl, sMethod, mParameters, oObject, sMethodName, sBody, bSuppressErrorMessage) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendAsyncRequest"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sUrl === 'string', "typeof sUrl === 'string'", "RequestUtil.js(156): sendAsyncRequest");
        }
        ;

        UCF_RequestUtil["sendRequest"](sUrl, sMethod, true, mParameters, oObject, sMethodName, sBody, bSuppressErrorMessage);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendAsyncRequest"] = 0;
    }
    ;

    /**
     * Sends a request to the server
     *
     * @private
     * @param {string} sUrl The URL for the request
     * @param {string} sMethod The HTTP Request method, either "GET" or "POST"
     * @param {boolean} bAsync Whether the request should be sent asynchronously
     * @param {Object} mParameters The request parameters (if any)
     * @param {UCF_Object} oObject The callback object (if asynchronous)
     * @param {string} sMethodName The name of the method to call (if asynchronous)
     * @param {string} [sBody] Post body if method = post
     * @param {boolean} [bSuppressErrorMessage=false]
     * @return {UCF_RequestUtil_Response} A response object
     */
    UCF_RequestUtil["sendRequest"] = function (sUrl, sMethod, bAsync, mParameters, oObject, sMethodName, sBody, bSuppressErrorMessage) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendRequest"]++;
        }
        ;  //eslint-disable-line complexity
        /** @type {string} */
        var sPostBody = null;
        /** @type {any} */
        var oCachedRequest = [];
        /** @type {number} */
        var iRequestBytes = 0;
        /** @type {string} */
        var sEncodedParameters;
        /** @type {number} */
        var i;
        /** @type {XMLHttpRequest} */
        var oXmlHttp;

        // Set a variable for QTP to check if we are still a request
        UCF_RequestUtil["bWaitingForServerResponse"] = true;
        window["document"]["qtp_readystate"] = false;

        if (!sMethod) {
            sMethod = 'GET';
        }
        if (!bAsync) {
            // CSN:I-261165 2013 bAsync might be null from ABAP call.
            bAsync = false;
        }

        // Request parameters are encoded, and either added to the URL (GET) or
        // written to the request body (POST)
        if (mParameters) {
            sEncodedParameters = UCF_RequestUtil["sEncodeParameters"](mParameters);

            if (sMethod === 'GET') {
                if (sUrl["indexOf"]('?') > 0) {
                    sUrl += '&';
                } else {
                    sUrl += '?';
                }
                sUrl += sEncodedParameters;
            } else if (sMethod === 'POST') {
                sPostBody = sEncodedParameters;
            }
        } else if (sBody) {
            sPostBody = sBody;
        }

        if (sPostBody) {
            iRequestBytes += sPostBody["length"];
        }

        for (i = 0; i < arguments["length"]; i++) {
            oCachedRequest["push"](arguments[i]);
        }

        // Synchronous requests can reuse the existing request object,
        // only asynchronous need to create new ones
        oXmlHttp = new XMLHttpRequest();

        // If request is asynchronous, and a callback object has been
        // defined, register the event handler for callback
        if (bAsync && oObject) {
            oXmlHttp["onreadystatechange"] = function () {
                _forwardRequestCallback(oXmlHttp, oObject, sMethodName, oCachedRequest);
            };
        }

        // Open the connection
        oXmlHttp["open"](sMethod, sUrl, bAsync);

        // See note 2292940: Since IE10, IE returns a native XML document by default.
        // This mode cannot handle large amounts of data => Fall back to MSXML document
        // eslint-disable-next-line no-magic-numbers
        if (UCF_UserAgent["bIsTrident"](6) && !__UCF_IE6__) {
            oXmlHttp["responseType"] = 'msxml-document';
        }

        // Set X-Requested-With header
        iRequestBytes += UCF_RequestUtil["iSetRequestHeader"](
            oXmlHttp,
            'X-Requested-With',
            'XMLHttpRequest'
        );
        iRequestBytes += UCF_RequestUtil["iSetRequestHeader"](
            oXmlHttp,
            'X-XHR-Logon',
            'accept'
        );

        // Set POST Content-Type Header if needed
        if (sMethod === 'POST') {
            iRequestBytes += UCF_RequestUtil["iSetRequestHeader"](
                oXmlHttp,
                'Content-Type',
                'application/x-www-form-urlencoded'
            );
            UCF_FesrUtil["notifyRequest"](oXmlHttp, iRequestBytes);
        }

        // Send the request
        try {
            oXmlHttp["send"](sPostBody);
        } catch (oExeption) {
            if (!bSuppressErrorMessage)
                UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["NETWORK"]);

            return UCF_RequestUtil["oCreateResponseObject"](oXmlHttp);
        }

        if (bAsync) {
            return null;
        } else {
            // If request is synchronous, return the response
            return UCF_RequestUtil["oCreateResponseObject"](oXmlHttp);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendRequest"] = 0;
    }
    ;

    /**
     * Sends a beacon request to the server
     *
     * @param {string} sUrl The URL for the request
     * @param {Object} mParameters The request parameters (if any)
     * @param {string} sBody (optional) Post body will be ignored once mParameters are used
     * @return {boolean} whether the beacon could be enqueued
     * @public
     */
    UCF_RequestUtil["sendBeaconRequest"] = function (sUrl, mParameters, sBody) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendBeaconRequest"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sUrl === 'string', "typeof sUrl === 'string'", "RequestUtil.js(300): sendBeaconRequest");
        }
        ;

        var bResult = false;
        var sPostBody = "";
        var oBeaconDataToSend;

        // Request parameters are encoded written to the request body (POST)
        if (UCF_JsUtil["bIsArray"](mParameters)) {
            sPostBody = UCF_JsUtil["map"](mParameters, function (oParameters) {
                return UCF_RequestUtil["sEncodeParameters"](oParameters);
            })["join"]('&');
        } else if (mParameters) {
            sPostBody = UCF_RequestUtil["sEncodeParameters"](mParameters);
        } else if (sBody) {
            sPostBody = sBody;
        }

        if (('navigator' in window) && ('sendBeacon' in window["navigator"]) && ('Blob' in window)) {

            if (sPostBody && sPostBody !== "") {
                oBeaconDataToSend = new Blob([sPostBody], { //blobs are supported in all browsers using sendBeacon
                    "type": "application/x-www-form-urlencoded;charset=UTF-8"
                });
            }

            bResult = window["navigator"]["sendBeacon"](sUrl, oBeaconDataToSend);
            // Remark: The simpler call
            // navigator.sendBeacon(beaconURL, .beaconData);
            // is currently only working in FF
            // chrome is setting the content-type to text/plain See: https://w3c-test.org/beacon/headers/header-content-type.html
            // edge crashes with "Unhandled rejection with value: object "TypeError: Failed to execute 'sendBeacon()' on 'Window': Invalid argument."
            // See also https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16352146/

            if (bResult) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "sendBeacon request was enqueued for URL:" + sUrl, "RequestUtil.js(334): sendBeaconRequest");
                }
                ;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "sendBeacon request enqueued failed for URL:" + sUrl, "RequestUtil.js(336): sendBeaconRequest");
                }
                ;
            }
        } else { //IE doesn't support beacon -> do it classical
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, "sendBeacon request is not supported use standard XHR async request for URL:" + sUrl, "RequestUtil.js(339): sendBeaconRequest");
            }
            ;
            UCF_RequestUtil["sendAsyncRequest"](sUrl, "POST", null, null, "", sPostBody);
            bResult = true; //assuming it works
        }
        return bResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendBeaconRequest"] = 0;
    }
    ;

    /**
     * Helper function to send an unload request to the server in case
     * the browser window is closed or the user navigates to another page.
     * Depending on the browser a syncXHR is used or a async sendBeacon.
     *
     * In case of sendBeacon the parameter bEnsureSyncRefresh is used to
     * write the UnloadURL with a timestamp into sessionStorage.
     * During startup the sessionStorage is read to unloadURL is fired.
     *
     * @private
     * @param {string} sUrl the termination url
     * @param {string} [mPostParameters] the request parameters (if any)
     * @param {string} [sSessionHandling=''] type of SessionHandling, DEFAULT, SYNC
     */
    UCF_RequestUtil["sendUnloadRequest"] = function (sUrl, mPostParameters, sSessionHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendUnloadRequest"]++;
        }
        ;

        var sPostBody = null,
            sMethod = "GET",
            aLogoffQueue = null,
            oSessionInformation = {};

        if (!sUrl) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "No unload Url available", "RequestUtil.js(368): sendUnloadRequest");
            }
            ;
            return;
        }

        if (!UCF_JsUtil["bIsSameHost"](sUrl)) {
            // no support for foreign URLs anymore due to security policy
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "The unload Url to other hosts is not supported" + sUrl, "RequestUtil.js(374): sendUnloadRequest");
            }
            ;
            return;
        }

        if (mPostParameters) {
            //used by ITS
            sPostBody = UCF_RequestUtil["sEncodeParameters"](mPostParameters);
            sMethod = 'POST';
        }

        //SessionHandling DEFAULT or SYNC - ensure in case of SYNC to send request at least async
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, "Try to send unload request to: " + sUrl + " post parameter (optional):" + sPostBody, "RequestUtil.js(385): sendUnloadRequest");
        }
        ;
        try {
            var req = new XMLHttpRequest();

            // Fortify ignore this line
            req["open"](sMethod, sUrl, false); //sync
            req["send"](sPostBody);
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "Unload Url was send via sync XHR", "RequestUtil.js(392): sendUnloadRequest");
            }
            ;
        } catch (ex) {
            try {
                //Chrome announced to remove the possibility to send a sync XHR during unload. Try sendBeacon instead even this doesn't work reliable in Chroem and others
                //Safari on IOS supports sendBeacon, but NOT in onPageUnload, see https://www.ctrl.blog/entry/safari-beacon-issues.html (tested with safari on iOS 12.3)
                //Firefox doesn't send in a reliable way sendBacon during  browser close (tested with FF68.0.1)

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "Unload Url was not possible to send via sync XHR try sendBeacon: try/catch error: " + ex, "RequestUtil.js(399): sendUnloadRequest");
                }
                ;
                UCF_RequestUtil["sendBeaconRequest"](sUrl, null, sPostBody);
            } catch (ex) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "Unload Url was NOT send to: " + sUrl + " try/catch error: " + ex, "RequestUtil.js(402): sendUnloadRequest");
                }
                ;
            }

            try {
                if (sSessionHandling === "SYNC" || sSessionHandling === "SYNCREFRESH") {

                    aLogoffQueue = UCF_JsUtil["oJsonParse"](window["sessionStorage"]["getItem"]("sap-logoff-queue"));
                    oSessionInformation = {
                        "url": sUrl,
                        "timestamp": UCF_JsUtil["iGetTimeStamp"](),
                        "postBody": sPostBody
                    };

                    if (!aLogoffQueue) {
                        aLogoffQueue = [];
                    }
                    aLogoffQueue["push"](oSessionInformation);

                    window["sessionStorage"]["setItem"]("sap-logoff-queue", UCF_JsUtil["sJsonStringify"](aLogoffQueue));
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, "Store unload URL in session storage in sap-logoff-queue: " + sUrl, "RequestUtil.js(417): sendUnloadRequest");
                    }
                    ;
                }
            } catch (ex) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "Store unload URL in session storage not possible: " + sUrl + " try/catch error: " + ex, "RequestUtil.js(420): sendUnloadRequest");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendUnloadRequest"] = 0;
    }
    ;

    /**
     * Helper function to check sessionStorage for URLs which should send
     * to server to logoff the previous session (e.g. caused by F5 refresh).
     *
     * Check sessionstorage.sap-logoff-queue for entries and create an array
     * of UCF_Promise containing the functionality to sedn the logoff requests.
     *
     * @private
     * @return {Array<UCF_Promise>} Promises to call to sendUnlaodRequests or empty array.
     */
    UCF_RequestUtil["aSessionStorageUnloadRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["aSessionStorageUnloadRequest"]++;
        }
        ;
        var aLogoffQueue = null,
            aPromises = [],
            iTimeToSend = 10000; //time in ms for which the unload request is send

        try {
            if (window["sessionStorage"]) {
                //sessionStorage does not work with IE QuirksMode

                aLogoffQueue = window["sessionStorage"]["getItem"]("sap-logoff-queue");

                if (aLogoffQueue) {
                    aLogoffQueue = UCF_JsUtil["arrayFromObject"](UCF_JsUtil["oJsonParse"](aLogoffQueue));

                    UCF_JsUtil["forEach"](aLogoffQueue, function (oLogoffQueueItem) {
                        if (oLogoffQueueItem && oLogoffQueueItem["timestamp"] && (UCF_JsUtil["iGetTimeStamp"]() - oLogoffQueueItem["timestamp"] < iTimeToSend)) {
                            aPromises["push"](UCF_RequestUtil["pSendSessionStorageUnloadRequest"](oLogoffQueueItem["url"], oLogoffQueueItem["postBody"]));
                        }
                    });
                }
                //remove sap-logoff-queue
                window["sessionStorage"]["removeItem"]("sap-logoff-queue");
            }
        } catch (ex) {
            return [];
        }
        ;
        return aPromises;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["aSessionStorageUnloadRequest"] = 0;
    }
    ;

    /**
     * Provides a promise sending asynchroniously an unload URL to the server.
     *
     * @private
     * @param {string} sUrl the termination url
     * @param {string} [sPostBody] the post body (if any)
     * @return {UCF_Promise} Promises to send unload URL.
     */
    UCF_RequestUtil["pSendSessionStorageUnloadRequest"] = function (sUrl, sPostBody) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["pSendSessionStorageUnloadRequest"]++;
        }
        ;
        return new UCF_Promise(function (resolve, reject) {

            if (!sUrl) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "No unload Url available", "RequestUtil.js(476): onreadystatechange");
                }
                ;
                reject("No unload Url available");
                return;
            }

            //todo replace this with UCF_RequestUtil.sendAsyncRequest
            if (!UCF_JsUtil["bIsSameHost"](sUrl)) {
                // no support for foreign URLs anymore due to security policy
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "The unload Url to other hosts is not supported" + sUrl, "RequestUtil.js(484): onreadystatechange");
                }
                ;

                //continute with the normal functionality. Don't raise an error
                reject("The unload Url to other hosts is not supported");
                return;
            }

            var oXmlHttp = new XMLHttpRequest(),
                sMethod = "GET";

            oXmlHttp["onreadystatechange"] = function () {
                if (oXmlHttp["readyState"] === 4) {
                    resolve(oXmlHttp["responseText"]);
                }
            };

            if (sPostBody) {
                sMethod = "POST";
            }
            // Fortify ignore this line
            oXmlHttp["open"](sMethod, sUrl, true); //async
            oXmlHttp["send"](sPostBody);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["pSendSessionStorageUnloadRequest"] = 0;
    }
    ;

    /**
     * Set a request header and returns the length of the header/value pair
     * successful, the text and the XML document
     * @param {XMLHttpRequest} oXmlHttp Object
     * @param {string} sHeader header name of the request header
     * @param {string} sValue value of the request header
     *
     * @return {int} Length of the header/value pair
     * @private
     */

    UCF_RequestUtil["iSetRequestHeader"] = function (oXmlHttp, sHeader, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["iSetRequestHeader"]++;
        }
        ;
        oXmlHttp["setRequestHeader"](sHeader, sValue);

        // UI5 uses "(sHeader.length + sValue.length + 3) * 2" due to double string length for byte length as in js characters are stored as 16 bit ints: According HTTPWatch this is wrong
        // sHeader + ": " + sValue + " "   --  means two blank and one colon === 3
        return (sHeader["length"] + sValue["length"] + 3); //eslint-disable-line no-magic-numbers

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["iSetRequestHeader"] = 0;
    }
    ;

    /**
     * Create a response object containing whether the request was
     * successful, the text and the XML document
     * @param {Object} oXmlHttp Object
     * @return {UCF_RequestUtil_Response} A new response object
     * @private
     */
    UCF_RequestUtil["oCreateResponseObject"] = function (oXmlHttp) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["oCreateResponseObject"]++;
        }
        ;
        /** @type {string} */
        var sStatusCode = oXmlHttp["status"];
        /** @type {boolean} */
            // eslint-disable-next-line eqeqeq
        var bSuccess = sStatusCode == '200' || sStatusCode == '304';
        /** @type {string} */
        var sText = oXmlHttp["responseText"];
        /** @type {Object} */
        var oDocument = oXmlHttp["responseXML"];
        /** @type {Object} used to check whether a JSON parse error occurs */
        var oJson = null;
        /** @type {UCF_RequestUtil_ParseError} */
        var oParseError = null;
        /** @type {string} */
        var sResponseHeaders;
        /** @type {Array<string>} */
        var aResponseHeaders;
        /** @type {Object<string,string>} */
        var mResponseHeaders;
        /** @type {Array<string,string>} */
        var aTmp;
        /** @type {number} */
        var i;
        /** @type {string} */
        var sContentType;

        // Callback to Debug Framework
        try {
            if (oXmlHttp["debugCallback"]) {
                sResponseHeaders = oXmlHttp["getAllResponseHeaders"]();
                aResponseHeaders = [];
                mResponseHeaders = {};
                aTmp = [];
                if (sResponseHeaders) {
                    aResponseHeaders = sResponseHeaders["split"]('\r');
                    for (i in aResponseHeaders) {
                        aTmp = aResponseHeaders[i]["split"](':');
                        mResponseHeaders[aTmp[0]] = aTmp[1];
                    }
                }
                oXmlHttp["debugCallback"](sStatusCode, sText, mResponseHeaders);
            }
        } catch (e) {
        }
        ;

        sContentType = oXmlHttp["getResponseHeader"]('content-type');
        if (sContentType && sContentType["indexOf"]('application/json') > -1) {
            // must use indexOf as the content-type often contains the charset e.g. text/xml; charset=utf-8

            try {
                oJson = UCF_JsUtil["oJsonParse"](sText); // eslint-disable-line no-unused-vars
                oParseError = UCF_RequestUtil["oGetParseError"](oDocument);
            } catch (ex) {
                oParseError = {
                    "errorCode": -1,
                    "url": '',
                    "reason": 'Not valid json',
                    "srcText": ex["message"],
                    "line": '',
                    "linepos": '',
                    "filepos": ''
                };
            }
        } else if (sContentType && sContentType["indexOf"]('text/xml') > -1) {
            // must use indexOf as the content-type often contains the charset e.g. text/xml; charset=utf-8

            // Firefox 1.5/2.0 bug nr 326337 (XHR/domain relaxing)
            // in some cases even trying causes FF2 to throw an exception
            // eslint-disable-next-line no-magic-numbers
            if (UCF_UserAgent["bIsFirefox"](2) && !UCF_UserAgent["bIsFirefox"](3)) {
                oDocument = UCF_JsUtil["oParseXMLDocument"](sText);
            }
            oParseError = UCF_RequestUtil["oGetParseError"](oDocument);
        } else {
            // This case is important for ITS logoff. The HTTP server send a HTML page
            // as a response and only if we have a oParseError
            // EventHandler.onXmlHttpResponse() will call LS.destroy() !
            oParseError = UCF_RequestUtil["oGetParseError"](oDocument);
        }

        if (__UCF_IE6__) {
            // eslint-disable-next-line no-implied-eval
            window["setTimeout"]('eval(UCF_RequestUtil.bWaitingForServerResponse=false)', 0);
            // eslint-disable-next-line no-implied-eval, no-magic-numbers
            window["setTimeout"]('eval(window.document.qtp_readystate=true)', 100);
        } else {
            setTimeout(
                function () {
                    UCF_RequestUtil["bWaitingForServerResponse"] = false;
                },
                0
            );
            // eslint-disable-next-line no-magic-numbers
            setTimeout(function () {
                document["qtp_readystate"] = true;
            }, 100);
        }

        return {
            "bSuccess": bSuccess,
            "sStatusCode": sStatusCode,
            "oParseError": oParseError,
            "sText": sText,
            "oJson": null,
            "oDocument": oDocument
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["oCreateResponseObject"] = 0;
    }
    ;

    /**
     * Extracts parse error information from the document (if any)
     *
     * @param {Object} oDocument document to check
     * @return {UCF_RequestUtil_ParseError} oParseError if errors were found, or null
     * @private
     */
    UCF_RequestUtil["oGetParseError"] = function (oDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["oGetParseError"]++;
        }
        ;
        /** @type {UCF_RequestUtil_ParseError} */
        var oParseError = {
            "errorCode": -1,
            "url": '',
            "reason": 'unknown error',
            "srcText": '',
            "line": '',
            "linepos": '',
            "filepos": ''
        };
        /** @type {string} */
        var sErrorText = '';
        /** @type {RegExp} */
        var rParserError = null;

        // IE
        if (
            (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) &&
            oDocument &&
            oDocument["parseError"] &&
            oDocument["parseError"]["errorCode"] !== 0
        ) {
            return oDocument["parseError"];
        }

        // Firefox
        if (
            UCF_UserAgent["bIsGecko"]() &&
            oDocument &&
            oDocument["documentElement"] &&
            oDocument["documentElement"]["tagName"] === 'parsererror'
        ) {
            sErrorText = oDocument["documentElement"]["firstChild"]["nodeValue"];
            rParserError = /XML Parsing Error: (.*)\nLocation: (.*)\nLine Number (\d+), Column (\d+):(.*)/;

            if (rParserError["test"](sErrorText)) {
                oParseError["reason"] = RegExp["$1"];
                oParseError["url"] = RegExp["$2"];
                oParseError["line"] = parseInt(RegExp["$3"]);
                oParseError["linepos"] = parseInt(RegExp["$4"]);
                oParseError["srcText"] = RegExp["$5"];
            }

            return oParseError;
        }

        // Safari
        if (
            UCF_UserAgent["bIsWebKit"]() &&
            oDocument &&
            oDocument["documentElement"] &&
            oDocument["documentElement"]["tagName"] === 'html' &&
            oDocument["getElementsByTagName"]('parsererror')["length"] > 0
        ) {
            sErrorText = UCF_JsUtil["sSerializeXMLDocument"](oDocument);
            rParserError = /error on line (\d+) at column (\d+): ([^<]*)/;

            if (rParserError["test"](sErrorText)) {
                oParseError["reason"] = RegExp["$3"];
                oParseError["url"] = '';
                oParseError["line"] = parseInt(RegExp["$1"]);
                oParseError["linepos"] = parseInt(RegExp["$2"]);
                oParseError["srcText"] = '';
            }

            return oParseError;
        }

        if (!oDocument || !oDocument["documentElement"]) {
            return oParseError;
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["oGetParseError"] = 0;
    }
    ;

    /**
     * Creates a URL encoded representation of the parameter map
     *
     * @param {Object<string,(string|Array<string>)>} mParameters The map of parameters
     * @return {string} URL encoded representation of the parameter map
     * @private
     */
    UCF_RequestUtil["sEncodeParameters"] = function (mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sEncodeParameters"]++;
        }
        ;
        /** @type {Array<string>} */
        var aBuffer = [];
        /** @type {string} */
        var i;
        /** @type {Array<string>} */
        var aParameterValues;
        /** @type {number} */
        var j;

        for (i in mParameters) {
            // Arrays are used, if multiple values for the same name exist
            if (mParameters[i] instanceof Array) {
                aParameterValues = mParameters[i];
                for (j = 0; j < aParameterValues["length"]; j++) {
                    aBuffer["push"](
                        encodeURIComponent(i) + '=' + encodeURIComponent(aParameterValues[j])
                    );
                }
            } else {
                aBuffer["push"](
                    encodeURIComponent(i) + '=' + encodeURIComponent(mParameters[i])
                );
            }
        }

        return aBuffer["join"]('&');

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sEncodeParameters"] = 0;
    }
    ;

    /**
     * Disable the use of ActiveX in the RequestUtil
     * @private
     */
    UCF_RequestUtil["disableActiveX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["disableActiveX"]++;
        }
        ;
        UCF_RequestUtil["bUseActiveX"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["disableActiveX"] = 0;
    }
    ;

    /**
     * Disable the use of XHR in the RequestUtil
     * @private
     */
    UCF_RequestUtil["disableXHR"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["disableXHR"]++;
        }
        ;
        UCF_RequestUtil["bUseXHR"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["disableXHR"] = 0;
    }
    ;

    /**
     * Check for failed (canceled) requests on InternetExplorer
     *
     * @param {XMLHttpRequest} oXmlHttp XMLHttp request
     * @param {Object} oCachedRequest cached request to able to send it again in special error cases
     * @return {boolean} `true` if request failed, otherwise `false`
     * @private
     */
    UCF_RequestUtil["_ieRequestFailed"] = function (oXmlHttp, oCachedRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["_ieRequestFailed"]++;
        }
        ;
        /** @type {string} */
        var sStatus;
        /** @type {string} */
        var traceText;

        // see CSN 1164292_2012 and note 1679126	(MS KBA
        // http://support.microsoft.com/kb/2826958 & KB895954)
        if (oXmlHttp && typeof oXmlHttp["status"] !== 'undefined' && oCachedRequest) {
            sStatus = oXmlHttp["status"]["toString"]();

            switch (sStatus) { // see URL: support.microsoft.com/kb/193625
                case '12019': // ERROR_INTERNET_INCORRECT_HANDLE_STATE
                case '12152': // ERROR_HTTP_INVALID_SERVER_RESPONSE
                case '12031': // ERROR_INTERNET_CONNECTION_RESET
                case '0': // UNKNOWN ERROR
                    traceText = 'Network error caused by IE and Server with status=' + sStatus + ', resend complete requst (retry count=' + UCF_RequestUtil["retryCounter"] + ')';
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, traceText, "RequestUtil.js(801): _ieRequestFailed");
                    }
                    ;

                    if (
                        oCachedRequest["length"] >= 4 && // eslint-disable-line no-magic-numbers
                        oCachedRequest[3] != null && // eslint-disable-line no-magic-numbers
                        oCachedRequest[3] != '' // eslint-disable-line no-magic-numbers, eqeqeq
                    ) {
                        // eslint-disable-next-line no-magic-numbers
                        oCachedRequest[3]["traceIEError"] = traceText;
                    }
                    if (UCF_RequestUtil["retryCounter"] < 5) { //eslint-disable-line no-magic-numbers
                        UCF_RequestUtil["retryCounter"]++;

                        if (UCF_RequestUtil["retryCounter"] <= 1) {
                            UCF_RequestUtil["sendRequest"]["apply"](UCF_RequestUtil, oCachedRequest);
                        } else {
                            UCF_JsUtil["delayedCall"](
                                UCF_RequestUtil["retryCounter"] * 50, // eslint-disable-line no-magic-numbers
                                UCF_RequestUtil,
                                'sendRequest',
                                oCachedRequest
                            );
                        }
                    } else {
                        UCF_RequestUtil["retryCounter"] = 0;
                        UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["NETWORK"]);
                    }

                    return true;
            }
        }

        UCF_RequestUtil["retryCounter"] = 0;

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["_ieRequestFailed"] = 0;
    }
    ;

    /**
     * Sends a form request to a given target.
     *
     * @param {string} sMethod The method that is used for the post
     * @param {string} sUrl The url used for the Request
     * @param {Object<string,(string|Array<string>)>} mParameters Map of string key
     * and string value pairs to be passed to as request parameters to the url
     * @param {string} sTarget Name of the frame used as target for the request. If
     * no target is given the current window is used. Use '_blank' for a new
     * browser window or '_top' for the topmost browser window.
     * @private
     */
    UCF_RequestUtil["sendFormRequest"] = function (sMethod, sUrl, mParameters, sTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["sendFormRequest"]++;
        }
        ;
        /** @type {HTMLFormElement} */
        var oForm;
        /** @type {string} */
        var i;
        /** @type {string|Array<string>} */
        var oValue;
        /** @type {number} */
        var j;

        if (sMethod === 'GET' && !mParameters && !sTarget) {
            document["location"]["href"] = sUrl;
        } else {
            oForm = document["createElement"]('form');
            oForm["setAttribute"]('action', sUrl);
            oForm["setAttribute"]('target', sTarget);
            oForm["setAttribute"]('method', sMethod);
            for (i in mParameters) {
                oValue = mParameters[i];
                if (typeof oValue === 'string') {
                    UCF_RequestUtil["addFormField"](oForm, i, oValue);
                } else {
                    for (j = 0; j < oValue["length"]; j++) {
                        UCF_RequestUtil["addFormField"](oForm, i, oValue[j]);
                    }
                }
            }
            document["body"]["appendChild"](oForm);
            oForm["submit"]();
            document["body"]["removeChild"](oForm);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["sendFormRequest"] = 0;
    }
    ;

    /**
     * Adds a hidden input field with given name and value to the form
     * @param {element} oForm The form DOMElement where to add the field
     * @param {string} sName The name of the input element to add
     * @param {string} sValue The value of the input field
     * @private
     */
    UCF_RequestUtil["addFormField"] = function (oForm, sName, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RequestUtil["_"]["addFormField"]++;
        }
        ;
        /** @type {HTMLInputElement} */
        var oInput = document["createElement"]('input');

        oInput["setAttribute"]('type', 'hidden');
        oInput["setAttribute"]('name', sName);
        oInput["setAttribute"]('value', sValue);
        oForm["appendChild"](oInput);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RequestUtil["_"]["addFormField"] = 0;
    }
    ;

    UCF_RequestUtil.prototype["aPublicMethods"] = ["sendAsyncRequest", "sendBeaconRequest"].concat(UCF_RequestUtil.prototype.aPublicMethods || []);
    /* global _assert */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_JsUtil */

/// <reference path="./JsUtil.js"/>

    /**
     * String Utility Functions
     * This class provides static methods for string operations.
     *
     *
     * @class
     * @version
     */
    function UCF_StringUtil() {
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["UCF_StringUtil"]++;
        }
        ;
    };window["UCF_StringUtil"] = UCF_StringUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_StringUtil");
        UCF_StringUtil["_"] = {UCF_StringUtil: 0};
    }
    ;
    ;

    /**
     * Add leading or ending charachters to string until a total length is reached.
     * The charachters should not be empty.
     * @public
     *
     * @param {string}  sBaseString string that will be filled with chars
     * @param {string}  sFillChar character that will be added
     * @param {int}     iTotalLength length of the result string
     * @param {boolean} bAddInFront whether the chars are added in the front or in the back of the sBaseString
     * @return {string} The string where the chars where added
     */
    UCF_StringUtil["fillChars"] = function (sBaseString, sFillChar, iTotalLength, bAddInFront) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["fillChars"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sBaseString) === "string", "typeof(sBaseString) === \"string\"", "StringUtil.js(29): fillChars");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sFillChar) === "string", "typeof(sFillChar) === \"string\"", "StringUtil.js(30): fillChars");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (iTotalLength) === "number", "typeof(iTotalLength) === \"number\"", "StringUtil.js(31): fillChars");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(Math["floor"](iTotalLength) === iTotalLength, "Math.floor(iTotalLength) === iTotalLength", "StringUtil.js(32): fillChars");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sFillChar["length"] <= 1, "sFillChar.length <= 1", "StringUtil.js(33): fillChars");
        }
        ;

        var sNewString = sBaseString;

        while (sNewString["length"] < iTotalLength) {
            if (bAddInFront) {
                sNewString = sFillChar + sNewString;
            } else {
                sNewString += sFillChar;
            }
        }
        return sNewString;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["fillChars"] = 0;
    }
    ;

    /**
     * Repeats `value` `count` times.
     *
     *     UCF_StringUtil.repeat('wat', 3) // => 'watwatwat'
     *     UCF_StringUtil.repeat('*', 'secret'.length) // => '******'
     *
     * @public
     * @param {string} value the value to be repeated
     * @param {integer} count the number of times `value` should be repeated
     * @return {string}
     */
    UCF_StringUtil["repeat"] = function (value, count) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["repeat"]++;
        }
        ;
        return Array((count || 1) + 1)["join"]((value || ''));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["repeat"] = 0;
    }
    ;

    /**
     * Returns true if sString starts with sSubString
     *
     * @public
     *
     * @param {string} sString Value to be searched
     * @param {string} sSubString Value to be found
     * @param {boolean} bIgnoreCase whether to ignore the case (optional)
     * @return {boolean} true if sString starts with sSubString
     */
    UCF_StringUtil["bStartsWith"] = function (sString, sSubString, bIgnoreCase) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["bStartsWith"]++;
        }
        ;
        if (bIgnoreCase) {
            sString = sString["toUpperCase"]();
            sSubString = sSubString["toUpperCase"]();
        }
        return UCF_JsUtil["indexOf"](sString, sSubString) === 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["bStartsWith"] = 0;
    }
    ;

    /**
     * Returns true if sString ends with sSubString
     *
     * @public
     *
     * @param {string} sString Value to be searched
     * @param {string} sSubString Value to be found
     * @param {boolean} bIgnoreCase whether to ignore the case (optional)
     * @return {boolean} true if sString ends with sSubString
     */
    UCF_StringUtil["bEndsWith"] = function (sString, sSubString, bIgnoreCase) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["bEndsWith"]++;
        }
        ;
        if (bIgnoreCase) {
            sString = sString["toUpperCase"]();
            sSubString = sSubString["toUpperCase"]();
        }
        var iPos = UCF_JsUtil["indexOf"](sString, sSubString);
        return iPos >= 0 && iPos === sString["length"] - sSubString["length"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["bEndsWith"] = 0;
    }
    ;

    /**
     * Returns true if sSubString is contained in sString
     *
     * @public
     *
     * @param {string} sString Value to be searched
     * @param {string} sSubString Value to be found
     * @param {boolean} bIgnoreCase whether to ignore the case (optional)
     * @return {boolean} true if sString contains the sSubString
     */
    UCF_StringUtil["bContains"] = function (sString, sSubString, bIgnoreCase) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["bContains"]++;
        }
        ;

        if (sString && sSubString) {
            if (bIgnoreCase) {
                sString = sString["toUpperCase"]();
                sSubString = sSubString["toUpperCase"]();
            }
            return UCF_JsUtil["indexOf"](sString, sSubString) >= 0;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["bContains"] = 0;
    }
    ;

    /**
     * Removes all whitespace characters (" ", \r, \n, \t) from the given value
     *
     * @public
     *
     * @param {string} sValue
     * @return {string} The cleaned string
     */
    UCF_StringUtil["sStripWhiteSpace"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["sStripWhiteSpace"]++;
        }
        ;
        return sValue["replace"](/\s/g, "");

        //TODO: 160 is not found as "\s" - maybe use sValue.replace(/[\s\xA0]/g, "");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["sStripWhiteSpace"] = 0;
    }
    ;

    /**
     * Removes all whitespace characters (" ", \r, \n, \t) from the given value from the beginning and the end
     *
     * @public
     *
     * @param {string} sValue
     * @return {string} The trimmed string
     */
    UCF_StringUtil["sTrim"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["sTrim"]++;
        }
        ;
        if (!sValue) {
            return '';
        }

        if (__UCF_IE6__)
            return sValue["replace"](/(^[\s\xA0]+|[\s\xA0]+$)/gm, "");
        else
            return sValue["trim"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["sTrim"] = 0;
    }
    ;

    /**
     * Returns true if sValue is empty or only contains whitespace characters
     *
     * @public
     *
     * @param {string} sValue
     * @return {boolean} true if sValue is empty or only contains whitespace characters
     */
    UCF_StringUtil["bIsEmpty"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["bIsEmpty"]++;
        }
        ;
        return /^\s*$/["test"](sValue);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["bIsEmpty"] = 0;
    }
    ;

    /**
     * Replaces the part from iStartIndex to iEndIndex of sString with sReplaceString
     *
     * @example
     * UCF_StringUtil.replaceAtIndex('Hello, World!', 1, 11, 'i, All')
     * // => 'Hi, All!'
     *
     * @param {string} sString the original string
     * @param {integer} iStartIndex the start index
     * @param {integer} iEndIndex the end index
     * @param {string} sReplace the replace string
     * @return {string} the resulting string
     */
    UCF_StringUtil["replaceAtIndex"] = function (sString, iStartIndex, iEndIndex, sReplace) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["replaceAtIndex"]++;
        }
        ;
        return sString["substring"](0, iStartIndex) + sReplace + sString["substring"](iEndIndex);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["replaceAtIndex"] = 0;
    }
    ;

    /**
     * Parses the string to an integer and returns 0 if NaN
     *
     * @param {Object} oObj any object - mainly objects that are accepted by parseInt()
     * @return {integer} the integer value or 0
     * @private
     */
    UCF_StringUtil["iParseInt"] = function (oObj) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["iParseInt"]++;
        }
        ;
        var i = parseInt(oObj);
        return isNaN(i) ? 0 : i;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["iParseInt"] = 0;
    }
    ;

    /**
     * Converts a dash/underscore-separated string to its
     * camelCased equivalent
     *
     * @example
     * UCF_StringUtil.sCamelize('foo-bar-baz')
     * // => 'fooBarBaz'
     *
     * @param {string} sValue the dashed string to be converted
     * @return {string} the camelCased equivalent
     */
    UCF_StringUtil["sCamelize"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["sCamelize"]++;
        }
        ;
        return sValue["replace"](/[-_]([a-z])/g, function (match, group) {
            return group["toUpperCase"]();
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["sCamelize"] = 0;
    }
    ;

    /**
     * Converts a camelized string to its dasherized equivalent
     *
     * @example
     * UCF_StringUtil.sDasherize('fooBarBaz')
     * // => 'foo-bar-baz'
     *
     * @param {string} sValue the value to be dasherized
     * @return {string} the dasherized equivalent
     */
    UCF_StringUtil["sDasherize"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["sDasherize"]++;
        }
        ;
        return sValue["replace"](/([A-Z][a-z]+)/g, function (match, group) {
            return '-' + group["toLowerCase"]();
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["sDasherize"] = 0;
    }
    ;

    /**
     * Converts a string to its titleized (== words uppercase) form
     *
     * @example
     * UCF_StringUtil.sTitleize('foo bar baz')
     * // => 'Foo Bar Baz'
     *
     * @param {string} sValue the string to be converted
     * @return {string} the titleized equivalent
     */
    UCF_StringUtil["sTitleize"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_StringUtil["_"]["sTitleize"]++;
        }
        ;
        return sValue["replace"](/(^.| .)/g, function (match, group) {
            return group["toUpperCase"]();
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_StringUtil["_"]["sTitleize"] = 0;
    }
    ;

    UCF_StringUtil.prototype["aPublicMethods"] = ["fillChars", "repeat", "bStartsWith", "bEndsWith", "bContains", "sStripWhiteSpace", "sTrim", "bIsEmpty"].concat(UCF_StringUtil.prototype.aPublicMethods || []);
    /* global UCF_EventProvider, UCF_Object */
/// <reference path='../EventProvider.js'/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_JsUtil */

/// <reference path='./JsUtil.js'/>

    /**
     * System popup
     * @class
     *
     */
    function UCF_SystemPopup() {
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["UCF_SystemPopup"]++;
        }
        ;
        /** @type {UCF_SystemPopup} */

        UCF_EventProvider["apply"](this);

        /** @type {string} */
        this["sId"] = UCF_JsUtil["sGetUID"](); 	// eslint-disable-line ur/no-memory-leaks
        /** @type {boolean} */
        this["bIsOpen"] = false;
        /** @type {Array<{sId: string, sText: string}>} */
        this["aButtons"] = [];

        this["fClickHandler"] = null; // eslint-disable-line ur/no-memory-leaks
    };window["UCF_SystemPopup"] = UCF_SystemPopup;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_SystemPopup");
        UCF_SystemPopup["_"] = {UCF_SystemPopup: 0};
    }
    ;
    UCF_SystemPopup["prototype"] = new UCF_Object();
    UCF_SystemPopup.prototype["sClassName"] = "UCF_SystemPopup"; // new UCF_EventProvider();

    UCF_SystemPopup["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["destroy"]++;
        }
        ;
        this["sContent"] = null;
        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["destroy"] = 0;
    }
    ;

    UCF_SystemPopup["prototype"]["onClick"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["onClick"]++;
        }
        ;
        this["fClickHandler"] = fCallback;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["onClick"] = 0;
    }
    ;

    /**
     * Set the title for the SystemPopup
     *
     * @param {string} sTitle
     */
    UCF_SystemPopup["prototype"]["setTitle"] = function (sTitle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["setTitle"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oTitleRef;

        // eslint-disable-next-line ur/no-memory-leaks
        this["sTitle"] = sTitle;

        if (this["bIsOpen"]) {
            oTitleRef = document["getElementById"](this["sId"] + '-title');
            // eslint-disable-next-line no-unsanitized/property
            oTitleRef["innerHTML"] = sTitle;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["setTitle"] = 0;
    }
    ;

    /**
     * Set the content for the SystemPopup
     *
     * @param {string} sContent
     */
    UCF_SystemPopup["prototype"]["setContent"] = function (sContent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["setContent"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oContentRef;

        this["sContent"] = sContent;

        if (this["bIsOpen"]) {
            oContentRef = document["getElementById"](this["sId"] + '-content');
            // eslint-disable-next-line no-unsanitized/property
            oContentRef["innerHTML"] = sContent;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["setContent"] = 0;
    }
    ;

    /**
     * Adds a button to the SystemPopup. The order of calls will determine the
     * button order. The ID of the button is returned with the internal Button
     * event.
     *
     * @param {string} sId Button ID
     * @param {string} sText Text
     */
    UCF_SystemPopup["prototype"]["setButton"] = function (sId, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["setButton"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oButtonsRef;

        this["aButtons"]["push"]({"sId": sId, "sText": sText});

        if (this["bIsOpen"]) {
            oButtonsRef = document["getElementById"](this["sId"] + '-buttons');
            // eslint-disable-next-line no-unsanitized/property
            oButtonsRef["innerHTML"] = this["sGetButtonHTMLWithoutTexts"]();
            this["renderButtonTexts"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["setButton"] = 0;
    }
    ;

    /**
     * Creates the HTML output for the Buttons
     *
     * @return {string}
     */
    UCF_SystemPopup["prototype"]["sGetButtonHTMLWithoutTexts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["sGetButtonHTMLWithoutTexts"]++;
        }
        ;
        return UCF_JsUtil["reduce"](this["aButtons"], function (sHTML, oButton) {
            return sHTML + '<span ' +
                'id="' + oButton["sId"] + '" ' +
                'style="' +
                'border: 1px solid black;' +
                'padding: 1px 3px 1px 3px;' +
                'margin-left: 1em' +
                '" > < /span>';
        }, '');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["sGetButtonHTMLWithoutTexts"] = 0;
    }
    ;

    /** @private */
    UCF_SystemPopup["prototype"]["renderButtonTexts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["renderButtonTexts"]++;
        }
        ;
        UCF_JsUtil["forEach"](this["aButtons"], function (oButton) {
            UCF_DomUtil["setInnerText"](UCF_DomUtil["$"](oButton["sId"]), oButton["sText"]);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["renderButtonTexts"] = 0;
    }
    ;

    /**
     * Clears the buttons that were previously added with setButton()
     */
    UCF_SystemPopup["prototype"]["clearButtons"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["clearButtons"]++;
        }
        ;
        this["aButtons"] = [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["clearButtons"] = 0;
    }
    ;

    /**
     * Shows an error message for the user and blocks all interaction with the document
     */
    UCF_SystemPopup["prototype"]["show"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["show"]++;
        }
        ;
        /** @type {HTMLIFrameElement} */
        var oFrame;
        /** @type {HTMLDivElement} */
        var oDiv;

        if (!this["bIsOpen"]) {
            this["bIsOpen"] = true;

            oFrame = document["createElement"]('IFRAME');
            oFrame["setAttribute"]('id', this["sId"] + '-frame');
            oFrame["setAttribute"]('allowTransparency', 'true');
            oFrame["setAttribute"]('frameBorder', 'no');
            oFrame["src"] = 'about:blank';
            oFrame["border"] = '0';
            UCF_DomUtil["setStyle"](oFrame, {
                "position": 'absolute',
                "top": '-2px',
                "left": '-2px',
                "width": '150%',
                "height": '150%',
                "border": 'none',
                "background": '#000'
            });
            // eslint-disable-next-line no-magic-numbers
            UCF_DomUtil["setOpacityStyle"](oFrame, 50);

            oDiv = document["createElement"]('DIV');
            oDiv["setAttribute"]('id', this["sId"] + '-window');
            UCF_DomUtil["setStyle"](oDiv, {
                "position": 'absolute',
                "left": '25%',
                "top": '25%',
                "width": '50%',
                "height": '50%'
            });
            // eslint-disable-next-line no-unsanitized/property
            oDiv["innerHTML"] =
                // <div>
                '<div style="' +
                'line-height:normal;' +
                'border-style:solid;' +
                'border-width:1px;' +
                'border-bottom-color:#1D4971;' +
                'border-left-color:#77A4D8;' +
                'border-right-color:#1D4971;' +
                'border-top-color:#77A4D8;' +
                'background-color:white;' +
                'cursor:default">' +
                //   <div>
                '<div style="border-style:solid;' +
                'border-width:1px;' +
                'border-bottom-color:#77A4D8;' +
                'border-left-color:#1D4971;' +
                'border-right-color:#77A4D8;' +
                'border-top-color:#1D4971;' +
                'background-color:#2e6695">' +
                //     <div id="-title">
                '<div id="' + this["sId"] + '-title" style="' +
                'padding:3px 0 3px 6px;' +
                'font-family:Arial;' +
                'font-size:11px;' +
                'font-weight:bold;' +
                'color:#FFF;' +
                'text-overflow:ellipsis;' +
                'overflow:hidden">' +
                this["sTitle"] +
                '</div>' +
                //     </div>
                '</div>' +
                //   </div>
                //   <div id="-content">
                '<div id="' + this["sId"] + '-content">' + this["sContent"] + '</div>' +
                //   </div>
                //   <div id="-buttons">
                '<div id="' + this["sId"] + '-buttons" style="' +
                'padding:3px 24px 12px 3px;' +
                'font-size: 0.7em;text-align:right">' +
                this["sGetButtonHTMLWithoutTexts"]() +
                '</div>' +
                //   </div>
                // </div>
                '</div>';

            if (document["body"]) {
                UCF_DomUtil["setStyle"](document["body"], {"overflow": 'hidden'});

                UCF_DomUtil["append"](document["body"], oFrame);
                UCF_DomUtil["append"](document["body"], oDiv);

                this["renderButtonTexts"]();
                UCF_DomUtil["attachEvent"](
                    UCF_DomUtil["$"](this["sId"] + '-buttons'),
                    'click',
                    this["fClickHandler"]
                );
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["show"] = 0;
    }
    ;

    /** Hides the error message */
    UCF_SystemPopup["prototype"]["hide"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SystemPopup["_"]["hide"]++;
        }
        ;
        if (this["bIsOpen"]) {
            this["bIsOpen"] = false;

            UCF_DomUtil["removeFromDom"](UCF_DomUtil["$"](this["sId"] + '-frame'));
            UCF_DomUtil["removeFromDom"](UCF_DomUtil["$"](this["sId"] + '-window'));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SystemPopup["_"]["hide"] = 0;
    }
    ;

    /* global _assert */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="./StringUtil.js"/>
    /* global UCF_BrowserEvent */

/// <reference path="../../ls/browser/BrowserEvent.js"/>

    /**
     * Provides methods to determine user agent and versions of the
     * browser.
     *
     * Samples
     *
     * Check for IE 7 and higher
     * if (UCF_UserAgent.bIsIE()){...};
     *
     * Check for IE 7 and higher
     * if (UCF_UserAgent.bIsIE(7)){...};
     *
     * Check for Firefox 2 but not 3 and higher
     * if (UCF_UserAgent.bIsFirefox(2) && !UCF_UserAgent.bIsFirefox(3)){...};
     *
     * Do something for different versions of WebKit start with the newest one
     * if (UCF_UserAgent.bIsWebkit(528.23)) { ... }
     * else if (UCF_UserAgent.bIsWebkit(528.19)) { ... }
     * else if (UCF_UserAgent.bIsWebkit(528.1)) { ... }
     * else if (UCF_UserAgent.bIsWebkit(500)) { ... }
     *
     *
     *
     * @class
     */
    function UCF_UserAgent() {
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["UCF_UserAgent"]++;
        }
        ;

    };window["UCF_UserAgent"] = UCF_UserAgent;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_UserAgent");
        UCF_UserAgent["_"] = {UCF_UserAgent: 0};
    }
    ;

    /** ENGINES */
    /** @enum {string} */
    UCF_UserAgent["ENGINE"] = {
        /** Trident */
        "Trident": 'TRIDENT',
        /** Enum value from  UserAgent.enumeration and UserAgentConfig.xml - Gecko used by Firefox and Flock */
        "Gecko": 'GECKO',
        /** Enum value from  UserAgent.enumeration and UserAgentConfig.xml - WebKit used by Safari and Chrome */
        "Webkit": 'WEBKIT',
        /** EdgeHTML engine */
        "EdgeHtml": 'EDGEHTML'
    };

    /** BROWSERS */
    /** @enum {string} */
    UCF_UserAgent["BROWSER"] = {
        /** Enum value from  UserAgent.enumeration and UserAgentConfig.xml - Microsoft Internet Explorer aka Trident*/
        "MSIE": 'MSIE',
        /** Firefox */
        "Firefox": 'Firefox',
        /** Safari */
        "Safari": 'Safari',
        /** Chrome */
        "Chrome": 'Chrome',
        /** Opera */
        "Opera": 'Opera',
        /** Browser using EDGE.DLL (project Spartan)*/
        "MSEdge": 'MSEdge',
        /** Browser based on Edge@Chrome */
        "Edge": 'Edge',
        /** PhantomJS */
        "PhantomJS": 'PhantomJS',
        //** Android Browser on Android Devices */
        "Android": 'Android'
    };

//Browser appreviations aligned to UI5 for FESR
    /** @enum {string} */
    UCF_UserAgent["BROWSER_ABBREVIATION"] = {};
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["MSIE"]] = "ie";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["Firefox"]] = "ff";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["Safari"]] = "sf";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["Chrome"]] = "cr";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["Opera"]] = "op";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["MSEdge"]] = "ed";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["PhantomJS"]] = "pj";
    UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["BROWSER"]["Android"]] = "an";

    /** PLATFORMS */
    /** Platform.enumeration is not used by UCF_System but CamelCase syntax */
    /** Ensure to use same values as in UCF_System.sPlatform from server */
    /** @typedef {'WINDOWS'|'MACINTOSH'|'X11'|'IOS'|'ANDROID'|'BLACKBERRY'|'WINDOWS_PHONE'|'CHROMEOS'} UCF_UserAgent_Platform */
    /** @const {Object<string, UCF_UserAgent_Platform>} */
    UCF_UserAgent["PLATFORM"] = {
        /** Enum value from UserAgentConfig.xml -  Windows **/
        "Windows": 'Windows',
        /** Enum value from UserAgentConfig.xml - MacOs */
        "MacOs": 'Macintosh',
        /** Enum value from UserAgentConfig.xml -  Linux */
        "Linux": 'X11',
        /** Enum value from UserAgentConfig.xml - iOS */
        "IOs": 'iOS',
        /** Enum value from UserAgentConfig.xml - Android */
        "Android": 'Android',
        /** Enum value from UserAgentConfig.xml - Blackberry */
        "Blackberry": 'Blackberry',
        /** Enum value from UserAgentConfig.xml - Android */
        "WindowsPhone": 'WindowsPhone',
        /** Enum value from UserAgentConfig.xml - ChromeOS */
        "ChromeOs": 'ChromeOS'

    };

//PLATFORMS appreviations aligned to UI5 for FESR
    /** @enum {string} */
    UCF_UserAgent["PLATFORM_ABBREVIATION"] = {};
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["Windows"]] = "win";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["MacOs"]] = "mac";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["Linux"]] = "linux";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["Android"]] = "Android";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["Blackberry"]] = "bb";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["WindowsPhone"]] = "winphone";
    UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["PLATFORM"]["ChromeOs"]] = "CrOS";

    /** Enumeration containing the names of known types of the devices. */
    /** @enum {number} */
    UCF_UserAgent["DEVICETYPE"] = {
        "Unknwon": 0,
        "Combi": 1,
        "Desktop": 2,
        "Phone": 3,
        "Tablet": 4
    };

    /** @typedef {0} UCF_UserAgent_ResponsiveBreakpoint_S */
    /** @typedef {601} UCF_UserAgent_ResponsiveBreakpoint_M */
    /** @typedef {1025} UCF_UserAgent_ResponsiveBreakpoint_L */
    /** @typedef {1441} UCF_UserAgent_ResponsiveBreakpoint_XL */
    /** @typedef {UCF_UserAgent_ResponsiveBreakpoint_S|UCF_UserAgent_ResponsiveBreakpoint_M|UCF_UserAgent_ResponsiveBreakpoint_L|UCF_UserAgent_ResponsiveBreakpoint_XL} UCF_UserAgent_ResponsiveBreakpoint */
    /** @type {Object<string,UCF_UserAgent_ResponsiveBreakpoint>} */
    UCF_UserAgent["RESPONSIVE_BREAKPOINT"] = {
        "S": 0,
        "M": 601,
        "L": 1025,
        "XL": 1441
    };

    /**
     * Initializes the User Agent
     * @private
     */

    UCF_UserAgent["init"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["init"]++;
        }
        ;  // eslint-disable-line complexity
        var sUserAgent = window["navigator"]["userAgent"],
            sSearchUA = /Trident\/(\d+\.\d+)/,
            sSearchB = [/MSIE (\d+\.\d+)/];

        // Default is IE
        UCF_UserAgent["sUA"] = UCF_UserAgent["ENGINE"]["Trident"];
        UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["MSIE"];
        UCF_UserAgent["fUAVersion"] = 0;
        UCF_UserAgent["fBVersion"] = 0;
        UCF_UserAgent["bPhone"] = null; //null is undecided
        UCF_UserAgent["bTablet"] = null; //null is undecided
        UCF_UserAgent["bDesktop"] = true;
        UCF_UserAgent["bCombi"] = null; //null is undecided
        UCF_UserAgent["sOsVersion"] = "";
        UCF_UserAgent["bTouchSupport"] = null; //null is undecided
        UCF_UserAgent["bIsIOSDesktopBrowser"] = false;

        // Check for MSEdge (project Spartan)
        // "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.<OS build number>"
        if (sUserAgent["indexOf"]("Edge/") > -1) {
            UCF_UserAgent["sUA"] = UCF_UserAgent["ENGINE"]["EdgeHtml"];
            sSearchUA = /Edge\/(\d+\.\d+)/;
            UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["MSEdge"];
            sSearchB["push"](/Edge\/(\d+\.\d+)/);
        }
            // Check for Edge@Chrome
        // "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3794.0 Safari/537.36 Edg/76.0.161.0"
        else if (sUserAgent["indexOf"]("Edg/") > -1) {
            UCF_UserAgent["sUA"] = UCF_UserAgent["ENGINE"]["Webkit"];
            sSearchUA = /WebKit\/(\d+.\d+)/;
            UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["Edge"];
            sSearchB["push"](/Edg\/(\d+\.\d+)/);
        }

        // Check for Gecko
        else if (sUserAgent["indexOf"]("Gecko/") > -1) {
            UCF_UserAgent["sUA"] = UCF_UserAgent["ENGINE"]["Gecko"];
            sSearchUA = /rv:(\d+\.\d+)/;
            // Check for Firefox
            if (sUserAgent["indexOf"]("Firefox/") > -1) {
                UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["Firefox"];
                sSearchB["push"](/Firefox\/(\d+\.\d+)/);
            }
        }

        // Check for PhantomJS
        else if (sUserAgent["indexOf"]("PhantomJS/") > -1) {
            //should lool like Mozilla/5.0 (Macintosh; Intel Mac OS X) AppleWebKit/534.34 (KHTML, like Gecko) PhantomJS/1.9.0 (development) Safari/534.34
            UCF_UserAgent["sUA"] = UCF_UserAgent["BROWSER"]["PhantomJS"];
            UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["PhantomJS"];
            sSearchUA = /PhantomJS\/(\d+\.\d+)/;
            sSearchB["push"](/PhantomJS\/(\d+\.\d+)/);
        }

        // Check for WebKit
        else if (sUserAgent["indexOf"]("WebKit/") > -1) {
            UCF_UserAgent["sUA"] = UCF_UserAgent["ENGINE"]["Webkit"];
            sSearchUA = /WebKit\/(\d+.\d+)/;
            // Check for Chrome
            if (sUserAgent["indexOf"]("Chrome/") > -1) {
                UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["Chrome"];
                sSearchB["push"](/Chrome\/(\d+\.\d+)/);
            }
            // Check for Safari, do not put before the chrome check because chome also contains Safari/
            else if (sUserAgent["indexOf"]("Safari/") > -1) {
                UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["Safari"];
                sSearchB["push"](/Version\/(\d+\.\d+)/);
            }
        }

        // Check for Opera
        else if (sUserAgent["indexOf"]("Opera/") > -1) {
            UCF_UserAgent["sUA"] = UCF_UserAgent["BROWSER"]["Opera"];
            UCF_UserAgent["sB"] = UCF_UserAgent["BROWSER"]["Opera"];
            sSearchUA = /Opera\/(\d+\.\d+)/;
            sSearchB["push"](/Opera\/(\d+\.\d+)/);
        }

        // else default is IE and Trident

        if (sSearchUA["test"](sUserAgent)) {
            UCF_UserAgent["fUAVersion"] = parseFloat(RegExp["$1"]);
        }

        // IE11 (Trident 7.0) and higher does not contain "MSIE v.v" anymore
        // see http://msdn.microsoft.com/en-us/library/bg182625(v=vs.85).aspx
        // UAString == "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko"
        if (UCF_UserAgent["sUA"] === UCF_UserAgent["ENGINE"]["Trident"] && UCF_UserAgent["fUAVersion"] >= 7.0) {
            sSearchB["push"](/rv:(\d+\.\d+)/);
        }

        for (var i = 0; i < sSearchB["length"]; i++) {
            if (sSearchB[i]["test"](sUserAgent)) {
                UCF_UserAgent["fBVersion"] = parseFloat(RegExp["$1"]);
            }
        }

        //harmonize with platform.enum and
        /** @type {UCF_UserAgent_Platform} */
        UCF_UserAgent["sOs"] = null;
        if (sUserAgent["indexOf"]("Windows Phone") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["WindowsPhone"];
        else if (sUserAgent["indexOf"]("Windows ") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["Windows"];
        else if (sUserAgent["indexOf"]("Android") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["Android"];
        else if (sUserAgent["indexOf"]("Linux") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["Linux"];
        else if (sUserAgent["indexOf"]("iPad") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["IOs"];
        else if (sUserAgent["indexOf"]("iPhone") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["IOs"];
        else if (sUserAgent["indexOf"]("iPod") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["IOs"];
        else if (sUserAgent["indexOf"]("Mac OS") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["MacOs"];
        else if (sUserAgent["indexOf"]("CrOS") > -1) UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["ChromeOs"];

        // platform (i.e. OS) version if available
        var rVersion;
        switch (UCF_UserAgent["sOs"]) {
            case UCF_UserAgent["PLATFORM"]["WindowsPhone"]:
                rVersion = /Windows Phone (\d+).(\d)/i;
                break;
            case UCF_UserAgent["PLATFORM"]["Windows"]:
                rVersion = /Windows NT (\d+).(\d)/i;
                break;
            case UCF_UserAgent["PLATFORM"]["MacOs"]:
                rVersion = /Mac OS X (\d+).(\d+)/i;
                break;
            case UCF_UserAgent["PLATFORM"]["IOs"]:
                rVersion = /OS (\d+).(\d+)/i;
                break;
            case UCF_UserAgent["PLATFORM"]["Android"]:
                rVersion = /Android (\d+).(\d+)/i;
                break;
            case UCF_UserAgent["PLATFORM"]["Linux"]:
                // to do
                break;
            case UCF_UserAgent["PLATFORM"]["ChromeOs"]:
                rVersion = /X11; CrOS x86_64 (\d+).(\d+)/i;
        }

        var uaResult = rVersion && sUserAgent["match"](rVersion);
        if (uaResult) {
            if (UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["Windows"]) {
                if (uaResult[1] === "6" && uaResult["length"] > 2) {
                    if (uaResult[2] === "1") {
                        UCF_UserAgent["sOsVersion"] = "7";
                    } else if (uaResult[2] > 1) {
                        UCF_UserAgent["sOsVersion"] = "8";
                    }
                } else {
                    UCF_UserAgent["sOsVersion"] = uaResult[1];
                }
            } else {
                UCF_UserAgent["sOsVersion"] = uaResult[1] + "." + uaResult[2];
            }
        }

        if (UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["MacOs"] && !UCF_UserAgent["bSkipIPadOsOverrule"]()) {
            // Apple changed the default in IPadOS 13 to request the desktop version of the page.
            // "Request Desktop Website -> All websites" (for more infos see: https://forums.developer.apple.com/thread/119186).
            // IPad/Iphone is removed from user agent string
            // Therefore the OS is detected as MACINTOSH instead of iOS --> overrule Apple

            //Running an Safari/Chrome on iOS or IPadOS in desktop mode provides a Macintosh like user agent.
            //IPadOS 13 change the default for Safari and request the desktop version.
            //"Request Desktop Website -> All websites" (for more infos see: https://forums.developer.apple.com/thread/119186).

            //Example useragent of IOS with Desktop:
            //Safari: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.1 Safari/605.1.15
            //Chrome: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/11.1.1 Safari/605.1.15
            //
            //Example of request for the browser mobile version
            //iPhone: Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Mobile/15E148 Safari/604.1
            //iPad: Mozilla/5.0 (iPad; CPU OS 13_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.4 Mobile/15E148 Safari/604.1

            //Macinthosh (<=July 2020) doesn't have a touchPoints > 1
            //Treat all MacOS with touchPoint as IOs based

            UCF_UserAgent["bIsIOSDesktopBrowser"] = (navigator["maxTouchPoints"] > 1);
            if (UCF_UserAgent["bIsIOSDesktopBrowser"]) {
                UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["IOs"];
            }
        }

        // check if the compatibility mode is used (MSIE8 / MSIE9) when they indentifies themselves as MSIE7/MSIE6
        // http://blogs.msdn.com/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
        // http://blogs.msdn.com/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
        UCF_UserAgent["bIECompatibilityMode"] = false;
        if (UCF_UserAgent["sB"] === UCF_UserAgent["BROWSER"]["MSIE"]) {
            //Trident
            // <IE7 : not defined by MS (using Trident 3.0)
            // IE8: Trident 4.0
            // IE9: Trident 5.0
            // IE10: Trident 6.0
            // IE11: Trident 7.0
            if (!UCF_UserAgent["fUAVersion"]) UCF_UserAgent["fUAVersion"] = 3.0; //Use version 3.0 Trident for IE7 and lower
            UCF_UserAgent["bIECompatibilityMode"] = (UCF_UserAgent["fUAVersion"] >= 4.0) && (UCF_UserAgent["fBVersion"] - UCF_UserAgent["fUAVersion"] < 4.0);
        }

        UCF_UserAgent["bIsTablet"]();
        UCF_UserAgent["bIsPhone"]();
        UCF_UserAgent["bDesktop"] = !UCF_UserAgent["bIsPhone"]() && !UCF_UserAgent["bIsTablet"]();
        UCF_UserAgent["bCombi"] = UCF_UserAgent["bDesktop"] && UCF_UserAgent["bSupportTouch"]();

        if (navigator["userAgentData"] && navigator["userAgentData"]["getHighEntropyValues"]) {
            navigator["userAgentData"]["getHighEntropyValues"]([
                "platform",
                "platformVersion",
                "architecture",
                "model",
                "uaFullVersion"
            ])["then"](function (res) {
                UCF_UserAgent["initChValues"](res);
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["init"] = 0;
    }
    ;

    UCF_UserAgent["initChValues"] = function (oClientHints) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["initChValues"]++;
        }
        ;
        if (oClientHints["platform"]) {
            if (oClientHints["platform"] === 'Windows')
                UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["Windows"];
            else if (oClientHints["platform"] === 'Mac OS X')
                UCF_UserAgent["sOs"] = UCF_UserAgent["PLATFORM"]["MacOs"];
        }
        if (oClientHints["platformVersion"])
            UCF_UserAgent["sOsVersion"] = oClientHints["platformVersion"]["split"]('.')[0];

        if (oClientHints["uaFullVersion"])
            UCF_UserAgent["fBVersion"] =
                parseFloat(oClientHints["uaFullVersion"]["replace"](
                    /(\d*.\d*).*/g,
                    function (match, p1) {
                        return p1;
                    }
                ));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["initChValues"] = 0;
    }
    ;

    /**
     * @protected
     * @static
     * @return {boolean}
     */
    UCF_UserAgent["bSkipIPadOsOverrule"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bSkipIPadOsOverrule"]++;
        }
        ;
        return UCF_StringUtil["bContains"](
            UCF_DomUtil["dataset"](document["getElementsByTagName"]('html')[0])["sapLsSystemFeatureflags"],
            'UserAgent.skipIPadOsOverrule'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bSkipIPadOsOverrule"] = 0;
    }
    ;
    /**
     * Checks is a given version fVersion is greater or equal a check version fCheckVersion
     *
     * @private
     *
     * @param {int} fVersion
     * @param {int} fCheckVersion
     *
     * @return {boolean} true if the fVersion is greater or equal to fCheckVersion otherwise false
     */
    UCF_UserAgent["bVersionCheck"] = function (fVersion, fCheckVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bVersionCheck"]++;
        }
        ;
        if (typeof (fVersion) === "number") {
            return fVersion <= fCheckVersion;
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bVersionCheck"] = 0;
    }
    ;

    /**
     * Checks current useragent is the same as a given sUserAgent and its version is greater or equal to a given version
     *
     * @private
     *
     * @param {string} sUserAgent
     * @param {float} fVersion
     *
     * @return {boolean} true if the useragent and version match otherwise false
     */
    UCF_UserAgent["bIsUserAgent"] = function (sUserAgent, fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsUserAgent"]++;
        }
        ;
        if (UCF_UserAgent["sUA"] === sUserAgent && typeof (fVersion) !== "number") return true;
        return UCF_UserAgent["sUA"] === sUserAgent && UCF_UserAgent["bVersionCheck"](fVersion, UCF_UserAgent["fUAVersion"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsUserAgent"] = 0;
    }
    ;

    /**
     * Checks current browser is the same as a given sBrowser and its version is greater or equal to a given version
     *
     * @private
     *
     * @param {atring} sBrowser
     * @param {float} fVersion
     *
     * @return {boolean} true if the browser and version match otherwise false
     */
    UCF_UserAgent["bIsBrowser"] = function (sBrowser, fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsBrowser"]++;
        }
        ;
        if (UCF_UserAgent["sB"] === sBrowser && typeof (fVersion) !== "number") return true;
        return UCF_UserAgent["sB"] === sBrowser && UCF_UserAgent["bVersionCheck"](fVersion, UCF_UserAgent["fBVersion"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsBrowser"] = 0;
    }
    ;

    /**
     * Checks whether MS Trident runs as user agent
     *
     * @public
     *
     * @param {float} fVersion
     * @param {boolean} bExact
     *
     * @return {boolean} true if Trident runs and its version is higher or the same as the given version. When using exact it only checkt for the given version
     */
    UCF_UserAgent["bIsTrident"] = function (fVersion, bExact) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsTrident"]++;
        }
        ;
        if (bExact) {
            return UCF_UserAgent["bIsUserAgent"](UCF_UserAgent["ENGINE"]["Trident"]) && UCF_UserAgent["fUAVersion"] === fVersion;
        } else {
            return UCF_UserAgent["bIsUserAgent"](UCF_UserAgent["ENGINE"]["Trident"], fVersion);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsTrident"] = 0;
    }
    ;

    /**
     * Checks whether MS EdgeHTML engine runs as user agent
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean}  true if EdgeHTML runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsEdgeHtml"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsEdgeHtml"]++;
        }
        ;
        return UCF_UserAgent["bIsUserAgent"](UCF_UserAgent["ENGINE"]["EdgeHtml"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsEdgeHtml"] = 0;
    }
    ;

    /**
     * Checks if Gecko runs as user agent
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if Gecko runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsGecko"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsGecko"]++;
        }
        ;
        return UCF_UserAgent["bIsUserAgent"](UCF_UserAgent["ENGINE"]["Gecko"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsGecko"] = 0;
    }
    ;

    /**
     * Checks if WebKit runs as user agent
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if WebKit runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsWebKit"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsWebKit"]++;
        }
        ;
        return UCF_UserAgent["bIsUserAgent"](UCF_UserAgent["ENGINE"]["Webkit"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsWebKit"] = 0;
    }
    ;

    /**
     * Checks whether IE runs as browser
     *
     * @public
     *
     * @param {float} fVersion
     * @param {boolean} bExact
     *
     * @return {boolean} true if IE runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsIE"] = function (fVersion, bExact) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsIE"]++;
        }
        ;
        if (bExact) {
            return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["MSIE"], fVersion) && UCF_UserAgent["fBVersion"] === fVersion;
        } else {
            return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["MSIE"], fVersion);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsIE"] = 0;
    }
    ;

    /**
     * Checks whether MS Edge (project Spartan) runs as browser
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if MSEdge runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsMSEdge"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsMSEdge"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["MSEdge"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsMSEdge"] = 0;
    }
    ;

    /**
     * Checks whether Edge@Chrome runs as browser
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if Edge runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsEdge"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsEdge"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Edge"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsEdge"] = 0;
    }
    ;

    /**
     * Checks if Firefox runs as browser
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if WebKit runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsFirefox"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsFirefox"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Firefox"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsFirefox"] = 0;
    }
    ;

    /**
     * Checks if Safari runs as browser
     *
     * @public
     *
     * @param {float} fVersion
     *
     * @return {boolean} true if Safari runs and its version is higher or the same as the given version
     */
    UCF_UserAgent["bIsSafari"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsSafari"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Safari"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsSafari"] = 0;
    }
    ;

    /**
     * Checks if Chrome runs as browser
     *
     * @public
     * @param {float} fVersion
     * @return {boolean} true if Chrome runs and its version is higher or the same as the given versio
     */
    UCF_UserAgent["bIsChrome"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsChrome"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Chrome"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsChrome"] = 0;
    }
    ;

    /**
     * Checks if Chromium (Edge || Chrome) runs as browser
     *
     * @public
     * @param {float} fVersion
     * @return {boolean} true if Chrome runs and its version is higher or the same as the given versio
     */
    UCF_UserAgent["bIsChromium"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsChromium"]++;
        }
        ;
        return (UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Chrome"], fVersion) || UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["Edge"], fVersion));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsChromium"] = 0;
    }
    ;

    /**
     * Checks if PhantomJS runs as browser
     *
     * @public
     * @param {float} fVersion
     * @return {boolean} true if PhantomJS runs and its version is higher or the same as the given versio
     */
    UCF_UserAgent["bIsPhantomJS"] = function (fVersion) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsPhantomJS"]++;
        }
        ;
        return UCF_UserAgent["bIsBrowser"](UCF_UserAgent["BROWSER"]["PhantomJS"], fVersion);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsPhantomJS"] = 0;
    }
    ;

    /**
     * Checks if the OS is Windows
     *
     * @public
     * @return {boolean} true if Windows is running
     */
    UCF_UserAgent["bIsWindows"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsWindows"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["Windows"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsWindows"] = 0;
    }
    ;

    /**
     * Checks if the OS is Linux
     *
     * @public
     *
     * @return {boolean} true if Linux is running
     */
    UCF_UserAgent["bIsLinux"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsLinux"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["Linux"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsLinux"] = 0;
    }
    ;

    /**
     * Checks if the OS is Mac Os
     *
     * @public
     *
     * @return {boolean} true if MacOs is running
     */
    UCF_UserAgent["bIsMacOs"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsMacOs"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["MacOs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsMacOs"] = 0;
    }
    ;

    /**
     * Checks if the OS is iOS
     *
     * @public
     * @return {boolean} true if iOS is running
     */
    UCF_UserAgent["bIsIOS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsIOS"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["IOs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsIOS"] = 0;
    }
    ;

    /**
     * Checks if the OS is Android
     *
     * @public
     * @return {boolean} true if Android is running
     */
    UCF_UserAgent["bIsAndroid"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsAndroid"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["Android"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsAndroid"] = 0;
    }
    ;

    /**
     * Checks if the OS is ChromeOS
     *
     * @public
     * @return {boolean} true if Android is running
     */
    UCF_UserAgent["bIsChromeOS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsChromeOS"]++;
        }
        ;
        return UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["ChromeOs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsChromeOS"] = 0;
    }
    ;

    /**
     * Returns the platform string
     *
     * @private
     *
     * @return {string} the UCFSystem.sPlatfom string
     */
    UCF_UserAgent["sGetPlatform"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetPlatform"]++;
        }
        ;
        return UCF_UserAgent["sOs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetPlatform"] = 0;
    }
    ;

    /**
     * Returns the platform appreviation string
     *
     * @private
     *
     * @return {string} the UCFSystem.sPlatfom string
     */
    UCF_UserAgent["sGetPlatformAppreviation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetPlatformAppreviation"]++;
        }
        ;
        return UCF_UserAgent["PLATFORM_ABBREVIATION"][UCF_UserAgent["sGetPlatform"]()];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetPlatformAppreviation"] = 0;
    }
    ;

    /**
     * Returns the platform version if available otherwise ""
     *
     * @private
     *
     * @return {string} the platform version string
     */
    UCF_UserAgent["sGetPlatformVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetPlatformVersion"]++;
        }
        ;
        return UCF_UserAgent["sOsVersion"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetPlatformVersion"] = 0;
    }
    ;

    /**
     * The user agent name
     *
     * @private
     *
     * @return {string} the user agent name like used in UCF_System
     */
    UCF_UserAgent["sGetUserAgentName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetUserAgentName"]++;
        }
        ;
        return UCF_UserAgent["sUA"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetUserAgentName"] = 0;
    }
    ;

    /**
     * Provides the browser name
     *
     * @private
     *
     * @return {string} the browser name
     */
    UCF_UserAgent["sGetBrowserName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetBrowserName"]++;
        }
        ;
        return UCF_UserAgent["sB"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetBrowserName"] = 0;
    }
    ;

    /**
     * Provides the browser name apprviation
     *
     * @private
     *
     * @return {string} the browser name
     */
    UCF_UserAgent["sGetBrowserNameAppreviation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["sGetBrowserNameAppreviation"]++;
        }
        ;
        return UCF_UserAgent["BROWSER_ABBREVIATION"][UCF_UserAgent["sGetBrowserName"]()];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["sGetBrowserNameAppreviation"] = 0;
    }
    ;

    /**
     * Provides the browser version
     *
     * @private
     *
     * @return {float} the browser version
     */
    UCF_UserAgent["iGetBrowserVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["iGetBrowserVersion"]++;
        }
        ;
        return UCF_UserAgent["fBVersion"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["iGetBrowserVersion"] = 0;
    }
    ;

    /**
     * Checks if the Internet Explorer is running in compatibility mode
     *
     * @public
     *
     * @return {boolean} true if MacOs is running
     */
    UCF_UserAgent["bIsIECompatibilityMode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsIECompatibilityMode"]++;
        }
        ;
        return UCF_UserAgent["bIsIE"]() && UCF_UserAgent["bIECompatibilityMode"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsIECompatibilityMode"] = 0;
    }
    ;

    /**
     * Checks if the browser needs to render in the standard rendering mode
     *
     * @private
     *
     * @return {boolean} true if the standard mode rendering must be used
     */
    UCF_UserAgent["bIsStandardsMode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsStandardsMode"]++;
        }
        ;
        return document["compatMode"] === "CSS1Compat";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsStandardsMode"] = 0;
    }
    ;

    /**
     * Checks if the browser runs in QME
     *
     * @private
     *
     * @return {boolean} true
     */
    UCF_UserAgent["bIsQME"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsQME"]++;
        }
        ;
        return UCF_UserAgent["bIsIE"]() && parseInt(document["documentMode"]) >= 9 && document["compatMode"]["indexOf"]("BackCompat") !== -1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsQME"] = 0;
    }
    ;

    /**
     * Returns whether the browser runs on a tablet device
     *
     * @private
     * @param {string} sUserAgent Given useragent otherwise use navigator.userAgent
     *
     * @return {boolean} true if the browser runs on a tablet
     */
    UCF_UserAgent["bIsTablet"] = function (sUserAgent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsTablet"]++;
        }
        ;

        if (!sUserAgent) sUserAgent = navigator["userAgent"];

        if (UCF_UserAgent["bTablet"] === null) {
            UCF_UserAgent["bTablet"] = false;

            try {
                //old test: UCF_UserAgent.bTablet = sUserAgent.indexOf("iPad") > -1 || (/(?=android)(?=.*mobile)/i.test(sUserAgent) && (Math.max(window.screen.width / window.devicePixelRatio, window.screen.height / window.devicePixelRatio) >= 600)) && UCF_UserAgent.bSupportTouch();

                if (UCF_UserAgent["bIsIOS"]()) {
                    //treat browser on IOS running in tablet mode as tablet
                    //ToDo: report IOS browser running on a IPhone as desktop browser correctly as phone
                    return UCF_UserAgent["bTablet"] = (/ipad/i["test"](sUserAgent) || UCF_UserAgent["bIsIOSDesktopBrowser"]);

                }

                if (UCF_UserAgent["bSupportTouch"]()) {

                    if (UCF_UserAgent["bIsWindows"]() || UCF_UserAgent["bIsChromeOS"]() || UCF_UserAgent["bIsMacOs"]()) {
                        //do not treat any Winodws >8.1 devices as tablet but desktop
                        //do not treat any ChromeOS devices as tablet but desktop

                        // With IPadiOS 13 the string 'iPad' was removed from the user agent string through a browser setting, which is applied on all sites by default:
                        // "Request Desktop Website -> All websites" (for more infos see: https://forums.developer.apple.com/thread/119186).
                        // Therefore the OS is detected as MACINTOSH instead of iOS --> do not treat it as tablet
                        return UCF_UserAgent["bTablet"] = false;
                    }

                    if (UCF_UserAgent["bIsChromium"]() && UCF_UserAgent["bIsAndroid"]() && UCF_UserAgent["sGetPlatformVersion"]() >= 4.4) {
                        // From Android version 4.4, WebView also uses Chrome as Kernel.
                        // We can use the user agent pattern defined in Chrome to do phone/tablet detection
                        // According to the information here: https://developer.chrome.com/multidevice/user-agent#chrome_for_android_user_agent,
                        //the existence of "Mobile" indicates it's a phone. But because the crosswalk framework which is used in Fiori Client
                        //inserts another "Mobile" to the user agent for both tablet and phone, we need to check whether "Mobile Safari/<Webkit Rev>" exists.
                        return UCF_UserAgent["bTablet"] = !/Mobile Safari\/[.0-9]+/["test"](sUserAgent);
                    }

                    var densityFactor = window["devicePixelRatio"] ? window["devicePixelRatio"] : 1; // may be undefined in Windows Phone devices

                    // On Android sometimes window.screen.width returns the logical CSS pixels, sometimes the physical device pixels;
                    // Tests on multiple devices suggest this depends on the Webkit version.
                    // The Webkit patch which changed the behavior was done here: https://bugs.webkit.org/show_bug.cgi?id=106460
                    // Chrome 27 with Webkit 537.36 returns the logical pixels,
                    // Chrome 18 with Webkit 535.19 returns the physical pixels.
                    // The BlackBerry 10 browser with Webkit 537.10+ returns the physical pixels.
                    // So it appears like somewhere above Webkit 537.10 we do not hve to divide by the devicePixelRatio anymore.
                    if (UCF_UserAgent["bIsAndroid"]() && UCF_UserAgent["bIsWebKit"](537.11)) {
                        densityFactor = 1;
                    }

                    UCF_UserAgent["bTablet"] = (Math["min"](window["screen"]["width"] / densityFactor, window["screen"]["height"] / densityFactor) >= 600);

                    // special workaround for Nexus 7 where the window.screen.width is 600px or 601px in portrait mode (=> tablet)
                    // but window.screen.height 552px in landscape mode (=> phone), because the browser UI takes some space on top.
                    // So the detected device type depends on the orientation :-(
                    // actually this is a Chrome bug, as "width"/"height" should return the entire screen's dimensions and
                    // "availWidth"/"availHeight" should return the size available after subtracting the browser UI
                    if (UCF_UserAgent["bIsLandscape"]()
                        && (window["screen"]["height"] === 552 || window["screen"]["height"] === 553) // old/new Nexus 7
                        && (/Nexus 7/i["test"](sUserAgent))) {
                        UCF_UserAgent["bTablet"] = true;
                    }
                    return UCF_UserAgent["bTablet"];

                } else {
                    // This simple android phone detection can be used here because this is the mobile emulation mode in desktop browser
                    var android_phone = (/(?=android)(?=.*mobile)/i["test"](sUserAgent));
                    // in desktop browser, it's detected as tablet when
                    // UR decided a Windows 8 device is never a Tablet - UI5 does
                    // (1. Windows 8 device with a touch screen where "Touch" is contained in the userAgent)
                    // 2. Android emulation and it's not an Android phone
                    return UCF_UserAgent["bTablet"] = (UCF_UserAgent["bIsAndroid"]() && !android_phone); // || UI5 (UCF_UserAgent.bIsIE() && sUserAgent.indexOf("Touch") !== -1);
                }

            } catch (ex) {
                UCF_UserAgent["bTablet"] = false;
            }
        }

        return UCF_UserAgent["bTablet"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsTablet"] = 0;
    }
    ;

    /**
     * Returns whether the browser runs on a phone device
     *
     * @private
     * @param {string} sUserAgent Given useragent otherwise use navigator.userAgent
     *
     * @return {boolean} true if the browser runs on a phone
     */
    UCF_UserAgent["bIsPhone"] = function (sUserAgent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsPhone"]++;
        }
        ;

        if (!sUserAgent) sUserAgent = navigator["userAgent"];

        if (UCF_UserAgent["bPhone"] === null) {
            UCF_UserAgent["bPhone"] = false;

            try {
                //old test: UCF_UserAgent.bPhone = /iphone/i.test(sUserAgent) || (/(?=android)(?=.*mobile)/i.test(sUserAgent) && (Math.max(window.screen.width / window.devicePixelRatio, window.screen.height / window.devicePixelRatio) < 600)) && UCF_UserAgent.bSupportTouch();

                if (UCF_UserAgent["bIsIOS"]()) {
                    return UCF_UserAgent["bPhone"] = /iphone/i["test"](sUserAgent);
                    //ToDo: report IOS browser running as desktop browser correctly as phone
                }

                if (UCF_UserAgent["sOs"] === UCF_UserAgent["PLATFORM"]["WindowsPhone"]) {
                    return UCF_UserAgent["bPhone"] = true;
                } else if (UCF_UserAgent["bIsWindows"]() || UCF_UserAgent["bIsChromeOS"]() || UCF_UserAgent["bIsMacOs"]()) {
                    //do not treat any Winodws >8.1 devices as phone or tablet
                    //do not treat any ChromeOS devices as phone or tablet but desktop/combi
                    return UCF_UserAgent["bPhone"] = false;
                }

                //UI5 treats all devices with (UCF_UserAgent.bSupportTouch() && !UCF_UserAgent.bIsTablet()) as phone - we test explicitly for Linux
                if (UCF_UserAgent["bSupportTouch"]() && !UCF_UserAgent["bIsLinux"]() && !UCF_UserAgent["bIsTablet"]()) {
                    return UCF_UserAgent["bPhone"] = true;
                } else {
                    return UCF_UserAgent["bPhone"] = false;
                }

                /* if we would decided to explicitly test on PHone this would be the starting point

			if (UCF_UserAgent.bSupportTouch()) {

				if (UCF_UserAgent.bIsChromium() && UCF_UserAgent.bIsAndroid() && UCF_UserAgent.sGetPlatformVersion() >= 4.4) {
					// From Android version 4.4, WebView also uses Chrome as Kernel.
					// We can use the user agent pattern defined in Chrome to do phone/tablet detection
					// According to the information here: https://developer.chrome.com/multidevice/user-agent#chrome_for_android_user_agent,
					//the existence of "Mobile" indicates it's a phone. But because the crosswalk framework which is used in Fiori Client
					//inserts another "Mobile" to the user agent for both tablet and phone, we need to check whether "Mobile Safari/<Webkit Rev>" exists.
					return UCF_UserAgent.bPhone = /Mobile Safari\/[.0-9]+/.test(sUserAgent);
				}

				var densityFactor = window.devicePixelRatio ? window.devicePixelRatio : 1; // may be undefined in Windows Phone devices

				// On Android sometimes window.screen.width returns the logical CSS pixels, sometimes the physical device pixels;
				// Tests on multiple devices suggest this depends on the Webkit version.
				// The Webkit patch which changed the behavior was done here: https://bugs.webkit.org/show_bug.cgi?id=106460
				// Chrome 27 with Webkit 537.36 returns the logical pixels,
				// Chrome 18 with Webkit 535.19 returns the physical pixels.
				// The BlackBerry 10 browser with Webkit 537.10+ returns the physical pixels.
				// So it appears like somewhere above Webkit 537.10 we do not hve to divide by the devicePixelRatio anymore.
				if (UCF_UserAgent.bIsAndroid() && UCF_UserAgent.bIsWebKit(537.11)) {
					densityFactor = 1;
				}

				UCF_UserAgent.bPhone = (Math.max(window.screen.width / densityFactor, window.screen.height / densityFactor) < 600);

				// special workaround for Nexus 7 where the window.screen.width is 600px or 601px in portrait mode (=> tablet)
				// but window.screen.height 552px in landscape mode (=> phone), because the browser UI takes some space on top.
				// So the detected device type depends on the orientation :-(
				// actually this is a Chrome bug, as "width"/"height" should return the entire screen's dimensions and
				// "availWidth"/"availHeight" should return the size available after subtracting the browser UI
				if (UCF_UserAgent.bIsLandscape()
					&& (window.screen.height === 552 || window.screen.height === 553) // old/new Nexus 7
					&& (/Nexus 7/i.test(sUserAgent))) {
					UCF_UserAgent.bPhone = false;
				}
				return UCF_UserAgent.bPhone;
			}
			*/

            } catch (ex) {
                UCF_UserAgent["bPhone"] = false;
            }
        }

        return UCF_UserAgent["bPhone"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsPhone"] = 0;
    }
    ;

    /**
     * Returns whether the browser runs on a combi device
     * which is a desktop device with detected touch device
     *
     * @private
     *
     * @return {boolean} true if the browser runs on a combi device
     */
    UCF_UserAgent["bIsCombi"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsCombi"]++;
        }
        ;
        return UCF_UserAgent["bCombi"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsCombi"] = 0;
    }
    ;

    /**
     * Returns whether the browser runs on a desktop device without detected touch screen
     *
     * @private
     *
     * @return {boolean} true if the browser runs on a desktop
     */
    UCF_UserAgent["bIsDesktop"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsDesktop"]++;
        }
        ;
        return UCF_UserAgent["bDesktop"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsDesktop"] = 0;
    }
    ;

    /**
     * Returns whether the device supports touch
     *
     * @private
     *
     * @return {boolean} true if the device supports touch
     */
    UCF_UserAgent["bSupportTouch"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bSupportTouch"]++;
        }
        ;
        if (UCF_UserAgent["bTouchSupport"] === null) {
            try {
                UCF_UserAgent["bTouchSupport"] = !!(('ontouchstart' in window) || (navigator["maxTouchPoints"] > 0) || window["DocumentTouch"] && document instanceof window["DocumentTouch"]);

                if (UCF_UserAgent["bIsPhantomJS"]()) {
                    UCF_UserAgent["bTouchSupport"] = false;
                }
            } catch (ex) {
                UCF_UserAgent["bTouchSupport"] = false;
            }
        }

        return UCF_UserAgent["bTouchSupport"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bSupportTouch"] = 0;
    }
    ;

    /**
     * Gets the Device type
     *
     * Possible Device Types and mapping to integer according FESR documentation
     * 0 --> The device is not recognized.
     * 1 --> The device is recognized as a combination of a desktop system and tablet (combi)
     * 2 --> The device is recognized as a desktop system.
     * 3 --> The device is recognized as a phone.
     * 4 --> The device is recognized as a tablet.
     *
     * @private
     * @return {number} the device type
     */
    UCF_UserAgent["iGetDeviceType"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["iGetDeviceType"]++;
        }
        ;
        if (UCF_UserAgent["bIsCombi"]()) {
            //if device is combi && desktop --> return combi
            return UCF_UserAgent["DEVICETYPE"]["Combi"];
        } else if (UCF_UserAgent["bIsDesktop"]()) {
            return UCF_UserAgent["DEVICETYPE"]["Desktop"];
        } else if (UCF_UserAgent["bIsPhone"]()) {
            return UCF_UserAgent["DEVICETYPE"]["Phone"];
        } else if (UCF_UserAgent["bIsTablet"]()) {
            return UCF_UserAgent["DEVICETYPE"]["Tablet"];
        }
        return UCF_UserAgent["DEVICETYPE"]["Unknwon"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["iGetDeviceType"] = 0;
    }
    ;

    /**
     * Whether the screen is in Landscape or Portrat mode for phone/tablets
     *
     * @public
     * @return { boolean } whether is landscape (true) or in portrait mode (false)
     */
    UCF_UserAgent["bIsLandscape"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bIsLandscape"]++;
        }
        ;
        return UCF_DomUtil["sScreenOrientation"]() === "landscape";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bIsLandscape"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_UserAgent_ResponsiveBreakpoint} eResponsiveBreakpoint
     * @param {UCF_LS} [oLS]
     * @return {boolean}
     */
    UCF_UserAgent["bMatchesResponsiveBreakpoint"] = function (eResponsiveBreakpoint, oLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["bMatchesResponsiveBreakpoint"]++;
        }
        ;
        /** @type {UCF_UserAgent_ResponsiveBreakpoint} */
        var iMin = eResponsiveBreakpoint;
        /** @type {UCF_UserAgent_ResponsiveBreakpoint} */
        var iMax = UCF_JsUtil["reduce"](
            UCF_JsUtil["values"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]),
            function (iCurrent, iResponsiveBreakpoint) {
                return iResponsiveBreakpoint > eResponsiveBreakpoint
                    ? Math["min"](iCurrent, iResponsiveBreakpoint)
                    : iCurrent;
            },
            /*2^32 - 1 = */
            4294967295 // eslint-disable-line no-magic-numbers
        );
        /** @type {number} */
        var iWidth;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["contains"](UCF_JsUtil["values"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]), eResponsiveBreakpoint), "UCF_JsUtil.contains(UCF_JsUtil.values(UCF_UserAgent.RESPONSIVE_BREAKPOINT), eResponsiveBreakpoint)", "UserAgent.js(1055): bMatchesResponsiveBreakpoint");
        }
        ;

        if (__UCF_IE6__) {
            if (oLS) {
                iWidth = (oLS["oGetVisualViewport"](0) || {"width": 0})["width"];

                return iMin <= iWidth && iWidth < iMax;
            } else {
                return false;
            }
        } else {
            return window["matchMedia"](
                '(min-width: ' + iMin + 'px) and (max-width: ' + iMax + 'px)'
            )["matches"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["bMatchesResponsiveBreakpoint"] = 0;
    }
    ;

    /**
     * @param {Element} oRef
     * @param {number} iWidthPx
     */
    UCF_UserAgent["setResponsiveBreakpointScope"] = function (oRef, iWidthPx) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_UserAgent["_"]["setResponsiveBreakpointScope"]++;
        }
        ;
        // removes all resonsive breakpoint classes from oRef
        UCF_DomUtil["removeClass"](oRef, UCF_JsUtil["map"](
            UCF_JsUtil["keys"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]),
            function (sRB) {
                return 'lsScope--' + sRB["toLowerCase"]();
            }
        )["join"](' '));
        // adds the class of the largest smaller responsive breakpoint to oRef
        UCF_DomUtil["addClass"](oRef, 'lsScope--' + UCF_JsUtil["reduce"](
            UCF_JsUtil["filter"](
                UCF_JsUtil["entries"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]),
                function (aEntry) {
                    return aEntry[1] <= iWidthPx;
                }
            ),
            function (aLargest, aEntry) {
                return aEntry[1] > aLargest[1] ? aEntry : aLargest;
            },
            ['NaN', Number["NEGATIVE_INFINITY"]]
        )[0]["toLowerCase"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_UserAgent["_"]["setResponsiveBreakpointScope"] = 0;
    }
    ;

    UCF_UserAgent["init"]();

    UCF_UserAgent.prototype["aPublicMethods"] = ["bIsTrident", "bIsEdgeHtml", "bIsGecko", "bIsWebKit", "bIsIE", "bIsMSEdge", "bIsEdge", "bIsFirefox", "bIsSafari", "bIsChrome", "bIsChromium", "bIsPhantomJS", "bIsWindows", "bIsLinux", "bIsMacOs", "bIsIOS", "bIsAndroid", "bIsChromeOS", "bIsIECompatibilityMode", "bIsLandscape"].concat(UCF_UserAgent.prototype.aPublicMethods || []);
    /* global UCF_System */
/// <reference path="../../ls/core/System.js"/>
    /* global _trace, DEBUG, ERROR */
/// <reference path="../debug/Tracer.js"/>
    /* global UCF_Object */
/// <reference path="../Object.js"/>
    /* global UCF_DomUtil */
/// <reference path="./DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="./JsUtil.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="../../ls/core/ResourceUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="./RequestUtil.js"/>
    /* global UCF_StringUtil */

/// <reference path="./StringUtil.js"/>

    /**
     * Shows or hides an version info pane
     *
     *
     * @version
     * @class
     * @public
     */
    function UCF_VersionInfo() {
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["UCF_VersionInfo"]++;
        }
        ;
        UCF_Object["apply"](this);
        this["bRunning"] = false;
    };window["UCF_VersionInfo"] = UCF_VersionInfo;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_VersionInfo");
        UCF_VersionInfo["_"] = {UCF_VersionInfo: 0};
    }
    ;
    ;
    UCF_VersionInfo["prototype"] = new UCF_Object();
    UCF_VersionInfo.prototype["sClassName"] = "UCF_VersionInfo";

    /**
     * Destructor
     */
    UCF_VersionInfo["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["destroy"]++;
        }
        ;
        this["oDiv"] = null;
        this["selectionHandler"] = null;
        this["clickHandler"] = null;
        this["eventForwarder"] = null;
        this["sOut"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["destroy"] = 0;
    }
    ;

    /**
     * Trigger method which is called by the debug handler when shortcut is pressed
     * @private
     */
    UCF_VersionInfo["prototype"]["trigger"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["trigger"]++;
        }
        ;
        // Toggle display on and off
        if (!this["bRunning"]) {
            this["start"]();
        } else {
            this["stop"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["trigger"] = 0;
    }
    ;

    /**
     * shows the info pane
     * @private
     */
    UCF_VersionInfo["prototype"]["start"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["start"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, "Show Version Info", "VersionInfo.js(63): selectionHandler");
        }
        ;
        var oDoc = UCF_DomUtil["oGetDocument"]();

        var oDiv = oDoc["createElement"]("div");

        oDiv["style"]["position"] = "absolute";
        oDiv["style"]["left"] = "10px";
        oDiv["style"]["height"] = "125px";
        oDiv["style"]["backgroundColor"] = "#FF7";
        oDiv["style"]["border"] = "1px solid #888";
        oDiv["style"]["margin"] = "3px";
        oDiv["style"]["padding"] = "2px";
        oDiv["style"]["overflow"] = "auto";
        oDiv["style"]["fontSize"] = "0.7em";
        oDiv["style"]["zIndex"] = 9999;
        oDiv["style"]["lineHeight"] = "1.2em";

        UCF_DomUtil["setOpacityStyle"](oDiv, 80);
        // eslint-disable-next-line no-unsanitized/property
        oDiv["innerHTML"] = this["sGetText"]();
        oDoc["body"]["appendChild"](oDiv);
        var oHelper = this;
        this["sOut"] = oDiv["innerText"];
        this["oDiv"] = oDiv;

        this["selectionHandler"] = function () {
            return false;
        };
        this["clickHandler"] = function () {
            if (navigator["clipboard"]) {
                navigator["clipboard"]["writeText"](oHelper["sOut"])["then"](function () {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Copying to clipboard was successful!', "VersionInfo.js(94): clickHandler");
                    }
                    ;
                }, function (err) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Could not copy to clipboard: ', "VersionInfo.js(96): clickHandler", err);
                    }
                    ;
                });
            } else if (window["clipboardData"] && window["clipboardData"]["setData"]) {
                window["clipboardData"]["setData"]("Text", oHelper["sOut"]);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, ' Try document.execCommand ', "VersionInfo.js(101): clickHandler");
                }
                ;
                var textArea = document["createElement"]("textarea");
                textArea["value"] = oHelper["sOut"];
                textArea["style"]["position"] = "fixed"; //avoid scrolling to bottom
                document["body"]["appendChild"](textArea);
                textArea["focus"]();
                textArea["select"]();

                try {
                    document["execCommand"]('copy');
                } catch (err) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, '	Was not possible to copy te text: ', "VersionInfo.js(112): clickHandler", err);
                    }
                    ;
                }

                document["body"]["removeChild"](textArea);
            }
            return false;
        };

        this["eventForwarder"] = function () {
            oHelper["onScrollOrResize"]();
        };

        UCF_DomUtil["attachEvent"](oDiv, "click", this["clickHandler"]);
        UCF_DomUtil["attachEvent"](oDiv, "selectstart", this["selectionHandler"]);
        UCF_DomUtil["attachEvent"](window, "scroll", this["eventForwarder"]);
        UCF_DomUtil["attachEvent"](window, "resize", this["eventForwarder"]);

        this["updatePanePosition"]();
        this["bRunning"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["start"] = 0;
    }
    ;

    /** hides the info pane
     * @private
     */
    UCF_VersionInfo["prototype"]["stop"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["stop"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, "Hide Size Info", "VersionInfo.js(137): stop");
        }
        ;
        this["bRunning"] = false;
        var oDoc = UCF_DomUtil["oGetDocument"]();
        oDoc["body"]["removeChild"](this["oDiv"]);
        UCF_DomUtil["detachEvent"](window, "scroll", this["eventForwarder"]);
        UCF_DomUtil["detachEvent"](window, "resize", this["eventForwarder"]);
        UCF_DomUtil["detachEvent"](this["oDiv"], "selectstart", this["selectionHandler"]);
        UCF_DomUtil["detachEvent"](this["oDiv"], "click", this["clickHandler"]);
        this["oDiv"] = null;

        this["mTexts"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["stop"] = 0;
    }
    ;

    /**
     * Scroll event handler
     * @private
     */
    UCF_VersionInfo["prototype"]["onScrollOrResize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["onScrollOrResize"]++;
        }
        ;

        this["updatePanePosition"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["onScrollOrResize"] = 0;
    }
    ;

    /**
     * Update the position of the info pane on the screen
     * @private
     */
    UCF_VersionInfo["prototype"]["updatePanePosition"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["updatePanePosition"]++;
        }
        ;
        this["oDiv"]["style"]["top"] = UCF_DomUtil["iClientHeight"]() - this["oDiv"]["offsetHeight"] - 6 + UCF_DomUtil["oGetScrollOffset"]()["y"] + "px";
        this["oDiv"]["style"]["width"] = UCF_DomUtil["iClientWidth"]() - 20 + "px";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["updatePanePosition"] = 0;
    }
    ;
    /**
     * Returns a map with the plain texts loaded from the properties
     * @return {map} a map with the plain texts loaded from the properties
     * @private
     */
    UCF_VersionInfo["prototype"]["mGetPlainTexts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["mGetPlainTexts"]++;
        }
        ;
        this["mTexts"] = {};
        this["loadTexts"]();
        return this["mTexts"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["mGetPlainTexts"] = 0;
    }
    ;

    /**
     * Returns the Sting containing all debug information
     * @return {string} HTML string containing all debug information
     * @private
     */
    UCF_VersionInfo["prototype"]["sGetText"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["sGetText"]++;
        }
        ;
        var entry;
        var s = [];

        this["mTexts"] = {};
        this["loadTexts"]();
        s["push"]("<b>SAP Unified Rendering Lightspeed Version Information:</b> <br/>");
        for (entry in this["mTexts"]) {
            s["push"](entry + "\t=\t" + this["mTexts"][entry] + "<br/>");
        }

        s["push"]("<br/><br/><b>System settings:</b> <br/>");
        for (entry in window["UCF_System"]) {
            var v = window["UCF_System"][entry];
            if (typeof v === 'boolean' || typeof v === 'string' || typeof v === 'number') {
                s["push"](entry + "\t=\t" + v + "<br/>");
            }
        }

        return s["join"]("");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["sGetText"] = 0;
    }
    ;

    /**
     * Loads texts locally or from a property file on the server and adds a js mat to access them on the client
     * @private
     */
    UCF_VersionInfo["prototype"]["loadTexts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadTexts"]++;
        }
        ;
        this["loadTextsLocal"]("Lightspeed");
        this["loadTextsLocal"]("UICore");

        this["loadURL"](window["UCF_System"]["sExternalThemeRoot"] + "/../version.properties", "External Theme:");

        this["loadThemingMode"]("Theming Mode");
        this["loadThemingMetaData"]("Theming Meta Data");
        this["loadThemingBaseContent"]("Theming Base Content");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadTexts"] = 0;
    }
    ;

    /**
     * Loads theming mode and copies it to the internal string map
     * @private
     * @param {string} sProject
     */
    UCF_VersionInfo["prototype"]["loadThemingMode"] = function (sProject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadThemingMode"]++;
        }
        ;
        this["mTexts"][sProject + ":METHOD"] = "UCF_ResourceUtil.fGetThemingVersion";

        var sVersion = UCF_ResourceUtil["fGetThemingVersion"]();
        for (var sMode in UCF_ResourceUtil["VERSION"])
            if (UCF_ResourceUtil["VERSION"][sMode] === sVersion)
                return this["mTexts"][sProject + ":Name"] = sMode;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadThemingMode"] = 0;
    }
    ;

    /**
     * Loads theming meta data via UCF_ResourceUtil.oExtractCssMetaData() and copies it to the internal string map
     * @private
     * @param {string} sProject
     */
    UCF_VersionInfo["prototype"]["loadThemingMetaData"] = function (sProject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadThemingMetaData"]++;
        }
        ;
        if (UCF_ResourceUtil["fGetThemingVersion"]() !== UCF_ResourceUtil["VERSION"]["Repository"])
            return this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":INFO")] = "Theming meta data is only available for theming mode \"Repository\"";

        this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":METHOD")] = "UCF_ResourceUtil.oExtractCssMetaData";

        var oCssMetaData = UCF_ResourceUtil["oExtractCssMetaData"]();
        if (!oCssMetaData)
            return this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":ERROR")] = "Theming meta data not found or not accessible from browser";

        for (var sProperty in oCssMetaData) {
            if (typeof oCssMetaData[sProperty] === "string") {
                this["mTexts"][sProject + ":" + sProperty] = oCssMetaData[sProperty];
            } else if (UCF_JsUtil["bIsArray"](oCssMetaData[sProperty])) {
                this["mTexts"][sProject + ":" + sProperty] = oCssMetaData[sProperty]["join"](", ");
            } else if (typeof oCssMetaData[sProperty] === "object") {
                for (var sSubProperty in oCssMetaData[sProperty]) {
                    if (typeof oCssMetaData[sProperty][sSubProperty] === "string")
                        this["mTexts"][sProject + ":" + sProperty + "." + sSubProperty] = oCssMetaData[sProperty][sSubProperty];
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadThemingMetaData"] = 0;
    }
    ;

    /**
     * Loads theming base content meta data and copies parts of it to the internal string map
     * @private
     * @param {string} sProject
     */
    UCF_VersionInfo["prototype"]["loadThemingBaseContent"] = function (sProject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadThemingBaseContent"]++;
        }
        ;
        if (UCF_ResourceUtil["fGetThemingVersion"]() !== UCF_ResourceUtil["VERSION"]["Repository"])
            return this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":INFO")] = "Theming base content is only available for theming mode \"Repository\"";

        var sURL = window["UCF_System"]["sThemeRepositoryURL"] + '/Base/.theming' + "?" + (window["UCF_System"]["sClientVersionKey"] || '');
        this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":URL")] = sURL;

        var oResponse = UCF_RequestUtil["sendSyncRequest"](sURL, null, null, null, true); // bSuppressErrorMessage!
        if (oResponse && oResponse["bSuccess"]) {
            var oDotTheming = UCF_JsUtil["oJsonParse"](oResponse["sText"]);
            this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":sVersion")] = oDotTheming["sVersion"];
        } else {
            this["mTexts"][UCF_StringUtil["sTrim"](sProject + ":ERROR")] = "Base content version not found or not accessible from browser";
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadThemingBaseContent"] = 0;
    }
    ;

    /**
     * Loads texts locally, i.e., from UCF_VersionInfo.mVersionProperties
     * @private
     * @param {string} sProperty
     */
    UCF_VersionInfo["prototype"]["loadTextsLocal"] = function (sProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadTextsLocal"]++;
        }
        ;
        this["mTexts"][UCF_StringUtil["sTrim"](sProperty + ":PROPERTIES")] = "UCF_VersionInfo.mVersionProperties.m" + sProperty;
        for (var i in UCF_VersionInfo["mVersionProperties"]["m" + sProperty])
            this["mTexts"][sProperty + ":" + i] = UCF_VersionInfo["mVersionProperties"]["m" + sProperty][i];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadTextsLocal"] = 0;
    }
    ;

    /**
     * Loads URL and copy it to the internal string map
     * @private
     * @param {string} sBaseUrl
     * @param {string} sProject
     */
    UCF_VersionInfo["prototype"]["loadURL"] = function (sBaseUrl, sProject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_VersionInfo["_"]["loadURL"]++;
        }
        ;
        var sVersion = window["UCF_System"]["sClientVersionKey"],
            oResponse = {"bSuccess": false};

        if (!window["UCF_System"]["bUseXHR"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "Version Info is is loaded over XHR while XHR is deactivated.", "VersionInfo.js(306): loadURL");
            }
            ;
        }

        var sURL = sBaseUrl + (sVersion !== "" ? ("?" + sVersion) : "");
        oResponse = UCF_RequestUtil["sendSyncRequest"](sURL);

        if (oResponse["bSuccess"]) {
            var aLines = oResponse["sText"]["split"]("\n");
            this["mTexts"][UCF_StringUtil["sTrim"](sProject + "URL")] = sURL;

            for (var i = 0; i < aLines["length"]; i++) {
                if (aLines[i]["indexOf"]("#") === 0) continue;
                var iSeperatorPos = aLines[i]["indexOf"]("="),
                    sKey = UCF_StringUtil["sTrim"](aLines[i]["substring"](0, iSeperatorPos)["replace"](/"/g, "")),
                    sValue = aLines[i]["substring"](iSeperatorPos + 1)["replace"](/^\s+|\s+$/, '');
                sValue = sValue["replace"](/"/g, '\\\"');
                sValue = UCF_StringUtil["sTrim"](sValue);
                try {
                    sValue = UCF_JsUtil["oJsonParse"]('"' + sValue + '"');
                } catch (e) {
                    sValue = '';
                }
                if (sValue !== "") {
                    this["mTexts"][sProject + sKey] = sValue;
                }
            }
        } else {
            this["mTexts"][sProject + "URL"] = "404 - Resource \"" + sURL + "\" not found or not accessible from browser";
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_VersionInfo["_"]["loadURL"] = 0;
    }
    ;

    /**
     *  To be filled at compile time with values from js/dbg/version.properties and js/dbg/uicore/version.properties
     *  @public
     */
    UCF_VersionInfo["mVersionProperties"] = {
        "mLightspeed": {
            "urreleaseversion": "2102",
            "urrelease": "UnifiedR_03_REL",
            "urproject": "lightspeed",
            "urchangelist": "331831",
            "urtimestamp": "202102211111",
            "urimplementationversion": "03.000.20210219202242.0000",
            "codeline": "$File: //tc1/lightspeed/UnifiedR_03_REL/src/_version/version/version.properties $",
            "uicoreproject": "uicore",
            "uicoreversion": "10.30.7.331835.0",
            "uicorechangelist": "331835",
            "uicoretimestamp": "202102211019",
            "uicoreimplementationversion": "03.000.20210219202242.0000"
        },
        "mUICore": {
            "urversion": "10.30.7.331835.0",
            "urrelease": "UnifiedR_03_REL",
            "urchangelist": "331835",
            "urtimestamp": "202102211019",
            "urimplementationversion": "03.000.20210219202242.0000",
            "urproject": "uicore",
            "codeline": "$File: //tc1/uicore/UnifiedR_03_REL/src/_version/version/version.properties $"
        }
    };

    UCF_VersionInfo.prototype["aPublicMethods"] = ["UCF_VersionInfo"].concat(UCF_VersionInfo.prototype.aPublicMethods || []);

    /**
     * XSS Prevention Encoding Functions
     * This class provides static methods for encoding of strings.
     * Encoding according to the Secure Programming Guide
     * https://wiki.wdf.sap.corp/wiki/display/NWCUIAMSIM/XSS+Secure+Programming+Guide
     *
     * @class
     *
     *
     * @version
     */
    function UCF_XSSEncoder() {
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["UCF_XSSEncoder"]++;
        }
        ;
    };window["UCF_XSSEncoder"] = UCF_XSSEncoder;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_XSSEncoder");
        UCF_XSSEncoder["_"] = {UCF_XSSEncoder: 0};
    }
    ;
    ;

    /**
     * Create hex and pad to length
     * @private
     * @param {Integer} iChar the character
     * @param {Integer} iLength the length
     * @return {string}
     */
    UCF_XSSEncoder["hex"] = function (iChar, iLength) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["hex"]++;
        }
        ;
        var sHex = iChar["toString"](16);
        if (iLength) {
            while (iLength > sHex["length"]) {
                sHex = "0" + sHex;
            }
        }
        return sHex;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["hex"] = 0;
    }
    ;

    /**
     * RegExp and escape function for HTML escaping
     */
    UCF_XSSEncoder["rHtml"] = /[\x00-\x08\x11\x12\x14-\x2b\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\xff\u2028\u2029]/g;
    UCF_XSSEncoder["rHtmlReplace"] = /[\x00-\x08\x11\x12\x14-\x1f\x7f-\x9f]/;
    UCF_XSSEncoder["mHtmlLookup"] = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "\"": "&quot;"
    };
    UCF_XSSEncoder["fHtml"] = function (sChar) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["fHtml"]++;
        }
        ;
        var sEscaped = UCF_XSSEncoder["mHtmlLookup"][sChar];
        if (!sEscaped) {
            if (UCF_XSSEncoder["rHtmlReplace"]["test"](sChar)) {
                sEscaped = "&#xfffd;";
            } else {
                sEscaped = "&#x" + UCF_XSSEncoder["hex"](sChar["charCodeAt"](0)) + ";";
            }
            UCF_XSSEncoder["mHtmlLookup"][sChar] = sEscaped;
        }
        return sEscaped;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["fHtml"] = 0;
    }
    ;

    /**
     * Escape the string for inclusion into HTML content or attribute
     *
     * @public
     * @param {string} sString The string to be escaped
     * @return {string} The escaped string
     */
    UCF_XSSEncoder["encodeHTML"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["encodeHTML"]++;
        }
        ;
        return sString["replace"](this["rHtml"], this["fHtml"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["encodeHTML"] = 0;
    }
    ;

    /**
     * Escape the string for inclusion into XML content or attribute
     *
     * @param {string} sString The string to be escaped
     * @return {string} The escaped string
     * @public
     */
    UCF_XSSEncoder["encodeXML"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["encodeXML"]++;
        }
        ;
        return sString["replace"](this["rHtml"], this["fHtml"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["encodeXML"] = 0;
    }
    ;

    /**
     * RegExp and escape function for JS escaping
     */
    UCF_XSSEncoder["rJS"] = /[\x00-\x2b\x2d\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\xff\u2028\u2029]/g;
    UCF_XSSEncoder["mJSLookup"] = {};
    UCF_XSSEncoder["fJS"] = function (sChar) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["fJS"]++;
        }
        ;
        var sEscaped = UCF_XSSEncoder["mJSLookup"][sChar];
        if (!sEscaped) {
            var iChar = sChar["charCodeAt"](0);
            if (iChar < 256) {
                sEscaped = "\\x" + UCF_XSSEncoder["hex"](iChar, 2);
            } else {
                sEscaped = "\\u" + UCF_XSSEncoder["hex"](iChar, 4);
            }
            UCF_XSSEncoder["mJSLookup"][sChar] = sEscaped;
        }
        return sEscaped;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["fJS"] = 0;
    }
    ;

    /**
     * Escape the string for inclusion into a JS string literal
     *
     * @param {string} sString The string to be escaped
     * @return {string} The escaped string
     * @public
     */
    UCF_XSSEncoder["encodeJS"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["encodeJS"]++;
        }
        ;
        return sString["replace"](this["rJS"], this["fJS"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["encodeJS"] = 0;
    }
    ;

    /**
     * RegExp and escape function for URL escaping
     */
    UCF_XSSEncoder["rURL"] = /[\x00-\x29\x2b\x2c\x2f\x3a-\x40\x5b-\x5e\x60\x7b-\xff\u2028\u2029]/g;
    UCF_XSSEncoder["mURLLookup"] = {};
    UCF_XSSEncoder["fURL"] = function (sChar) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["fURL"]++;
        }
        ;
        var sEscaped = UCF_XSSEncoder["mURLLookup"][sChar];
        if (!sEscaped) {
            var iChar = sChar["charCodeAt"](0);
            if (iChar < 128) {
                sEscaped = "%" + UCF_XSSEncoder["hex"](iChar, 2);
            } else if (iChar < 2048) {
                sEscaped = "%" + UCF_XSSEncoder["hex"]((iChar >> 6) | 192, 2) +
                    "%" + UCF_XSSEncoder["hex"]((iChar & 63) | 128, 2);
            } else {
                sEscaped = "%" + UCF_XSSEncoder["hex"]((iChar >> 12) | 224, 2) +
                    "%" + UCF_XSSEncoder["hex"](((iChar >> 6) & 63) | 128, 2) +
                    "%" + UCF_XSSEncoder["hex"]((iChar & 63) | 128, 2);
            }
            UCF_XSSEncoder["mURLLookup"][sChar] = sEscaped;
        }
        return sEscaped;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["fURL"] = 0;
    }
    ;

    /**
     * Escape the string for inclusion into an URL parameter
     *
     * @param {string} sString The string to be escaped
     * @return {string} The escaped string
     * @public
     */
    UCF_XSSEncoder["encodeURL"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["encodeURL"]++;
        }
        ;
        return sString["replace"](this["rURL"], this["fURL"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["encodeURL"] = 0;
    }
    ;

    /**
     * RegExp and escape function for CSS escaping
     */
    UCF_XSSEncoder["rCSS"] = /[\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xff\u2028\u2029][0-9A-Fa-f]?/g;
    UCF_XSSEncoder["fCSS"] = function (sChar) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["fCSS"]++;
        }
        ;
        var iChar = sChar["charCodeAt"](0);
        if (sChar["length"] === 1) {
            return "\\" + UCF_XSSEncoder["hex"](iChar);
        } else {
            return "\\" + UCF_XSSEncoder["hex"](iChar) + " " + sChar["substr"](1);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["fCSS"] = 0;
    }
    ;

    /**
     * Escape the string for inclusion into CSS
     *
     * @param {string} sString The string to be escaped
     * @return {string} The escaped string
     * @public
     */
    UCF_XSSEncoder["encodeCSS"] = function (sString) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_XSSEncoder["_"]["encodeCSS"]++;
        }
        ;
        return sString["replace"](this["rCSS"], this["fCSS"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_XSSEncoder["_"]["encodeCSS"] = 0;
    }
    ;


    UCF_XSSEncoder.prototype["aPublicMethods"] = ["encodeHTML", "encodeXML", "encodeJS", "encodeURL", "encodeCSS"].concat(UCF_XSSEncoder.prototype.aPublicMethods || []);
    /* global _assert, _trace, DEBUG */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_System */

/// <reference path="../core/System.js"/>

    /**
     * Abstraction of a browser event. Contains the DOM event in property <code>oDomEvent</code>.
     *
     *
     * @class
     * @param {Event} oDomEvent the real browser event object
     */
    function UCF_BrowserEvent(oDomEvent) {
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["UCF_BrowserEvent"]++;
        }
        ;
        UCF_Object["apply"](this);

        if (arguments["length"] > 0) {
            this["init"](oDomEvent);
        }
    };window["UCF_BrowserEvent"] = UCF_BrowserEvent;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_BrowserEvent");
        UCF_BrowserEvent["_"] = {UCF_BrowserEvent: 0};
    }
    ;
    ;
    UCF_BrowserEvent["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_BrowserEvent.prototype["sClassName"] = "UCF_BrowserEvent";

    /** @override */
    UCF_BrowserEvent["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["destroy"]++;
        }
        ;
        this["_oSourceRect"] = null;
        this["_iPageY"] = null;
        this["_iPageX"] = null;
        this["_iParentY"] = null;
        this["_iParentX"] = null;
        this["_iScreenY"] = null;
        this["_iScreenX"] = null;
        this["_iClientY"] = null;
        this["_iClientX"] = null;
        this["_iKeyCode"] = null;
        this["_bRepeat"] = null;
        this["_bCtrl"] = null;
        this["_bAlt"] = null;
        this["_bShift"] = null;
        this["oFromElement"] = null;
        this["oSource"] = null;
        this["bHandled"] = null;
        this["bCancelBubble"] = null;
        this["sName"] = null;
        this["oDomEvent"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["destroy"] = 0;
    }
    ;

    /**
     * Button state constants - Browser specific constants are mapped to that enum.
     * @enum
     */
    UCF_BrowserEvent["prototype"]["MOUSE_BUTTON_STATE"] = {
        "None": 0,
        "Left": 1, //FireFox 0
        "Right": 2, //FF 3
        "Left_Right": 3,
        "Middle": 4, //FF 1
        "Left_Middle": 5,
        "Right_Middle": 6,
        "Left_Right_Middle": 7
    };

    /**
     * @private
     * @static
     * @type {boolean}
     */
    UCF_BrowserEvent["bTouchInteraction"] = false;
    /**
     * @private
     * @static
     * @type {boolean}
     */
    UCF_BrowserEvent["bSingleTouchInteraction"] = false;

    /**
     * Init event with DOM event, needed for pooling.
     *
     * @param {Event} oDomEvent
     */
    UCF_BrowserEvent["prototype"]["init"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["init"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomEvent === "object", "typeof oDomEvent === \"object\"", "BrowserEvent.js(92): init");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomEvent != null, "oDomEvent != null", "BrowserEvent.js(93): init");
        }
        ;

        var touch0 = oDomEvent["touches"] && oDomEvent["touches"][0] ? oDomEvent["touches"][0] : oDomEvent["changedTouches"] && oDomEvent["changedTouches"][0] ? oDomEvent["changedTouches"][0] : undefined;

        this["oDomEvent"] = oDomEvent;
        this["sName"] = oDomEvent["type"];
        this["bCancel"] = false;
        this["bCancelBubble"] = false;
        this["bLocked"] = false;
        this["bHandled"] = false;
        this["oSource"] = this["oDomEvent"]["srcElement"] || this["oDomEvent"]["target"] || this["oDomEvent"]["currentTarget"];
        this["oFromElement"] = null;
        this["oSourceControl"] = null;
        this["_bShift"] = oDomEvent["shiftKey"];
        this["_bAlt"] = oDomEvent["altKey"];
        this["_bCtrl"] = (UCF_UserAgent["bIsMacOs"]() || UCF_UserAgent["bIsIOS"]()) ? oDomEvent["metaKey"] : oDomEvent["ctrlKey"];
        this["_bRepeat"] = oDomEvent["repeat"];
        this["_iKeyCode"] = oDomEvent["keyCode"] || oDomEvent["charCode"];
        this["_iClientX"] = Math["round"](typeof oDomEvent["clientX"] === "number" ? oDomEvent["clientX"] : (touch0 ? touch0["clientX"] : undefined));
        this["_iClientY"] = Math["round"](typeof oDomEvent["clientY"] === "number" ? oDomEvent["clientY"] : (touch0 ? touch0["clientY"] : undefined));
        this["_iScreenX"] = Math["round"](typeof oDomEvent["screenX"] === "number" ? oDomEvent["screenX"] : (touch0 ? touch0["screenX"] : undefined));
        this["_iScreenY"] = Math["round"](typeof oDomEvent["screenY"] === "number" ? oDomEvent["screenY"] : (touch0 ? touch0["screenY"] : undefined));
        this["_iParentX"] = Math["round"](UCF_UserAgent["bIsGecko"]() ? this["oDomEvent"]["layerX"] : this["oDomEvent"]["x"]);
        this["_iParentY"] = Math["round"](UCF_UserAgent["bIsGecko"]() ? this["oDomEvent"]["layerY"] : this["oDomEvent"]["y"]);
        this["_iPageX"] = 0;
        this["_iPageY"] = 0;
        if (UCF_UserAgent["bIsAndroid"]() || UCF_UserAgent["bIsCombi"]()) {
            this["_iPageX"] = Math["round"](typeof oDomEvent["pageX"] === "number" ? oDomEvent["pageX"] : (touch0 ? touch0["pageX"] : undefined));
            this["_iPageY"] = Math["round"](typeof oDomEvent["pageY"] === "number" ? oDomEvent["pageY"] : (touch0 ? touch0["pageY"] : undefined));
        }
        this["oData"] = null;
        this["_oSourceRect"] = null;
        this["bPreventBlur"] = false;

        UCF_BrowserEvent["updateSingleTouchInteraction"](oDomEvent);
        UCF_BrowserEvent["updateTouchInteraction"](oDomEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["init"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Event} oDomEvent
     * @return {void}
     */
    UCF_BrowserEvent["updateTouchInteraction"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["updateTouchInteraction"]++;
        }
        ;
        if (oDomEvent["type"] === 'touchstart') {
            UCF_BrowserEvent["bTouchInteraction"] = true;
        } else if (oDomEvent["type"] === 'mousedown' && !UCF_BrowserEvent["bSingleTouchInteraction"]) {
            UCF_BrowserEvent["bTouchInteraction"] = false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["updateTouchInteraction"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Event} oDomEvent
     * @return {void}
     */
    UCF_BrowserEvent["updateSingleTouchInteraction"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["updateSingleTouchInteraction"]++;
        }
        ;
        if (oDomEvent["type"] === 'touchstart') {
            UCF_BrowserEvent["bSingleTouchInteraction"] = true;
        } else if (
            oDomEvent["type"] === 'touchmove' ||
            // touchend after touchmove => revert to false afterwards
            (!UCF_BrowserEvent["bSingleTouchInteraction"] && oDomEvent["type"] === 'touchend')
        ) {
            UCF_BrowserEvent["clearSingleTouchInteractionReset"]();
            UCF_BrowserEvent["bSingleTouchInteraction"] = true;
            UCF_BrowserEvent["resetSingleTouchInteraction"]();
        } else if (
            UCF_BrowserEvent["bSingleTouchInteraction"] && oDomEvent["type"] === 'mouseup'
        ) {
            UCF_BrowserEvent["resetSingleTouchInteraction"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["updateSingleTouchInteraction"] = 0;
    }
    ;

    /**
     * multiple touchmoves or a touchend after a touchmove could encounter an
     * already existing delayed call to resetSingleTouchInteraction. They have to clear
     * that, set bSingleTouchInteraction=true for this single event, and reset it with a
     * new delayed call afterwards.
     *
     * @private
     * @static
     */
    UCF_BrowserEvent["clearSingleTouchInteractionReset"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["clearSingleTouchInteractionReset"]++;
        }
        ;
        if (UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"]) {
            UCF_JsUtil["cancelImmediate"](UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"]);
            UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"] = undefined;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["clearSingleTouchInteractionReset"] = 0;
    }
    ;

    /**
     * the event itself has to be a touch interaction event if a touchstart
     * happened before, we have to reset after the event (i.e. via timeout)
     *
     * @private
     * @static
     * @return {void}
     */
    UCF_BrowserEvent["resetSingleTouchInteraction"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["resetSingleTouchInteraction"]++;
        }
        ;
        if (!UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"]) {
            UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"] = UCF_JsUtil["setImmediate"](
                UCF_BrowserEvent["resetSingleTouchInteractionDirectly"]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["resetSingleTouchInteraction"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @return {void}
     */
    UCF_BrowserEvent["resetSingleTouchInteractionDirectly"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["resetSingleTouchInteractionDirectly"]++;
        }
        ;
        UCF_BrowserEvent["bSingleTouchInteraction"] = false;
        UCF_BrowserEvent["sResetSingleTouchInteractionImmediateId"] = undefined;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["resetSingleTouchInteractionDirectly"] = 0;
    }
    ;

    /**
     * Deserializes a BrowserEvent for macro recording
     * @param {string} sBrowserEvent the serialized BrowserEvent
     */
    UCF_BrowserEvent["prototype"]["deserialize"] = function (sBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["deserialize"]++;
        }
        ;
        /** @type {UCF_BrowserEvent} */
        var oBrowserEvent = UCF_JsUtil["oJsonParse"](sBrowserEvent);

        oBrowserEvent["oSource"] = UCF_DomUtil["oDeserializeDomRef"](oBrowserEvent["oSource"]);
        oBrowserEvent["oFromSource"] = UCF_DomUtil["oDeserializeDomRef"](oBrowserEvent["oFromSource"]);

        this["sName"] = oBrowserEvent["sName"];
        this["oSource"] = oBrowserEvent["oSource"];
        this["oDomEvent"] = {
            "cancelBubble": false,
            "returnValue": false
        };
        this["bCancelBubble"] = oBrowserEvent["bCancelBubble"];
        this["bHandled"] = oBrowserEvent["bHandled"];
        this["oFromElement"] = oBrowserEvent["oFromSource"];
        this["_bShift"] = oBrowserEvent["bShift"];
        this["_bAlt"] = oBrowserEvent["bAlt"];
        this["_bCtrl"] = oBrowserEvent["bCtrl"];
        this["_bRepeat"] = oBrowserEvent["bRepeat"];
        this["_iKeyCode"] = oBrowserEvent["iKeyCode"];
        this["_iClientX"] = oBrowserEvent["iClientX"];
        this["_iClientY"] = oBrowserEvent["iClientY"];
        this["_iScreenX"] = oBrowserEvent["iScreenX"];
        this["_iScreenY"] = oBrowserEvent["iScreenY"];
        this["_iParentX"] = oBrowserEvent["iParentX"];
        this["_iParentY"] = oBrowserEvent["iParentY"];
        this["_iPageX"] = oBrowserEvent["iPageX"];
        this["_iPageY"] = oBrowserEvent["iPageY"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["deserialize"] = 0;
    }
    ;

    /**
     * Serializes a BrowserEvent for macro recording
     * @return {string} the serialized BrowserEvent
     */
    UCF_BrowserEvent["prototype"]["serialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["serialize"]++;
        }
        ;
        return UCF_JsUtil["sJsonStringify"]({
            "sName": this["sName"],
            "sSource": UCF_DomUtil["sSerializeDomRef"](this["oSource"]),
            "bCancelBubble": this["bCancelBubble"],
            "bHandled": this["bHandled"],
            "sFromElement": UCF_DomUtil["sSerializeDomRef"](this["oFromElement"]),
            "bShift": this["_bShift"],
            "bAlt": this["_bAlt"],
            "bCtrl": this["_bCtrl"],
            "bRepeat": this["_bRepeat"],
            "iKeyCode": this["_iKeyCode"],
            "iClientX": this["_iClientX"],
            "iClientY": this["_iClientY"],
            "iScreenX": this["_iScreenX"],
            "iScreenY": this["_iScreenY"],
            "iParentX": this["_iParentX"],
            "iParentY": this["_iParentY"],
            "iPageX": this["iPageX"](),
            "iPageY": this["iPageY"]()
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["serialize"] = 0;
    }
    ;

    /**
     * Reset event data, needed for pooling
     */
    UCF_BrowserEvent["prototype"]["reset"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["reset"]++;
        }
        ;
        this["oDomEvent"] = null;
        this["sName"] = null;
        this["bCancelBubble"] = false;
        this["bHandled"] = false;
        this["oSource"] = null;
        this["oFromElement"] = null;
        this["oSourceControl"] = null;
        this["_bShift"] = false;
        this["_bAlt"] = false;
        this["_bCtrl"] = false;
        this["_bRepeat"] = false;
        this["_iKeyCode"] = 0;
        this["_iClientX"] = -1;
        this["_iClientY"] = -1;
        this["_iScreenX"] = -1;
        this["_iScreenY"] = -1;
        this["_iParentX"] = -1;
        this["_iParentY"] = -1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["reset"] = 0;
    }
    ;

    /**
     * Returns the name of the event
     * @return {string}
     */
    UCF_BrowserEvent["prototype"]["sGetName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["sGetName"]++;
        }
        ;
        return this["sName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["sGetName"] = 0;
    }
    ;

    /**
     * Sets the name of the event
     * @param {String} sName name of the event
     */
    UCF_BrowserEvent["prototype"]["setName"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["setName"]++;
        }
        ;
        this["sName"] = sName;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["setName"] = 0;
    }
    ;

    /**
     * Returns the source of the event
     *
     * @return {HTMLElement} element
     */
    UCF_BrowserEvent["prototype"]["oGetSource"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetSource"]++;
        }
        ;
        return this["oSource"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetSource"] = 0;
    }
    ;

    /**
     * Returns the control on which the event occurred
     *
     * @return {UCF_Control} UCF_Control
     */
    UCF_BrowserEvent["prototype"]["oGetSourceControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetSourceControl"]++;
        }
        ;
        return this["oSourceControl"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetSourceControl"] = 0;
    }
    ;

    /**
     * Sets source of the event
     * @param {element} oSource The source of the DomEvent
     */
    UCF_BrowserEvent["prototype"]["setSource"] = function (oSource) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["setSource"]++;
        }
        ;
        this["oSource"] = oSource;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["setSource"] = 0;
    }
    ;

    /**
     * Returns the first parent element with defined ct-attribute of the event source element.
     * Contains special handling for controls, that have a root element marked
     * with suffix -r and for imagemaps connected to an image (-map)
     *
     * @return {HTMLElement} element
     */
    UCF_BrowserEvent["prototype"]["oGetSourceRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetSourceRoot"]++;
        }
        ;

        var oSourceRoot = this["oGetSource"](),
            oRealRoot, sId;

        // if oSourceRoot is undefined, window or document, return null
        if (!oSourceRoot || oSourceRoot == window || oSourceRoot == document) {
            return null;
        }

        // if source does not have a valid document return null and write a DEBUG trace (IE problem)
        if ((oSourceRoot["document"] && oSourceRoot["document"] != document) || oSourceRoot["parentNode"] == null) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "Browser event " + this["sGetName"]() + " was fired, but source element is not valid", "BrowserEvent.js(358): oGetSourceRoot");
            }
            ;
            return null;
        }

        // go up the parent chain, until ct is found or window/document is reached
        while (oSourceRoot != document) {
            sId = oSourceRoot["id"];
            if (sId) {
                if (oSourceRoot["getAttribute"]("ct")) return oSourceRoot;

                // 	special logic for RichTextEdit. The event is fired in a non LS IFrame but the control is the RTE
                if (oSourceRoot["getAttribute"]("subct") && oSourceRoot["getAttribute"]("subct") == "RTE_IF") {
                    return UCF_DomUtil["$"](oSourceRoot["getAttribute"]("id"));
                }

                if (UCF_StringUtil["bEndsWith"](sId, "-r") || // root of a control
                    UCF_StringUtil["bEndsWith"](sId, "-o") || // object of an active component
                    UCF_StringUtil["bEndsWith"](sId, "-ph") || // placeholder
                    UCF_StringUtil["bEndsWith"](sId, "-part") || // part of control
                    UCF_StringUtil["bEndsWith"](sId, "-map")) { // map of an image
                    oRealRoot = UCF_DomUtil["$"](sId["substr"](0, sId["lastIndexOf"]("-")));
                    // if id with "-r" exists, id without "-r" must also exist!
                    if (__UCF_ASSERT__) {
                        UCF_Tracer.assert(oRealRoot != null, "oRealRoot != null", "BrowserEvent.js(380): oGetSourceRoot");
                    }
                    ;
                    // if element exists, and has a ct attribute return it,
                    // otherwise continue searching
                    if (oRealRoot && oRealRoot["getAttribute"]("ct")) {
                        return oRealRoot;
                    }
                }
            }
            oSourceRoot = oSourceRoot["parentNode"];
            if (oSourceRoot == null) {
                //handlig of events that occur on an inactive dom might cause oSourceRoot to be null here (Datepicker navigation)
                //this is a general security check
                return null;
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetSourceRoot"] = 0;
    }
    ;

    /**
     * Returns whether the control key was pressed during the event or not
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bCtrl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bCtrl"]++;
        }
        ;
        return this["_bCtrl"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bCtrl"] = 0;
    }
    ;

    /**
     * Returns whether the alt key was pressed during the event or not
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bAlt"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bAlt"]++;
        }
        ;
        return this["_bAlt"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bAlt"] = 0;
    }
    ;

    /**
     * Returns whether the shift key was pressed during the event or not
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bShift"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bShift"]++;
        }
        ;
        return this["_bShift"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bShift"] = 0;
    }
    ;

    /**
     * Returns whether the key is repeated
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bRepeat"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bRepeat"]++;
        }
        ;
        return this["_bRepeat"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bRepeat"] = 0;
    }
    ;

    /**
     * Returns the key code of the event
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iKeyCode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iKeyCode"]++;
        }
        ;
        return this["_iKeyCode"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iKeyCode"] = 0;
    }
    ;

    /**
     * Returns the x position of the event
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iClientX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iClientX"]++;
        }
        ;
        return this["_iClientX"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iClientX"] = 0;
    }
    ;

    /**
     * Returns the y position of the event
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iClientY"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iClientY"]++;
        }
        ;
        return this["_iClientY"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iClientY"] = 0;
    }
    ;

    /**
     * Returns the x position of the event relative to its source
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iOffsetX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iOffsetX"]++;
        }
        ;
        var oDomEvent = this["oDomEvent"];

        if (oDomEvent["offsetX"] || oDomEvent["offsetX"] === 0) return oDomEvent["offsetX"];

        if (!this["_oSourceRect"]) this["_oSourceRect"] = UCF_DomUtil["oGetObjectRect"](this["oGetSource"]());

        return this["iPageX"]() - this["_oSourceRect"]["left"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iOffsetX"] = 0;
    }
    ;

    /**
     * Returns the y position of the event relative to its source
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iOffsetY"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iOffsetY"]++;
        }
        ;
        var oDomEvent = this["oDomEvent"];

        if (oDomEvent["offsetY"] || oDomEvent["offsetY"] === 0) return oDomEvent["offsetY"];

        if (!this["_oSourceRect"]) this["_oSourceRect"] = UCF_DomUtil["oGetObjectRect"](this["oGetSource"]());

        return this["iPageY"]() - this["_oSourceRect"]["top"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iOffsetY"] = 0;
    }
    ;

    /**
     * Returns the x position of the event in the body of the document including the scrolling offset
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iPageX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iPageX"]++;
        }
        ;
        if (this["_iPageX"]) return this["_iPageX"];

        if (this["oDomEvent"]["pageX"]) {
            // None-IE
            this["_iPageX"] = this["oDomEvent"]["pageX"];
            if (window["UCF_System"]["bIsRTL"]) {
                this["_iPageX"] = this["_iPageX"] - UCF_DomUtil["iGetVerticalScrollbarOffset"](document["body"]) - (document["body"]["scrollWidth"] - UCF_DomUtil["iClientWidth"]());
            }
        } else {
            // IE
            if (UCF_UserAgent["bIsStandardsMode"]()) {
                this["_iPageX"] = this["oDomEvent"]["clientX"] - document["documentElement"]["scrollLeft"];
                if (window["UCF_System"]["bIsRTL"]) {
                    this["_iPageX"] = this["_iPageX"] - UCF_DomUtil["iGetVerticalScrollbarOffset"](document["body"]);
                }
            } else {
                this["_iPageX"] = this["oDomEvent"]["clientX"] + document["body"]["scrollLeft"];
                if (window["UCF_System"]["bIsRTL"]) {
                    this["_iPageX"] = this["_iPageX"] - UCF_DomUtil["iGetVerticalScrollbarOffset"](document["body"]) - (document["body"]["scrollWidth"] - UCF_DomUtil["iClientWidth"]());
                }
            }
        }

        if (UCF_UserAgent["bIsIOS"]() && (this["sName"] === 'touchend' || this["sName"] === 'lslongtap')) {
            this["_iPageX"] = this["oDomEvent"]["changedTouches"][0]["pageX"];
        }

        // Normalize
        this["_iPageX"] = Math["round"](this["_iPageX"]);

        return this["_iPageX"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iPageX"] = 0;
    }
    ;

    /**
     * Returns the y position of the event in the body of the document including the scrolling offset
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iPageY"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iPageY"]++;
        }
        ;

        if (this["_iPageY"]) return this["_iPageY"];
        if (this["oDomEvent"]["pageY"]) {
            this["_iPageY"] = this["oDomEvent"]["pageY"];
        } else {
            var iScrollTop = document["body"]["scrollTop"] || document["documentElement"]["scrollTop"];
            this["_iPageY"] = this["oDomEvent"]["clientY"] + iScrollTop;
        }

        if (UCF_UserAgent["bIsIOS"]() && (this["sName"] === 'touchend' || this["sName"] === 'lslongtap')) {
            this["_iPageY"] = this["oDomEvent"]["changedTouches"][0]["pageY"];
        }

        //Normalize
        this["_iPageY"] = Math["round"](this["_iPageY"]);

        return this["_iPageY"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iPageY"] = 0;
    }
    ;

    /**
     * Returns the x position of the event
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iScreenX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iScreenX"]++;
        }
        ;
        return this["_iScreenX"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iScreenX"] = 0;
    }
    ;

    /**
     * Returns the y position of the event
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iScreenY"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iScreenY"]++;
        }
        ;
        return this["_iScreenY"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iScreenY"] = 0;
    }
    ;

    /**
     * Returns scroll delta of the mouse wheel
     *
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iWheelDelta"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iWheelDelta"]++;
        }
        ;
        //FF and IE does not process the direction and the scale in the same manner
        return this["oDomEvent"]["detail"] ? this["oDomEvent"]["detail"] * -1 : this["oDomEvent"]["wheelDelta"] / 40;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iWheelDelta"] = 0;
    }
    ;

    /**
     * Cancels the bubbling of the event in the DOM and avoids keycode handling of the browser.
     * Calls preventDefault() and stopPropagation() on the DOM event.
     */
    UCF_BrowserEvent["prototype"]["cancel"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["cancel"]++;
        }
        ;
        if (UCF_BrowserEvent["bSingleTouchInteraction"]) {
            UCF_BrowserEvent["resetSingleTouchInteraction"]();
        }
        if (this["oDomEvent"]) {
            UCF_DomUtil["cancelEvent"](this["oDomEvent"]);
            if (this["oDomEvent"]["keyCode"] != 0) {
                this["_iKeyCode"] = 0;
            }
        }
        this["bCancel"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["cancel"] = 0;
    }
    ;

    /**
     * Cancels the bubbling of the event in the lightspeed framework.
     */
    UCF_BrowserEvent["prototype"]["cancelBubble"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["cancelBubble"]++;
        }
        ;
        this["bCancelBubble"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["cancelBubble"] = 0;
    }
    ;

    /**
     * Returns whether the event was canceled in the lightspeed framework.
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bGetCancelBubble"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bGetCancelBubble"]++;
        }
        ;
        return this["bCancelBubble"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bGetCancelBubble"] = 0;
    }
    ;

    /**
     * Returns whether the dom event was canceled in the lightspeed framework.
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bIsDomEventCanceled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsDomEventCanceled"]++;
        }
        ;
        return this["oDomEvent"]["cancelBubble"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsDomEventCanceled"] = 0;
    }
    ;

    /**
     * Returns the currents state of the mouse buttons.
     * See enumeration UCF_BrowserEvent.MOUSE_BUTTON_STATE
     *
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["eGetMouseButtonState"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["eGetMouseButtonState"]++;
        }
        ;
        // Special handling of button codes on Firefox
        var iButton = this["oDomEvent"]["which"];
        if (iButton) {
            switch (iButton) {
                case 1:
                    return this["MOUSE_BUTTON_STATE"]["Left"];
                case 2:
                    return this["MOUSE_BUTTON_STATE"]["Middle"];
                case 3:
                    return this["MOUSE_BUTTON_STATE"]["Right"];
                //TODO: combined button codes
            }
        } else if (this["bIsTouchEvent"]()) {
            return this["MOUSE_BUTTON_STATE"]["Left"];
        }
        return this["oDomEvent"]["button"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["eGetMouseButtonState"] = 0;
    }
    ;

    /**
     * Returns the element that had the focus
     *
     * @return {HTMLElement}
     */
    UCF_BrowserEvent["prototype"]["oGetFromElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetFromElement"]++;
        }
        ;

        if (this["oFromElement"]) {
            //check if the from element was removed from the active dom
            if (this["oFromElement"]["document"] == window["document"]) {
                return this["oFromElement"];
            } else {
                //look for an element with the same id in the active dom
                var sId = this["oFromElement"]["id"];
                if (sId) return UCF_DomUtil["$"](sId);
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetFromElement"] = 0;
    }
    ;

    /**
     * Retrieves the x-coordinate, in pixels, of the mouse pointer's position relative to a relatively positioned parent element.
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iParentX"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iParentX"]++;
        }
        ;
        return this["_iParentX"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iParentX"] = 0;
    }
    ;

    /**
     * Retrieves the y-coordinate, in pixels, of the mouse pointer's position relative to a relatively positioned parent element.
     * @return {number}
     */
    UCF_BrowserEvent["prototype"]["iParentY"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["iParentY"]++;
        }
        ;
        return this["_iParentY"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["iParentY"] = 0;
    }
    ;

    /**
     * Whether the event has been triggered by the user (like keyboard and mouse events) or are
     * browser events like onload or onunload
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bIsUserTriggered"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsUserTriggered"]++;
        }
        ;
        switch (this["sName"]) {
            case "load":
            case "unload":
            case "resize":
                return false;
            default:
                return true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsUserTriggered"] = 0;
    }
    ;

    /**
     * True, if the event has been triggered by keyboard
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bIsKeyboardTriggered"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsKeyboardTriggered"]++;
        }
        ;
        switch (this["oDomEvent"]["type"]) {
            case "keydown":
            case "keyup":
            case "keypress":
                return true;
            default:
                return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsKeyboardTriggered"] = 0;
    }
    ;

    /**
     * True, if the event is triggered inside the LoadingAnimation
     * @private
     * @param {oBrowserEvent} oBrowserEvent
     * @return {boolean}
     */
    UCF_BrowserEvent["prototype"]["bIsLoadingAnimationTriggered"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsLoadingAnimationTriggered"]++;
        }
        ;
        return UCF_DomUtil["bContains"](UCF_DomUtil["$"]("ur-loading"), this["oSource"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsLoadingAnimationTriggered"] = 0;
    }
    ;

    /**
     * For mouse down event a handler can call this method to avoid that there is a blur event fired
     * This is picked up by the BrowserWindow and will cause the next blur event to be not fired to the controls.
     */
    UCF_BrowserEvent["prototype"]["preventBlur"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["preventBlur"]++;
        }
        ;
        this["bPreventBlur"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["preventBlur"] = 0;
    }
    ;

    /**
     * Returns object to provide custom data to parent handler while event processing
     * @return {Object}
     */
    UCF_BrowserEvent["prototype"]["oGetData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetData"]++;
        }
        ;
        if (!this["oData"]) this["oData"] = {};
        return this["oData"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetData"] = 0;
    }
    ;

    /**
     * Returns an array of all changed touch points with a fallback entry for a single touch. The fallback entry has these properties: 'pageX', 'pageY', identifier.
     * For a single, first touchstart with one finger, the content of changedTouches array is the same as the <code>touches</code> array in modern browsers.
     * IE11 implements only <code>changedTouches</code> array.
     * Returns null if this is not an touch event.
     *
     * @return {Array|null} the Array with all touch points
     */
    UCF_BrowserEvent["prototype"]["aGetChangedTouches"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["aGetChangedTouches"]++;
        }
        ;
        if (this["bIsTouchEvent"]()) {
            var oDomEvent = this["oDomEvent"];

            // IE11 implements only event.changedTouches but not event.touches
            return oDomEvent["changedTouches"] ?
                oDomEvent["changedTouches"] : [{
                    "pageX": oDomEvent["pageX"],
                    "pageY": oDomEvent["pageY"],
                    "identifier": oDomEvent["pointerId"]
                }];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["aGetChangedTouches"] = 0;
    }
    ;

    /**
     * Returns true if this event is triggered by a touch user interaction.
     * @return {boolean} true if this is a touch event
     * obsolete
     */
    UCF_BrowserEvent["prototype"]["bIsTouchEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsTouchEvent"]++;
        }
        ;
        return this["oDomEvent"]["type"]["match"](/^(MSPointer|touch|gesture)/i) &&
        (!this["oDomEvent"]["MSPOINTER_TYPE_TOUCH"] || this["oDomEvent"]["pointerType"] === this["oDomEvent"]["MSPOINTER_TYPE_TOUCH"]) ? true : false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsTouchEvent"] = 0;
    }
    ;

    /**
     * Returns true if this event is triggered by a touch user interaction.
     * @return {boolean} true if this is a touch event
     */
    UCF_BrowserEvent["prototype"]["bIsTouchInteraction"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsTouchInteraction"]++;
        }
        ;
        return UCF_BrowserEvent["bTouchInteraction"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsTouchInteraction"] = 0;
    }
    ;

    /**
     * Returns the distance in px from the last 'touchstart' position in both directions for a <b>'touchmove'</b> event if it
     * is part of a 'swipe'. Returns null if this is not a <b>'touchmove'</b> event.
     * @return {Object.<string,number>|null} Properties: x,y
     */
    UCF_BrowserEvent["prototype"]["oGetSwipeDistance"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["oGetSwipeDistance"]++;
        }
        ;
        return this["oMoveDistance"] ? this["oMoveDistance"] : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["oGetSwipeDistance"] = 0;
    }
    ;

    /**
     * Returns true if this <b>'touchmove'</b> event is part of a 'swipe'. Returns null if this is not a <b>'touchmove'</b> event.
     * @return {boolean|null}
     */
    UCF_BrowserEvent["prototype"]["bSwipeThresholdExceeded"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bSwipeThresholdExceeded"]++;
        }
        ;
        return this["bSwipeThresholdExceeded"] !== undefined ? this["bSwipeThresholdExceeded"] : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bSwipeThresholdExceeded"] = 0;
    }
    ;

    /**
     *  Returns true iff the current hovering is a proper one, i.e. done
     *  by the mouse pointer.
     */
    UCF_BrowserEvent["prototype"]["bIsMouseHover"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserEvent["_"]["bIsMouseHover"]++;
        }
        ;
        return UCF_DomUtil["bHasClass"](document["body"], "lsPage--mouse");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserEvent["_"]["bIsMouseHover"] = 0;
    }
    ;

    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_ObjectPool */
/// <reference path="../../core/ObjectPool.js"/>
    /* global _assert, _trace, DEBUG, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_KeyCodes */
/// <reference path="../../core/enums/KeyCodes.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_KeyboardHelper */
/// <reference path="../core/KeyboardHelper.js"/>
    /* global UCF_System */
/// <reference path="../core/System.js"/>
    /* global UCF_DragAndDropManager */
/// <reference path="../helper/DragAndDropManager.js"/>
    /* global UCF_ResizeEventHelper */
/// <reference path="../helper/ResizeEventHelper.js"/>
    /* global UCF_BrowserEvent */
/// <reference path="./BrowserEvent.js"/>
    /* global UCF_LongTapDetector */
/// <reference path="./LongTapDetector.js"/>
    /* global UCF_SwipeDetector */
/// <reference path="./SwipeDetector.js"/>
    /* global UCF_TapDetector */
/// <reference path="./TapDetector.js"/>
    /* global UCF_ZoomDetector */
/// <reference path="./ZoomDetector.js"/>

    /** @typedef {'ROUNDTRIP'|'DRAGDROP'|'PENDINGNAVIGATION'|'POPUP'|'FRAMEPROTECT'|'DESIGNTIME'|'POSTMESSAGE'} UCF_BrowserWindow_Locktype */
    /** @typedef {'lsup'|'lsdown'|'lsleft'|'lsright'|'lsnext'|'lsprevious'|'lspageup'|'lspagedown'|'lstop'|'lsbottom'|'lshome'|'lsend'|'lsselect'|'lsspace'|'lsenter'|'lsescape'|'lsexpand'|'lscollapse'|'lscollapseall'|'lsshow'|'lshide'|'lsdragstart'|'lsdrag'|'lsdragover'|'lsdraghover'|'lsdragscroll'|'lsdrop'|'lsdragend'|'lsdragenter'|'lsdragleave'|'lsfocusin'|'lsfocusout'|'lsfocus'|'lsblur'|'lstabnext'|'lstabprevious'|'lstabsequencenext'|'lstabsequenceprevious'|'lsskipforward'|'lsskipback'|'lscontainerfocus'|'lscontainerblur'|'lsaccessibility'|'lshotkey'|'lsacchierarchy'|'lsfocuslost'|'lsdelayeddoubleclick'|'lsmousewheel'|'lstouchstart'|'lstouchmove'|'lstouchend'|'lsgesturestart'|'lsgesturechange'|'lsgestureend'|'lslongtap'|'lslongtapend'|'lsextralongtap'|'lsextralongtapend'|'lsswipeleft'|'lsswiperight'} UCF_BrowserWindow_LsEvent * /
     /** @typedef {number} UCF_BrowserWindow_Event */
    /** @typedef {'touchstart'|'touchmove'|'touchend'|'touchcancel'|'gesturestart'|'gesturechange'|'gestureend'} UCF_BrowserWindow_TouchEvent */
    /** @typedef {Object<string,string>} UCF_BrowserWindow_TabSequence maps start ids (key) to target ids (value) */
    /** @typedef {string|HTMLElement} UCF_BrowserWindow_IsolatedArea */
    /**
     * @typedef {Object} UCF_BrowserWindow_LayoutChangeParameters
     * @property {string} sSourceControlId The ID of the control that fired the
     * event. This could be used to filter-out the control's own events if it also
     * has to fire 'LayoutChange' events.
     * @property {string} sSourceClassName The class name of the event source, i.e.
     * 'UCF_PageUpdater', 'UCF_RenderManager'
     * @property {string} bIsWindowResize The event was caused by a resize event of
     * the window object (BrowserWindow)
     * @property {UCF_BrowserWindow_LayoutChangeCustomData} oCustomData
     */
    /**
     * @typedef {Object} UCF_BrowserWindow_LayoutChangeCustomData
     * @property {string} SrenderedControlId The ID of the rendered control
     * (RenderManager)
     * @property {number} iIndex The current index of update-documents inside a
     * full-update (PageUpdater)
     * @property {number} iCount The current number of update-documents inside a
     * full-update (PageUpdater)
     */
    /**
     * @typedef {Object} UCF_BrowserWindow_MouseEventParameters
     * @property {UCF_DragAndDropManager} oDragAndDropManager
     */
    /**
     * @typedef {Object} UCF_BrowserWindow_EventParameters
     * @property {UCF_BrowserEvent} oBrowserEvent
     */
    /**
     * @typedef {Object} UCF_BrowserWindow_KeyboardEventParameters
     * @property {number} iKey
     * @property {UCF_BrowserEvent} oBrowserEvent
     */

    /**
     * @typedef {Object} UCF_BrowserWindow_EventInfo
     * @property {boolean} bCtrl
     * @property {boolean} bShift
     * @property {boolean} bAlt
     * @property {boolean} bCtrlOnly
     * @property {boolean} bAltOnly
     * @property {boolean} bShiftOnly
     * @property {boolean} bNoModifiers
     */

    /**
     * Abstraction of the browser window, catches all events occuring in the
     * browser.
     *
     * @class
     * @link UCF_BrowserEvent
     *
     * @param {HTMLElement} oRootRef the root container for lightspeed content
     */
    function UCF_BrowserWindow(oRootRef) {
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["UCF_BrowserWindow"]++;
        }
        ;
        /** @type {UCF_BrowserWindow} */
        var self = this;

        UCF_EventProvider["apply"](this);

        this["defineEvents"]([
            'ControlEvent',
            'Load',
            'Unload',
            'Resize',
            'Focus',
            'Blur',
            'AnyEvent',
            'Debug',
            /**
             * Notifies controls that a change was done to the DOM, that can cause the
             * need to do client-side calculations (size, position). The event will be
             * fired by the LS framework in these cases:
             * - After applying an update (PageUpdated)
             * - after client-side-rendering (RenderManager)
             * - when a 'resize' event was fired by the `window` object (BrowserWindow).
             * On iOS a 'resize' can also be caused by a zoom. When a 'LayoutChange' is
             * fired it is usually not necessary to know what caused the event. Some
             * classes provide this information by using `notifyLayoutChangeFrom()` and
             * providing some event parameters. Depending on the event provider/source,
             * the event handlers can access these parameters:
             * - `sSourceControlId`: The ID of the control that fired the event. This
             *   could be used to filter-out the control's own events if it also has to
             *   fire 'LayoutChange' events.
             * - `sSourceClassName`: The class name of the event source:
             *   'UCF_PageUpdater', 'UCF_RenderManager'
             * - `bIsWindowResize`: The event was caused by a resize event of the window
             *   object (BrowserWindow)'
             * - `oCustomData`:
             *   - `sRenderedControlId`: The ID of the rendered control (RenderManager),
             *   - `iIndex`/`iCount`: The current index and number of update-documents
             *     inside an full-update (PageUpdater).
             * Each update will cause a 'LayoutChange' event. But a handler may want to
             * react only to the last one.
             * @see UCF_BrowserWindow_LayoutChangeParameters
             */
            'LayoutChange',
            'EventPlayer',
            'Lock',
            'Unlock',
            /**
             * Some DOM elements are rendered/shown that are positioned on top of other
             * controls (e.g. LayeredControls like PopupMenu, PopupWindow)
             */
            'LayersVisible',
            /**
             * The elements that caused the 'LayersVisible' event are removed/hidden
             * again.
             */
            'LayersHidden',
            'Offline',
            'Online',
            'DDManagerCreate',
            'RecorderEvent',
            'IsolatedAreaEvent',
            'ToggleMessageFocus',

            /**
             * The screen orientation is changed on a mobile device or tablet. This
             * affects the size of the page. Use {@link UCF_DomUtil#oGetClientHeight} and
             * {@link UCF_DomUtil.oGetClientHeight} to read the new values or
             * {@link UCF_DomUtil.sScreenOrientation} to get 'landscape' or 'portrait'.
             */
            'OrientationChange',

            /**
             * The user has triggered a zoom using the 'pinch' or 'double tab' gesture.
             * Event parameter 'bZoomIn' can be accessed to find out the zoom direction:
             * `oEvent.mGetParameters().bZoomIn`.
             * Read the new zoom factor using {@link UCF_DomUtil#oGetZoomFactor}.
             */
            'ZoomChange',
            'VisibilityChange',
            'BeforeUnload',
            /**
             * The user has tapped anywhere. A "Tap" is fired on touchend, if the distance
             * between (screenX, screenY) of touchstart and touchend is less than 5 px
             * ({@link UCF_TapDetector#DISTANCE_THRESHOLD_PX}). The touchend event can
             * be accessed via `oEvent.mGetParameters().oBrowserEvent`.
             */
            'Tap',
            'LayeredControlClose',
            'LayeredControlOpen'
        ]);

        /**
         * forwarder function for events
         * @param {Event} oDomEvent
         */
        this["forwardBrowserEvent"] = function (oDomEvent) { // eslint-disable-line ur/no-memory-leaks
            self["handleBrowserEvent"](oDomEvent);
        };

        /** @type {HTMLElement} the root container reference */
        this["oRootRef"] = oRootRef;
        /** @type {HTMLElement} */
        UCF_KeyboardHelper["oRootRef"] = oRootRef;

        // attach to all browser events, that are interesting
        this["attachBrowserEvents"](this["A_WINDOW_EVENTS"], window);
        this["attachBrowserEvents"](this["A_DOCUMENT_EVENTS"], document);
        this["attachBrowserEvents"](this["A_DOM_EVENTS"], this["oRootRef"]);

        // attach to document rather than body (otherwise, iOS suppresses event
        // propagation if content width exceeds 100%)
        this["attachBrowserEvents"](this["A_DOM_EVENTS_TOUCH"], document);

        /** @type {TODO} Locked state */
        this["oLocked"] = {};

        /**
         * @type {boolean} Flag for an alternative keyboard handling (used by ITS)
         */
        this["bAlternativeKeyboardHandling"] = false;

        /** @type {HTMLElement} Last focussed DOM element */
        this["oCurrentDomRef"] = null;

        /** @type {UCF_ObjectPool} Pool for re-use of browser event objects */
        this["oBrowserEventPool"] = new (UCF_ClassLoader["oGetClass"]("UCF_ObjectPool"))(UCF_BrowserEvent);

        /** @type {UCF_ResizeEventHelper} */
        this["oResizeEventHelper"] = null;

        /**
         * @type {UCF_DragAndDropManager} Manager for all drag/drop related functions
         */
        this["oDragAndDropManager"] = null;

        /** @type {boolean} Window focus state */
        this["bFocussed"] = true;

        /** @type {boolean} Number of currently visible layers */
        this["iVisibleLayers"] = 0;

        /** @type {boolean} */
        this["bEventPlayer"] = false;

        /** @type {string} */
        this["sDelayedDoubleClickTimeout"] = null;
        /** @type {HTMLElement} */
        this["oDelayedDoubleClickedDomRef"] = null;

        /** @type {Object<string,UCF_BrowserWindow_TabSequence>} */
        this["mTabSequences"] = null;
        /** @type {UCF_BrowserWindow_IsolatedArea[]} */
        this["aIsolatedAreas"] = [];
        /** @type {boolean} */
        this["bDestroyed"] = false;
        /** @type {boolean} */
        this["bPreventBlur"] = false;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'BrowserWindow created', "BrowserWindow.js(253): UCF_BrowserWindow");
        }
        ;
    };window["UCF_BrowserWindow"] = UCF_BrowserWindow;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_BrowserWindow");
        UCF_BrowserWindow["_"] = {UCF_BrowserWindow: 0};
    }
    ;
    ;
    UCF_BrowserWindow["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_BrowserWindow.prototype["sClassName"] = "UCF_BrowserWindow";

    /** @const {number} */
    UCF_BrowserWindow["DELAYED_DOUBLECLICK_GATE_MS"] = 300;

    /** @enum {UCF_BrowserWindow_Locktype} */
    UCF_BrowserWindow["LOCKTYPES"] = {
        "ROUNDTRIP": 'ROUNDTRIP',
        "DRAGDROP": 'DRAGDROP',
        "PENDINGNAVIGATION": 'PENDINGNAVIGATION',
        "POPUP": 'POPUP',
        "FRAMEPROTECT": 'FRAMEPROTECT',
        "DESIGNTIME": 'DESIGNTIME',
        "POSTMESSAGE": 'POSTMESSAGE'
    };

    /**
     * Lightspeed events, which are fired by the BrowserWindow and handled by
     * control implementations. The handler functions that must be implemented by
     * the controls must be named like the enum values with the prefix 'on', for
     * example: 'onlshome'. Special events for touch devices, e.g. 'lslongtap':
     * The events are fired in addition to the DOM touch events.
     * @enum {UCF_BrowserWindow_LsEvent}
     */
    UCF_BrowserWindow["prototype"]["E_LS_EVENTS"] = {
        "up": 'lsup',
        "down": 'lsdown',
        "left": 'lsleft',
        "right": 'lsright',
        "next": 'lsnext',
        "previous": 'lsprevious',
        "pageup": 'lspageup',
        "pagedown": 'lspagedown',
        "top": 'lstop',
        "bottom": 'lsbottom',
        "home": 'lshome',
        "end": 'lsend',
        "select": 'lsselect',
        "space": 'lsspace',
        "enter": 'lsenter',
        "escape": 'lsescape',
        "expand": 'lsexpand',
        "collapse": 'lscollapse',
        "collapseall": 'lscollapseall',
        "show": 'lsshow',
        "hide": 'lshide',
        "dragstart": 'lsdragstart',
        "drag": 'lsdrag',
        "dragover": 'lsdragover',
        "draghover": 'lsdraghover',
        "dragscroll": 'lsdragscroll',
        "drop": 'lsdrop',
        "dragend": 'lsdragend',
        "dragenter": 'lsdragenter',
        "dragleave": 'lsdragleave',
        "focusin": 'lsfocusin',
        "focusout": 'lsfocusout',
        "focus": 'lsfocus',
        "blur": 'lsblur',
        "tabnext": 'lstabnext',
        "tabprevious": 'lstabprevious',
        "tabsequencenext": 'lstabsequencenext',
        "tabsequenceprevious": 'lstabsequenceprevious',
        "skipforward": 'lsskipforward',
        "skipback": 'lsskipback',
        "containerfocus": 'lscontainerfocus',
        "containerblur": 'lscontainerblur',
        "accessibility": 'lsaccessibility',
        "hotkey": 'lshotkey',
        "acchierarchy": 'lsacchierarchy',
        "focuslost": 'lsfocuslost',
        "delayeddoubleclick": 'lsdelayeddoubleclick',
        "mousewheel": 'lsmousewheel',
        "touchstart": 'lstouchstart',
        "touchmove": 'lstouchmove',
        "touchend": 'lstouchend',
        "gesturestart": 'lsgesturestart',
        "gesturechange": 'lsgesturechange',
        "gestureend": 'lsgestureend',

        /** The user touches an element and does not remove the finger for 800ms */
        "longtap": 'lslongtap',

        /** Event is triggered for the 'touchend' of a 'longtap' */
        "longtapend": 'lslongtapend',

        /**
         * The user holds the finger on an element for an extra-long time (longer
         * than 'lslongtap')
         */
        "extralongtap": 'lsextralongtap',

        /** Event is triggered for the 'touchend' of a 'extralongtap' */
        "extralongtapend": 'lsextralongtapend',

        // /**
        //  * The user tabs twice on the same element.
        //  * The control's `onlsdoubletab()` handler will receive the
        //  * second 'touchend' as argument. If the implementation processes the
        //  * event, it should call {@link UCF_BrowserEvent#cancel} to prevent the
        //  * default double-tab-zoom-in/out of the browser.
        //  */
        // doubletab: 'lsdoubletab',

        /**
         * Touch an element and move the finger to the left. The
         * {@link UCF_BrowserWindow} argument of the handler is the corresponding
         * 'touchend' event. If the implementation processes the event, it should
         * call {@link UCF_BrowserEvent#cancel}.
         * {@link UCF_BrowserEvent#bSwipeThresholdExceeded} can be used in a
         * **'touchmove'** handler to apply CSS changes before the 'lsswipexxx'
         * event is fired.
         */
        "swipeleft": 'lsswipeleft',

        /** Touch an element and move the finger to the right. */
        "swiperight": 'lsswiperight'
    };

    /**
     * Events that are provided by the window object
     *
     * @private
     * @const {string[]}
     */
    UCF_BrowserWindow["prototype"]["A_WINDOW_EVENTS"] = [
        'load',
        'unload',
        'offline',
        'online',
        'resize',
        'scroll',
        'focus',
        'orientationchange',
        'beforeunload'
    ];

    /**
     * Events that are provided by the root container. Attention: do not add
     * mousemove for performance reasons. If mousemove is needed attach it only for
     * the time it is required and do not forget to detach again.
     *
     * @private
     * @const {string[]}
     */
    UCF_BrowserWindow["prototype"]["A_DOM_EVENTS"] = [
        // !! IMPORTANT When attaching events which are not known by IE (e.g.
        // 'DOMMouseScroll' or 'zzz' or even '') IE leaks in memory when JS framework
        // is loaded in IFrame
        'click',
        'dblclick',
        'dragstart',
        'drop',
        'mousedown',
        'mouseup',
        'mouseover',
        'mouseout',
        'paste',
        'cut',
        'activate',
        'deactivate',
        'focusin',
        'focusout',
        'focus',
        'blur',
        // Mousewheel support for FireFox by DOMMouseScroll. Attaching both will lead
        // to mem leak in IE when loaded in IFrame
        (UCF_UserAgent["bIsGecko"]() ? 'DOMMouseScroll' : 'mousewheel'),
        'help'
    ];

    /**
     * Events that are provided by the document object.
     * Attention: these need to be registered on the document instead of the
     * root container, because they are causing memory leaks on IE when registered
     * on a div
     *
     * @private
     * @const {string}
     */
    UCF_BrowserWindow["prototype"]["A_DOCUMENT_EVENTS"] = [
        'contextmenu',
        'select',
        'selectstart',
        'submit',
        'keydown',
        'keyup',
        'keypress',
        'reset',
        'visibilitychange'
    ];

    /**
     * TODO: this is unsused (2019-04-12)
     *
     * @private
     * @enum {string}
     */
    UCF_BrowserWindow["prototype"]["MOUSE_EVENTS"] = {
        'mousemove': null,
        'mousedown': null,
        'mouseup': null,
        'mouseover': null,
        'mouseenter': null,
        'mouseleave': null,
        'mouseout': null,
        'contextmenu': null,
        'click': null,
        'dblclick': null,
        'drag': null,
        'dragdrop': null,
        'dragend': null,
        'mousewheel': null
    };

    /**
     * Destructor, detaches all event handlers and deletes created window members
     * @private
     */
    UCF_BrowserWindow["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["destroy"]++;
        }
        ;
        if (this["aIsolatedAreas"]["length"] > 0) {
            this["aIsolatedAreas"] = [];
        }
        try {
            // CSN: 3767464 2013 -> Script Error while accessing document because
            // document is already destroyed.
            this["detachBrowserEvents"](this["A_WINDOW_EVENTS"], window);
            this["detachBrowserEvents"](this["A_DOCUMENT_EVENTS"], document);
            this["detachBrowserEvents"](this["A_DOM_EVENTS"], this["oRootRef"]);
            this["detachBrowserEvents"](this["A_DOM_EVENTS_TOUCH"], document);
        } catch (ex) {

        }

        this["oDelayedDoubleClickedDomRef"] = null;

        this["oRootRef"] = null;

        if (this["oLongTapDetector"]) {
            this["oLongTapDetector"]["destroy"]();
            this["oLongTapDetector"] = null;
        }

        if (this["oSwipeDetector"]) {
            this["oSwipeDetector"]["destroy"]();
            this["oSwipeDetector"] = null;
        }

        if (this["oZoomDetector"]) {
            this["oZoomDetector"]["destroy"]();
            this["oZoomDetector"] = null;
        }

        if (this["oTapDetector"]) {
            this["oTapDetector"]["destroy"]();
            this["oTapDetector"] = null;
        }

        // clean up DragAndDropManager
        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["destroy"]();
            this["oDragAndDropManager"] = null;
        }

        if (UCF_DomUtil["oGetTopWindow"]()) {
            // CSN 252472 2014... freed script try if this help
            UCF_DomUtil["oGetTopWindow"]()["oDragSession"] = null;
        }

        this["oLocked"] = null;
        this["oCurrentDomRef"] = null;
        this["oNextFocusDomRef"] = null;
        this["oPreviousFocusDomRef"] = null;

        if (this["oBrowserEventPool"]) {
            this["oBrowserEventPool"]["destroy"]();
            this["oBrowserEventPool"] = null;
        }

        if (this["oResizeEventHelper"]) {
            this["oResizeEventHelper"]["destroy"]();
            this["oResizeEventHelper"] = null;
        }

        this["mTabSequences"] = null;

        if (this["sDelayedDoubleClickTimeout"]) {
            UCF_JsUtil["clearDelayedCall"](this["sDelayedDoubleClickTimeout"]);
            this["sDelayedDoubleClickTimeout"] = null;
        }

        this["bPreventBlur"] = null;
        this["bTouchStartOnActiveTextInput"] = null;
        // TODO forwardBrowserEvent

        this["bDestroyed"] = true;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["destroy"] = 0;
    }
    ;

    /**
     * Attach a browser event on a dom element. This will be handled by central
     * event handling and passed to the control the dom element belongs to
     *
     * @private
     * @param {string} sName the name of the event to attach
     * @param {HTMLElement} oDomRef the dom reference where to attach the event
     */
    UCF_BrowserWindow["prototype"]["attachBrowserEvent"] = function (sName, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["attachBrowserEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "BrowserWindow.js(564): attachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName !== '', "sName !== ''", "BrowserWindow.js(565): attachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName === 'online' || sName["substr"](0, 'on'["length"]) !== 'on', "sName === 'online' || sName.substr(0, 'on'.length) !== 'on'", "BrowserWindow.js(566): attachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "BrowserWindow.js(567): attachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "BrowserWindow.js(568): attachBrowserEvent");
        }
        ;

        // Special handling of resize events on Firefox and Safari
        if (sName === 'resize' && oDomRef !== window) {
            if (!this["oResizeEventHelper"]) {
                this["oResizeEventHelper"] = new (UCF_ClassLoader["oGetClass"]("UCF_ResizeEventHelper"))(
                    this["forwardBrowserEvent"]
                );
            }
            this["oResizeEventHelper"]["attachEvent"](oDomRef);
        } else {
            // Special handling for orientation change
            if (sName === 'orientationchange') {
                // oDomRef == window
                if ('orientationchange' in oDomRef) {
                    UCF_DomUtil["attachEvent"](
                        oDomRef,
                        'orientationchange',
                        this["forwardBrowserEvent"],
                        true
                    );
                }
            }
            UCF_DomUtil["attachEvent"](oDomRef, sName, this["forwardBrowserEvent"], true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["attachBrowserEvent"] = 0;
    }
    ;

    /**
     * Attach multiple events on a dom element
     *
     * @param {string[]} aEventList array of event names to attach
     * @param {HTMLElement} oDomRef the dom reference where to attach the event
     * @private
     */
    UCF_BrowserWindow["prototype"]["attachBrowserEvents"] = function (aEventList, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["attachBrowserEvents"]++;
        }
        ;
        /** @type {UCF_BrowserWindow} */
        var self = this;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (aEventList) === 'object', "typeof(aEventList) === 'object'", "BrowserWindow.js(606): attachBrowserEvents");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === 'object', "typeof(oDomRef) === 'object'", "BrowserWindow.js(607): attachBrowserEvents");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "BrowserWindow.js(608): attachBrowserEvents");
        }
        ;

        UCF_JsUtil["forEach"](aEventList, function (sEvent) {
            self["attachBrowserEvent"](sEvent, oDomRef);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["attachBrowserEvents"] = 0;
    }
    ;

    /**
     * Detach browser event from dom element
     *
     * @private
     * @param {string} sName the name of the event to detach
     * @param {HTMLElement} oDomRef the dom reference where to detach the event
     */
    UCF_BrowserWindow["prototype"]["detachBrowserEvent"] = function (sName, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["detachBrowserEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sName) === 'string', "typeof(sName) === 'string'", "BrowserWindow.js(623): detachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName !== '', "sName !== ''", "BrowserWindow.js(624): detachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName === 'online' || sName["substr"](0, 'on'["length"]) !== 'on', "sName === 'online' || sName.substr(0, 'on'.length) !== 'on'", "BrowserWindow.js(625): detachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === 'object', "typeof(oDomRef) === 'object'", "BrowserWindow.js(626): detachBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "BrowserWindow.js(627): detachBrowserEvent");
        }
        ;

        // Special handling of resize events on Firefox
        if (sName === 'resize' && oDomRef !== window) {
            if (this["oResizeEventHelper"]) {
                this["oResizeEventHelper"]["detachEvent"](oDomRef);
            }
        } else {
            UCF_DomUtil["detachEvent"](oDomRef, sName, this["forwardBrowserEvent"], true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["detachBrowserEvent"] = 0;
    }
    ;

    /**
     * Detach multiple browser events from a dom element
     *
     * @private
     * @param {string[]} aEventList array of event names to detach
     * @param {HTMLElement} oDomRef the dom reference where to detach the event
     */
    UCF_BrowserWindow["prototype"]["detachBrowserEvents"] = function (aEventList, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["detachBrowserEvents"]++;
        }
        ;
        /** @type {UCF_BrowserWindow} */
        var self = this;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (aEventList) === 'object', "typeof(aEventList) === 'object'", "BrowserWindow.js(650): detachBrowserEvents");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === 'object', "typeof(oDomRef) === 'object'", "BrowserWindow.js(651): detachBrowserEvents");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "BrowserWindow.js(652): detachBrowserEvents");
        }
        ;

        UCF_JsUtil["forEach"](aEventList, function (sEvent) {
            self["detachBrowserEvent"](sEvent, oDomRef);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["detachBrowserEvents"] = 0;
    }
    ;

    /**
     * Locks the browser window, do not forward any UI events, cancel all browser
     * events
     *
     * @private
     * @param {UCF_BrowserWindow_Locktype} type
     */
    UCF_BrowserWindow["prototype"]["lock"] = function (type) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["lock"]++;
        }
        ;
        /** @type {boolean} */
        var bWasUnlocked;

        // deselect value and remove caret otherwise you can type in a locked window
        UCF_DomUtil["removeCaret"](this["oCurrentDomRef"]);

        bWasUnlocked = !this["bIsLocked"]();
        this["oLocked"][type] = true;
        if (
            type === UCF_BrowserWindow["LOCKTYPES"]["ROUNDTRIP"] &&
            this["oResizeEventHelper"]
        ) {
            this["oResizeEventHelper"]["bActive"] = false;
        }
        if (bWasUnlocked) {
            this["fireEvent"](this["E_EVENTS"]["Lock"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["lock"] = 0;
    }
    ;

    /**
     * Unlocks the browser window for a given LockType
     *
     * @private
     * @param {UCF_BrowserWindow_Locktype} type
     */
    UCF_BrowserWindow["prototype"]["unlock"] = function (type) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["unlock"]++;
        }
        ;
        if (this["bDestroyed"]) return;

        /** @type {boolean} */
        var bWasLocked = this["bIsLocked"]();

        delete this["oLocked"][type];
        if (
            type === UCF_BrowserWindow["LOCKTYPES"]["ROUNDTRIP"] &&
            this["oResizeEventHelper"]
        ) {
            this["oResizeEventHelper"]["bActive"] = true;
        }
        if (bWasLocked && !this["bIsLocked"]()) {
            this["fireEvent"](this["E_EVENTS"]["Unlock"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["unlock"] = 0;
    }
    ;

    /**
     * Check if the window is locked for any reason.
     *
     * @private
     * @return {boolean} bIsLocked
     */
    UCF_BrowserWindow["prototype"]["bIsLocked"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bIsLocked"]++;
        }
        ;
        if (this["bDestroyed"]) return false;
        return UCF_JsUtil["keys"](this["oLocked"])["length"] > 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bIsLocked"] = 0;
    }
    ;

    /**
     * Check if the window is focussed
     *
     * @private
     * @return {boolean} bIsFocussed
     */
    UCF_BrowserWindow["prototype"]["bIsFocussed"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bIsFocussed"]++;
        }
        ;
        return this["bFocussed"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bIsFocussed"] = 0;
    }
    ;
    /**
     * Checks whether the browser window is locked by a special type.
     *
     * @private
     * @param {UCF_BrowserWindow_Locktype} type
     * @return {boolean} bLocked
     */
    UCF_BrowserWindow["prototype"]["bIsLockedByType"] = function (type) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bIsLockedByType"]++;
        }
        ;
        if (this["bDestroyed"]) return false;
        return this["oLocked"][type];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bIsLockedByType"] = 0;
    }
    ;

    /**
     * Check if the window is locked due to drag and drop
     *
     * @private
     * @return {boolean} bLockedAsDragDrop
     */
    UCF_BrowserWindow["prototype"]["bLockedAsDragDrop"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bLockedAsDragDrop"]++;
        }
        ;
        return this["bIsLockedByType"](UCF_BrowserWindow["LOCKTYPES"]["DRAGDROP"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bLockedAsDragDrop"] = 0;
    }
    ;

    /**
     * Check if the window is locked due to drag and drop
     *
     * @private
     * @return {boolean} bLockedAsDesigntime
     */
    UCF_BrowserWindow["prototype"]["bLockedAsDesigntime"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bLockedAsDesigntime"]++;
        }
        ;
        return this["bIsLockedByType"](UCF_BrowserWindow["LOCKTYPES"]["DESIGNTIME"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bLockedAsDesigntime"] = 0;
    }
    ;

    /**
     * Central event handler for all browser events. Events are forwarded
     * to this method from forwardBrowserEvent
     *
     * @param {Event} oDomEvent
     * @return {boolean} bHandled Browser event handled
     * @private
     */
    UCF_BrowserWindow["prototype"]["handleBrowserEvent"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["handleBrowserEvent"]++;
        }
        ;
        /** @type {boolean} */
        var bContinue = true;
        /** @type {UCF_BrowserEvent} */
        var oBrowserEvent;
        /** @type {HTMLElement} */
        var oSourceElement;
        /** @type {number} */
        var i;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {string} */
        var sHandlerName;
        /** @type {TODO} */
        var mEventParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomEvent) === 'object', "typeof(oDomEvent) === 'object'", "BrowserWindow.js(786): handleBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomEvent != null, "oDomEvent != null", "BrowserWindow.js(787): handleBrowserEvent");
        }
        ;

        // detaching events in destroy in NOT enough to prevent unload event to be
        // dispatched by already-destroyed LS instance: WDA will call LS.destroy() in
        // it's unload handler which means the event dispatching in the browser is
        // 'in progress' and it will still dispatch the unload event to LS!
        if (this["bDestroyed"] && oDomEvent["type"] === 'unload') {
            return false;
        }

        // Drop unnecessary events as soon as possible
        if (this["bIsUnnecessaryEvent"](oDomEvent)) {
            return false;
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Handle browser event: ' + oDomEvent["type"], "BrowserWindow.js(802): handleBrowserEvent");
        }
        ;

        oBrowserEvent = this["oBrowserEventPool"]["oBorrowObject"](oDomEvent);

        this["preProcessLostFocus"](oBrowserEvent);
        if (this["aIsolatedAreas"]["length"] > 0) {
            oSourceElement = oDomEvent["target"] || oDomEvent["srcElement"];

            // event source could be window or body object
            if (oSourceElement && oSourceElement["parentNode"]) {
                for (i = 0; i < this["aIsolatedAreas"]["length"]; i++) {
                    oDomRef = this["aIsolatedAreas"][i];

                    if (typeof (oDomRef) === 'string') {
                        oDomRef = UCF_DomUtil["$"](oDomRef);
                    }

                    if (UCF_DomUtil["bContains"](oDomRef, oSourceElement)) {
                        delete oBrowserEvent["bContinue"];
                        this["fireEvent"](this["E_EVENTS"]["IsolatedAreaEvent"], {
                            "oBrowserEvent": oBrowserEvent,
                            "type": oBrowserEvent["sGetName"]()
                        });
                        // eslint-disable-next-line max-depth
                        if (typeof (oBrowserEvent["bContinue"]) === 'undefined') {
                            bContinue = false;
                        } else if (!oBrowserEvent["bContinue"]) {
                            oBrowserEvent["cancel"]();
                            bContinue = false;
                        }
                    }
                }
            }
        }

        if (bContinue) {
            // Process local handler functions first
            sHandlerName = 'on' + oBrowserEvent["sGetName"]();
            if (this[sHandlerName]) {
                this[sHandlerName](oBrowserEvent);
            }

            if (this["bEventPlayer"]) {
                mEventParams = {"oBrowserEvent": oBrowserEvent};
                this["fireEvent"](this["E_EVENTS"]["EventPlayer"], mEventParams);
            }

            this["handleLSTouchGestures"](oBrowserEvent);

            this["processBrowserEvent"](oBrowserEvent);
        }
        this["postProcessLostFocus"](oBrowserEvent);

        // If we dispatched a click on a IFrame-PopupWindow close button,
        // this LS instance is now thoroughly destroyed...
        if (this["oBrowserEventPool"]) {
            this["oBrowserEventPool"]["returnObject"](oBrowserEvent);
        }

        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["handleBrowserEvent"] = 0;
    }
    ;

    /**
     * Setup and process special handlers to map touch events to ls-events for
     * gestures. Note: 'Detector' implementation should have no side-effects and
     * NOT change the BrowserEvent or BrowserWindow properties
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["handleLSTouchGestures"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["handleLSTouchGestures"]++;
        }
        ;
        /** @type {string} */
        var sHandlerName = 'on' + oBrowserEvent["sGetName"]();
        /** @type {boolean} */
        var bIsTouchEvent = UCF_StringUtil["bStartsWith"](sHandlerName, 'ontouch') ||
            UCF_StringUtil["bStartsWith"](sHandlerName, 'ongesture');
        /** @type {UCF_LongTapDetector} */
        var oLongTapDetector;
        /** @type {UCF_SwipeDetector} */
        var oSwipeDetector;
        /** @type {UCF_ZoomDetector} */
        var oZoomDetector;
        /** @type {UCF_TapDetector} */
        var oTapDetector;

        // LongTap: Chrome on Android has emulated contextmenu event!
        // Swipe: Not yet supported: Need to change detection of pinch because
        //        Android/Chrome has no gesturestart event
        // Zoom: Not yet supported on Android/Chrome
        //	if (UCF_System.sInteractionType === 'TOUCH' /*&& !UCF_UserAgent.bIsAndroid()*/ ) {
        if (bIsTouchEvent) {
            oLongTapDetector = this["oGetLongTapDetector"]();
            if (sHandlerName in oLongTapDetector) {
                oLongTapDetector[sHandlerName](oBrowserEvent);
            }

            oSwipeDetector = this["oGetSwipeDetector"]();
            if (sHandlerName in oSwipeDetector) {
                oSwipeDetector[sHandlerName](oBrowserEvent);
            }
        }

        oZoomDetector = this["oGetZoomDetector"]();
        if (sHandlerName in oZoomDetector) {
            oZoomDetector[sHandlerName](oBrowserEvent);
        }
        //}

        if (bIsTouchEvent) {
            oTapDetector = this["oGetTapDetector"]();
            if (sHandlerName in oTapDetector) {
                oTapDetector[sHandlerName](oBrowserEvent);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["handleLSTouchGestures"] = 0;
    }
    ;
// #region LongTapDetector ----------------------------------------------------
    /**
     * @private
     * @return {UCF_LongTapDetector}
     */
    UCF_BrowserWindow["prototype"]["oGetLongTapDetector"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetLongTapDetector"]++;
        }
        ;
        if (!this["oLongTapDetector"]) {
            /** @type {UCF_LongTapDetector} */
            this["oLongTapDetector"] = new (UCF_ClassLoader["oGetClass"]("UCF_LongTapDetector"))();

            this["oLongTapDetector"]["attachEvent"](this["oLongTapDetector"]["E_EVENTS"]["LongTap"], this, 'onLongTap');
            this["oLongTapDetector"]["attachEvent"](this["oLongTapDetector"]["E_EVENTS"]["LongTapEnd"], this, 'onLongTapEnd');
            this["oLongTapDetector"]["attachEvent"](this["oLongTapDetector"]["E_EVENTS"]["ExtraLongTap"], this, 'onExtraLongTap');
            this["oLongTapDetector"]["attachEvent"](this["oLongTapDetector"]["E_EVENTS"]["ExtraLongTapEnd"], this, 'onExtraLongTapEnd');
        }

        return this["oLongTapDetector"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetLongTapDetector"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onLongTap"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onLongTap"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: longtap', "BrowserWindow.js(941): onLongTap");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["longtap"], oEvent["mGetParameters"]()["oBrowserEvent"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onLongTap"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onLongTapEnd"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onLongTapEnd"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: longtapend', "BrowserWindow.js(950): onLongTapEnd");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["longtapend"], oEvent["mGetParameters"]()["oBrowserEvent"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onLongTapEnd"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onExtraLongTap"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onExtraLongTap"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: extralongtap', "BrowserWindow.js(959): onExtraLongTap");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["extralongtap"], oEvent["mGetParameters"]()["oBrowserEvent"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onExtraLongTap"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onExtraLongTapEnd"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onExtraLongTapEnd"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: extralongtapend', "BrowserWindow.js(968): onExtraLongTapEnd");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["extralongtapend"], oEvent["mGetParameters"]()["oBrowserEvent"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onExtraLongTapEnd"] = 0;
    }
    ;
// #endregion
// #region SwipeDetector ------------------------------------------------------
    /**
     * @private
     * @return {UCF_SwipeDetector}
     */
    UCF_BrowserWindow["prototype"]["oGetSwipeDetector"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetSwipeDetector"]++;
        }
        ;
        if (!this["oSwipeDetector"]) {
            /** @type {UCF_SwipeDetector} */
            this["oSwipeDetector"] = new (UCF_ClassLoader["oGetClass"]("UCF_SwipeDetector"))();

            this["oSwipeDetector"]["attachEvent"](this["oSwipeDetector"]["E_EVENTS"]["Swipe"], this, 'onSwipe');
            this["oSwipeDetector"]["attachEvent"](this["oSwipeDetector"]["E_EVENTS"]["MoveInfo"], this, 'onMoveInfo');
        }

        return this["oSwipeDetector"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetSwipeDetector"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onSwipe"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onSwipe"]++;
        }
        ;
        /** @type {UCF_SwipeDetector_SwipeParameters} */
        var mParameters = oEvent["mGetParameters"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: swipe' + mParameters["sDirection"], "BrowserWindow.js(997): onSwipe");
        }
        ;

        if (this["fireLSEvent"](
            this["E_LS_EVENTS"]['swipe' + mParameters["sDirection"]],
            mParameters["oBrowserEvent"]
        )) {
            mParameters["oBrowserEvent"]["cancel"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onSwipe"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onMoveInfo"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onMoveInfo"]++;
        }
        ;
        /** @type {UCF_SwipeDetector_MoveInfoParameters} */
        var mParameters = oEvent["mGetParameters"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: moveinfo', "BrowserWindow.js(1015): onMoveInfo");
        }
        ;

        mParameters["oBrowserEvent"]["oMoveDistance"] = {
            "iX": mParameters["iX"],
            "iY": mParameters["iY"]
        };
        mParameters["oBrowserEvent"]["bSwipeThresholdExceeded"] = mParameters["bThresholdExceeded"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onMoveInfo"] = 0;
    }
    ;
// #endregion
// #region ZoomDetector -------------------------------------------------------
    /**
     * @private
     * @return {UCF_ZoomDetector}
     */
    UCF_BrowserWindow["prototype"]["oGetZoomDetector"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetZoomDetector"]++;
        }
        ;
        if (!this["oZoomDetector"]) {
            /** @type {UCF_ZoomDetector} */
            this["oZoomDetector"] = new (UCF_ClassLoader["oGetClass"]("UCF_ZoomDetector"))();

            this["oZoomDetector"]["attachEvent"](
                this["oZoomDetector"]["E_EVENTS"]["ZoomChange"],
                this,
                'onZoomChange'
            );
        }

        return this["oZoomDetector"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetZoomDetector"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onZoomChange"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onZoomChange"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: zoomchange', "BrowserWindow.js(1049): onZoomChange");
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["ZoomChange"], {
            "bZoomIn": oEvent["mGetParameters"]()["bZoomIn"]
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onZoomChange"] = 0;
    }
    ;
// #endregion
// #region TapDetector --------------------------------------------------------
    /**
     * @private
     * @return {UCF_TapDetector}
     */
    UCF_BrowserWindow["prototype"]["oGetTapDetector"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetTapDetector"]++;
        }
        ;
        if (!this["oTapDetector"]) {
            /** @type {UCF_TapDetector} */
            this["oTapDetector"] = new (UCF_ClassLoader["oGetClass"]("UCF_TapDetector"))();

            this["oTapDetector"]["attachEvent"](this["oTapDetector"]["E_EVENTS"]["Tap"], this, 'onTap');
        }

        return this["oTapDetector"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetTapDetector"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_BrowserWindow["prototype"]["onTap"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onTap"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: tap', "BrowserWindow.js(1076): onTap");
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["Tap"], oEvent["mGetParameters"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onTap"] = 0;
    }
    ;
// #endregion

    /**
     * Process browser events.
     * Dependent on the current state, no events, only drag events or
     * all events are passed to the corresponding controls
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {void}
     */
    UCF_BrowserWindow["prototype"]["processBrowserEvent"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["processBrowserEvent"]++;
        }
        ;
        /** @type {boolean} */
        var bProcessDragDrop;
        /** @type {string} */
        var sName;
        /** @type {UCF_BrowserWindow_EventParameters} */
        var mEventParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent != null, "oBrowserEvent != null", "BrowserWindow.js(1098): processBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(1099): processBrowserEvent");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, '->(' + oBrowserEvent["sGetName"]() + ')', "BrowserWindow.js(1101): processBrowserEvent");
        }
        ;

        bProcessDragDrop = (
            this["bLockedAsDragDrop"]() &&
            this["bIsDragDropEvent"](oBrowserEvent["sGetName"]())
        );

        // if browser is locked do not process any user triggered events
        if (
            this["bIsLocked"]() &&
            oBrowserEvent["bIsUserTriggered"]() &&
            !bProcessDragDrop &&
            !oBrowserEvent["bIsLoadingAnimationTriggered"]()
        ) {
            // cancelling the event causes problems during d&d
            if (!this["bLockedAsDragDrop"]()) {
                // Lock also scrolling
                if (oBrowserEvent["sGetName"]() === 'scroll') {
                    this["restoreScrollPosition"](oBrowserEvent["oGetSource"]());
                }
                if (oBrowserEvent["sGetName"]() === 'beforeunload') {
                    // special handling for beforeunload as oBrowserEvent.cancel(); would
                    // set preventDefault. PreventDefault causes a dirty loss popup of the
                    // browser which should not be the case. Original issue:
                    // ClickjackingFramingProtection.js could not be loaded -> lightspeed
                    // is locked but closing the window causes a data loss popup

                    // TODO Do we need a special handling here?
                } else {
                    oBrowserEvent["cancel"]();
                }
            }
        } else if (oBrowserEvent["bLocked"]) {
            // if event occurred in a control inside a locked container it should be
            // ignored
            oBrowserEvent["cancel"]();
        } else {
            sName = oBrowserEvent["sGetName"]();
            // Record previous scrollposition for scroll locking
            if (sName === 'scroll') {
                this["storeScrollPosition"](oBrowserEvent["oGetSource"]());
            }

            // if the event already had been canceled return
            if (!oBrowserEvent["bCancelBubble"]) {
                mEventParams = {"oBrowserEvent": oBrowserEvent};

                // fire AnyEvent for any browser event occuring
                this["fireEvent"](this["E_EVENTS"]["AnyEvent"], mEventParams);

                // fire RecorderEvent for Selenium before control event
                this["fireEvent"](this["E_EVENTS"]["RecorderEvent"], mEventParams);

                // fire ControlEvent for any browser event occuring (needs to be fired
                // separately to keep correct order of AnyEvent and control events)
                this["fireEvent"](this["E_EVENTS"]["ControlEvent"], mEventParams);

                if (oBrowserEvent["bPreventBlur"]) {
                    this["bPreventBlur"] = oBrowserEvent["bPreventBlur"];
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["processBrowserEvent"] = 0;
    }
    ;

    /**
     * Determine if event is necessary
     *
     * @private
     * @param {Event} oDomEvent
     * @return {boolean} bIsUnnecessaryEvent
     */
    UCF_BrowserWindow["prototype"]["bIsUnnecessaryEvent"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bIsUnnecessaryEvent"]++;
        }
        ;
        /** @type {string} */
        var sType = oDomEvent["type"];
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {number} */
        var iWidth;
        /** @type {number} */
        var iHeight;

        // In Internet Explorer nested tables sometimes create a huge amount of
        // resize events without any actual resizing
        if (sType === 'resize' && UCF_UserAgent["bIsIE"]()) {
            oDomRef = oDomEvent["srcElement"] || oDomEvent["target"];
            if (oDomRef && oDomRef["nodeType"] && oDomRef["nodeType"] === 1) {
                iWidth = oDomRef["offsetWidth"];
                iHeight = oDomRef["offsetHeight"];
                if (oDomRef["iLastWidth"] === iWidth &&
                    oDomRef["iLastHeight"] === iHeight) {
                    return true;
                } else {
                    oDomRef["iLastWidth"] = iWidth;
                    oDomRef["iLastHeight"] = iHeight;
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bIsUnnecessaryEvent"] = 0;
    }
    ;

    /**
     * @protected
     * @return {UCF_DragAndDropManager}
     *
     * @see {@link UCF_AcfAdapter#getDragSession}
     * @see {@link UCF_AcfAdapter#createDragSession}
     * @see {@link UCF_AcfAdapter#destroyDragSession}
     * @see {@link UCF_LS#sCreateDragSession}
     * @see {@link UCF_LS#sGetDragSession}
     * @see {@link UCF_LS#destroyDragSession}
     */
    UCF_BrowserWindow["prototype"]["oGetDragAndDropManager"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetDragAndDropManager"]++;
        }
        ;
        /** @type {UCF_BrowserWindow_MouseEventParameters} */
        var mEventParams;

        if (!this["oDragAndDropManager"]) {
            this["oDragAndDropManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_DragAndDropManager"))(this);
            // fire DDManagerCreate to pass oLS to DDManager
            mEventParams = {"oDragAndDropManager": this["oDragAndDropManager"]};
            this["fireEvent"](this["E_EVENTS"]["DDManagerCreate"], mEventParams);
        }

        return this["oDragAndDropManager"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetDragAndDropManager"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["oncontextmenu"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oncontextmenu"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'oncontextmenu', "BrowserWindow.js(1232): oncontextmenu");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyContextMenu"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oncontextmenu"] = 0;
    }
    ;

    /**
     * @private
     * The visibilitychange event is fired when the content of a tab has become
     * visible or has been hidden.
     * @param {UCF_BrowserEvent} oBrowserEvent
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange
     */
    UCF_BrowserWindow["prototype"]["onvisibilitychange"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onvisibilitychange"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'onvisivibilitychange', "BrowserWindow.js(1248): onvisibilitychange");
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["VisibilityChange"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onvisibilitychange"] = 0;
    }
    ;

    /**
     * The beforeunload event is fired when the browser (tab) is closed.
     * In case of a return value the browser will ask for confirmation if the
     * browser should be closed.
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {void}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload
     */
    UCF_BrowserWindow["prototype"]["onbeforeunload"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onbeforeunload"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'onBeforeUnload', "BrowserWindow.js(1264): onbeforeunload");
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["BeforeUnload"], oBrowserEvent);

        // to force a confirmation popup use preventDefault and for Chrome use a
        // returnValue != undefined or null
        // oBrowserEvent.oDomEvent.preventDefault();
        // oBrowserEvent.oDomEvent.returnValue = "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onbeforeunload"] = 0;
    }
    ;

    /**
     * Handle onmousewheel (mouse wheel for IE only)
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     *
     * @see {@link UCF_BrowserWindow#DOMMouseScroll}
     */
    UCF_BrowserWindow["prototype"]["onmousewheel"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmousewheel"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'onmousewheel', "BrowserWindow.js(1282): onmousewheel");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["mousewheel"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmousewheel"] = 0;
    }
    ;

    /**
     * Handle onDOMMouseScroll (mouse wheel for FireFox only)
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     *
     * @see {@link UCF_BrowserWindow#onmousewheel}
     */
    UCF_BrowserWindow["prototype"]["onDOMMouseScroll"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onDOMMouseScroll"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'DOMMouseScroll', "BrowserWindow.js(1295): onDOMMouseScroll");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["mousewheel"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onDOMMouseScroll"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onorientationchange"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onorientationchange"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: fire orientationchange', "BrowserWindow.js(1304): onorientationchange");
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["OrientationChange"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onorientationchange"] = 0;
    }
    ;

    /**
     * Handle onselect
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {void}
     */
    UCF_BrowserWindow["prototype"]["onselect"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onselect"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'onselect', "BrowserWindow.js(1316): onselect");
        }
        ;
        // oBrowserEvent.cancel();
        oBrowserEvent["oDomEvent"]["returnValue"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onselect"] = 0;
    }
    ;

    /**
     * Processing of 'focuslost logic'. This is needed as isolated areas can
     * terminate the standard handleBrowserEvent processing
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["preProcessLostFocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["preProcessLostFocus"]++;
        }
        ;
        /** @type {string} */
        var sName = oBrowserEvent["sName"];
        /** @type {HTMLElement} */
        var oSource;

        if (
            sName === 'focusin' ||
            (
                sName === 'focus' &&
                UCF_UserAgent["bIsFirefox"]() &&
                !UCF_UserAgent["bIsFirefox"](52) // eslint-disable-line no-magic-numbers
            )
        ) {
            // Workaround for IE behaviour: Detect focus on flash which triggered open
            // of external window via portal navigation. This must be supressed,
            // otherwise the main window will have bFocussed=true and pop into the
            // foreground and hide new window !
            if (
                (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) &&
                this["bIsLockedByType"](UCF_BrowserWindow["LOCKTYPES"]["PENDINGNAVIGATION"])
            ) {
                oSource = oBrowserEvent["oGetSource"]();
                if (
                    oSource &&
                    oSource["getAttribute"] &&
                    oSource["getAttribute"]('ct') === 'FLC'
                ) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Ignoring focus on flash during pending navigation (open external window)', "BrowserWindow.js(1356): preProcessLostFocus");
                    }
                    ;

                    return;
                }
            }

            // If window is not marked as focus, throw Focus event
            this["oNextFocusDomRef"] = oBrowserEvent["oGetSource"]();
            if (!this["bFocussed"]) {
                this["bFocussed"] = true;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Focus', "BrowserWindow.js(1366): preProcessLostFocus");
                }
                ;
                this["fireEvent"](this["E_EVENTS"]["Focus"]);
            }
            // Using the IE focusin event because it bubbles
            oBrowserEvent["oFromElement"] = this["oCurrentDomRef"];

            this["oNextFocusDomRef"] = oBrowserEvent["oGetSource"]();
            this["oCurrentDomRef"] = oBrowserEvent["oGetSource"]();
            UCF_DomUtil["setActiveElement"](this["oCurrentDomRef"]);
        } else if (sName === 'focusout' ||
            (
                sName === 'blur' &&
                UCF_UserAgent["bIsFirefox"]() &&
                !UCF_UserAgent["bIsFirefox"](52) // eslint-disable-line no-magic-numbers
            )
        ) {
            // Using the IE focusout event because it bubbles
            this["oNextFocusDomRef"] = null;
            this["oPreviousFocusDomRef"] = this["oCurrentDomRef"];

            // this.oCurrentDomRef might be null if you change the window
            if (this["oCurrentDomRef"]) {
                UCF_DomUtil["setActiveElement"](this["oCurrentDomRef"]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["preProcessLostFocus"] = 0;
    }
    ;

    /**
     * Processing of 'focuslost logic'. This is needed as isolated areas can
     * terminate the standard handleBrowserEvent processing
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_BrowserWindow["prototype"]["postProcessLostFocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["postProcessLostFocus"]++;
        }
        ;
        /** @type {string} */
        var sName = oBrowserEvent["sName"];

        if (sName === 'focusout' ||
            (
                sName === 'blur' &&
                UCF_UserAgent["bIsFirefox"]() &&
                !UCF_UserAgent["bIsFirefox"](52) // eslint-disable-line no-magic-numbers
            )
        ) {
            if (this["bPreventBlur"]) {
                this["bPreventBlur"] = false;
            } else {
                UCF_JsUtil["delayedCall"](0, this, 'checkForLostFocus', [oBrowserEvent]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["postProcessLostFocus"] = 0;
    }
    ;

    /**
     * Fires the focus lost event if control have to close domrefs or cleanup
     * the focuslost event is fired it the current window looses the focus
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["checkForLostFocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["checkForLostFocus"]++;
        }
        ;
        // Safari fires blur when innerHTML-exchange remove the focussed element.
        // Therefore this blur has to be ignored
        if (
            !UCF_UserAgent["bIsWebKit"]() ||
            UCF_DomUtil["bIsInActiveDom"](this["oCurrentDomRef"])
        ) {
            if (this["oNextFocusDomRef"] == null) {
                //If window is focussed, throw Blur event
                if (this["bFocussed"]) {
                    this["bFocussed"] = false;
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Blur', "BrowserWindow.js(1437): checkForLostFocus");
                    }
                    ;
                    this["fireEvent"](this["E_EVENTS"]["Blur"]);
                }
            }

            if (this["oNextFocusDomRef"] == null ||
                (this["oNextFocusDomRef"]["tagName"] &&
                    this["oNextFocusDomRef"]["tagName"] === 'IFRAME')
            ) {
                oBrowserEvent["oDomEvent"] = {
                    "srcElement": null,
                    "type": 'lsfocuslost'
                };
                if (UCF_UserAgent["bIsDesktop"]()) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'fire lsfocuslost', "BrowserWindow.js(1451): checkForLostFocus");
                    }
                    ;
                    this["fireLSEvent"](this["E_LS_EVENTS"]["focuslost"], oBrowserEvent);
                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'lsfocuslost suppressed for tablet and phone', "BrowserWindow.js(1454): checkForLostFocus");
                    }
                    ;
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["checkForLostFocus"] = 0;
    }
    ;

    /**
     * Handle onfocusin
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {void}
     */
    UCF_BrowserWindow["prototype"]["onfocusin"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onfocusin"]++;
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["focus"], oBrowserEvent);
        this["fireLSEvent"](this["E_LS_EVENTS"]["containerfocus"], oBrowserEvent);
        // if the control handled the focus event and focuses another dom element
        // another focus event is processed and the this.oCurrentDomRef is set to the
        // new element. It also will fire an focusin event for the new element
        // immediately. after returning the from this new event queue the old focus
        // is is processed for an element that does not have the focus anymore. To
        // avoid we test if the this.oCurrentDomRef is still the same as the source
        // of the BrowserEvent. if not we do not fire an accessibility event.
        if (window["UCF_System"]["bIs508"] || window["UCF_System"]["bIsAria"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["accessibility"], oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onfocusin"] = 0;
    }
    ;

    /**
     * Handle onfocus
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onfocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onfocus"]++;
        }
        ;
        // Using the FF focus event because it bubbles
        // eslint-disable-next-line no-magic-numbers
        if (UCF_UserAgent["bIsFirefox"]() && !UCF_UserAgent["bIsFirefox"](52)) {
            this["onfocusin"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onfocus"] = 0;
    }
    ;

    /**
     * Handle onblur
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onblur"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onblur"]++;
        }
        ;
        // Using the FF focus event because it bubbles
        // eslint-disable-next-line no-magic-numbers
        if (UCF_UserAgent["bIsFirefox"]() && !UCF_UserAgent["bIsFirefox"](52)) {
            this["onfocusout"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onblur"] = 0;
    }
    ;

    /**
     * Handle onfocusout
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onfocusout"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onfocusout"]++;
        }
        ;
        if (!this["bPreventBlur"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["blur"], oBrowserEvent);
            this["fireLSEvent"](this["E_LS_EVENTS"]["containerblur"], oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onfocusout"] = 0;
    }
    ;

    /**
     * Handles onkeyup centrally
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onkeyup"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onkeyup"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();

        if (iKey === UCF_KeyCodes["ALT"]) {
            UCF_KeyboardHelper["hideAccessKeys"]();
        }

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyKeyUp"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onkeyup"] = 0;
    }
    ;

    /**
     * Fire central events for keyboard navigation
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {void}
     */
    UCF_BrowserWindow["prototype"]["onkeydown"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onkeydown"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();
        /** @type {boolean} */
        var bCtrl = oBrowserEvent["bCtrl"]();
        /** @type {boolean} */
        var bShift = oBrowserEvent["bShift"]();
        /** @type {boolean} */
        var bAlt = oBrowserEvent["bAlt"]();
        /** @type {boolean} */
        var bArrowKey;
        /** @type {UCF_BrowserWindow_KeyboardEventParameters} */
        var mEventParams;

        // Workaround for nonfunctional keyup event on IE
        if (!bAlt) {
            UCF_KeyboardHelper["hideAccessKeys"]();
        }

        // AccessKey visualization for alt and shift+alt
        // Alt + Down/Up/Left/Right are Hotkeys and have to be excluded from the
        // access keys
        bArrowKey = (
            iKey === UCF_KeyCodes["ARROW_DOWN"] ||
            iKey === UCF_KeyCodes["ARROW_UP"] ||
            iKey === UCF_KeyCodes["ARROW_LEFT"] ||
            iKey === UCF_KeyCodes["ARROW_RIGHT"]
        );

        if (bAlt && !bCtrl && !bArrowKey) {
            UCF_KeyboardHelper["showAccessKeys"]();
        }

        // special handling for ctrl+shift+alt used for debug or accessibility
        // reasons
        if (bCtrl && bAlt && bShift) {
            // Toggle Message Area Focus, if activated by the framework
            if (iKey === UCF_KeyCodes["M"]) {
                this["fireEvent"](this["E_EVENTS"]["ToggleMessageFocus"]);

                return;
            }

            // enable / disable tutor texts
            if (
                iKey === UCF_KeyCodes["T"] &&
                window["UCF_System"]["bIs508"] &&
                !__UCF_DEBUG__
            ) {
                window["UCF_System"]["bAccTutor"] = !window["UCF_System"]["bAccTutor"];
                // TODO Implement real session storage

                return;
            }

            // Hint: the WDA wants to register special helpers on interal systems also
            // in the non-ClientDebug mode; current implementation also enables to add
            // helpers via FireBug etc.
            // CSN: 252119 2012 keycodes 1 or 2 used for onlsacchierarchy event
            if (!(iKey === UCF_KeyCodes["_1"] || iKey === UCF_KeyCodes["_2"])) {
                // add all exceptions of ctrl+alt+shift+keyCode are handled in
                // findMatchingLSEvents all others are might debug commands
                mEventParams = {"iKey": iKey, "oBrowserEvent": oBrowserEvent};
                this["fireEvent"](this["E_EVENTS"]["Debug"], mEventParams);

                // as long as we don't fire LS events on Ctrl+Shift+Alt+<?> we can return
                // here otherwise remove it
                return;
            }
        }

        this["findMatchingLSEvents"](oBrowserEvent);

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyKeyDown"](oBrowserEvent);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onkeydown"] = 0;
    }
    ;

    /**
     * Handles the onresize event of the browser.
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event object that
     * occurred
     */
    UCF_BrowserWindow["prototype"]["onresize"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onresize"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oSource = oBrowserEvent["oGetSource"]();

        if (!oSource || oSource === window || oSource === document) {
            UCF_JsUtil["delayedCall"](0, this, 'notifyLayoutChange', [true]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onresize"] = 0;
    }
    ;

    /**
     * Returns information on a given browser event
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @return {UCF_BrowserWindow_EventInfo}
     */
    UCF_BrowserWindow["prototype"]["oGetBrowserEventInfo"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["oGetBrowserEventInfo"]++;
        }
        ;
        /** @type {boolean} */
        var bCtrl = oBrowserEvent["bCtrl"]();
        /** @type {boolean} */
        var bShift = oBrowserEvent["bShift"]();
        /** @type {boolean} */
        var bAlt = oBrowserEvent["bAlt"]();

        return {
            "bCtrl": bCtrl,
            "bShift": bShift,
            "bAlt": bAlt,
            "bCtrlOnly": bCtrl && !bShift && !bAlt,
            "bAltOnly": bAlt && !bCtrl && !bShift,
            "bShiftOnly": bShift && !bCtrl && !bAlt,
            //bCtrlAlt : bCtrl && bAlt && !bShift,
            "bNoModifiers": !bCtrl && !bAlt && !bShift
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["oGetBrowserEventInfo"] = 0;
    }
    ;

    /**
     * Create custom LS events for special keys
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["findMatchingLSEvents"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["findMatchingLSEvents"]++;
        }
        ;  // eslint-disable-line complexity
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();
        /** @type {UCF_BrowserWindow_EventInfo} */
        var oEventInfo = this["oGetBrowserEventInfo"](oBrowserEvent);
        /** @type {string} */
        var sEventName;

        /* beautify preserve:start */
        // home
        if (iKey === UCF_KeyCodes["HOME"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["home"], oBrowserEvent, true);
            if (oEventInfo["bCtrlOnly"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["top"], oBrowserEvent);
            }
        } else
            // end
        if (iKey === UCF_KeyCodes["END"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["end"], oBrowserEvent, true);
            if (oEventInfo["bCtrlOnly"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["bottom"], oBrowserEvent);
            }
        } else
            // pageup
        if (iKey === UCF_KeyCodes["PAGE_UP"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["pageup"], oBrowserEvent, true);
        } else
            // pagedown
        if (iKey === UCF_KeyCodes["PAGE_DOWN"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["pagedown"], oBrowserEvent, true);
        } else
            // space and select
        if (iKey === UCF_KeyCodes["SPACE"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["select"], oBrowserEvent, true);
            this["fireLSEvent"](this["E_LS_EVENTS"]["space"], oBrowserEvent, true);
        } else
            // enter and select
        if (iKey === UCF_KeyCodes["ENTER"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["select"], oBrowserEvent, true);
            this["fireLSEvent"](this["E_LS_EVENTS"]["enter"], oBrowserEvent, true);
        } else
            // collapseall
        if (
            (iKey === UCF_KeyCodes["NUMPAD_ASTERISK"] && oEventInfo["bNoModifiers"]) ||
            (iKey === UCF_KeyCodes["PLUS"] && oEventInfo["bShift"])
        ) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["collapseall"], oBrowserEvent);
        } else
            // expand
        if (UCF_KeyboardHelper["bIsPlusKey"](iKey)) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["expand"], oBrowserEvent, true);
        } else
            // collapse
        if (UCF_KeyboardHelper["bIsMinusKey"](iKey)) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["collapse"], oBrowserEvent, true);
        } else
            // escape
        if (iKey === UCF_KeyCodes["ESCAPE"] && oEventInfo["bNoModifiers"]) {
            if (this["oDragAndDropManager"]) {
                this["oDragAndDropManager"]["notifyEscapePressed"](oBrowserEvent);
            }
            this["fireLSEvent"](this["E_LS_EVENTS"]["escape"], oBrowserEvent);
        } else
            // show
        if (iKey === UCF_KeyCodes["F4"] && oEventInfo["bNoModifiers"]) {
            // alt+arrow down fires show too
            this["fireLSEvent"](this["E_LS_EVENTS"]["show"], oBrowserEvent);
        } else
            // tab
        if (iKey === UCF_KeyCodes["TAB"] && !oEventInfo["bAlt"] && !oEventInfo["bCtrl"]) {
            this["tabKeyToLSEvent"](oBrowserEvent);
        } else
            // skipping (standard and alternative mode)
        if (UCF_KeyboardHelper["bIsSkippingShortcut"](oBrowserEvent, this["bAlternativeKeyboardHandling"])) {
            sEventName = (iKey === UCF_KeyCodes["ARROW_UP"] || (iKey === UCF_KeyCodes["F6"] && oEventInfo["bShift"]))
                ? this["E_LS_EVENTS"]["skipback"]
                : this["E_LS_EVENTS"]["skipforward"];
            this["fireLSEvent"](sEventName, oBrowserEvent);
        } else
            // contextmenu Shift-F10 hack
        if (iKey === UCF_KeyCodes["F10"] && oEventInfo["bShiftOnly"]) {
            this["fireLSEvent"]('contextmenu', oBrowserEvent);
        } else
            // announce accessibility container
        if (
            window["UCF_System"]["bIs508"] &&
            (iKey === UCF_KeyCodes["_1"] || iKey === UCF_KeyCodes["_2"]) &&
            oEventInfo["bCtrl"] &&
            oEventInfo["bAlt"] &&
            oEventInfo["bShift"]
        ) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["acchierarchy"], oBrowserEvent);
        } else if (UCF_UserAgent["bIsMacOs"]() && oEventInfo["bCtrlOnly"]) {
            // [CMD][UP] (on MacOS) == [HOME]
            if (iKey === UCF_KeyCodes["ARROW_UP"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["home"], oBrowserEvent);
            } else
                // [CMD][DOWN] (on MacOS) == [END]
            if (iKey === UCF_KeyCodes["ARROW_DOWN"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["end"], oBrowserEvent);
            }
        }
        // beautify preserve:end

        this["arrowKeyToLSEvent"](oBrowserEvent);

        // hotkeys: all other events could be hotkeys
        this["fireHotkeys"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["findMatchingLSEvents"] = 0;
    }
    ;

    /**
     * Create custom LS events for TAB key
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["tabKeyToLSEvent"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["tabKeyToLSEvent"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();
        /** @type {UCF_BrowserWindow_EventInfo} */
        var oEventInfo = this["oGetBrowserEventInfo"](oBrowserEvent);
        /** @type {string} */
        var sEventName = oEventInfo["bShift"]
            ? this["E_LS_EVENTS"]["tabprevious"]
            : this["E_LS_EVENTS"]["tabnext"];

        if (iKey === UCF_KeyCodes["TAB"] && !oEventInfo["bAlt"] && !oEventInfo["bCtrl"]) {
            this["fireLSEvent"](sEventName, oBrowserEvent);
            // TabSequence:
            // See Control.onlstabsequencenext()
            // It will overrule tab-chain for Control that implement lstabnext() and
            // use Control.focusNextElement. It is currently not possible to overrule
            // the tab-sequence inside containers that implement lstabnext() but do NOT
            // use Control.focusNextControl(), e.g. SapTable
            if (
                this["mTabSequences"] &&
                !window["UCF_System"]["bIs508"] &&
                iKey === UCF_KeyCodes["TAB"] &&
                !oEventInfo["bAlt"] &&
                !oEventInfo["bCtrl"]
            ) {
                sEventName = oEventInfo["bShift"]
                    ? this["E_LS_EVENTS"]["tabsequenceprevious"]
                    : this["E_LS_EVENTS"]["tabsequencenext"];
                this["fireLSEvent"](sEventName, oBrowserEvent);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["tabKeyToLSEvent"] = 0;
    }
    ;

    /**
     * Create custom LS events for hotkeys
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["fireHotkeys"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["fireHotkeys"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();
        /** @type {UCF_BrowserWindow_EventInfo} */
        var oEventInfo = this["oGetBrowserEventInfo"](oBrowserEvent);

        //Check if browser event was canceled
        //Shift+F10 is context menu and the event is always canceled!!
        if (!oBrowserEvent["bIsDomEventCanceled"]()) {

            if (iKey === 13 && oBrowserEvent["bIsTouchInteraction"]()) {
                //IOS enables shift automatically for the first character in an InputField. (tested with onscreen keyboard and attached keyboard and in both cases was bIsTouchInteraction = true)
                //Ignore shift for enter (iKey==13)
                oEventInfo["bShift"] = false;
                if (oEventInfo["bShiftOnly"]) {
                    oEventInfo["bShiftOnly"] = false;
                }
            }

            // hotkeys: all other events could be hotkeys
            if (UCF_KeyboardHelper["bIsValidHotkey"](
                iKey,
                oEventInfo["bCtrl"],
                oEventInfo["bAlt"],
                oEventInfo["bShift"],
                this["bAlternativeKeyboardHandling"]
            )) {
                if (
                    oEventInfo["bCtrlOnly"] &&
                    iKey === UCF_KeyCodes["C"] &&
                    UCF_DomUtil["sGetSelectionText"](document["body"])
                ) {
                    // Do nothing because it is a copy of selected text
                } else {
                    this["fireLSEvent"](this["E_LS_EVENTS"]["hotkey"], oBrowserEvent);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["fireHotkeys"] = 0;
    }
    ;

    /**
     * Create custom LS events for arrow keys
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["arrowKeyToLSEvent"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["arrowKeyToLSEvent"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();
        /** @type {UCF_BrowserWindow_EventInfo} */
        var oEventInfo = this["oGetBrowserEventInfo"](oBrowserEvent);
        /** @type {number} */
        var iNextKey;
        /** @type {number} */
        var iPreviousKey;

        /* beautify preserve:start */
        // down && show
        if (iKey === UCF_KeyCodes["ARROW_DOWN"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["down"], oBrowserEvent, true);
            if (oEventInfo["bAltOnly"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["show"], oBrowserEvent);
            }
        } else
            // up
        if (iKey === UCF_KeyCodes["ARROW_UP"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["up"], oBrowserEvent, true);
        } else
            // left
        if (iKey === UCF_KeyCodes["ARROW_LEFT"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["left"], oBrowserEvent, true);
        } else
            // right
        if (iKey === UCF_KeyCodes["ARROW_RIGHT"]) {
            this["fireLSEvent"](this["E_LS_EVENTS"]["right"], oBrowserEvent, true);
        }
        /* beautify preserve:end */

        //Check if browser event was canceled above
        if (!oBrowserEvent["bIsDomEventCanceled"]()) {
            iNextKey = window["UCF_System"]["bIsRTL"]
                ? UCF_KeyCodes["ARROW_LEFT"]
                : UCF_KeyCodes["ARROW_RIGHT"];
            iPreviousKey = window["UCF_System"]["bIsRTL"]
                ? UCF_KeyCodes["ARROW_RIGHT"]
                : UCF_KeyCodes["ARROW_LEFT"];

            // previous
            if (iKey === iPreviousKey || iKey === UCF_KeyCodes["ARROW_UP"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["previous"], oBrowserEvent, true);
            }

            // next
            if (iKey === iNextKey || iKey === UCF_KeyCodes["ARROW_DOWN"]) {
                this["fireLSEvent"](this["E_LS_EVENTS"]["next"], oBrowserEvent, true);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["arrowKeyToLSEvent"] = 0;
    }
    ;

    /**
     * Fire a virtual browser event by cloning an existing event
     *
     * @private
     * @param {string} sName the name of the new event
     * @param {UCF_BrowserEvent} oBrowserEvent the original browser event
     * @param {boolean} bCheckModifier whether 'modifier' should be added to the
     * event name if modifiers are used
     * @return {boolean} `true` if event was canceled during handler processing
     */
    UCF_BrowserWindow["prototype"]["fireLSEvent"] = function (sName, oBrowserEvent, bCheckModifier) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["fireLSEvent"]++;
        }
        ;
        /** @type {boolean} */
        var bAnyModifier;
        /** @type {UCF_BrowserEvent} */
        var oNewBrowserEvent;

        if (this["bDestroyed"]) return;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(1949): fireLSEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sName) === 'string', "typeof(sName) === 'string'", "BrowserWindow.js(1950): fireLSEvent");
        }
        ;

        bAnyModifier = oBrowserEvent && (oBrowserEvent["bCtrl"]() ||
            oBrowserEvent["bShift"]() ||
            oBrowserEvent["bAlt"]());
        oNewBrowserEvent = this["oBrowserEventPool"]["oBorrowObject"](
            oBrowserEvent["oDomEvent"]
        );

        if (bCheckModifier && bAnyModifier) {
            sName += 'modifier';
        }

        oNewBrowserEvent["setName"](sName);
        oNewBrowserEvent["setSource"](oBrowserEvent["oGetSource"]());
        oNewBrowserEvent["oFromElement"] = oBrowserEvent["oFromElement"];
        oNewBrowserEvent["oSourceControl"] = oBrowserEvent["oSourceControl"];

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Lightspeed event ' + sName + ' fired', "BrowserWindow.js(1968): fireLSEvent");
        }
        ;
        this["processBrowserEvent"](oNewBrowserEvent);

        this["oBrowserEventPool"]["returnObject"](oNewBrowserEvent);

        return oNewBrowserEvent["bCancel"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["fireLSEvent"] = 0;
    }
    ;

    /**
     * Handle onmousedown
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onmousedown"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmousedown"]++;
        }
        ;
        /** @type {UCF_BrowserWindow_MouseEventParameters} */
        var mEventParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(1986): onmousedown");
        }
        ;
        if (!this["oDragAndDropManager"]) {
            this["oDragAndDropManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_DragAndDropManager"))(this);
            // fire DDManagerCreate to pass oLS to DDManager
            mEventParams = {"oDragAndDropManager": this["oDragAndDropManager"]};
            this["fireEvent"](this["E_EVENTS"]["DDManagerCreate"], mEventParams);
        }

        this["oDragAndDropManager"]["notifyMouseDown"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmousedown"] = 0;
    }
    ;

    /**
     * Handle onmouseover
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onmouseover"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmouseover"]++;
        }
        ;
        /** @type {UCF_BrowserWindow_MouseEventParameters} */
        var mEventParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2007): onmouseover");
        }
        ;

        // create D&D manager on inter-iframe communication
        if (!this["oDragAndDropManager"] && UCF_DomUtil["oGetTopWindow"]()["oDragSession"]) {
            this["oDragAndDropManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_DragAndDropManager"))(this);
            // fire DDManagerCreate to pass oLS to DDManager
            mEventParams = {"oDragAndDropManager": this["oDragAndDropManager"]};
            this["fireEvent"](this["E_EVENTS"]["DDManagerCreate"], mEventParams);
        }

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyMouseOver"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmouseover"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onmouseout"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmouseout"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2027): onmouseout");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyMouseOut"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmouseout"] = 0;
    }
    ;

    /**
     * Handle onmousemove
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onmousemove"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmousemove"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2041): onmousemove");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyMouseMove"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmousemove"] = 0;
    }
    ;

    /**
     * Handle ondragstart
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ondragstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ondragstart"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2055): ondragstart");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyDragStart"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ondragstart"] = 0;
    }
    ;

    /**
     * Handle ondragover
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ondragover"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ondragover"]++;
        }
        ;
        /** @type {UCF_BrowserWindow_MouseEventParameters} */
        var mEventParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2072): ondragover");
        }
        ;

        if (!this["oDragAndDropManager"]) {
            this["oDragAndDropManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_DragAndDropManager"))(this);
            // fire DDManagerCreate to pass oLS to DDManager
            mEventParams = {"oDragAndDropManager": this["oDragAndDropManager"]};
            this["fireEvent"](this["E_EVENTS"]["DDManagerCreate"], mEventParams);
        }

        this["oDragAndDropManager"]["notifyDragOver"](oBrowserEvent);
        // preventDefault neccessary to get drop event
        //	oBrowserEvent.oDomEvent.preventDefault();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ondragover"] = 0;
    }
    ;

    /**
     * Handle ondragend
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ondragend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ondragend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2093): ondragend");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyDragEnd"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ondragend"] = 0;
    }
    ;

    /**
     * Handle ondrop
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ondrop"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ondrop"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2107): ondrop");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyDrop"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ondrop"] = 0;
    }
    ;

    /**
     * Handle onmouseup
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onmouseup"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onmouseup"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2121): onmouseup");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyMouseUp"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onmouseup"] = 0;
    }
    ;

    /**
     * Handles onoffline
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onoffline"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onoffline"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2135): onoffline");
        }
        ;

        this["fireEvent"](this["E_EVENTS"]["Offline"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onoffline"] = 0;
    }
    ;

    /**
     * Handles ononline
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ononline"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ononline"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2147): ononline");
        }
        ;

        this["fireEvent"](this["E_EVENTS"]["Online"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ononline"] = 0;
    }
    ;

    /**
     * Handle onclick
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_BrowserWindow["prototype"]["onclick"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onclick"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2159): onclick");
        }
        ;

        if (this["oDragAndDropManager"]) {
            this["oDragAndDropManager"]["notifyMouseClick"](oBrowserEvent);
        }

        // gate for ignoring on double click: only clicks on the same element count
        if (
            this["sDelayedDoubleClickTimeout"] == null ||
            oBrowserEvent["oGetSource"]() !== this["oDelayedDoubleClickedDomRef"]
        ) {
            // start/restart timed gate
            this["oDelayedDoubleClickedDomRef"] = oBrowserEvent["oGetSource"]();
            UCF_JsUtil["clearDelayedCall"](this["sDelayedDoubleClickTimeout"]);
            this["sDelayedDoubleClickTimeout"] = UCF_JsUtil["delayedCall"](
                UCF_BrowserWindow["DELAYED_DOUBLECLICK_GATE_MS"],
                this,
                'openDelayedDoubleClickGate',
                []
            );
        }

        if (this["sDelayedDoubleClickTimeout"] === -1) {
            // gate has opened, fire event
            this["sDelayedDoubleClickTimeout"] = null;
            this["fireLSEvent"](this["E_LS_EVENTS"]["delayeddoubleclick"], oBrowserEvent);
            this["oDelayedDoubleClickedDomRef"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onclick"] = 0;
    }
    ;

    /**
     * "open" delayed double click gate
     *
     * @private
     */
    UCF_BrowserWindow["prototype"]["openDelayedDoubleClickGate"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["openDelayedDoubleClickGate"]++;
        }
        ;
        this["sDelayedDoubleClickTimeout"] = -1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["openDelayedDoubleClickGate"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayoutChange event
     *
     * @param {boolean} [bIsWindowResize=false] `true` = caused by a resize event
     * of the window
     */
    UCF_BrowserWindow["prototype"]["notifyLayoutChange"] = function (bIsWindowResize) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayoutChange"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["LayoutChange"], {
            "bIsWindowResize": bIsWindowResize === true
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayoutChange"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayoutChangeFrom event
     * @param {string} sControlId The source control Id that is attached as
     * parameter to the event
     * @param {string} sClassName The source control class name that is attached as
     * parameter to the event
     * @param {string} [oCustom] An optional custom object
     */
    UCF_BrowserWindow["prototype"]["notifyLayoutChangeFrom"] = function (sControlId, sClassName, oCustom) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayoutChangeFrom"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["LayoutChange"], {
            "sSourceControlId": sControlId,
            "sSourceClassName": sClassName,
            "oCustomData": oCustom
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayoutChangeFrom"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayeredControl open event
     * @param {string} sControlId The source control Id that is attached as
     * parameter to the event
     * @param {string} sClassName The source control class name that is attached as
     * parameter to the event
     * @param {string} [oCustom] An optional custom object
     */
    UCF_BrowserWindow["prototype"]["notifyLayeredControlOpen"] = function (sControlId, sClassName, oCustom) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayeredControlOpen"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["LayeredControlOpen"], {
            "sSourceControlId": sControlId,
            "sSourceClassName": sClassName,
            "oCustomData": oCustom
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayeredControlOpen"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayeredControl close event
     * @param {string} sControlId The source control Id that is attached as
     * parameter to the event
     * @param {string} sClassName The source control class name that is attached as
     * parameter to the event
     * @param {string} [oCustom] An optional custom object
     */
    UCF_BrowserWindow["prototype"]["notifyLayeredControlClose"] = function (sControlId, sClassName, oCustom) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayeredControlClose"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["LayeredControlClose"], {
            "sSourceControlId": sControlId,
            "sSourceClassName": sClassName,
            "oCustomData": oCustom
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayeredControlClose"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayersVisible event
     *
     * @protected
     *
     * @see {@link UCF_LayeredControl#openBase}
     * @see {@link UCF_PopupMenu#open}
     * @see {@link UCF_PopupWindow#initialize}
     * @see {@link UCF_RichTooltip#show}
     * @see {@link UCF_Control#notifyLayerVisible}
     * @see {@link UCF_PopupBase#initialize}
     */
    UCF_BrowserWindow["prototype"]["notifyLayerVisible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayerVisible"]++;
        }
        ;
        if (this["iVisibleLayers"] === 0) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Fire LayersVisible event', "BrowserWindow.js(2272): notifyLayerVisible");
            }
            ;
            this["fireEvent"](this["E_EVENTS"]["LayersVisible"]);
        }
        this["iVisibleLayers"]++;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Currently visible layers: ' + this["iVisibleLayers"], "BrowserWindow.js(2276): notifyLayerVisible");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayerVisible"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayersHidden event
     *
     * @protected
     *
     * @see {@link UCF_LayeredControl#closeBase}
     * @see {@link UCF_PopupMenu#hide}
     * @see {@link UCF_PopupWindow#destroy}
     * @see {@link UCF_PopupWindow#close}
     * @see {@link UCF_Control#notifyLayerHidden}
     * @see {@link UCF_PopupBase#destroy}
     * @see {@link UCF_PopupBase#close}
     * @see {@link UCF_PopupManager#closePopup}
     */
    UCF_BrowserWindow["prototype"]["notifyLayerHidden"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["notifyLayerHidden"]++;
        }
        ;
        this["iVisibleLayers"]--;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Currently visible layers: ' + this["iVisibleLayers"], "BrowserWindow.js(2295): notifyLayerHidden");
        }
        ;
        if (this["iVisibleLayers"] === 0) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Fire LayersHidden event', "BrowserWindow.js(2297): notifyLayerHidden");
            }
            ;
            this["fireEvent"](this["E_EVENTS"]["LayersHidden"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["notifyLayerHidden"] = 0;
    }
    ;

    /**
     * Check if there are visible layers on the window
     *
     * @protected
     * @return {boolean} bLayersVisible
     *
     * @see {@link UCF_AcfAdapter}
     */
    UCF_BrowserWindow["prototype"]["bLayersVisible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bLayersVisible"]++;
        }
        ;
        return this["iVisibleLayers"] > 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bLayersVisible"] = 0;
    }
    ;

    /**
     * Handle onhelp (only available for IE11 not for other browsers like Chrome or FF)
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["onhelp"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["onhelp"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2321): onhelp");
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'onhelp', "BrowserWindow.js(2322): onhelp");
        }
        ;

        //IE11 fires onhelp always for F1 including modfiers. Need to cancel the event if F1 hotkey is bound. Decison will be made in Page.onlsHotkey
        //DomEvent has no information about modifier keys.

        this["fireLSEvent"](this["E_LS_EVENTS"]["hotkey"], oBrowserEvent);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["onhelp"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sName
     * @return {boolean}
     */
    UCF_BrowserWindow["prototype"]["bIsDragDropEvent"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["bIsDragDropEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sName) === 'string', "typeof(sName) === 'string'", "BrowserWindow.js(2337): bIsDragDropEvent");
        }
        ;

        switch (sName) {
            case this["E_LS_EVENTS"]["drag"]:
            case this["E_LS_EVENTS"]["dragover"]:
            case this["E_LS_EVENTS"]["draghover"]:
            case this["E_LS_EVENTS"]["dragscroll"]:
            case this["E_LS_EVENTS"]["drop"]:
            case this["E_LS_EVENTS"]["dragend"]:
            case this["E_LS_EVENTS"]["dragenter"]:
            case this["E_LS_EVENTS"]["dragleave"]:
            case this["E_LS_EVENTS"]["mousemove"]:
                // IE behaves strange when setting returnValue to false after dragging an
                // <IMG>, so do not cancel mousemove
                return true;
            default:
                return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["bIsDragDropEvent"] = 0;
    }
    ;

    /**********  TOUCH SUPPORT **********/

    /**
     * iOS Safari touch and gesture events
     * https://developer.apple.com/documentation/webkitjs/gestureevent?language=javascript
     *
     * @const {UCF_BrowserWindow_TouchEvent[]}
     */
    UCF_BrowserWindow["prototype"]["A_DOM_EVENTS_TOUCH"] = [
        'touchstart',
        'touchmove',
        'touchend',
        'touchcancel',
        'gesturestart',
        'gesturechange',
        'gestureend'
    ];

    /**
     * Handle ontouchstart
     * Sets this flag on the event: UCF_BrowserWindow.oGetData().bSourceIsActiveTextInput
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ontouchstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ontouchstart"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2382): ontouchstart");
        }
        ;
        if (!this["oDragAndDropManager"]) {
            this["oGetDragAndDropManager"]();
        }

        // Remember where the initial touchstart occured and what the active element was.
        // This information is needed later, when mobile-Chrome emulates an contextmenu event
        // TODO: ?? Unfortunately this code need access to oLS, which is a bit messy.
        this["bTouchOnActiveTextInput"] = false;
        var oSource = oBrowserEvent["oGetSource"]();
        var oSourceControl = oSource ? this["oDragAndDropManager"]["oPage"]["oLS"]["oGetControlByDomRef"](oSource) : null;
        var bSourceIsActiveTextInput =
            oSourceControl &&
            UCF_JsUtil["contains"](
                ['UCF_InputField', 'UCF_ComboBox', 'UCF_SuggestBox', 'UCF_TextEdit'],
                oSourceControl["sClassName"]
            ) &&
            UCF_DomUtil["bContains"](oSourceControl["oRootRef"], UCF_DomUtil["oGetActiveElement"]());
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: ontouchstart: bSourceIsActiveTextInput=' + bSourceIsActiveTextInput, "BrowserWindow.js(2400): ontouchstart");
        }
        ;
        this["bTouchStartOnActiveTextInput"] = bSourceIsActiveTextInput;

        this["fireLSEvent"](this["E_LS_EVENTS"]["touchstart"], oBrowserEvent);

        this["oDragAndDropManager"]["notifyMouseDown"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ontouchstart"] = 0;
    }
    ;

    /**
     * Handle ontouchmove
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ontouchmove"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ontouchmove"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2415): ontouchmove");
        }
        ;

        this["fireLSEvent"](this["E_LS_EVENTS"]["touchmove"], oBrowserEvent);

        if (!this["oDragAndDropManager"]) {
            this["oGetDragAndDropManager"]();
        }
        this["oDragAndDropManager"]["notifyMouseMove"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ontouchmove"] = 0;
    }
    ;

    /**
     * Handle ontouchend
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ontouchend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ontouchend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2432): ontouchend");
        }
        ;

        this["fireLSEvent"](this["E_LS_EVENTS"]["touchend"], oBrowserEvent);

        if (!this["oDragAndDropManager"]) {
            this["oGetDragAndDropManager"]();
        }
        this["oDragAndDropManager"]["notifyMouseUp"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ontouchend"] = 0;
    }
    ;

    /**
     * Handle ontouchcancel
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ontouchcancel"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ontouchcancel"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2449): ontouchcancel");
        }
        ;
        this["ontouchend"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ontouchcancel"] = 0;
    }
    ;

    /**
     * Handle ongesturestart
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ongesturestart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ongesturestart"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2460): ongesturestart");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["gesturestart"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ongesturestart"] = 0;
    }
    ;

    /**
     * Handle ongesturechange
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ongesturechange"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ongesturechange"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2471): ongesturechange");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["gesturechange"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ongesturechange"] = 0;
    }
    ;

    /**
     * Handle ongestureend
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_BrowserWindow["prototype"]["ongestureend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["ongestureend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "BrowserWindow.js(2482): ongestureend");
        }
        ;
        this["fireLSEvent"](this["E_LS_EVENTS"]["gestureend"], oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["ongestureend"] = 0;
    }
    ;

    /**
     * Adds a tab sequence with a given id
     *
     * @private
     * @param {string} sTabSequenceId The id of the sequence
     * @param {UCF_BrowserWindow_TabSequence} mTabSequenceMap The map of control ids with
     * their next focusable id
     */
    UCF_BrowserWindow["prototype"]["addTabSequence"] = function (sTabSequenceId, mTabSequenceMap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["addTabSequence"]++;
        }
        ;
        /** @type {string} */
        var n;

        if (!this["mTabSequences"]) {
            this["mTabSequences"] = {};
        }
        this["mTabSequences"][sTabSequenceId] = mTabSequenceMap;
        this["mTabSequences"][sTabSequenceId + '_shift'] = {};
        for (n in mTabSequenceMap) {
            this["mTabSequences"][sTabSequenceId + '_shift'][mTabSequenceMap[n]] = n;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["addTabSequence"] = 0;
    }
    ;

    /**
     * Removes a tab sequence with a given id
     *
     * @private
     * @param {string} sTabSequenceId The id of the sequence
     */
    UCF_BrowserWindow["prototype"]["removeTabSequence"] = function (sTabSequenceId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["removeTabSequence"]++;
        }
        ;
        /** @type {string} */
        var n;

        if (sTabSequenceId in this["mTabSequences"]) {
            delete this["mTabSequences"][sTabSequenceId];
            delete this["mTabSequences"][sTabSequenceId + '_shift'];
        }
        for (n in this["mTabSequences"]) {
            return;
        }
        this["mTabSequences"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["removeTabSequence"] = 0;
    }
    ;

    /**
     * Add the given dom reference to be handled as an isolated area where events
     * are not handled by Lightspeed.
     *
     * @public
     * @param {UCF_BrowserWindow_IsolatedArea} oDomRefOrId The dom ref or an id of
     * an element
     */
    UCF_BrowserWindow["prototype"]["addIsolatedArea"] = function (oDomRefOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["addIsolatedArea"]++;
        }
        ;
        if (oDomRefOrId) {
            this["aIsolatedAreas"]["push"](oDomRefOrId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["addIsolatedArea"] = 0;
    }
    ;

    /**
     * Remove the given dom reference to be handled as an isolated area where
     * events are bubbled and handled by Lightspeed again.
     *
     * @public
     * @param {UCF_BrowserWindow_IsolatedArea} oDomRefOrId The dom ref or an id of
     * an element
     */
    UCF_BrowserWindow["prototype"]["removeIsolatedArea"] = function (oDomRefOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["removeIsolatedArea"]++;
        }
        ;
        /** @type {UCF_BrowserWindow_IsolatedArea[]} */
        var aIsolatedAreas;
        /** @type {number} */
        var i;

        if (oDomRefOrId) {
            aIsolatedAreas = [];
            for (i = 0; i < this["aIsolatedAreas"]["length"]; i++) {
                if (this["aIsolatedAreas"][i] !== oDomRefOrId) {
                    aIsolatedAreas["push"](this["aIsolatedAreas"][i]);
                }
            }
            this["aIsolatedAreas"] = aIsolatedAreas;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["removeIsolatedArea"] = 0;
    }
    ;

    /**
     * Stores the current position of an scrollable element
     *
     * @public
     * @param {HTMLElement} oScrollElement The dom ref of the scrollable element
     */
    UCF_BrowserWindow["prototype"]["storeScrollPosition"] = function (oScrollElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["storeScrollPosition"]++;
        }
        ;
        if (oScrollElement) {
            if (oScrollElement === document && window["pageYOffset"]) {
                oScrollElement["lsStoredScrollTop"] = window["pageYOffset"];
                oScrollElement["lsStoredScrollLeft"] = window["pageXOffset"];
            } else {
                oScrollElement["lsStoredScrollTop"] = oScrollElement["scrollTop"];
                oScrollElement["lsStoredScrollLeft"] = oScrollElement["scrollLeft"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["storeScrollPosition"] = 0;
    }
    ;

    /**
     * Restores the latest scrollposition of an scrollable element which leads to a
     * locked scrolling.
     *
     * @public
     * @param {HTMLElement} oScrollElement The dom ref of the scrollable element
     */
    UCF_BrowserWindow["prototype"]["restoreScrollPosition"] = function (oScrollElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BrowserWindow["_"]["restoreScrollPosition"]++;
        }
        ;
        if (oScrollElement) {
            if ('lsStoredScrollTop' in oScrollElement) {
                if (this["bIsLockedByType"](UCF_BrowserWindow["LOCKTYPES"]["POPUP"])) {
                    // PopupWindow may have already calculated its position based on
                    // scrollTop=0 AND is contained in the body of the main page (WDA
                    // standalone) => Do not scroll
                    // Scroll position is still restored after the PopupWindow is closed
                    return;
                }
                if (oScrollElement === document && window["pageYOffset"]) {
                    window["scrollTo"](
                        oScrollElement["lsStoredScrollLeft"],
                        oScrollElement["lsStoredScrollTop"]
                    );
                } else {
                    oScrollElement["scrollTop"] = oScrollElement["lsStoredScrollTop"];
                    oScrollElement["scrollLeft"] = oScrollElement["lsStoredScrollLeft"];
                }
            } else {
                this["storeScrollPosition"](oScrollElement);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BrowserWindow["_"]["restoreScrollPosition"] = 0;
    }
    ;

    UCF_BrowserWindow.prototype["aPublicMethods"] = ["addIsolatedArea", "removeIsolatedArea", "storeScrollPosition", "restoreScrollPosition"].concat(UCF_BrowserWindow.prototype.aPublicMethods || []);
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global _trace, DEBUG, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_BrowserEvent */

/// <reference path="./BrowserEvent.js"/>

    /**
     * handles touch events to generate the 'lslongtap' and 'lslongtapend' events.
     *
     * @class
     * @extends UCF_EventProvider
     */
    function UCF_LongTapDetector() {
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["UCF_LongTapDetector"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['LongTap', 'LongTapEnd', 'ExtraLongTap', 'ExtraLongTapEnd']);

        /** @type {{x:number, y:number}} */
        this["oTabAndHoldStartPosition"] = null;
        /** @type {string} */
        this["sTabAndHoldTimeout"] = null;
        /** @type {UCF_BrowserEvent} */
        this["oTabAndHoldEvent"] = null;
        /** @type {string} */
        this["sTabAndHoldExtraLongTimeout"] = null;
        /** @type {UCF_BrowserEvent} */
        this["oTabAndHoldExtraLongEvent"] = null;
        /** @type {boolean} */
        this["bLongTapFired"] = false;
        /** @type {boolean} */
        this["bExtraLongTapFired"] = false;
    };window["UCF_LongTapDetector"] = UCF_LongTapDetector;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_LongTapDetector");
        UCF_LongTapDetector["_"] = {UCF_LongTapDetector: 0};
    }
    ;
    ;
    UCF_LongTapDetector["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_LongTapDetector.prototype["sClassName"] = "UCF_LongTapDetector";

    /**
     * The delay time that triggeres the 'lslongtap' event.
     *
     * @private
     * @static
     * @const {number}
     */
    UCF_LongTapDetector["DELAY_MS"] = 700;

    /**
     * The delay time that triggeres the 'lsextralongtap' event.
     *
     * @private
     * @static
     * @const {number}
     */
    UCF_LongTapDetector["DELAY_EXTRA_MS"] = 1200;

    /**
     * @private
     * @static
     * @const {number}
     */
    UCF_LongTapDetector["DISTANCE_THRESHOLD_PX"] = 15;

    /** @protected */
    UCF_LongTapDetector["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["destroy"]++;
        }
        ;
        this["clearTouchAndHoldTimers"]();

        if (this["oTabAndHoldExtraLongEvent"]) {
            this["oTabAndHoldExtraLongEvent"]["destroy"]();
            this["oTabAndHoldExtraLongEvent"] = null;
        }
        if (this["oTabAndHoldEvent"]) {
            this["oTabAndHoldEvent"]["destroy"]();
            this["oTabAndHoldEvent"] = null;
        }
        this["oTabAndHoldStartPosition"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["destroy"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["ontouchstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["ontouchstart"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: Received touchstart', "LongTapDetector.js(87): ontouchstart");
        }
        ;
        if (
            this["sTabAndHoldTimeout"] == null &&
            oBrowserEvent["oDomEvent"]["touches"]["length"] === 1
        ) {
            this["bLongTapFired"] = false;

            this["oTabAndHoldStartPosition"] = {
                "x": oBrowserEvent["oDomEvent"]["touches"][0]["clientX"],
                "y": oBrowserEvent["oDomEvent"]["touches"][0]["clientY"]
            };

            // need to copy because of event-pool
            // eslint-disable-next-line ur/no-memory-leaks
            this["oTabAndHoldEvent"] = new (UCF_ClassLoader["oGetClass"]("UCF_BrowserEvent"))(oBrowserEvent["oDomEvent"]);
            this["sTabAndHoldTimeout"] = UCF_JsUtil["delayedCall"](
                UCF_LongTapDetector["DELAY_MS"],
                this,
                'fireLongTap',
                [this["oTabAndHoldEvent"]]
            );

            // need to copy because of event-pool
            // eslint-disable-next-line ur/no-memory-leaks
            this["oTabAndHoldExtraLongEvent"] = new (UCF_ClassLoader["oGetClass"]("UCF_BrowserEvent"))(oBrowserEvent["oDomEvent"]);
            this["sTabAndHoldExtraLongTimeout"] = UCF_JsUtil["delayedCall"](
                UCF_LongTapDetector["DELAY_EXTRA_MS"],
                this,
                'fireExtraLongTap',
                [this["oTabAndHoldExtraLongEvent"]]
            );
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'TOUCH: Detected another touchstart during timeout -> cancel longtap processing', "LongTapDetector.js(119): ontouchstart");
            }
            ;
            this["clearTouchAndHoldTimers"]();
        }

        // Another finger? -> cancel longtap
        if (
            this["sTabAndHoldTimeout"] != null &&
            oBrowserEvent["oDomEvent"]["changedTouches"]["length"] > 1
        ) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'TOUCH: Detected another finger in touchstart -> cancel longtap processing', "LongTapDetector.js(128): ontouchstart");
            }
            ;
            this["clearTouchAndHoldTimers"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["ontouchstart"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["ontouchmove"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["ontouchmove"]++;
        }
        ;
        /** @type {Touch} */
        var oTouch;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: Received touchmove', "LongTapDetector.js(141): ontouchmove");
        }
        ;

        if (this["sTabAndHoldTimeout"]) {
            if (oBrowserEvent["oDomEvent"]["changedTouches"]["length"] > 1) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'TOUCH: Detected another finger in touchmove -> cancel longtap processing', "LongTapDetector.js(145): ontouchmove");
                }
                ;
                this["clearTouchAndHoldTimers"]();
            } else {
                oTouch = oBrowserEvent["oDomEvent"]["touches"][0];
                if (
                    Math["abs"](this["oTabAndHoldStartPosition"]["x"] - oTouch["clientX"]) > UCF_LongTapDetector["DISTANCE_THRESHOLD_PX"] ||
                    Math["abs"](this["oTabAndHoldStartPosition"]["y"] - oTouch["clientY"]) > UCF_LongTapDetector["DISTANCE_THRESHOLD_PX"]
                ) {
                    this["clearTouchAndHoldTimers"]();
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["ontouchmove"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["ontouchend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["ontouchend"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: Received touchend', "LongTapDetector.js(164): ontouchend");
        }
        ;
        this["clearTouchAndHoldTimers"]();
        if (this["bLongTapFired"] && !this["bExtraLongTapFired"]) {
            this["bLongTapFired"] = false;
            this["fireEvent"](this["E_EVENTS"]["LongTapEnd"], {"oBrowserEvent": oBrowserEvent});
        }
        if (this["bExtraLongTapFired"]) {
            this["bExtraLongTapFired"] = false;
            this["fireEvent"](this["E_EVENTS"]["ExtraLongTapEnd"], {
                "oBrowserEvent": oBrowserEvent
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["ontouchend"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["ontouchcancel"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["ontouchcancel"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: Received touchcancel', "LongTapDetector.js(183): ontouchcancel");
        }
        ;

        if (UCF_UserAgent["bIsSafari"]()) {
            this["ontouchend"](oBrowserEvent);
        }
        // Ignore touchcancel on Android, which sends it after an emulated
        // contextmenu event if it also created a text-selection.
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["ontouchcancel"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["ongesturestart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["ongesturestart"]++;
        }
        ;
        // Detect 'pinch' gesture which could be in progress for any amount of time!
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: Detected a gesture -> cancel longtap processing', "LongTapDetector.js(198): ongesturestart");
        }
        ;
        this["clearTouchAndHoldTimers"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["ongesturestart"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["fireLongTap"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["fireLongTap"]++;
        }
        ;
        this["sTabAndHoldTimeout"] = null;
        this["fireEvent"](this["E_EVENTS"]["LongTap"], {"oBrowserEvent": oBrowserEvent});
        this["bLongTapFired"] = true;

        if (this["oTabAndHoldEvent"]) {
            this["oTabAndHoldEvent"]["destroy"]();
            this["oTabAndHoldEvent"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["fireLongTap"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_LongTapDetector["prototype"]["fireExtraLongTap"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["fireExtraLongTap"]++;
        }
        ;
        this["sTabAndHoldExtraLongTimeout"] = null;
        this["fireEvent"](this["E_EVENTS"]["ExtraLongTap"], {"oBrowserEvent": oBrowserEvent});
        this["bExtraLongTapFired"] = true;

        if (this["oTabAndHoldExtraLongEvent"]) {
            this["oTabAndHoldExtraLongEvent"]["destroy"]();
            this["oTabAndHoldExtraLongEvent"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["fireExtraLongTap"] = 0;
    }
    ;

    /** @private */
    UCF_LongTapDetector["prototype"]["clearTouchAndHoldTimers"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LongTapDetector["_"]["clearTouchAndHoldTimers"]++;
        }
        ;
        UCF_JsUtil["clearDelayedCall"](this["sTabAndHoldTimeout"]);
        UCF_JsUtil["clearDelayedCall"](this["sTabAndHoldExtraLongTimeout"]);
        this["sTabAndHoldTimeout"] = null;
        this["sTabAndHoldExtraLongTimeout"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LongTapDetector["_"]["clearTouchAndHoldTimers"] = 0;
    }
    ;

    /* global _trace, DEBUG */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>

    /**
     * @typedef {Object} UCF_SwipeDetector_SwipeParameters
     * @property {'left'|'right'} sDirection
     * @property {UCF_BrowserEvent} oBrowserEvent
     */

    /**
     * @typedef {Object} UCF_SwipeDetector_MoveInfoParameters
     * @property {number} iX
     * @property {number} iY
     * @property {boolean} bThresholdExceeded
     * @property {UCF_BrowserEvent} oBrowserEvent
     */

    /**
     * handles touch events to generate the 'lsswipeleft/right' events.
     *
     * @class
     * @extends UCF_EventProvider
     */
    function UCF_SwipeDetector() {
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["UCF_SwipeDetector"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['Swipe', 'MoveInfo']);

        /** @type {{iX: number, iY: number}} */
        this["oStart"] = null;
    };window["UCF_SwipeDetector"] = UCF_SwipeDetector;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_SwipeDetector");
        UCF_SwipeDetector["_"] = {UCF_SwipeDetector: 0};
    }
    ;
    ;
    UCF_SwipeDetector["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_SwipeDetector.prototype["sClassName"] = "UCF_SwipeDetector";

    /**
     * @private
     * @static
     * @const {number}
     */
    UCF_SwipeDetector["DISTANCE_THRESHOLD_PX"] = 10;

    /** @override */
    UCF_SwipeDetector["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["destroy"]++;
        }
        ;
        this["oStart"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["destroy"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_SwipeDetector["prototype"]["ontouchstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["ontouchstart"]++;
        }
        ;
        if (oBrowserEvent["oDomEvent"]["touches"]["length"] === 1) {
            this["oStart"] = {
                "iX": oBrowserEvent["oDomEvent"]["touches"][0]["clientX"],
                "iY": oBrowserEvent["oDomEvent"]["touches"][0]["clientY"]
            };
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["ontouchstart"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_SwipeDetector["prototype"]["ontouchmove"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["ontouchmove"]++;
        }
        ;
        /** @type {number} */
        var iX;
        /** @type {number} */
        var iY;

        if (this["oStart"]) {
            iX = 0;
            iY = 0;

            if (
                oBrowserEvent["oDomEvent"]["touches"]["length"] === 1 &&
                oBrowserEvent["oDomEvent"]["changedTouches"]["length"] === 1
            ) {
                iX = oBrowserEvent["oDomEvent"]["touches"][0]["clientX"] - this["oStart"]["iX"];
                iY = oBrowserEvent["oDomEvent"]["touches"][0]["clientY"] - this["oStart"]["iY"];

                this["fireEvent"](this["E_EVENTS"]["MoveInfo"], {
                    "iX": iX,
                    "iY": iY,
                    "bThresholdExceeded": Math["abs"](iX) > UCF_SwipeDetector["DISTANCE_THRESHOLD_PX"],
                    // TODO compare Y-axis as well
                    "oBrowserEvent": oBrowserEvent
                });
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["ontouchmove"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_SwipeDetector["prototype"]["ontouchend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["ontouchend"]++;
        }
        ;
        /** @type {number} */
        var iDistX;

        if (this["oStart"]) {
            iDistX = oBrowserEvent["oDomEvent"]["changedTouches"][0]["clientX"] - this["oStart"]["iX"];
            if (Math["abs"](iDistX) > UCF_SwipeDetector["DISTANCE_THRESHOLD_PX"]) {
                // TODO compare Y-axis as well (-> fire up/down as well)
                this["fireEvent"](this["E_EVENTS"]["Swipe"], {
                    "sDirection": iDistX > 0 ? 'right' : 'left',
                    "oBrowserEvent": oBrowserEvent
                });
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["ontouchend"] = 0;
    }
    ;

    /** @protected */
    UCF_SwipeDetector["prototype"]["ontouchcancel"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["ontouchcancel"]++;
        }
        ;
        this["oStart"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["ontouchcancel"] = 0;
    }
    ;

    /** @protected */
    UCF_SwipeDetector["prototype"]["ongesturestart"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SwipeDetector["_"]["ongesturestart"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'TOUCH: Detected a gesture -> cancel swipe processing', "SwipeDetector.js(121): ongesturestart");
        }
        ;

        this["oStart"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SwipeDetector["_"]["ongesturestart"] = 0;
    }
    ;

    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_BrowserEvent */

/// <reference path="./BrowserEvent.js"/>

    /**
     * detects TAP events, i.e. touchstart -> < 3 touchmove -> touchend
     *
     * @class
     * @extends UCF_EventProvider
     */
    function UCF_TapDetector() {
        if (__UCF_COVERAGE__) {
            UCF_TapDetector["_"]["UCF_TapDetector"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['Tap']);

        /** @type {number} */
        this["iIdentifier"] = null;
        /** @type {number} */
        this["iScreenX"] = null;
        /** @type {number} */
        this["iScreenY"] = null;
    };window["UCF_TapDetector"] = UCF_TapDetector;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_TapDetector");
        UCF_TapDetector["_"] = {UCF_TapDetector: 0};
    }
    ;
    ;
    UCF_TapDetector["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_TapDetector.prototype["sClassName"] = "UCF_TapDetector";

    /**
     * @private
     * @const {number}
     */
    UCF_TapDetector["DISTANCE_THRESHOLD_PX"] = 10;

    /** @override */
    UCF_TapDetector["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_TapDetector["_"]["destroy"]++;
        }
        ;
        this["iScreenY"] = null;
        this["iScreenX"] = null;
        this["iIdentifier"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_TapDetector["_"]["destroy"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_TapDetector["prototype"]["ontouchstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_TapDetector["_"]["ontouchstart"]++;
        }
        ;
        /** @type {Touch} */
        var oTouch;

        if (oBrowserEvent["oDomEvent"]["touches"]["length"] === 1) {
            oTouch = oBrowserEvent["oDomEvent"]["touches"]["item"](0);

            this["iIdentifier"] = oTouch["identifier"];
            this["iScreenX"] = oTouch["screenX"];
            this["iScreenY"] = oTouch["screenY"];
        } else {
            this["iIdentifier"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_TapDetector["_"]["ontouchstart"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_TapDetector["prototype"]["ontouchend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_TapDetector["_"]["ontouchend"]++;
        }
        ;
        /** @type {Touch} */
        var oTouch;
        /** @type {UCF_BrowserEvent} */
        var oBrowserEventClone;

        if (
            typeof this["iIdentifier"] === 'number' &&
            oBrowserEvent["oDomEvent"]["changedTouches"]["length"] === 1
        ) {
            oTouch = oBrowserEvent["oDomEvent"]["changedTouches"]["item"](0);

            if (
                oTouch["identifier"] === this["iIdentifier"] &&
                Math["abs"](this["iScreenX"] - oTouch["screenX"]) < UCF_TapDetector["DISTANCE_THRESHOLD_PX"] &&
                Math["abs"](this["iScreenY"] - oTouch["screenY"]) < UCF_TapDetector["DISTANCE_THRESHOLD_PX"]
            ) {
                // eslint-disable-next-line ur/no-memory-leaks
                oBrowserEventClone = new (UCF_ClassLoader["oGetClass"]("UCF_BrowserEvent"))(oBrowserEvent["oDomEvent"]);
                this["fireEvent"](this["E_EVENTS"]["Tap"], {
                    // need to clone the event because of the object pool
                    "oBrowserEvent": oBrowserEventClone
                });
                oBrowserEventClone["destroy"]();
            } else {
                this["iIdentifier"] = null;
            }
        } else {
            this["iIdentifier"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_TapDetector["_"]["ontouchend"] = 0;
    }
    ;

    /* global _trace, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_EventProvider */

/// <reference path="../../core/EventProvider.js"/>

    /**
     * detects zoom changes to generate the internal 'ZoomChange' events.
     *
     * @class
     */
    function UCF_ZoomDetector() {
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["UCF_ZoomDetector"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['ZoomChange']);

        /** @type {boolean} */
        this["bGesture"] = false;
        /** @type {string} */
        this["sZoomDelay"] = null;
        /**
         * The zoom detector gets created lazy at the first mouse/touch event but
         * that should be early enough to get the initial zoom factor. Will be null
         * if not on iOS
         * @type {number}
         */
        this["iZoomFactor"] = UCF_DomUtil["iGetBodyZoom"]();
    };window["UCF_ZoomDetector"] = UCF_ZoomDetector;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ZoomDetector");
        UCF_ZoomDetector["_"] = {UCF_ZoomDetector: 0};
    }
    ;
    ;
    UCF_ZoomDetector["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_ZoomDetector.prototype["sClassName"] = "UCF_ZoomDetector";

    /**
     * @private
     * @const {number}
     */
    UCF_ZoomDetector["DELAY_MS"] = 200;

    /** @override */
    UCF_ZoomDetector["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["destroy"]++;
        }
        ;
        if (this["sZoomDelay"]) {
            UCF_JsUtil["clearDelayedCall"](this["sZoomDelay"]);
            this["sZoomDelay"] = null;
        }
        this["iZoomFactor"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ZoomDetector["_"]["destroy"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_ZoomDetector["prototype"]["onscroll"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["onscroll"]++;
        }
        ;
        // iOS: Use 'scroll' event to detect zoom changes by 'double-tab' gesture
        // or orientation-change. But 'scroll' events are also fired during the
        // zoom with 'pinch' gesture (while fingers are still moving...)
        if (!this["bGesture"]) {
            this["handleZoom"](oBrowserEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ZoomDetector["_"]["onscroll"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_ZoomDetector["prototype"]["ongesturestart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["ongesturestart"]++;
        }
        ;
        this["bGesture"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ZoomDetector["_"]["ongesturestart"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_ZoomDetector["prototype"]["ongestureend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["ongestureend"]++;
        }
        ;
        this["bGesture"] = false;
        this["handleZoom"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ZoomDetector["_"]["ongestureend"] = 0;
    }
    ;

    /**
     * @private
     * @param {boolean} bNow `true` when handler should be executed immediately.
     * During the delay-time the processing is blocked.
     */
    UCF_ZoomDetector["prototype"]["handleZoom"] = function (bNow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ZoomDetector["_"]["handleZoom"]++;
        }
        ;
        /** @type {number} */
        var iZoomFactorNow;
        /** @type {boolean} */
        var bZoomIn;

        if (this["iZoomFactor"] !== null) {
            if (bNow === true && this["sZoomDelay"] != null) {
                iZoomFactorNow = UCF_DomUtil["iGetBodyZoom"]();
                if (iZoomFactorNow !== this["iZoomFactor"]) {
                    bZoomIn = iZoomFactorNow > this["iZoomFactor"];
                    this["iZoomFactor"] = iZoomFactorNow;
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'TOUCH: Fire ZoomChange: ' + this["iZoomFactor"], "ZoomDetector.js(98): handleZoom");
                    }
                    ;
                    this["fireEvent"](this["E_EVENTS"]["ZoomChange"], {"bZoomIn": bZoomIn});
                }
                this["sZoomDelay"] = null;
            } else if (this["sZoomDelay"] == null) {
                this["sZoomDelay"] = UCF_JsUtil["delayedCall"](
                    UCF_ZoomDetector["DELAY_MS"],
                    this,
                    'handleZoom',
                    [true]
                );
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ZoomDetector["_"]["handleZoom"] = 0;
    }
    ;

    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="../../core/util/XSSEncoder.js"/>
    /* global _trace, _assert, _measure, ERROR, WARNING, DEBUG, START, STOP */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_FormatException */
/// <reference path="./FormatException.js"/>
    /* global UCF_ParseException */
/// <reference path="./ParseException.js"/>
    /* global UCF_ValidateException */
/// <reference path="./ValidateException.js"/>
    /* global UCF_ControlFactory */
/// <reference path="./ControlFactory.js"/>
    /* global UCF_CustomStyleProvider */
/// <reference path="./CustomStyleProvider.js"/>
    /* global UCF_ClientInterfaces */
/// <reference path="../controls/interfaces/ClientInterface.js"/>
    /* global UCF_Binding */
/// <reference path="../model/Binding.js"/>
    /* global UCF_SimpleType */
/// <reference path="../model/SimpleType.js"/>
    /* global UCF_TypedTemplatePool */
/// <reference path="../model/TypedTemplatePool.js"/>
    /* global UCF_JSONModel */
/// <reference path="../model/json/JSONModel.js"/>

    /** @typedef {any} TODO */
    /** @typedef {string} _LSX  */
    /** @typedef {Array<UCF_ClientElement>|UCF_ClientElement} UCF_ClientElement_Aggregation  */
    /** @typedef {'START'|'UP'|'DOWN'|'END'} UCF_ClientElement_AggregationPosition */
    /**
     * @typedef {Object} UCF_ClientElement_PropertyChangeInfo
     * @property {UCF_ClientElement} sender this object
     * @property {string} name the name of the property that was changed
     * @property {T} oldValue the old value of the property
     * @property {T} newValue the new value of the property
     * @template T
     */
    /**
     * @typedef {Object} UCF_ClientElement_BindingInfoParameters
     * @property {boolean} managerange
     */
    /**
     * @typedef {function(string, UCF_BindingContext): UCF_ClientElement} UCF_ClientElement_BindingFactory
     * @param {string} sId
     * @param {UCF_BindingContext} oContext
     * @return {UCF_ClientElement}
     */
    /**
     * @typedef {function} UCF_ClientElement_BindingFormatter
     */
    /**
     * @typedef {Object} UCF_ClientElement_BindingInfo
     * @property {UCF_Binding} binding
     * @property {string} bindingtype
     * @property {string} datatype
     * @property {UCF_ClientElement_BindingFactory} factory
     * @property {UCF_ClientElement_BindingFormatter} formatter
     * @property {UCF_Binding.Mode} mode
     * @property {string} model
     * @property {function(UCF_Event): void} modelChangeHandler
     * @property {UCF_ClientElement_BindingInfoParameters} parameters
     * @property {string} path
     * @property {boolean} skipModelUpdate
     * @property {TODO} sorter
     * @property {UCF_ClientElement} template
     * @property {UCF_SimpleType} type
     */
    /**
     * @typedef {Object} UCF_ClientElement_ContentChangedParent
     * @property {UCF_ClientElement} oObject the UCF_ClientElement that changed
     * @property {string} sParentAggregation the name of the aggregation oObject
     * is registered through at the parent (e.g. "Content")
     */
    /**
     * @typedef {Object} UCF_ClientElement_ChildrenChange
     * @property {UCF_ClientElement} oControl
     * @property {string} sParentAggregation
     * @property {UCF_ClientElement} oOldParent
     * @property {UCF_ClientElement} oNewParent
     * @property {boolean} bAdd
     */
    /**
     * @typedef {Object} UCF_ClientElement_RenderInfo
     * @property {string} Id
     * @property {string} _sControlClassName see <case> in renderer.xslt
     * @property {UCF_ClientElement} _oControl
     * @property {Object} _oCustomDataJson
     */
    /**
     * @typedef {Object} UCF_ClientElement_GridRange
     * @property {number} iStartX
     * @property {number} iStartY
     * @property {number} iEndX
     * @property {number} iEndY
     */
    /**
     * @typedef {Object} UCF_ClientElement_ListRange
     * @property {number} iStart
     * @property {number} iEnd
     */
    /** @typedef {UCF_ClientElement_ListRange|UCF_ClientElement_GridRange} UCF_ClientElement_Range */
    /**
     * @typedef {Object} UCF_ClientElement_MergeData
     * @property {number} from_x
     * @property {number} from_y
     * @property {number} to_x
     * @property {number} to_y
     */

    /**
     * @typedef {Object} UCF_ClientElement_EventConfiguration
     */
    /**
     * Base class for client elements that are managed on the client.
     * The server needs to send the client tree information in the current page.
     *
     * @class
     * @param {UCF_LS} oLS the Lightspeed instance
     * @param {string} sId the id of the element
     * @param {UCF_ClientElement_RenderInfo} oJson a Json representation of the control
     * @param {UCF_ClientElement} oParent The parent
     */
    function UCF_ClientElement(oLS, sId, oJson, oParent) {
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["UCF_ClientElement"]++;
        }
        ;
        if (arguments["length"] > 0) {
            UCF_EventProvider["apply"](this);

            this["defineEvents"](['PropertyChange', 'AfterRendering', 'BeforeRendering']);

            if (typeof sId === 'object') {
                // shift it
                oParent = oJson;
                oJson = sId;
                if (oJson["Id"]) {
                    sId = oJson["Id"];
                    delete oJson["Id"];
                }
            }

            /** @type {string} */
            this["sId"] = sId || UCF_ClientElement["createId"]('ls.id.'); // eslint-disable-line ur/no-memory-leaks
            /** @type {UCF_LS} */
            this["oLS"] = oLS;
            /** @type {UCF_ClientElement_RenderInfo} */
            this["oJson"] = oJson;

            /** @type {boolean} */
            this["bTempControl"] = oLS["oControlFactory"]["bAvoidClientControlRegistration"];

            if (!oLS["oControlFactory"]["bAvoidClientControlRegistration"]) {
                oLS["oControlFactory"]["mClientControls"][this["getId"]()] = this;
            }

            /** @type {Object<string,any>} */
            this["mProperties"] = {};
            /** @type {Object<string,UCF_ClientElement_Aggregation>} */
            this["mAggregations"] = {};
            /** @type {TODO} */
            this["mAssociations"] = {};
            /** @type {Object<string,UCF_ClientElement_EventConfiguration>} */
            this["mEvents"] = {};
            /** @type {string} */
            this["sAggregationName"] = null;
            /** @type {Object<string,UCF_ClientElement_BindingInfo>} */
            this["mBindingInfos"] = {};
            /** @type {Object<string,UCF_Model>} */
            this["oModels"] = {};
            /** @type {TODO} */
            this["mDebugInfos"] = {};
            /** @type {TODO} */
            this["mVirtualizedBindings"] = {};
            /** @type {UCF_Page} */
            this["oPage"] = oLS["oGetPageInternal"]();
            /** @type {boolean} */
            this["bRenderInvisibleContent"] = false;
            /** @type {TODO} */
            this["mCustomObjects"] = {};
            /** @type {Object<string,Array<UCF_ClientElement_ChildrenChange>>} */
            this["mChangeHandlers"] = {};
            /** @type {Object<string,UCF_ClientElement_ContentChangedParent>} */
            this["mContentChangedParents"] = {};
            /** @type {TODO} */
            this["mCustomStyleSuffix"] = {};
            /** @type {UCF_ClientElement} */
            this["oParent"] = oParent || null;
            /** @type {string} */
            this["sCustomStyleCheckName"] = null;
            /** @type {Object<string,string>} timers for virtualized aggregations */
            this["mUpdateAggregationTimers"] = {};

            this["initialize"]();
        }
    };window["UCF_ClientElement"] = UCF_ClientElement;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClientElement");
        UCF_ClientElement["_"] = {UCF_ClientElement: 0};
    }
    ;
    ;
    UCF_ClientElement["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_ClientElement.prototype["sClassName"] = "UCF_ClientElement";

    /**
     * @private
     * @static
     * @type {number}
     */
    UCF_ClientElement["iIdIndex"] = 0;
    /**
     * @private
     * @static
     * @type {number}
     */
    UCF_ClientElement["iUniqueIndex"] = 0;

    /**
     * Called after the constructor of the control is processed as the special
     * Client implementations for a control cannot override the constructor this
     * method needs to be implemented to initialize other variables.
     * @override
     * @private
     */
    UCF_ClientElement["prototype"]["initialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["initialize"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["initialize"] = 0;
    }
    ;

    /**
     * Returns the JSON for the rendering of the control. This is a special JSON
     * tree that contains value, default values of the control. The JSON is only
     * recreated if the control or one of its children is invalid. The created
     * render info is kept with the control instance as long as it is valid an can
     * be reused for additional rendering cycles.
     *
     * @private
     * @return {UCF_ClientElement_RenderInfo} The JSON for the rendering of the
     * control
     */
    UCF_ClientElement["prototype"]["getRenderInfo"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getRenderInfo"]++;
        }
        ;
        /** @type {UCF_ClientElement_RenderInfo} */
        var o = {};
        /** @type {UCF_ClientInterfaces_Interface} */
        var mMetadata = this["getMetadata"]();
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement_Aggregation|UCF_ClientElement} */
        var aAggregation;

        o["Id"] = this["getId"]();
        o["_sControlClassName"] = this["sClassName"];

        for (n in mMetadata["properties"]) {
            o[n] = n in this["mProperties"] ? this["mProperties"][n] : this['get' + n]();
        }

        for (n in mMetadata["associations"]) {
            o[n] = n in this["mAssociations"] ? this["mAssociations"][n] : this['get' + n]();
        }

        for (n in mMetadata["aggregations"]) {
            if (
                n !== 'ListBinding' &&
                n !== 'PropertyBinding' &&
                n !== 'GridBinding' &&
                n !== 'TreeBinding'
            ) {
                aAggregation = this['get' + n]();

                if (UCF_JsUtil["bIsArray"](aAggregation)) {
                    o[n] = UCF_JsUtil["map"](
                        aAggregation,
                        function (oAggregation) {
                            return oAggregation["getRenderInfo"]();
                        }
                    );
                } else if (aAggregation) {
                    o[n] = aAggregation["getRenderInfo"]();
                } else {
                    o[n] = null;
                }
            }
        }

        for (n in mMetadata["events"]) {
            if (!o["Events"]) {
                o["Events"] = {};
            }
            o["Events"][n] = this["getEventConfiguration"](n);
        }
        o["_oControl"] = this;
        // reset the invalidation state as the control is going to be rendered
        this["bInvalidated"] = false;

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getRenderInfo"] = 0;
    }
    ;

    /**
     * Pipelines to Eventprovider attach event as ACF Adapter has an event called
     * Event we cannot we would override the default implementation when creating
     * the interface of the ACF Adapter therefore the specialized created attach,
     * detach, fire methods always call _attachEvent in their implementation
     * @private
     */
    UCF_ClientElement["prototype"]["_attachEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["_attachEvent"]++;
        }
        ;
        UCF_EventProvider["prototype"]["attachEvent"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["_attachEvent"] = 0;
    }
    ;

    /**
     * @see UCF_ClientElement.prototype._attachEvent
     */
    UCF_ClientElement["prototype"]["_detachEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["_detachEvent"]++;
        }
        ;
        UCF_EventProvider["prototype"]["detachEvent"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["_detachEvent"] = 0;
    }
    ;

    /**
     * @see UCF_ClientElement.prototype._attachEvent
     */
    UCF_ClientElement["prototype"]["_fireEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["_fireEvent"]++;
        }
        ;
        UCF_EventProvider["prototype"]["fireEvent"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["_fireEvent"] = 0;
    }
    ;

    /**
     * Returns the top most control. The root control of a controltree. This always
     * has to be a control that can be rendered, therefore it is a
     * UCF_ClientControl instance
     *
     * @private
     * @return {UCF_ClientElement} The root control of the controltree.
     */
    UCF_ClientElement["prototype"]["getTopControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getTopControl"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oTop = this; // eslint-disable-line consistent-this

        while (oTop["getParent"]()) {
            oTop = oTop["getParent"]();
        }

        return oTop;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getTopControl"] = 0;
    }
    ;

    /**
     * Returns the UCF_ClientControlTree instance this control belongs to
     *
     * @public
     * @return {UCF_ClientControlTree} The controltree this control belongs to or
     * null
     */
    UCF_ClientElement["prototype"]["getControlTree"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getControlTree"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oTop = this["getTopControl"]();

        return (oTop && oTop["_oControlTree"]) || null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getControlTree"] = 0;
    }
    ;

    /**
     * Sets the UCF_ClientControlTree instance for the element
     *
     * Internal use only
     * @protected
     * @param {UCF_ClientControlTree} oControlTree The controltree
     */
    UCF_ClientElement["prototype"]["setControlTree"] = function (oControlTree) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setControlTree"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oTop = this["getTopControl"]();

        if (oTop === this) {
            oTop["_oControlTree"] = oControlTree;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setControlTree"] = 0;
    }
    ;

    /**
     * Returns whether the element contains the given element or id
     *
     * @public
     * @param {string|UCF_ClientElement} oControlOrId the control instance or the
     * control id
     * @return {boolean} true is the element contains the given element or id
     */
    UCF_ClientElement["prototype"]["contains"] = function (oControlOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["contains"]++;
        }
        ;
        /** @type {boolean} */
        var bContains = false;

        this["traverseChildren"](function (oControl) {
            if (
                (typeof oControlOrId === 'string' && oControl["getId"]() === oControlOrId) ||
                oControl === oControlOrId
            ) {
                bContains = true;

                return true;
            } else {
                return false;
            }
        });

        return bContains;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["contains"] = 0;
    }
    ;

    /**
     * Returns whether the current element is rendered
     *
     * @private
     * @return {boolean} true if the current element is rendered.
     */
    UCF_ClientElement["prototype"]["isRendered"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isRendered"]++;
        }
        ;
        return this["getUCFInstanceInternal"]() != null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isRendered"] = 0;
    }
    ;

    /**
     * Returns a JSON Object of the controls and its sub controls.
     *
     * @public
     * @return {Object} JSON Object of the controls and its sub controls.
     */
    UCF_ClientElement["prototype"]["toJSON"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["toJSON"]++;
        }
        ;
        /** @type {Object} */
        var o = {"Id": this["getId"]()};
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {Object} */
        var oResult = {};

        UCF_JsUtil["each"](this["mProperties"], function (sName, oValue) {
            if (oValue !== oMetadata["properties"][sName]["defaultValue"]) {
                o[sName] = oValue;
            }
        });
        UCF_JsUtil["each"](this["mAssociations"], function (sName, oValue) {
            if (oValue) {
                o[sName] = oValue;
            }
        });
        UCF_JsUtil["each"](this["mAggregations"], function (sName, oAggregation) {
            if (sName in oMetadata["aggregations"]) {
                if (oAggregation instanceof UCF_ClientElement) {
                    o[sName] = oAggregation["toJSON"]();
                } else if (UCF_JsUtil["bIsArray"](oAggregation)) {
                    o[sName] = UCF_JsUtil["map"](
                        oAggregation,
                        function (oAgg) {
                            return oAgg["toJSON"]();
                        }
                    );
                }
            }
        });
        UCF_JsUtil["each"](this["mEvents"], function (sName, oEvent) {
            o[sName] = oEvent;
        });

        oResult['sap.ls.controls.' + oMetadata["name"]] = o;

        return oResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["toJSON"] = 0;
    }
    ;

    /**
     * Returns a JSON String of the controls and its sub controls.
     * @public
     * @return {string} JSON String of the controls and its sub controls.
     */
    UCF_ClientElement["prototype"]["toJSONString"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["toJSONString"]++;
        }
        ;
        return UCF_JsUtil["sJsonStringify"](this["toJSON"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["toJSONString"] = 0;
    }
    ;

    /**
     * Adds a named custom object to the element
     *
     * @public
     * @param {string} sName The name of the object
     * @param {Object} oObject An object or reference to store with the element.
     */
    UCF_ClientElement["prototype"]["addCustomObject"] = function (sName, oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["addCustomObject"]++;
        }
        ;
        this["removeCustomObject"](sName);
        this["mCustomObjects"][sName] = oObject;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["addCustomObject"] = 0;
    }
    ;

    /**
     * Removes a named custom object from the element
     *
     * @public
     * @param {string} sName The name of the object
     * @param {boolean} [bDestroy=false] `true` to destroy the custom object
     */
    UCF_ClientElement["prototype"]["removeCustomObject"] = function (sName, bDestroy) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["removeCustomObject"]++;
        }
        ;
        if (this["mCustomObjects"][sName]) {
            if (this["mCustomObjects"][sName]["destroy"] && bDestroy) {
                this["mCustomObjects"][sName]["destroy"]();
            }
            delete this["mCustomObjects"][sName];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["removeCustomObject"] = 0;
    }
    ;

    /**
     * Returns the named custom object from the element
     *
     * @public
     * @param {string} sName The name of the object
     * @return {TODO} An object or reference stored with the element by given name.
     */
    UCF_ClientElement["prototype"]["getCustomObject"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getCustomObject"]++;
        }
        ;
        return this["mCustomObjects"][sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getCustomObject"] = 0;
    }
    ;

    /**
     * Returns a LSX String of the controls and its sub controls.
     *
     * @public
     * @param {string} sMethod the method used to register the control in the
     * control tree (e.g. 'content')
     * @return {_LSX} LSX String of the controls and its sub controls.
     */
    UCF_ClientElement["prototype"]["toLSXString"] = function (sMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["toLSXString"]++;
        }
        ;
        /** @type {Array<string>} */
        var aXML = [];
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {string} */
        var sControlName =
            oMetadata["name"]["substring"](0, 1)["toLowerCase"]() +
            oMetadata["name"]["substring"](1);
        /** @type {boolean} */
        var bClosed = false;

        aXML["push"]('<' + sControlName);
        if (sMethod) {
            aXML["push"](' method="' + sMethod + '"');
        }
        UCF_JsUtil["each"](this["mProperties"], function (sName, oValue) {
            if (oValue !== oMetadata["properties"][sName]["defaultValue"]) {
                sName = sName["substring"](0, 1)["toLowerCase"]() + sName["substring"](1);
                aXML["push"](' ' + sName + '="' + UCF_XSSEncoder["encodeXML"]('' + oValue) + '"');
            }
        });
        UCF_JsUtil["each"](this["mEvents"], function (sName, oEvent) {
            /** @type {string} */
            var n;

            sName = sName["substring"](0, 1)["toLowerCase"]() + sName["substring"](1);
            for (n in oEvent) {
                aXML["push"](' ' + sName + 'Info.' + n + '="' + oEvent[n] + '"');
            }
        });
        UCF_JsUtil["each"](this["mAggregations"], function (sName, oAggregation) {
            /** @type {number} */
            var i;

            if (sName in oMetadata["aggregations"]) {
                bClosed = true;
                aXML["push"]('>');
                if (oAggregation instanceof UCF_ClientElement) {
                    aXML["push"](oAggregation["toLSXString"]('set' + sName));
                } else if (UCF_JsUtil["bIsArray"](oAggregation)) {
                    for (i = 0; i < oAggregation["length"]; i++) {
                        aXML["push"](oAggregation[i]["toLSXString"]('add' + sName));
                    }
                }
            }
        });
        if (bClosed) {
            aXML["push"]('</' + sControlName + '>');
        } else {
            aXML["push"]('/>');
        }

        return aXML["join"]('');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["toLSXString"] = 0;
    }
    ;

    /**
     * Returns the name of the aggregation that the parent uses to embed this
     * control
     *
     * @private
     * @return {string} The name of the aggregation that the parent uses to embed
     * this control
     */
    UCF_ClientElement["prototype"]["getAggregationName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getAggregationName"]++;
        }
        ;
        return this["sAggregationName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getAggregationName"] = 0;
    }
    ;

    /**
     * Returns the first parent of the given class name
     *
     * @param {string} sClassName The name of the control type
     * @return {UCF_ClientElement} the first parent of the given class name
     */
    UCF_ClientElement["prototype"]["getParentByClassName"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getParentByClassName"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent;
        /** @type {string} */
        var sClassNames;

        if (typeof sClassName === 'string') {
            oParent = this["getParent"]();
            while (oParent) {
                if (oParent["sClassName"] === sClassName) {
                    return oParent;
                }
                oParent = oParent["getParent"]();
            }
        } else if (sClassName && sClassName["length"] > 0) {
            sClassNames = ',' + sClassName["join"](',') + ',';
            oParent = this["getParent"]();
            while (oParent) {
                if (sClassNames["indexOf"](',' + oParent["sClassName"] + ',') > -1) {
                    return oParent;
                }
                oParent = oParent["getParent"]();
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getParentByClassName"] = 0;
    }
    ;

    /**
     * Returns the index of the aggregation that the parent uses to embed this
     * control
     * @private
     * @return {?number} The index of the aggregation that the parent uses to embed
     * this control
     */
    UCF_ClientElement["prototype"]["getParentAggregationIndex"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getParentAggregationIndex"]++;
        }
        ;
        /** @type {UCF_ClientElement_Aggregation} */
        var aElements;
        /** @type {number} */
        var i;

        if (this["getParent"]()) {
            aElements = this["getParent"]()["getAggregation"](this["sAggregationName"]);
            for (i = 0; i < aElements["length"]; i++) {
                if (aElements[i] === this) {
                    return i;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getParentAggregationIndex"] = 0;
    }
    ;

    /**
     * Attaches an event handler that is called whenever a property is changed.
     * The event object passed to the given method is of type UCF_ClientElement_PropertyChangeInfo.
     *
     * @see UCF_ClientElement_PropertyChangeInfo
     * @private
     * @param {Object} oObj Any object.
     * @param {string} sMethod The method name to call on this object.
     */
    UCF_ClientElement["prototype"]["attachPropertyChange"] = function (oObj, sMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["attachPropertyChange"]++;
        }
        ;
        this["attachEvent"](this["E_EVENTS"]["PropertyChange"], oObj, sMethod);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["attachPropertyChange"] = 0;
    }
    ;

    /**
     * Detaches an event handler from the property change event.
     *
     * @private
     * @param {Object} oObj Any object.
     * @param {string} sMethod The method name to call on this object.
     */
    UCF_ClientElement["prototype"]["detachPropertyChange"] = function (oObj, sMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["detachPropertyChange"]++;
        }
        ;
        this["detachEvent"](this["E_EVENTS"]["PropertyChange"], oObj, sMethod);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["detachPropertyChange"] = 0;
    }
    ;

    /**
     * Fires the property change event and passes the object insta
     *
     * @private
     * @param {UCF_ClientElement_PropertyChangeInfo} mParam the payload to fire with the property change
     */
    UCF_ClientElement["prototype"]["firePropertyChange"] = function (mParam) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["firePropertyChange"]++;
        }
        ;
        this["_fireEvent"](this["E_EVENTS"]["PropertyChange"], mParam);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["firePropertyChange"] = 0;
    }
    ;

    /**
     * Pipelines any call to sMethodName of this instance to a debugger
     * statement.
     * @param {string} sMethodName name of the method to debug.
     * @private
     */
    UCF_ClientElement["prototype"]["addDebugInfo"] = function (sMethodName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["addDebugInfo"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var self;

        if (!this["mDebugInfos"][sMethodName]) {
            self = this;
            this["mDebugInfos"][sMethodName] = this[sMethodName];

            this[sMethodName] = (function () { // eslint-disable-line ur/no-memory-leaks
                return function () {
                    /** @type {number} */
                    var iTS = (new Date())["getTime"]();

                    debugger; // eslint-disable-line no-debugger

                    // eslint-disable-next-line no-magic-numbers
                    if ((new Date())["getTime"]() - iTS < 100) {
                        // no debugger attached
                        window["alert"](
                            'There is no debugger attached. Please attach it using F12 tools'
                        );
                    }

                    return self["mDebugInfos"][sMethodName]["apply"](self, arguments);
                };
            })(sMethodName, self);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["addDebugInfo"] = 0;
    }
    ;

    /**
     * Removes the pipelining to sMethodName of this instance to a debugger
     * statement.
     * @param {string} sMethodName name of the method to debug.
     * @private
     */
    UCF_ClientElement["prototype"]["removeDebugInfo"] = function (sMethodName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["removeDebugInfo"]++;
        }
        ;
        if (this["mDebugInfos"][sMethodName]) {
            this[sMethodName] = this["mDebugInfos"][sMethodName];
            delete this["mDebugInfos"][sMethodName];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["removeDebugInfo"] = 0;
    }
    ;

    /**
     * Render call to an element will cause a rerendering of the parent if it is a control
     * @public
     */
    UCF_ClientElement["prototype"]["render"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["render"]++;
        }
        ;
        if (this["getParent"]()) {
            this["getParent"]()["render"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["render"] = 0;
    }
    ;

    /**
     * Render call to an element will cause a rerendering of the parent if it is a control
     * @private
     */
    UCF_ClientElement["prototype"]["rerender"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["rerender"]++;
        }
        ;
        if (this["getParent"]()) {
            this["getParent"]()["rerender"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["rerender"] = 0;
    }
    ;

    /**
     * Sets the property with the given name to oValue. If the value was changed
     * the model is updated if the property was bound and also a property change
     * event is fired.
     *
     * @private
     * @param {string} sPropertyName the name of the property
     * @param {T} oValue the new value
     * @param {boolean} bSuppressRerendering avoid an rerendering of the element
     * after the property change. Rerendering has to be triggered manually in this
     * case.
     * @return {UCF_ClientElement} This client element for chaining
     * @template T
     */
    UCF_ClientElement["prototype"]["setProperty"] = function (sPropertyName, oValue, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setProperty"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {T} */
        var oOldValue;
        /** @type {UCF_ClientElement_RenderInfo} */
        var oJson;

        if (!oMetadata["properties"][sPropertyName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Property ' + sPropertyName + ' not defined.', "ClientElement.js(762): setProperty");
            }
            ;

            return this;
        }
        oOldValue = this["getProperty"](sPropertyName);

        // exit if the property value was not even changed
        if (oOldValue === oValue) {
            return this;
        }

        if (
            UCF_ClientElement["bIsDefaultValue"](oValue, this["mProperties"], sPropertyName)
        ) {
            oValue = UCF_ClientElement["oGetDefaultValue"](
                oMetadata["properties"],
                sPropertyName
            );
        }
        if (UCF_ClientElement["bIsPrimitiveValue"](
            oValue,
            oMetadata["properties"],
            sPropertyName
        )) {
            oValue = UCF_ClientElement["oGetPrimitiveValue"](
                oValue,
                oMetadata["properties"],
                sPropertyName
            );
        }
        if (UCF_ClientElement["bIsEnumValue"](oMetadata["properties"], sPropertyName)) {
            oValue = UCF_ClientElement["oGetEnumValue"](
                oValue,
                oMetadata["properties"],
                sPropertyName
            );
        }

        // check if the value changed
        if (oOldValue !== oValue) {
            // now set the new value
            this["mProperties"][sPropertyName] = oValue;

            // handle CustomData globally here and convert to JSON if possible
            if (sPropertyName === 'CustomData') {
                // never rerender if custom data is added and a UCF_Instance exists
                if (this["getUCFInstanceInternal"]()) {
                    this["getUCFInstanceInternal"]()["sCustomData"] = oValue;
                    bSuppressRerendering = true;
                }
                try {
                    oJson = UCF_JsUtil["oJsonParse"](oValue);
                    if (oJson) {
                        this["_oCustomDataJson"] = oJson;
                    }
                } catch (ex) {
                    this["_oCustomDataJson"] = null;
                }
            }

            // trigger model update and fire property change,
            this["emitPropertyChange"](sPropertyName, oOldValue, oValue);
            this["updateBoundModelProperty"](sPropertyName, oValue, this["mProperties"]);
            // suppress rerendering
            if (!bSuppressRerendering) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Setting property: ' + sPropertyName + ' invalidated the control: ' + this["sClassName"] + '#' + this["getId"](), "ClientElement.js(827): setProperty");
                }
                ;
                this["invalidate"]();
            }
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setProperty"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sName the name of the property
     * @param {T} oValue the value to update
     * @param {UCF_ClientElement_ValueBag} oActiveValues the values, e.g. this.mProperties
     */
    UCF_ClientElement["prototype"]["updateBoundModelProperty"] = function (sName, oValue, oActiveValues) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateBoundModelProperty"]++;
        }
        ;
        if (
            this["mBindingInfos"][sName] &&
            !this["mBindingInfos"][sName]["skipModelUpdate"]
        ) {
            this["updateModelProperty"](sName, oValue, oActiveValues[sName]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateBoundModelProperty"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sName the name of the property
     * @param {T} oOld the old value
     * @param {T} oNew the new value
     * @template T
     * @fires M_EVENTS.PropertyChange
     */
    UCF_ClientElement["prototype"]["emitPropertyChange"] = function (sName, oOld, oNew) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["emitPropertyChange"]++;
        }
        ;
        if (this["hasListeners"](this["E_EVENTS"]["PropertyChange"])) {
            this["firePropertyChange"]({
                "sender": this,
                "name": sName,
                "oldValue": oOld,
                "newValue": oNew
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["emitPropertyChange"] = 0;
    }
    ;

    /** @typedef {Object<string,UCF_ClientInterfaces_Property>|Object<string,UCF_ClientInterfaces_Association>|Object<string,UCF_ClientInterfacesUCF_ClientElement_Aggregation>} UCF_ClientElement_ValueBag */
    /**
     * @private
     * @static
     * @param {UCF_ClientElement_ValueBag} oValueBag the interface container (e.g. oMetadata.properties)
     * @param {string} sPropertyName the property
     * @return {any}
     */
    UCF_ClientElement["oGetDefaultValue"] = function (oValueBag, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["oGetDefaultValue"]++;
        }
        ;
        return typeof oValueBag === 'object'
            && sPropertyName in oValueBag
            && oValueBag[sPropertyName]["defaultValue"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["oGetDefaultValue"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {T} oValue the value
     * @param {UCF_ClientElement_ValueBag} oActiveValues the values in the client element
     * @param {string} sPropertyName the property
     * @return {boolean} `true` if oValue is a default value
     * @template T
     */
    UCF_ClientElement["bIsDefaultValue"] = function (oValue, oActiveValues, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bIsDefaultValue"]++;
        }
        ;
        return oValue === null ||
            typeof oValue === 'undefined' ||
            !(sPropertyName in oActiveValues);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bIsDefaultValue"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {T} oValue the value
     * @param {UCF_ClientElement_ValueBag} oValueBag the interface container (e.g. oMetadata.properties)
     * @param {string} sPropertyName the property
     * @return {T}
     * @template T
     */
    UCF_ClientElement["oGetPrimitiveValue"] = function (oValue, oValueBag, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["oGetPrimitiveValue"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Property} */
        var oProperty = oValueBag[sPropertyName];
        /** @type {string} */
        var sType = oProperty["type"];
        /** @type {T} */
        var oTmpValue;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(WARNING, 'Property ' + sPropertyName + ' must be of type ' + sType, "ClientElement.js(915): oGetPrimitiveValue");
        }
        ;

        // do some type mapping
        switch (sType) {
            case 'string':
                return '' + oValue;
            case 'int':
                oTmpValue = parseInt(oValue);

                return isNaN(oTmpValue)
                    ? oProperty["defaultValue"]
                    : oTmpValue;
            case 'float':
                oTmpValue = parseFloat(oValue);

                return isNaN(oTmpValue)
                    ? oProperty["defaultValue"]
                    : oTmpValue;
            case 'boolean':
                return oValue === 'X' || oValue === 'true' || oValue !== 0;
            default:
                return oValue;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["oGetPrimitiveValue"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {T} oValue the value
     * @param {UCF_ClientElement_ValueBag} oValueBag the interface container
     * @param {string} sPropertyName the property
     * @return {boolean} `true` if oValue is a primitive value
     * @template T
     */
    UCF_ClientElement["bIsPrimitiveValue"] = function (oValue, oValueBag, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bIsPrimitiveValue"]++;
        }
        ;
        /** @type {string} */
        var sType = oValueBag[sPropertyName]["type"];

        return typeof oValue !== sType &&
            !UCF_StringUtil["bContains"](sType, 'UCF_ClientInterfaces.E.');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bIsPrimitiveValue"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {T} oValue the value
     * @param {UCF_ClientElement_ValueBag} oValueBag the value bag
     * @param {string} sPropertyName the property
     * @return {T}
     * @template T
     */
    UCF_ClientElement["oGetEnumValue"] = function (oValue, oValueBag, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["oGetEnumValue"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Property} */
        var oProperty = oValueBag[sPropertyName];
        /** @type {string} */
        var sType = oProperty["type"];
        /** @type {UCF_ClientInterfaces_Enum} */
        var oEnum = UCF_ClientInterfaces["E"][
            sType["substring"](sType["lastIndexOf"]('.') + 1)
            ];

        if (oValue in oEnum) {
            return oEnum[oValue];
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Property ' + sPropertyName + ' must be of type ' + sType + ', ' + oValue + ' is not a valid enum value for' + sType, "ClientElement.js(979): oGetEnumValue");
            }
            ;

            return oProperty["defaultValue"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["oGetEnumValue"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_ClientElement_ValueBag} oValueBag the value bag
     * @param {string} sPropertyName the name of the property
     * @return {boolean} `true` if sPropertyName points to an enum in oValueBag
     */
    UCF_ClientElement["bIsEnumValue"] = function (oValueBag, sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bIsEnumValue"]++;
        }
        ;
        return UCF_StringUtil["bStartsWith"](
            oValueBag[sPropertyName]["type"],
            'UCF_ClientInterfaces.E.'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bIsEnumValue"] = 0;
    }
    ;

    /**
     * Returns the value of the property sPropertyName.
     * It returns and applies the default value if the property was not set.
     *
     * @private
     * @param {string} sPropertyName the name of the property
     * @return {any} The value of the property.
     */
    UCF_ClientElement["prototype"]["getProperty"] = function (sPropertyName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getProperty"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (oMetadata["properties"][sPropertyName]) {
            if (!(sPropertyName in this["mProperties"])) {
                this["mProperties"][sPropertyName] = oMetadata["properties"][sPropertyName]["defaultValue"];
            }

            return this["mProperties"][sPropertyName];
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Property ' + sPropertyName + ' not defined.', "ClientElement.js(1018): getProperty");
            }
            ;

            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getProperty"] = 0;
    }
    ;

    /**
     * Sets the association with the given name to oValue. If the value was changed
     * the model is updated if the property was bound and also a property change event is fired.
     *
     * @private
     * @param {string} sName the name of the property
     * @param {any} oValue the new value
     * @param {boolean} bSuppressRerendering avoid an rerendering of the element after the property change.
     *                  Rerendering has to be triggered manually in this case.
     * @return {UCF_ClientElement} This client element for chaining
     */
    UCF_ClientElement["prototype"]["setAssociation"] = function (sName, oValue, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setAssociation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {any} */
        var oOldValue;

        if (!oMetadata["associations"][sName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Association ' + sName + ' not defined.', "ClientElement.js(1042): setAssociation");
            }
            ;

            return this;
        }

        oOldValue = this["getAssociation"](sName);

        if (oOldValue !== oValue) {
            oValue = UCF_ClientElement["oGetDefaultValue"](
                    oValue,
                    oMetadata["associations"],
                    this["mAssociations"],
                    sName
                ) ||
                UCF_ClientElement["oGetPrimitiveValue"](
                    oValue,
                    oMetadata["associations"],
                    sName
                ) ||
                oValue;

            // check if the value changed
            if (oOldValue !== oValue) {
                // now set the new value
                this["mAssociations"][sName] = oValue;

                // trigger model update and fire property change
                this["emitPropertyChange"](sName, oOldValue, oValue);
                this["updateBoundModelProperty"](sName, oValue, this["mAssociations"]);
                // suppress rerendering
                if (!bSuppressRerendering) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Setting Association:' + sName + ' invalidated the control:' + this["sClassName"] + '-' + this["getId"](), "ClientElement.js(1073): setAssociation");
                    }
                    ;
                    this["invalidate"]();
                }
            }
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setAssociation"] = 0;
    }
    ;

    /**
     * Returns the value of the association sPropertyName. It returns and applies
     * the default value if the property was not set.
     * @private
     * @param {string} sName the name of the association
     * @return {any} The value of the property.
     */
    UCF_ClientElement["prototype"]["getAssociation"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getAssociation"]++;
        }
        ;
        var oMetadata = this["getMetadata"]();

        if (!oMetadata["associations"][sName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Association ' + sName + ' not defined.', "ClientElement.js(1093): getAssociation");
            }
            ;

            return null;
        }
        if (!(sName in this["mAssociations"])) {
            this["mAssociations"][sName] = oMetadata["associations"][sName]["defaultValue"];
        }

        return this["mAssociations"][sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getAssociation"] = 0;
    }
    ;

    /**
     * Returns an aggregations with a given name, if index is given it returns the
     * instance or a special index. This function might also return the array for
     * aggregations that are iterators.
     *
     * @private
     * @param {string} sAggregationName The name of the aggregation
     * @param {integer} iIndex optional The objects index that should be returns in
     * case of 0..n aggregations
     * @return {Array<UCF_ClientElement>|UCF_ClientElement} An array if iIndex is
     * not given or it is a 0..n aggregation else the object or null if not set.
     */
    UCF_ClientElement["prototype"]["getAggregation"] = function (sAggregationName, iIndex) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (!oMetadata["aggregations"][sAggregationName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sAggregationName + ' not defined.', "ClientElement.js(1121): getAggregation");
            }
            ;

            return null;
        }

        if (typeof iIndex === 'undefined' || iIndex === null) {
            if (oMetadata["aggregations"][sAggregationName]["multiple"]) {
                return this["mAggregations"][sAggregationName] || [];
            } else {
                return this["mAggregations"][sAggregationName];
            }
        } else if (oMetadata["aggregations"][sAggregationName]["multiple"]) {
            if (this["mAggregations"][sAggregationName] && this["mAggregations"][sAggregationName]["length"] > iIndex) {
                return this["mAggregations"][sAggregationName][iIndex];
            } else {
                return null;
            }
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getAggregation"] = 0;
    }
    ;

    /**
     * Sets an aggregation with a given name for a 0..1 aggregation.
     *
     * @private
     * @param {string} sAggregationName The name of the aggregation
     * @param {UCF_ClientElement} oInstance The instnace to be set
     * @param {boolean} bSuppressRerendering Whether rerendering should be triggered immediately
     * @return {UCF_ClientElement} This client element for chaining
     */
    UCF_ClientElement["prototype"]["setAggregation"] = function (sAggregationName, oInstance, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (!oMetadata["aggregations"][sAggregationName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sAggregationName + ' not defined.', "ClientElement.js(1157): setAggregation");
            }
            ;

            return this;
        }

        if (oMetadata["aggregations"][sAggregationName]["multiple"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Setter for ' + sAggregationName + ' not supported. Please use add' + sAggregationName, "ClientElement.js(1163): setAggregation");
            }
            ;
        } else {
            // exit if the aggregation has already the same instance
            if (
                this["mAggregations"][sAggregationName] &&
                this["mAggregations"][sAggregationName] === oInstance
            ) {
                return this;
            }

            if (this["mAggregations"][sAggregationName]) {
                this["mAggregations"][sAggregationName]["removeFromParent"]();
            }
            this["mAggregations"][sAggregationName] = oInstance;
            oInstance["setParent"](this, sAggregationName, bSuppressRerendering);
            if (!bSuppressRerendering) {
                this["invalidate"]();
            }
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setAggregation"] = 0;
    }
    ;

    /**
     * Adds an aggregation with a given name at the end.
     *
     * @private
     * @param {string} sAggregationName the name of the aggregation
     * @param {UCF_ClientElement} oInstance the instance to add to the aggregation
     * @param {boolean} bSuppressRerendering `true` to suppress rerendering
     */
    UCF_ClientElement["prototype"]["addAggregation"] = function (sAggregationName, oInstance, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["addAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (!oMetadata["aggregations"][sAggregationName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sAggregationName + ' not defined.', "ClientElement.js(1199): addAggregation");
            }
            ;
        } else if (oMetadata["aggregations"][sAggregationName]["multiple"]) {
            if (!this["mAggregations"][sAggregationName]) {
                this["mAggregations"][sAggregationName] = [];
            }
            this["mAggregations"][sAggregationName]["push"](oInstance);
            oInstance["setParent"](this, sAggregationName, bSuppressRerendering);
            if (!bSuppressRerendering) {
                this["invalidate"]();
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Adding for ' + sAggregationName + ' not supported. Please use set' + sAggregationName, "ClientElement.js(1210): addAggregation");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["addAggregation"] = 0;
    }
    ;

    /**
     * Inserts an aggregation with the given name at the given index or as the last item
     *
     * @private
     * @param {string} sAggregationName the string identifying the aggregation the
     * Element should be inserted into
     * @param {UCF_ClientElement} oInstance the element instance to insert
     * @param {number} iIndex the index in the aggregation to insert oInstance to
     * @param {boolean} [bSuppressRerendering] if true, the UI element is not
     * marked for redraw
     * @return {UCF_ClientElement} This client element for chaining
     */
    UCF_ClientElement["prototype"]["insertAggregation"] = function (sAggregationName, oInstance, iIndex, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["insertAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (!oMetadata["aggregations"][sAggregationName]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sAggregationName + ' not defined.', "ClientElement.js(1231): insertAggregation");
            }
            ;
        } else if (oMetadata["aggregations"][sAggregationName]["multiple"]) {
            if (!this["mAggregations"][sAggregationName]) {
                this["mAggregations"][sAggregationName] = [];
            }
            if (!isNaN(iIndex) && iIndex < 0) {
                iIndex = 0;
            }
            if (!isNaN(iIndex) &&
                this["mAggregations"][sAggregationName]["length"] > iIndex
            ) {
                this["mAggregations"][sAggregationName]["splice"](iIndex, 0, oInstance);
                oInstance["setParent"](this, sAggregationName, bSuppressRerendering);
                if (!bSuppressRerendering) {
                    this["invalidate"]();
                }
            } else {
                this["addAggregation"](sAggregationName, oInstance, bSuppressRerendering);
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Adding for ' + sAggregationName + ' not supported. Please use set' + sAggregationName, "ClientElement.js(1251): insertAggregation");
            }
            ;
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["insertAggregation"] = 0;
    }
    ;

    /**
     * Removes the control from its parent
     *
     * @public
     * @param {boolean} [bSuppressRerendering] if true, the UI element is not
     * marked for redraw
     */
    UCF_ClientElement["prototype"]["removeFromParent"] = function (bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["removeFromParent"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent;
        /** @type {string} */
        var sName;
        /** @type {string} */
        var n;
        /** @type {Array<UCF_ClientElement>} */
        var oAggregation;
        /** @type {number} */
        var i;
        /** @type {UCF_ClientElement} */
        var oElement;

        if (this["oParent"]) {
            oParent = this["oParent"];
            sName = this["sAggregationName"];

            if (this["mContentChangedParents"]) {
                for (n in this["mContentChangedParents"]) {
                    this["mContentChangedParents"][n]["oObject"]["fireChildrenChanged"](
                        this["mContentChangedParents"][n]["sParentAggregation"],
                        this,
                        this["oParent"],
                        null,
                        sName,
                        false
                    );
                }
            }
            delete this["mContentChangedParents"][oParent["getId"]()];

            oAggregation = oParent["mAggregations"][sName];
            if (!oAggregation) {
                return;
            }

            if (oParent["mMetadata"]["aggregations"][sName]["multiple"]) {
                for (i = 0; i < oAggregation["length"]; i++) {
                    oElement = oAggregation[i];
                    if (oElement === this) {
                        oAggregation["splice"](i, 1);
                    }
                }
            } else if (oAggregation === this) {
                oParent["mAggregations"][sName] = null;
            }
            if (!bSuppressRerendering) {
                oParent["invalidate"]();
            }
        }
        this["sAggregationName"] = null;
        this["oParent"] = null;

        this["updateBindingContext"]();
        this["updateBindings"](true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["removeFromParent"] = 0;
    }
    ;

    /**
     * Removes an element from the aggregation named `sAggregationName`.
     *
     * @private
     * @param {string} sName the string identifying the aggregation the Element
     * should be removed from
     * @param {number|UCF_ClientElement} vElement the position or ID of the Element
     * to remove or the Element itself; if `vElement` is invalid, a negative value
     * or a value greater or equal than the current size of the aggregation,
     * nothing is removed
     * @param {boolean} [bSuppressRerendering] if true, the UI element is not
     * marked for redraw
     * @return {UCF_ClientElement} The removed element or null
     */
    UCF_ClientElement["prototype"]["removeAggregation"] = function (sName, vElement, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["removeAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {UCF_ClientElement_Aggregation} */
        var oAggregation;
        /** @type {UCF_ClientElement} */
        var oInstance;
        /** @type {number} */
        var i;
        /** @type {UCF_ClientElement} */
        var oElement;
        /** @type {UCF_ClientElement} */
        var oRemovedElement;

        if (!this["hasAggregation"](sName)) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined.', "ClientElement.js(1351): removeAggregation");
            }
            ;

            return null;
        }
        if (typeof (vElement) !== 'number' && !vElement) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'No element specified for removal in aggregation ' + sName + '.', "ClientElement.js(1356): removeAggregation");
            }
            ;

            return null;
        }

        oAggregation = this["mAggregations"][sName];
        if (!oAggregation) {
            return null;
        }

        if (vElement instanceof UCF_ClientElement) {
            oInstance = vElement;
            if (oMetadata["aggregations"][sName]["multiple"]) {
                for (i = 0; i < oAggregation["length"]; i++) {
                    oElement = oAggregation[i];
                    if (oElement === oInstance) {
                        oElement["setParent"](null, sName, bSuppressRerendering);
                        oElement["destroy"](bSuppressRerendering);

                        return oElement;
                    }
                }
            } else if (oAggregation === oInstance) {
                this["clearAggregation"](sName, bSuppressRerendering);
            }

            return null;
        } else if (UCF_JsUtil["bIsArray"](oAggregation)) {
            if (oAggregation["length"] > vElement) {
                oRemovedElement = oAggregation[vElement];

                oAggregation[vElement]["destroy"](bSuppressRerendering);
                oAggregation["splice"](vElement, 1);
                if (!bSuppressRerendering) {
                    this["invalidate"]();
                }

                return oRemovedElement;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Nothing to remove for ' + sName + ' at index ' + vElement, "ClientElement.js(1395): removeAggregation");
                }
                ;

                return null;
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Remove for ' + sName + ' not supported. Please use clear' + sName, "ClientElement.js(1400): removeAggregation");
            }
            ;

            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["removeAggregation"] = 0;
    }
    ;

    /**
     * Replaces a old instance with the new instance of an aggregation
     *
     * @private
     * @param {string} sName The name of the aggregation
     * @param {UCF_ClientElement} oOldInstance The instance to be replaced
     * @param {UCF_ClientElement} oNewInstance The instance to be added
     * @param {boolean} [bSuppressRerendering] if true, the UI element is not marked for redraw
     * @return {UCF_ClientElement} This client element for chaining
     */
    UCF_ClientElement["prototype"]["replaceAggregation"] = function (sName, oOldInstance, oNewInstance, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["replaceAggregation"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {UCF_ClientElement_Aggregation} */
        var oAggregation;
        /** @type {UCF_ClientElement} */
        var oInstance;
        /** @type {number} */
        var i;
        /** @type {UCF_ClientElement} */
        var oElement;
        /** @type {UCF_ClientElement} */
        var self;

        if (!this["hasAggregation"](sName)) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined.', "ClientElement.js(1431): replaceAggregation");
            }
            ;

            return this;
        }
        if (typeof oOldInstance !== 'number' && !oOldInstance) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'No element specified for replacing in aggregation ' + sName + '.', "ClientElement.js(1436): replaceAggregation");
            }
            ;

            return this;
        }

        oAggregation = this["mAggregations"][sName];

        if (oAggregation && oOldInstance instanceof UCF_ClientElement) {
            oInstance = oOldInstance;
            if (oMetadata["aggregations"][sName]["multiple"]) {
                self = this;

                UCF_JsUtil["forEach"](
                    UCF_JsUtil["filter"](
                        oAggregation,
                        function (oElement) {
                            return oElement === oInstance;
                        }
                    ),
                    function (oElement, i) {
                        oAggregation["splice"](i, 1, oNewInstance);
                        oElement["setParent"](null, sName, bSuppressRerendering);
                        oNewInstance["setParent"](self, sName, bSuppressRerendering);
                        if (!bSuppressRerendering) {
                            self["invalidate"]();
                        }
                    }
                );
                for (i = 0; i < oAggregation["length"]; i++) {
                    oElement = oAggregation[i];
                    if (oElement === oInstance) {
                        oAggregation["splice"](i, 1, oNewInstance);
                    }
                }
            } else if (oAggregation === oInstance) {
                this["getRootRef"](); // has no side effects => why?

                this["clearAggregation"](sName, bSuppressRerendering);
                this["setAggregation"](sName, oNewInstance, bSuppressRerendering);
            }
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["replaceAggregation"] = 0;
    }
    ;

    /**
     * Removes all content from an aggregation with the given name.
     * and destroys all child elements.
     * @param {strig} sName The name of the aggregation
     * @param {boolean} [bSuppressRerendering] if true, the UI element is not marked for redraw
     * @private
     */
    UCF_ClientElement["prototype"]["clearAggregation"] = function (sName, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["clearAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_Aggregation} */
        var oAggregation;

        if (!this["hasAggregation"](sName)) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined for ' + this["sClassName"], "ClientElement.js(1491): clearAggregation");
            }
            ;

            return;
        }
        oAggregation = this["mAggregations"][sName];

        if (oAggregation) {
            delete this["mAggregations"][sName];

            if (UCF_JsUtil["bIsArray"](oAggregation)) {
                UCF_JsUtil["forEach"](
                    oAggregation,
                    function (oAgg) {
                        oAgg["destroy"](bSuppressRerendering);
                    }
                );
            } else {
                oAggregation["destroy"](bSuppressRerendering);
            }

            if (!bSuppressRerendering) {
                this["invalidate"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["clearAggregation"] = 0;
    }
    ;

    /**
     * Returns the id of the element
     *
     * @public
     * @return {string} the id of the client element
     */
    UCF_ClientElement["prototype"]["getId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getId"]++;
        }
        ;
        return this["sId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getId"] = 0;
    }
    ;

    /**
     * Sets the parent of the element based on an aggregation name
     *
     * @public
     * @param {UCF_ClientElement} oNewParent The client element that is the new
     * parent for this client element
     * @param {string} sAggregationName The name of the aggregation that this
     * client element is part of
     * @param {boolean} [bSuppressRerendering] `true` to suppress rerendering
     */
    UCF_ClientElement["prototype"]["setParent"] = function (oNewParent, sAggregationName, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setParent"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent = this["oParent"];
        /** @type {string} */
        var n;
        /** @type {boolean} */
        var bParentChanged;
        /** @type {UCF_ClientElement} */
        var oOldParent;

        if (this["mContentChangedParents"] && this["oParent"] !== oNewParent) {
            for (n in this["mContentChangedParents"]) {
                this["mContentChangedParents"][n]["oObject"]["fireChildrenChanged"](
                    this["mContentChangedParents"][n]["sParentAggregation"],
                    this,
                    oParent,
                    oNewParent,
                    sAggregationName,
                    oNewParent != null
                );
            }
        }

        bParentChanged = oNewParent && this["oParent"] !== oNewParent;
        oOldParent = this["oParent"];

        if (this["oParent"] && this["oParent"] !== oNewParent) {
            this["removeFromParent"](bSuppressRerendering);
        }

        if (oNewParent) {
            // add and move
            this["sAggregationName"] = sAggregationName || 'Content';
            if (oNewParent["mChangeHandlers"][this["sAggregationName"]]) {
                this["mContentChangedParents"][oNewParent["getId"]()] = {
                    "oObject": oNewParent,
                    "sParentAggregation": this["sAggregationName"]
                };
            } else if (oNewParent["mContentChangedParents"]) {
                for (n in this["mContentChangedParents"]) {
                    delete this["mContentChangedParents"][n];
                }
                for (n in oNewParent["mContentChangedParents"]) {
                    this["mContentChangedParents"][n] = {
                        "oObject": oNewParent["mContentChangedParents"][n]["oObject"],
                        "sParentAggregation": oNewParent["mContentChangedParents"][n]
                            ["sParentAggregation"]
                    };
                }
                for (n in this["mContentChangedParents"]) {
                    this["mContentChangedParents"][n]["oObject"]["fireChildrenChanged"](
                        this["mContentChangedParents"][n]["sParentAggregation"],
                        this,
                        oParent,
                        oNewParent,
                        sAggregationName,
                        oNewParent != null
                    );
                }
            }
        }
        if (!oNewParent && oParent) {
            // remove
            for (n in this["mContentChangedParents"]) {
                delete this["mContentChangedParents"][n];
            }
        }

        this["oParent"] = oNewParent;
        if (bParentChanged) {
            if (oOldParent) {
                oOldParent["invalidate"]();
            }
            this["invalidate"]();
        }
        if (oNewParent && this["hasModel"]()) {
            this["updateBindingContext"]();
            this["updateBindings"](true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setParent"] = 0;
    }
    ;

    /**
     * Returns the parent of the control
     *
     * @public
     * @return {UCF_ClientElement} the parent of the control
     */
    UCF_ClientElement["prototype"]["getParent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getParent"]++;
        }
        ;
        return this["oParent"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getParent"] = 0;
    }
    ;

    /**
     * Sets the UCF event configuration for an event
     *
     * @private
     * @param {string} sEventName The name of the event
     * @param {Object} oConfig The UCF event configuration as JSON from a control tree
     */
    UCF_ClientElement["prototype"]["setEventConfiguration"] = function (sEventName, oConfig) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setEventConfiguration"]++;
        }
        ;
        this["mEvents"][sEventName] = oConfig;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setEventConfiguration"] = 0;
    }
    ;

    /**
     * Returns the UCF event configuration for an event
     *
     * @private
     * @param {string} sEventName The name of the event
     * @return {Object} The UCF event configuration as JSON from a control tree
     */
    UCF_ClientElement["prototype"]["getEventConfiguration"] = function (sEventName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getEventConfiguration"]++;
        }
        ;
        return this["mEvents"][sEventName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getEventConfiguration"] = 0;
    }
    ;

    /**
     * Returns true if a property with the given name exists for the control.
     *
     * @private
     * @param {string} sName the name of the property
     * @return {boolean} `true` if a property with the given name exists for the
     * control.
     */
    UCF_ClientElement["prototype"]["hasProperty"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["hasProperty"]++;
        }
        ;
        /** @type {Object<string,UCF_ClientInterfaces_Properties>} */
        var oProperties = this["getMetadata"]()["properties"];

        return oProperties && oProperties[sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["hasProperty"] = 0;
    }
    ;

    /**
     * Returns true if an aggregation with the given name exists for the control.
     *
     * @private
     * @param {string} sName the name of the aggregation
     * @return {boolean} true if an aggregation with the given name exists for the control.
     */
    UCF_ClientElement["prototype"]["hasAggregation"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["hasAggregation"]++;
        }
        ;
        /** @type {Object<string,UCF_ClientElement_Aggregation>} */
        var oAggregations = this["getMetadata"]()["aggregations"];

        return oAggregations && oAggregations[sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["hasAggregation"] = 0;
    }
    ;

    /**
     * Binds a path to the element. Based on the runtime type of the path in the
     * model the defaultAggregation or defaultProperty is used if any
     *
     * @private
     * @param {Object} oBindingInfo A JSON containing the binding info for the object
     */
    UCF_ClientElement["prototype"]["bind"] = function (oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bind"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (oMetadata["defaultProperty"] || oMetadata["defaultAggregation"]) {
            if (oMetadata["defaultAggregation"]) {
                this["bindAggregation"](oMetadata["defaultAggregation"], oBindingInfo);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'No default aggregation found', "ClientElement.js(1692): bind");
                }
                ;
            }
            if (oMetadata["defaultProperty"]) {
                this["bindAggregation"](oMetadata["defaultAggregation"], oBindingInfo);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'No default property found', "ClientElement.js(1697): bind");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bind"] = 0;
    }
    ;

    /**
     * Bind a property to the model.
     * The Setter for the given property will be called with the value retrieved
     * from the data model.
     * This is a generic method which can be used to bind any property to the
     * model. A control may flag properties in the metamodel with
     * bindable="bindable" to get typed bind methods for a property.
     *
     * @public
     * @param {string} sName the name of the property
     * @param {string|UCF_ClientElement_BindingInfo} oBindingInfo the binding information
     * @return {UCF_ClientElement} reference to the instance itself
     */
    UCF_ClientElement["prototype"]["bindProperty"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bindProperty"]++;
        }
        ;
        /** @type {string} */
        var sPath;
        /** @type {TODO} */
        var oFormat;
        /** @type {string} */
        var sMode;
        /** @type {string} */
        var sModelName;
        /** @type {function} */
        var fnFormatter;
        /** @type {TODO} */
        var oType;
        /** @type {string} */
        var iSeparatorPos;

        if (this["hasProperty"](sName)) {
            // old API compatbility (sName, sPath, oFormat, sMode)
            if (typeof oBindingInfo === 'string') {
                sPath = arguments[1];
                oFormat = arguments[2]; // eslint-disable-line no-magic-numbers
                sMode = arguments[3]; // eslint-disable-line no-magic-numbers
                // if a model separator is found in the path, extract model name and path
                if (iSeparatorPos > 0) {
                    sModelName = sPath["substr"](0, iSeparatorPos);
                    sPath = sPath["substr"](iSeparatorPos + 1);
                }
                // find out whether formatter or type has been provided
                UCF_ClassLoader["oGetClass"]('UCF_SimpleType');
                if (typeof oFormat === 'function') {
                    fnFormatter = oFormat;
                } else if (oFormat instanceof UCF_SimpleType) {
                    oType = oFormat;
                }
                oBindingInfo = {
                    "path": sPath,
                    "formatter": fnFormatter,
                    "type": oType,
                    "model": sModelName,
                    "mode": sMode
                };
            }
            // if a model separator is found in the path, extract model name and path
            iSeparatorPos = oBindingInfo["path"]["indexOf"]('>');
            if (iSeparatorPos > 0) {
                oBindingInfo["model"] = oBindingInfo["path"]["substr"](0, iSeparatorPos);
                oBindingInfo["path"] = oBindingInfo["path"]["substr"](iSeparatorPos + 1);
            }
            // if property is already bound, unbind it first
            if (this["isBound"](sName)) {
                this["unbindProperty"](sName);
            }
            // store binding info to create the binding, as soon as the model is
            // available, or when the model is changed
            this["mBindingInfos"][sName] = oBindingInfo;

            // if the model is already available, create the binding
            if (this["getModel"](oBindingInfo["model"])) {
                this["_bindProperty"](sName, oBindingInfo);
            }
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bindProperty"] = 0;
    }
    ;

    /**
     * Set the model for databinding
     * @param {UCF_Model} oModel
     * @param {string} [sName]
     * @return {UCF_ClientElement} <code>this</code> to allow method chaining
     * @public
     */
    UCF_ClientElement["prototype"]["setModel"] = function (oModel, sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setModel"]++;
        }
        ;
        if (oModel !== this["oModels"][sName]) {
            this["oModels"][sName] = oModel;
            // update binding context, for primary model only
            if (!sName) {
                this["updateBindingContext"]();
            }
            // if the model changes, all bindings have to be recreated (at least those
            // to the previous model)
            this["updateBindings"](false, sName, true);
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setModel"] = 0;
    }
    ;

    /**
     * Get the model for databinding
     * If the element does not have a model set on itself, it will ask
     * the parent element for the model to use
     *
     * @public
     * @param {string} [sName]
     * @return {UCF_Model} oModel
     */
    UCF_ClientElement["prototype"]["getModel"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getModel"]++;
        }
        ;
        /** @type {UCF_Model} */
        var oModel = this["oModels"][sName];
        /** @type {string} */
        var n;

        if (!oModel && this["_oCurrentModel"]) {
            return this["_oCurrentModel"];
        }

        if (!this["oPage"] || !this["oPage"]["hasModels"]()) {
            return null;
        }

        if (!oModel && this["sModelId"]) {
            oModel = this["oPage"]["getModel"](this["sModelId"]);
        }
        if (!oModel && sName) {
            oModel = this["getParent"]() && this["getParent"]()["getModel"](sName);
        }
        if (!oModel) {
            oModel = this["getParent"]() && this["getParent"]()["getModel"]();
        }
        oModel = this["oPage"]["getModel"](sName) || oModel;

        if (oModel && sName) {
            this["oModels"][sName] = oModel;
        } else {
            for (n in this["oModels"]) {
                if (oModel) {
                    break;
                } else {
                    oModel = this["oModels"][n];
                }
            }
        }
        this["_oCurrentModel"] = oModel;

        return oModel;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getModel"] = 0;
    }
    ;

    /**
     * Check if a Model is set to the Element or to one of its Parents
     *
     * @public
     * @return {boolean}
     */
    UCF_ClientElement["prototype"]["hasModel"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["hasModel"]++;
        }
        ;
        return !UCF_JsUtil["bIsEmpty"](this["oModels"])
            || (this["getParent"]() && this["getParent"]()["hasModel"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["hasModel"] = 0;
    }
    ;

    /**
     * Create bindings in case the model was not available at the time bindProperty
     * or bindAggregation was called
     *
     * @private
     * @param {boolean} bUpdateAll Whether to update all child bindings
     * @param {string} [sModelName] The name of the model. If not given the parents
     * model or default model is taken
     * @param {boolean} [bRecreate] `true` to recreate all bindings
     */
    UCF_ClientElement["prototype"]["updateBindings"] = function (bUpdateAll, sModelName, bRecreate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateBindings"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var self = this;

        // create property and aggregation bindings if they don't exist yet
        UCF_JsUtil["each"](this["mBindingInfos"], function (sName, oBindingInfo) {
            if (
                self["getModel"](oBindingInfo["model"]) &&
                (bUpdateAll || oBindingInfo["model"] === sModelName)
            ) {
                if (bRecreate && oBindingInfo["binding"]) {
                    oBindingInfo["binding"]["detachChange"](oBindingInfo["modelChangeHandler"]);
                    if (oBindingInfo["template"]) {
                        oBindingInfo["template"]["destroy"]();
                    }
                    delete oBindingInfo["binding"];
                }
                if (!oBindingInfo["binding"]) {
                    if (oBindingInfo["factory"]) {
                        self["_bindAggregation"](sName, oBindingInfo);
                    } else {
                        self["_bindProperty"](sName, oBindingInfo);
                    }
                }
            }
        });

        // also update bindings in all child elements
        UCF_JsUtil["each"](this["mAggregations"], function (sName, oAggregation) {
            if (oAggregation instanceof UCF_ClientElement) {
                oAggregation["updateBindings"](bUpdateAll, sModelName, bRecreate);
            } else if (UCF_JsUtil["bIsArray"](oAggregation)) {
                UCF_JsUtil["forEach"](oAggregation, function (oAgg) {
                    oAgg["updateBindings"](bUpdateAll, sModelName, bRecreate);
                });
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateBindings"] = 0;
    }
    ;

    /**
     * Generic method which is called, whenever an aggregation binding is changed.
     * This method deletes all elements in this aggregation and recreates them
     * according to the data model. In case a control needs special handling for an
     * aggregation binding, it can create a typed update-method (e.g. "updateRows")
     * which will be used instead of the default behaviour.
     *
     * @private
     * @param {string} sName The name of the aggregation to update
     */
    UCF_ClientElement["prototype"]["updateAggregation"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingInfo} */
        var oBindingInfo = this["mBindingInfos"][sName];
        /** @type {UCF_Binding} */
        var oBinding;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregationInfo;

        if (oBindingInfo) {
            oBinding = oBindingInfo["binding"];

            if (oBinding) {
                oAggregationInfo = this["getMetadata"]()["aggregations"][sName];

                // do not destroy clones, that should be done by the parent
                if (!this["mVirtualizedBindings"][sName] && !this["bKeepClones"]) {
                    this[oAggregationInfo["_sDestructor"]]();
                }
                if (this["isTreeBinding"](sName, oBinding)) {
                    this["updateTreeAggregation"](sName, oBinding);
                } else if (this["isGridBinding"](sName, oBindingInfo)) {
                    this["updateGridAggregation"](sName, oBinding);
                } else {
                    this["updateListAggregation"](sName, oBinding);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateAggregation"] = 0;
    }
    ;

    /**
     * Delayed method which is called for templated aggregation updates if the
     * template changed, whenever an aggregation binding is changed. This method
     * deletes all elements in this aggregation and recreates them according to the
     * data model. In case a control needs special handling for a aggregation
     * binding, it can create a typed update-method (e.g. "updateRows") which will
     * be used instead of the default behaviour.
     *
     * @private
     * @param {string} sName The name of the aggregation to update
     */
    UCF_ClientElement["prototype"]["updateAggregationDelayed"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateAggregationDelayed"]++;
        }
        ;
        if (!this["mUpdateAggregationTimers"]) {
            this["mUpdateAggregationTimers"] = {};
        }

        if (this["mUpdateAggregationTimers"][sName]) {
            UCF_JsUtil["clearDelayedCall"](this["mUpdateAggregationTimers"][sName]);
            this["mUpdateAggregationTimers"][sName] = UCF_JsUtil["delayedCall"](
                0,
                this,
                'updateAggregation', [sName]
            );
        } else {
            this["mUpdateAggregationTimers"][sName] = true;
            this["updateAggregation"](sName);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateAggregationDelayed"] = 0;
    }
    ;

    /**
     * Updates the grid aggregation with the given name
     *
     * @private
     * @param {string} sName the name of the aggregation
     * @param {UCF_JSONGridBinding} oBinding The grid binding to update
     */
    UCF_ClientElement["prototype"]["updateGridAggregation"] = function (sName, oBinding) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateGridAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingFactory} */
        var fnFactory = this["mBindingInfos"][sName]["factory"];
        /** @type {UCF_ClientElement} */
        var oClone = null;
        /** @type {UCF_ClientElement_Range} */
        var oVisibleRange = this["getVisibleRange"](sName, oBinding);
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregationInfo = this["getMetadata"]()["aggregations"][sName];
        /** @type {UCF_ClientElement} */
        var self = this;
        /** @type {Array<UCF_BindingContext>} */
        var aContexts;
        /** @type {{oClone: UCF_ClientElement, oContext: UCF_BindingContext}} */
        var aInformClones;

        // Get a list of  the current aggregation children that match visible range
        if (oVisibleRange) {
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(START, 'ReturnAll');
            }
            ;
            aContexts = oBinding["getContexts"](oVisibleRange);
            if (aContexts && this["mVirtualizedBindings"][sName]) {
                this["mVirtualizedBindings"][sName]["returnAll"]();
            }
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, 'ReturnAll');
            }
            ;

            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(START, 'Update');
            }
            ;
            this["onCloneUpdateStart"]();

            aInformClones = [];
            UCF_JsUtil["forEach"](
                aContexts,
                /** @param {UCF_BindingContext} oContext the context */
                function (oContext) {
                    /** @type {any} */
                    var oParameter = oContext["getBindingParameter"]();
                    /** @type {string} */
                    var sId = self["getId"]() + '_[' + oParameter["key"] + ']';

                    oClone = fnFactory(sId, oContext);
                    if (oClone) {
                        if (oClone["getParent"]() !== self) {
                            self[oAggregationInfo["_sMutator"]](oClone, false);
                        }

                        if (self["mVirtualizedBindings"][sName]) {
                            if (__UCF_TRACE__) {
                                UCF_Tracer.trace(DEBUG, 'Inform clone about NEW context: ' + oClone["getId"](), "ClientElement.js(2030): updateGridAggregation");
                            }
                            ;
                            aInformClones["push"]({"oClone": oClone, "oContext": oContext});
                        }
                    }
                }
            );

            UCF_JsUtil["forEach"](
                aInformClones,
                function (oInform) {
                    /** @type {UCF_BindingContext} */
                    var oContext = oInform["oContext"];
                    /** @type {UCF_ClientElement} */
                    var oClone = oInform["oClone"];

                    if (oContext !== oClone["getBindingContext"]()) {
                        oClone["setBindingContext"](oContext);
                    }

                    self["onCloneUpdate"](oClone, oContext);
                }
            );
            this["onCloneUpdateEnd"]();
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, 'Update');
            }
            ;

            if (aContexts && this["mVirtualizedBindings"][sName]) {
                UCF_JsUtil["forEach"](
                    UCF_JsUtil["filter"](
                        this["mVirtualizedBindings"][sName]["getFreeInstances"](),
                        function (i) {
                            return i;
                        }
                    ),
                    function (oInstance) {
                        self["onCloneReturn"](oInstance);
                    }
                );
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateGridAggregation"] = 0;
    }
    ;

    /**
     * Updates the list aggregation with the given name
     * @param {string} sName the name of the aggregation
     * @param {UCF_JSONListBinding} oBinding The list binding to update
     * @private
     */
    UCF_ClientElement["prototype"]["updateListAggregation"] = function (sName, oBinding) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateListAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingFactory} */
        var fnFactory = this["mBindingInfos"][sName]["factory"];
        /** @type {UCF_ClientInterfaces_AggregationInfo} */
        var oAggregationInfo = this["getMetadata"]()["aggregations"][sName];
        /** @type {UCF_ClientElement_ListRange} */
        var oRange = {"iStart": 0, "iEnd": 0};
        /** @type {UCF_ClientElement} */
        var self = this;

        if (this["mVirtualizedBindings"][sName]) {
            this["mVirtualizedBindings"][sName]["returnAll"]();
        }
        if (this["getVisibleRange"]) {
            oRange = this["getVisibleRange"](sName, oBinding) || oRange;
        }

        if (this["bKeepClones"] && 'iStart' in oRange) {
            UCF_JsUtil["forEach"](
                oBinding["getContexts"](oRange["iStart"], oRange["iEnd"] - oRange["iStart"] + 1),
                function (oContext, i) {
                    /** @type {UCF_ClientElement} */
                    var oClone = self["getAggregation"](sName)[i];

                    if (!oClone) {
                        oClone = fnFactory(self["getId"]() + '_' + i, oContext);
                        self[oAggregationInfo["_sMutator"]](oClone);
                    }

                    oClone["setBindingContext"](oContext);
                }
            );
        } else if (!this["bKeepClones"] && 'iStart' in oRange) {
            UCF_JsUtil["forEach"](
                oBinding["getContexts"](oRange["iStart"], oRange["iEnd"] - oRange["iStart"] + 1),
                function (oContext, i) {
                    /** @type {string} */
                    var sId = self["getId"]() + '_' + i;
                    /** @type {UCF_ClientElement} */
                    var oClone;

                    if (!self["oLS"]["oControlFactory"]["oGetClientControlById"](
                        self["mBindingInfos"][sName]["template"]["getId"]() + '_' + sId
                    )) {
                        oClone = fnFactory(sId, oContext);
                        if (oClone) {
                            if (oClone["getParent"]() !== self) {
                                self[oAggregationInfo["_sMutator"]](oClone);
                            }
                            oClone["setBindingContext"](oContext);
                            if (self["mVirtualizedBindings"][sName]) {
                                self["onCloneUpdate"](oClone, oContext);
                            }
                        }
                    }
                }
            );
        }

        if (this["mVirtualizedBindings"][sName]) {
            UCF_JsUtil["forEach"](
                UCF_JsUtil["filter"](
                    this["mVirtualizedBindings"][sName]["getFreeInstances"](),
                    function (i) {
                        return i;
                    }
                ),
                function (oInstance) {
                    self["onCloneReturn"](oInstance);
                }
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateListAggregation"] = 0;
    }
    ;

    /**
     * Updates the tree aggregation with the given name
     *
     * @private
     * @param {string} sName the name of the aggregation
     * @param {UCF_JSONTreeBinding} oBinding the binding
     */
    UCF_ClientElement["prototype"]["updateTreeAggregation"] = function (sName, oBinding) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateTreeAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingFactory} */
        var fnFactory = this["mBindingInfos"][sName]["factory"];
        /** @type {UCF_ClientElement} */
        var oClone = null;
        /** @type {number} */
        var iNodeIndex = 0;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregationInfo = this["getMetadata"]()["aggregations"][sName];
        /** @type {UCF_ClientElement} */
        var self = this;
        /** @type {string} */
        var sControlId = this["getId"]();

        /**
         * @param {Array<UCF_BindingContext>} aContexts list of contexts to update
         * @param {UCF_ClientElement_BindingFactory} fnFactory factory to create
         * client elements
         * @param {UCF_JSONTreeBinding} oBinding the binding to update
         * @param {UCF_ClientElement} oParent the parent
         */
        function update(aContexts, fnFactory, oBinding, oParent) {
            UCF_JsUtil["forEach"](aContexts, function (oContext, iIndex) {
                var sId = sControlId + '_' + iNodeIndex++;

                oClone = fnFactory(sId, oContext);
                if (oClone) {
                    if (oClone["getParent"]() !== self) {
                        self[oAggregationInfo["_sMutator"]](oClone);
                    }
                    oClone["setBindingContext"](oContext);
                    if (self["mVirtualizedBindings"][sName]) {
                        self["onCloneUpdate"](oClone, oContext);
                    }
                    update(
                        oBinding["getNodeContexts"](oContext),
                        fnFactory,
                        oBinding,
                        oClone
                    );
                }
            });
        };

        this["onCloneUpdateStart"]();
        update(oBinding["getRootContexts"](), fnFactory, oBinding, this);
        this["onCloneUpdateEnd"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateTreeAggregation"] = 0;
    }
    ;

    /**
     * Clone an element
     *
     * @private
     * @param {string} [sIdSuffix] a suffix to be appended to the cloned element id
     * - separaterd by a '_'
     * @param {Array<string>} [aLocalIds] an array of local IDs within the cloned
     * hierarchy
     * @return {UCF_ClientElement} reference to the newly created clone
     */
    UCF_ClientElement["prototype"]["clone"] = function (sIdSuffix, aLocalIds) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["clone"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {string} */
        var sId = this["getId"]() + '_' + sIdSuffix;
        /** @type {Object<string,any>} */
        var mCloneProperties = {};
        /** @type {Object<string,any>} */
        var mOriginalProperties = this["mProperties"];
        /** @type {string} */
        var sKey;
        /** @type {UCF_ClientElement} */
        var oClone;
        /** @type {number} */
        var i;

        // if no id suffix has been provided use a generated UID
        if (!sIdSuffix) {
            sIdSuffix = UCF_ClientElement["createId"]('clone');
        }
        // if no local ID array has been passed, collect IDs of all contained
        // elements to be able to properly adapt associations, which are within the
        // cloned element hierarchy
        if (!aLocalIds) {
            aLocalIds = UCF_JsUtil["map"](
                this["findElements"](true),
                function (oElement) {
                    return oElement["getId"]();
                }
            );
        }

        // Clone properties (only those with non-default value)
        for (sKey in mOriginalProperties) {
            mCloneProperties[sKey] = mOriginalProperties[sKey];
        }

        // Clone aggregations
        UCF_JsUtil["each"](this["mAggregations"], function (sName, oAggregation) {
            if (sName in oMetadata["aggregations"]) {
                if (oAggregation instanceof UCF_ClientElement) {
                    mCloneProperties[sName] = oAggregation["clone"](sIdSuffix, aLocalIds);
                } else if (UCF_JsUtil["bIsArray"](oAggregation)) {
                    mCloneProperties[sName] = [];
                    UCF_JsUtil["forEach"](oAggregation, function (oAgg) {
                        mCloneProperties[sName]["push"](oAgg["clone"](sIdSuffix, aLocalIds));
                    });
                } else {
                    // must be an alt type
                    mCloneProperties[sName] = oAggregation;
                }
            }
        });

        // Clone associations
        UCF_JsUtil["each"](this["mAssociations"], function (sName, oAssociation) {
            // Check every associated ID against the ID array, to make sure associations within
            // the template are properly converted to associations within the clone
            if (UCF_JsUtil["bIsArray"](oAssociation)) {
                oAssociation = oAssociation["slice"](0);
                for (i = 0; i < oAssociation["length"]; i++) {
                    if (UCF_JsUtil["indexOf"](aLocalIds, oAssociation[i]) >= 0) {
                        oAssociation[i] += ('_' + sIdSuffix);
                    }
                }
            } else if (UCF_JsUtil["indexOf"](aLocalIds, oAssociation) >= 0) {
                oAssociation += ('_' + sIdSuffix);
            }
            mCloneProperties[sName] = oAssociation;
        });

        // Create clone instance
        oClone = UCF_ClientElement["createInstance"](
            this["sClassName"],
            this["oLS"],
            sId,
            mCloneProperties
        );

        // Clone events
        UCF_JsUtil["each"](this["mEvents"], function (sName, aConfig) {
            oClone["mEvents"][sName] = aConfig;
        });

        oClone["sCurrentTemplateId"] = this["getId"]();

        // Clone models
        UCF_JsUtil["each"](this["oModels"], function (sName, oModel) {
            oClone["setModel"](oModel, sName);
        });
        oClone["sModelId"] = this["sModelId"];
        oClone["bIsClone"] = true;
        // Clone bindings
        UCF_JsUtil["each"](this["mBindingInfos"], function (sName, oBindingInfo) {
            /** @type {UCF_ClientElement_BindingInfo} */
            var oCloneBindingInfo = {};
            /** @type {string} */
            var n;

            for (n in oBindingInfo) {
                oCloneBindingInfo[n] = oBindingInfo[n];
            }
            // remove the runtime binding info (otherwise the property will not be
            // connected again!)
            delete oCloneBindingInfo["binding"];
            if (oBindingInfo["factory"]) {
                oClone["bindAggregation"](sName, oCloneBindingInfo);
            } else {
                oClone["bindProperty"](sName, oCloneBindingInfo);
            }
        });

        return oClone;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["clone"] = 0;
    }
    ;

    /**
     * Returns whether the instance is a clone or not.
     *
     * @private
     * @return {boolean} Whether the instnace is a clone.
     */
    UCF_ClientElement["prototype"]["isClone"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isClone"]++;
        }
        ;
        return this["bIsClone"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isClone"] = 0;
    }
    ;

    /**
     * Searches and returns an array of child elements and controls which are
     * referenced within an aggregation or aggregations of child elements/controls.
     * This can be either done recursive or not.
     * <br>
     * <b>Take care: this operation might be expensive.</b>
     *
     * @param {boolean} [bRecursive] `true` to return all nested children
     * @return {Array<UCF_ClientElement>} array of child elements and controls
     * @public
     */
    UCF_ClientElement["prototype"]["findElements"] = function (bRecursive) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["findElements"]++;
        }
        ;
        /** @type {Array<UCF_ClientElement>} */
        var aControls = [];

        /** @param {UCF_ClientElement} oControl the control */
        function findElements(oControl) {
            UCF_JsUtil["each"](oControl["mAggregations"], function (_, a) {
                if (UCF_JsUtil["bIsArray"](a)) {
                    UCF_JsUtil["forEach"](a, function (oControl) {
                        aControls["push"](oControl);
                        if (bRecursive) {
                            findElements(oControl);
                        }
                    });
                } else if (a instanceof UCF_ClientElement) {
                    aControls["push"](a);
                    if (bRecursive) {
                        findElements(a);
                    }
                }
            });
        }

        findElements(this);

        return aControls;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["findElements"] = 0;
    }
    ;

    /**
     * Returns whether the given aggregation name sName or the given binding info
     * is a grid binding.
     *
     * @private
     * @param {string} sName  name of the aggregation
     * @param {Object} oBindingInfo  binding info object
     * @return {boolean} `true` if the binding is a grid binding.
     */
    UCF_ClientElement["prototype"]["isGridBinding"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isGridBinding"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregation;

        if (oBindingInfo && oBindingInfo["bindingtype"] === 'UCF_GridBinding') {
            return true;
        } else {
            oAggregation = this["getMetadata"]()["aggregations"][sName];
            if (oAggregation) {
                return oAggregation["bindingType"] === 'grid';
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined.', "ClientElement.js(2391): isGridBinding");
                }
                ;

                return false;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isGridBinding"] = 0;
    }
    ;

    /**
     * Returns whether the given aggregation name sName or the given binding info
     * is a list binding.
     *
     * @private
     * @param {string} sName  name of the aggregation
     * @param {Object} oBindingInfo  binding info object
     * @return {boolean} `true` if the binding is a grid binding.
     */
    UCF_ClientElement["prototype"]["isListBinding"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isListBinding"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregation;

        if (oBindingInfo && oBindingInfo["bindingtype"] === 'UCF_ListBinding') {
            return true;
        } else {
            oAggregation = this["getMetadata"]()["aggregations"][sName];
            if (oAggregation) {
                return oAggregation["bindingType"] !== 'grid' &&
                    oAggregation["bindingType"] !== 'tree';
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined.', "ClientElement.js(2419): isListBinding");
                }
                ;

                return false;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isListBinding"] = 0;
    }
    ;

    /**
     * Returns whether the given aggregation name sName or the given binding info
     * is a tree binding.
     *
     * @private
     * @param {string} sName  name of the aggregation
     * @param {Object} oBindingInfo  binding info object
     * @return {boolean} `true` if the binding is a grid binding.
     */
    UCF_ClientElement["prototype"]["isTreeBinding"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isTreeBinding"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregation;

        if (oBindingInfo && oBindingInfo["bindingtype"] === 'UCF_TreeBinding') {
            return true;
        } else {
            oAggregation = this["getMetadata"]()["aggregations"][sName];
            if (oAggregation) {
                return oAggregation["bindingType"] === 'tree';
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Aggregation ' + sName + ' not defined.', "ClientElement.js(2446): isTreeBinding");
                }
                ;

                return false;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isTreeBinding"] = 0;
    }
    ;

    /**
     * Binds a property, this is called directly if the model already exists or
     * lazy if the model is applied
     *
     * @see UCF_ClientElement.prototype.bindProperty
     * @param {string} sName the name of the property to bind
     * @param {UCF_ClientElement_BindingInfo} oBindingInfo the binding info
     * @private
     */
    UCF_ClientElement["prototype"]["_bindProperty"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["_bindProperty"]++;
        }
        ;
        /** @type {UCF_Model} */
        var oModel;
        /** @type {TODO} */
        var oContext;
        /** @type {UCF_Binding} */
        var oBinding;
        /** @type {UCF_ClientInterfaces_Property} */
        var oPropertyInfo; // TODO fix handling of hidden entitites?
        /** @type {UCF_ClientElement_BindingFormatter} */
        var fnFormatter = oBindingInfo["formatter"];
        /** @type {string} */
        var oType = oBindingInfo["type"];
        /** @type {string} */
        var sDataType = oBindingInfo["datatype"];
        /** @type {string} */
        var sConfiguration;
        /** @type {UCF_SimpleType} */
        var oTypeClass;
        /** @type {Object} */
        var oConfiguration;
        /** @type {UCF_SimpleType} */
        var oTypeInstance;
        /** @type {string} */
        var sInternalType;
        /** @type {UCF_ClientElement} */
        var self;

        /** */
        function handleModelChange() {
            /** @type {any} */
            var oValue = oBinding["getValue"]();

            if (fnFormatter) {
                oValue = fnFormatter["apply"](self, [oValue]);
            }
            if (oType) {
                try {
                    oValue = oType["formatValue"](oValue, sInternalType);
                    oBindingInfo["skipModelUpdate"] = true;
                    self[oPropertyInfo["_sMutator"]](oValue);
                    oBindingInfo["skipModelUpdate"] = false;
                } catch (oException) {
                    if (oException instanceof UCF_FormatException) {
                        this["oLS"]["fireFormatError"]({
                            "element": self,
                            "property": sName,
                            "type": oType,
                            "newValue": oValue,
                            "oldValue": self["getProperty"](sName),
                            "exception": oException
                        });
                    } else {
                        throw oException;
                    }
                }
            } else {
                oBindingInfo["skipModelUpdate"] = true;
                self[oPropertyInfo["_sMutator"]](oValue);
                oBindingInfo["skipModelUpdate"] = false;
            }
        };

        if (this["hasProperty"](sName)) {
            oModel = this["getModel"](oBindingInfo["model"]);
            oPropertyInfo = this["getMetadata"]()["properties"][sName];

            if (sDataType && !oType) {
                sConfiguration = oBindingInfo["typeconfig"] || null;
                oTypeClass = UCF_JSONModel["getDataType"](sDataType);
                if (oTypeClass) {
                    oConfiguration = null;
                    if (sConfiguration) {
                        oConfiguration = UCF_JsUtil["oJsonParse"](sConfiguration);
                    }
                    oTypeInstance = null;
                    if (oConfiguration) {
                        oTypeInstance = new oTypeClass(oConfiguration);
                    } else {
                        oTypeInstance = new oTypeClass();
                    }
                    oBindingInfo["type"] = oTypeInstance;
                }
                oType = oBindingInfo["type"];
            }

            sInternalType = oPropertyInfo["type"];
            self = this;

            // Only use context for bindings on the primary model
            oContext = oBindingInfo["model"] ? null : this["getBindingContext"]();

            // Create binding object
            oBinding = oModel["bindProperty"](
                oBindingInfo["path"],
                oContext,
                oBindingInfo["parameters"]
            );

            // Set additional information on the binding info
            oBindingInfo["skipModelUpdate"] = false;
            oBindingInfo["binding"] = oBinding;
            oBindingInfo["modelChangeHandler"] = handleModelChange;

            if (!oBindingInfo["mode"] ||
                !oModel["isBindingModeSupported"](oBindingInfo["mode"])
            ) {
                oBindingInfo["mode"] = oModel["getDefaultBindingMode"]();
            }

            // Attach to the change event of the binding and initialize value
            if (oBindingInfo["mode"] !== UCF_Binding["Mode"]["OneTime"]) {
                oBinding["attachChange"](handleModelChange, this);
            }
            handleModelChange();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["_bindProperty"] = 0;
    }
    ;

    /**
     * Get the binding object for a specific aggregation/property
     *
     * @public
     * @param {string} sName the name of the property or aggregation
     * @return {UCF_Binding} the binding for the given name
     */
    UCF_ClientElement["prototype"]["getBinding"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getBinding"]++;
        }
        ;
        return this["mBindingInfos"][sName] && this["mBindingInfos"][sName]["binding"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getBinding"] = 0;
    }
    ;

    /**
     * Unbind the property from the model
     *
     * @public
     * @param {string} sName the name of the property
     * @return {UCF_ClientElement} reference to the instance itself
     */
    UCF_ClientElement["prototype"]["unbindProperty"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["unbindProperty"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingInfo} */
        var oBindingInfo = this["mBindingInfos"][sName];

        if (oBindingInfo) {
            if (oBindingInfo["binding"]) {
                oBindingInfo["binding"]["detachChange"](oBindingInfo["modelChangeHandler"], this);
            }
            delete this["mBindingInfos"][sName];
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["unbindProperty"] = 0;
    }
    ;

    /**
     * Find out whether a property or aggregation is bound
     *
     * @public
     * @param {string} sName the name of the property or aggregation
     * @return {boolean} whether a binding exists for the given name
     */
    UCF_ClientElement["prototype"]["isBound"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isBound"]++;
        }
        ;
        return sName in this["mBindingInfos"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isBound"] = 0;
    }
    ;

    /**
     * Bind an aggregation to the model.
     * The bound aggregation will use the given template, clone it for each element
     * which exists in the bound list and set the appropriate binding context.
     * This is a generic method which can be used to bind any aggregation to the
     * model. A control may flag aggregations in the metamodel with
     * bindable="bindable" to get typed bind methods for an aggregation.
     *
     * @param {string} sName the aggregation to bind
     * @param {UCF_ClientElement_BindingInfo} oBindingInfo the binding info
     * @return {UCF_ClientElement} reference to the instance itself
     * @public
     */
    UCF_ClientElement["prototype"]["bindAggregation"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["bindAggregation"]++;
        }
        ;
        /** @type {string} */
        var sPath;
        /** @type {UCF_ClientElement} */
        var oTemplate;
        /** @type {TODO} */
        var oSorter;
        /** @type {Array<TODO>} */
        var aFilters;
        /** @type {number} */
        var iSeparatorPos;
        /** @type {UCF_ClientElement} */
        var self;

        // Old API compatibility (sName, sPath, oTemplate, oSorter, aFilters)
        if (typeof oBindingInfo === 'string') {
            sPath = arguments[1];
            oTemplate = arguments[2]; // eslint-disable-line no-magic-numbers
            oSorter = arguments[3]; // eslint-disable-line no-magic-numbers
            aFilters = arguments[4]; // eslint-disable-line no-magic-numbers
            oBindingInfo = {"path": sPath, "sorter": oSorter, "filters": aFilters};
            // allow either to pass the template or the factory function as 3rd parameter
            if (oTemplate instanceof UCF_ClientElement) {
                oBindingInfo["template"] = oTemplate;
            } else if (typeof oTemplate === 'function') {
                oBindingInfo["factory"] = oTemplate;
            }
        }

        // if a model separator is found in the path, extract model name and path
        iSeparatorPos = oBindingInfo["path"]["indexOf"]('>');
        if (iSeparatorPos > 0) {
            oBindingInfo["model"] = oBindingInfo["path"]["substr"](0, iSeparatorPos);
            oBindingInfo["path"] = oBindingInfo["path"]["substr"](iSeparatorPos + 1);
        }

        // if aggregation is already bound, unbind it first
        if (this["isBound"](sName)) {
            this["unbindAggregation"](sName);
        }

        // check whether a template has been provided, which is required for proper processing of the binding
        if (oBindingInfo["template"] || oBindingInfo["factory"]) {
            self = this;
            // if we have a template we will create a factory function
            if (oBindingInfo["template"]) {
                if (oBindingInfo["template"]["sClassName"] === 'TemplateList') {
                    oBindingInfo["template"]["destroy"] = function (nSuppressRerendering) {
                        UCF_JsUtil["each"](this["mTemplates"], function (_, oTemplate) {
                            oTemplate["destroy"](true);
                        });
                    };
                    oBindingInfo["template"]["clone"] = function (sId, oContext) {
                        var aItems;
                        var oFirstTemplate;
                        var oControl;
                        var sItemName;
                        var sPath;
                        var that = this;

                        if (!this["mTemplates"]) {
                            aItems = this["getItems"]();
                            oFirstTemplate = null;
                            this["mTemplates"] = {};

                            UCF_JsUtil["forEach"](aItems, function (oItem, i) {
                                var sTemplateName = oItem["getName"]();

                                oControl = oItem["getControl"]();

                                if (sTemplateName === '') {
                                    that["mTemplates"]["_defaulttemplate"] = oControl;
                                    if (self["mVirtualizedBindings"][sName]) {
                                        self["mVirtualizedBindings"][sName]["setDefaultType"](oControl);
                                    }
                                    oFirstTemplate = null;
                                } else {
                                    that["mTemplates"][sTemplateName] = oControl;
                                    if (self["mVirtualizedBindings"][sName]) {
                                        self["mVirtualizedBindings"][sName]["addType"](
                                            sTemplateName,
                                            oControl
                                        );
                                        if (i === 0) {
                                            oFirstTemplate = oControl;
                                        }
                                    }
                                }
                            });

                            if (oFirstTemplate) {
                                this["mTemplates"]["_defaulttemplate"] = oControl;
                                if (self["mVirtualizedBindings"][sName]) {
                                    self["mVirtualizedBindings"][sName]["setDefaultType"](oControl);
                                }
                            }
                        }

                        if (this["mBindingInfos"]["ItemName"]) {
                            if (!this["oTemplateBindings"]) {
                                this["oTemplateBindings"] = {};
                            }
                            sPath = oContext["getPath"]() + '/' + this["mBindingInfos"]["ItemName"]["path"];
                            if (!this["oTemplateBindings"][sPath]) {
                                this["oTemplateBindings"][sPath] = oContext["getModel"]()["bindProperty"](
                                    sPath
                                );
                                this["oTemplateBindings"][sPath]["attachChange"](function () {
                                    self["updateAggregationDelayed"](sName);
                                });
                            }
                            sItemName = oContext["getModel"]()["getProperty"](sPath);
                        } else {
                            sItemName = this["getItemName"]();
                        }

                        if (sItemName == null) {
                            return null; //no item template
                        }

                        return self["mVirtualizedBindings"][sName]
                            ? self["mVirtualizedBindings"][sName]["borrowInstance"](
                                sItemName,
                                sId,
                                oContext
                            )
                            : this["mTemplates"][sItemName];

                    };
                }

                oBindingInfo["factory"] = function (sId, oContext) {
                    if (
                        oBindingInfo["template"]["sClassName"] !== 'TemplateList' &&
                        self["mVirtualizedBindings"][sName]
                    ) {
                        if (!self["mVirtualizedBindings"][sName]["checkType"](
                            oBindingInfo["template"]
                        )) {
                            self["mVirtualizedBindings"][sName]["setDefaultType"](
                                oBindingInfo["template"]
                            );
                        }

                        return self["mVirtualizedBindings"][sName]["borrowInstance"](
                            '',
                            sId,
                            oContext
                        );
                    }

                    return oBindingInfo["template"]["clone"](sId, oContext);
                };
            }

            // store binding info to create the binding, as soon as the model is available, or when the model is changed
            this["mBindingInfos"][sName] = oBindingInfo;

            // if the model is already available create the binding
            if (this["getModel"](oBindingInfo["model"])) {
                this["_bindAggregation"](sName, oBindingInfo);
            }

            return this;
        } else {
            throw new Error('Missing template or factory function for aggregation ' + sName + ' of control id ' + this["getId"]() + ' !');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["bindAggregation"] = 0;
    }
    ;

    /**
     * Returns the index of an instance in the aggregation with the given name
     *
     * @private
     * @param {string} sName The name of the aggregation
     * @param {UCF_ClientElement} oInstance The instance to check
     * @return {number} The index or null
     */
    UCF_ClientElement["prototype"]["indexOfAggregation"] = function (sName, oInstance) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["indexOfAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_Aggregation} */
        var aAggregation = this["getAggregation"](sName);
        /** @type {number} */
        var i;

        if (aAggregation && aAggregation["length"]) {
            for (i = 0; i < aAggregation["length"]; i++) {
                if (aAggregation[i] === oInstance) {
                    return i;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["indexOfAggregation"] = 0;
    }
    ;

    /**
     * Returns the index of the current instance in a 0..n parent aggregation or
     * null if it is a 0..1 aggregation or there is no parent
     *
     * @private
     * @return {number} The index or null
     */
    UCF_ClientElement["prototype"]["indexInParentAggregation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["indexInParentAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent = this["getParent"]();
        /** @type {string} */
        var sName = this["sAggregationName"];
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata;

        if (oParent) {
            oMetadata = oParent["getMetadata"]();

            if (sName && oMetadata["aggregations"][sName]["multiple"]) {
                return this["getParent"]()["indexOfAggregation"](this["sAggregationName"], this);
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["indexInParentAggregation"] = 0;
    }
    ;

    /**
     * Returns the template id of the client element if created as a clone of a
     * TemplateList binding
     *
     * @private
     * @return {string} The id of the template or null
     */
    UCF_ClientElement["prototype"]["getTemplateId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getTemplateId"]++;
        }
        ;
        return this["sCurrentTemplateId"] || null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getTemplateId"] = 0;
    }
    ;

    /**
     * Sets whether the cloned objects of the given aggregation can be virtualized.
     * Virtualization allows to reuse instances of the same clone.
     * The control that supports vistualization needs to implement the methods:
     *   getVisibleRange(oRange)
     *   onCloneUpdate(oClone,oBindingContext)
     *   onCloneReturn(oClone)
     *   onCloneCreate(oClone)
     *   onCloneDelete(oClone)
     * @param {string} sName the the name of the aggregation to virtualize
     * @param {boolean} bUseVirtualization whether virtualization should be used for this aggregation
     * @private
     */
    UCF_ClientElement["prototype"]["setVirtualize"] = function (sName, bUseVirtualization) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setVirtualize"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Aggregation} */
        var oAggregation = this["getMetadata"]()["aggregations"][sName];
        /** @type {UCF_ClientElement} */
        var oClone;

        if (oAggregation) {
            // there is already a virtualized binding
            if (this["mVirtualizedBindings"][sName]) {
                while (this["mVirtualizedBindings"][sName]["length"] > 0) {
                    oClone = this["mVirtualizedBindings"][sName]["pop"]();
                    this["onCloneDelete"](oClone);
                    oClone["destroy"]();
                }
                this["mVirtualizedBindings"][sName]["destroy"]();
                if (bUseVirtualization === false) {
                    delete this["mVirtualizedBindings"][sName];
                }
            }
            if (bUseVirtualization) {
                this["mVirtualizedBindings"][sName] = new (UCF_ClassLoader["oGetClass"]("UCF_TypedTemplatePool"))(this);
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'No aggregation ' + sName, "ClientElement.js(2903): setVirtualize");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setVirtualize"] = 0;
    }
    ;

    /**
     * This is the abstract method that is called during virtualization to
     * get the current visible range of list or grid binding implementations.
     * If should return an object
     * For Grid : {
     *            iStartX:int,
     *            iStartY: int,
     *            iEndX:int,
     *            iEndY:int
     *        }
     * For List : {
     *            iStart:int,
     *            iEnd: int,
     *        }
     *
     * @private
     * @param {string} sName The name of the aggregation
     * @param {UCF_Binding} oBinding The binding context
     * @return {UCF_ClientElement_Range} The start and end of the visible range as a json
     */
    UCF_ClientElement["prototype"]["getVisibleRange"] = function (sName, oBinding) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getVisibleRange"]++;
        }
        ;
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getVisibleRange"] = 0;
    }
    ;

    /**
     * This is the abstract method that is called if during virtualization a given
     * oClone instance is reused because it is not used any longer. The
     * implementation of the control should override this methods and set all
     * properties based on the passed oBindingContext. For optimal performance all
     * setters called in the implementation should directly modify the rendering
     * dom instead of forcing a rerendering of the control.
     *
     * @private
     * @param {UCF_ClientElement} oClone the clone that needs an update from the
     * parent control
     * @param {UCF_BindingContext} oBindingContext the current binding context for
     * the clone, the binding context delivers information about the x and or y
     * position with getParameter method.
     */
    UCF_ClientElement["prototype"]["onCloneUpdate"] = function (oClone, oBindingContext) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneUpdate"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneUpdate"] = 0;
    }
    ;

    /**
     * Override this method to get informed that the clone update for
     * virtualized elements is starting
     * @private
     */
    UCF_ClientElement["prototype"]["onCloneUpdateStart"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneUpdateStart"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneUpdateStart"] = 0;
    }
    ;

    /**
     * Override this method to get informed that the clone update for
     * virtualized elements has ended
     * @private
     */
    UCF_ClientElement["prototype"]["onCloneUpdateEnd"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneUpdateEnd"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneUpdateEnd"] = 0;
    }
    ;

    /**
     * Override this method to get informed that a clone was returned to the pool
     * of clones that is reused for virtualized bindings
     *
     * @private
     * @param {UCF_ClientElement} oClone the clone that was returned.
     */
    UCF_ClientElement["prototype"]["onCloneReturn"] = function (oClone) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneReturn"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneReturn"] = 0;
    }
    ;

    /**
     * This is the abstract method that is called if a clone is created during visualization as
     * there where no free instances in the virtualization pool for this type of clone.
     * The implementation of the control should override this method and set all properties
     * that are necessary for initial rendering of the new clone. After the create method
     * also the onCloneUpdate method will be called.
     * The new clone should only set properties that do not rely on the binding context of the clone.
     *
     * @param {UCF_ClientElement} oClone the clone that needs an update from the parent control
     * @see onCloneUpdate
     * @private
     *
     */
    UCF_ClientElement["prototype"]["onCloneCreate"] = function (oClone) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneCreate"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneCreate"] = 0;
    }
    ;

    /**
     * This is the abstract method that is called if a clone is deleted and
     * removed from the vistualization pool.
     * The implemention of the control should override this method to clean all
     * references.
     * Destroy of the control will happen afterwards.
     *
     * @param {UCF_ClientElement} oClone the clone that needs an update from the parent control
     * @private
     */
    UCF_ClientElement["prototype"]["onCloneDelete"] = function (oClone) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onCloneDelete"]++;
        }
        ;
        oClone["destroy"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onCloneDelete"] = 0;
    }
    ;

    /**
     * Internal implementation to bind an aggregation. This is called directly if a
     * model exists or lazy if the model becomes available.
     *
     * @see UCF_ClientElement.prototype.bindAggregation
     * @private
     * @param {string} sName the name of the aggregation
     * @param {UCF_ClientElement_BindingInfo} oBindingInfo the info to bind
     */
    UCF_ClientElement["prototype"]["_bindAggregation"] = function (sName, oBindingInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["_bindAggregation"]++;
        }
        ;
        var self = this;
        var oBinding;
        var sModelName = oBindingInfo["model"];

        /** @param {UCF_Event} oEvent the model change */
        function handleModelChange(oEvent) {
            /** @type {string} */
            var sUpdater = 'update' + sName["substr"](0, 1)["toUpperCase"]() + sName["substr"](1);

            if (self[sUpdater]) {
                self[sUpdater]();
            } else {
                self["updateAggregation"](sName);
            }
        }

        if (this["isTreeBinding"](sName, oBindingInfo)) {
            oBinding = this["getModel"](sModelName)["bindTree"](
                oBindingInfo["path"],
                this["getBindingContext"](),
                oBindingInfo["filters"],
                oBindingInfo["parameters"]);
        } else if (this["isGridBinding"](sName, oBindingInfo)) {
            oBinding = this["getModel"](sModelName)["bindGrid"](
                oBindingInfo["path"],
                this["getBindingContext"](),
                oBindingInfo["sorter"],
                oBindingInfo["filters"],
                oBindingInfo["parameters"]
            );
        } else if (this["isListBinding"](sName, oBindingInfo)) {
            oBinding = this["getModel"](sModelName)["bindList"](
                oBindingInfo["path"],
                this["getBindingContext"](),
                oBindingInfo["sorter"],
                oBindingInfo["filters"],
                oBindingInfo["parameters"]
            );
        }

        oBindingInfo["binding"] = oBinding;
        oBindingInfo["modelChangeHandler"] = handleModelChange;

        oBinding["attachChange"](handleModelChange, this);
        handleModelChange();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["_bindAggregation"] = 0;
    }
    ;

    /**
     * Unbind the aggregation from the model
     *
     * @public
     * @param {string} sName the name of the aggregation
     * @return {UCF_ClientElement} reference to the instance itself
     */
    UCF_ClientElement["prototype"]["unbindAggregation"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["unbindAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingInfo} */
        var oBindingInfo = this["mBindingInfos"][sName];

        if (oBindingInfo) {
            if (oBindingInfo["binding"]) {
                oBindingInfo["binding"]["detachChange"](oBindingInfo["modelChangeHandler"]);
                if (oBindingInfo["template"]) {
                    oBindingInfo["template"]["destroy"]();
                }
                if (oBindingInfo["factory"]) {
                    oBindingInfo["template"]["destroy"]();
                }
                if (this["mVirtualizedBindings"][sName]) {
                    this["mVirtualizedBindings"][sName]["destroy"]();
                    this["mVirtualizedBindings"][sName] = new (UCF_ClassLoader["oGetClass"]("UCF_TypedTemplatePool"))(this);

                }
            }
            delete this["mBindingInfos"][sName];
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["unbindAggregation"] = 0;
    }
    ;

    /**
     * Destroys the element and removes if from the dom
     * @param {boolean} bSuppressRerendering avoid dom update. Dom remove has to be done manually in this case.
     * @see UCF_ClientElement.prototype.removeFromDom()
     * @public
     */
    UCF_ClientElement["prototype"]["destroy"] = function (bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["destroy"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var self;

        if (!this["bIsDestroyed"]) {
            this["bIsDestroyed"] = true; // TODO remove and rely on _super()
            self = this;
            // ensure that also our children are destroyed!!
            UCF_JsUtil["forEach"](
                UCF_JsUtil["keys"](this["mAggregations"] || {}),
                function (sAggregation) {
                    self["clearAggregation"](sAggregation, bSuppressRerendering);
                }
            );

            // remove this child from parent aggregation
            if (this["getParent"]() && this["sAggregationName"]) {
                this["getParent"]()["removeAggregation"](
                    this["sAggregationName"],
                    this,
                    bSuppressRerendering
                );
            }

            // Data Binding
            UCF_JsUtil["each"](this["mBindingInfos"], function (sName, oBindingInfo) {
                if (oBindingInfo["factory"]) {
                    self["unbindAggregation"](sName);
                } else {
                    self["unbindProperty"](sName);
                }
            });

            // remove from dom
            if (!bSuppressRerendering) {
                this["removeFromDom"]();
            }

            //set the parent to null
            if (!bSuppressRerendering) {
                this["setParent"](null, this["sAggregationName"], bSuppressRerendering);
            }

            if (!this["bTempControl"]) {
                this["oLS"]["oControlFactory"]["purgeClientControl"](this);
            }
            this["oLS"] = null;
            // this.sId = "";
            this["oJson"] = null;
            this["bTempControl"] = false;
            this["oPage"] = null;
            this["bRenderInvisibleContent"] = false;
            this["_oCustomDataJson"] = null;
            this["_oCurrentModel"] = null;
            this["oBindingContext"] = null;
            this["_bInvisibility"] = false;

            UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["destroy"] = 0;
    }
    ;

    /**
     * Removes the current dom element for the control from the dom
     *
     * @public
     */
    UCF_ClientElement["prototype"]["removeFromDom"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["removeFromDom"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oRootRef = this["getRootRef"]();

        if (oRootRef && oRootRef["parentNode"] && !this["bTempControl"]) {
            oRootRef["parentNode"]["removeChild"](oRootRef);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["removeFromDom"] = 0;
    }
    ;

    /**
     * Get the binding path for a specific aggregation/property
     *
     * @private
     * @param {string} sName the name of the property or aggregation
     * @return {string} the binding path for the given name
     */
    UCF_ClientElement["prototype"]["getBindingPath"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getBindingPath"]++;
        }
        ;
        return this["mBindingInfos"][sName] && this["mBindingInfos"][sName]["path"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getBindingPath"] = 0;
    }
    ;

    /**
     * Set the binding context for this element.
     *
     * @public
     * @param {UCF_BindingContext} oContext the new binding context for this element
     * @return {UCF_ClientElement} reference to the instance itself
     */
    UCF_ClientElement["prototype"]["setBindingContext"] = function (oContext) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setBindingContext"]++;
        }
        ;
        /** @type {UCF_BindingContext} */
        this["oBindingContext"] = oContext;

        this["updateBindingContext"]();

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setBindingContext"] = 0;
    }
    ;

    /**
     * Update the binding context in this element and all children
     *
     * @private
     * @param {boolean} bSkipLocal `true` to skip local bindings
     */
    UCF_ClientElement["prototype"]["updateBindingContext"] = function (bSkipLocal) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateBindingContext"]++;
        }
        ;
        /** @type {UCF_Model} */
        var oModel = this["getModel"]();
        /** @type {UCF_ClientElement} */
        var oParent = this["getParent"]();
        /** @type {UCF_BindingContext} */
        var oParentContext;
        /** @type {UCF_ClientElement} */
        var self = this;
        /** @type {UCF_BindingContext} */
        var oContext;

        if (this["sBindingPath"] && !bSkipLocal) {
            if (oParent && oModel === oParent["getModel"]()) {
                oParentContext = oParent["getBindingContext"]();
            }
            if (oModel) {
                oModel["createBindingContext"](
                    this["sBindingPath"],
                    oParentContext,
                    this["mBindingParameters"],
                    function (oContext) {
                        self["oBindingContext"] = oContext;
                        self["updateBindingContext"](true);
                    }
                );
            } else {
                this["oBindingContext"] = undefined;
            }
        } else {
            oContext = this["getBindingContext"]();
            // update context in existing bindings, but only for the primary model
            UCF_JsUtil["each"](this["mBindingInfos"], function (sName, oBindingInfo) {
                /** @type {UCF_Binding} */
                var oBinding = oBindingInfo["binding"];

                if (oBinding && oBinding["getModel"]() === oModel) {
                    oBinding["setContext"](oContext);
                }
            });

            // also update context in all child elements
            UCF_JsUtil["each"](this["mAggregations"], function (sName, oAggregation) {
                if (oAggregation instanceof UCF_ClientElement) {
                    oAggregation["updateBindingContext"]();
                } else if (oAggregation instanceof Array) {
                    UCF_JsUtil["forEach"](
                        oAggregation,
                        function (oAgg) {
                            oAgg["updateBindingContext"]();
                        }
                    );
                }
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateBindingContext"] = 0;
    }
    ;

    /**
     * Get the binding context of this element. If the element does not have a
     * binding context set on itself and has no own Model set, it will ask the
     * parent element for its binding context
     *
     * @public
     * @return {Object} the binding context of this element
     */
    UCF_ClientElement["prototype"]["getBindingContext"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getBindingContext"]++;
        }
        ;
        /** @type {UCF_Model} */
        var oModel = this["getModel"]();
        /** @type {UCF_Element} */
        var oParent;

        if (this["oBindingContext"]) {
            return this["oBindingContext"];
        } else {
            oParent = this["getParent"]();

            return oModel && oParent && oModel !== oParent["getModel"]()
                ? undefined
                : oParent && oParent["getBindingContext"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getBindingContext"] = 0;
    }
    ;

    /**
     * Sets the invalidation state of the control to determine if rerendering is
     * needed or not.
     *
     * @public
     */
    UCF_ClientElement["prototype"]["invalidate"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["invalidate"]++;
        }
        ;
        if (!this["bInvalidated"]) {
            this["bInvalidated"] = true;
            if (this["oParent"]) {
                this["oParent"]["invalidate"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["invalidate"] = 0;
    }
    ;

    /**
     * Checks whether a parent of the control is already invalidated.
     *
     * @private
     * @return {boolean} `true` if the parent is invalidated, else `false`
     */
    UCF_ClientElement["prototype"]["isParentInvalidated"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isParentInvalidated"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent = this["getParent"]();

        while (oParent) {
            if (oParent && oParent["isInvalidated"]()) {
                return true;
            }
            oParent = oParent["getParent"]();
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isParentInvalidated"] = 0;
    }
    ;

    /**
     * Returns whether the control is invalidated and needs rerendering or not
     *
     * @public
     * @return {boolean} `true` if invalidated.
     */
    UCF_ClientElement["prototype"]["isInvalidated"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isInvalidated"]++;
        }
        ;
        return this["bInvalidated"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isInvalidated"] = 0;
    }
    ;

    /**
     * Returns whether a child control is invalidated and needs rerendering or not
     *
     * @public
     * @return {boolean} true if a child invalidated.
     */
    UCF_ClientElement["prototype"]["isChildInvalidated"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isChildInvalidated"]++;
        }
        ;
        /** @type {boolean} */
        var bChildInvalidated = false;

        this["traverseChildren"](function (oElement) {
            if (oElement["isInvalidated"]()) {
                bChildInvalidated = true;

                return true;
            } else {
                return false;
            }
        });

        return bChildInvalidated;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isChildInvalidated"] = 0;
    }
    ;

    /**
     * Returns a list of children that are invalidated.
     *
     * @public
     * @return {Array<UCF_ClientElement>} List of all children that are invalidated
     */
    UCF_ClientElement["prototype"]["getInvalidatedChildren"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getInvalidatedChildren"]++;
        }
        ;
        /** @type {Array<UCF_ClientElement>} */
        var aChildren = [];

        this["traverseChildren"](function (oElement) {
            if (oElement["isInvalidated"]()) {
                aChildren["push"](oElement);
            }
        });

        return aChildren;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getInvalidatedChildren"] = 0;
    }
    ;

    /**
     * Returns the amount of invalidated children. With that it would be possible
     * to rerender the parent control if a specific number of children is
     * invalidated.
     *
     * @private
     * @return {number} The amount of invalidated children
     */
    UCF_ClientElement["prototype"]["numberOfInvalidatedChildren"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["numberOfInvalidatedChildren"]++;
        }
        ;
        /** @type {number} */
        var i = 0;

        this["traverseChildren"](function (oElement) {
            if (oElement["isInvalidated"]()) {
                i++;
            }
        });

        return i;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["numberOfInvalidatedChildren"] = 0;
    }
    ;

    /**
     * Sets the invalidation state of the element to the given value and stops
     * the rerendering triggers
     *
     * @public
     * @param {boolean} bValue the value to set bInvalidated to
     */
    UCF_ClientElement["prototype"]["setInvalidated"] = function (bValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setInvalidated"]++;
        }
        ;
        if (this["bInvalidated"] !== bValue) {
            if (this["iRenderTimer"]) {
                UCF_JsUtil["clearDelayedCall"](this["iRenderTimer"]);
            }
            this["bInvalidated"] = bValue;
            if (bValue) {
                this["invalidate"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setInvalidated"] = 0;
    }
    ;

    /**
     * Resets the invalidation state of the element after the control
     * is rerendered
     * @public
     */
    UCF_ClientElement["prototype"]["resetInvalidated"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["resetInvalidated"]++;
        }
        ;
        this["bInvalidated"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["resetInvalidated"] = 0;
    }
    ;

    /**
     * Checks whether the current control is still valid none of its children were
     * invalidated since the last rendering
     *
     * @private
     * @return {boolean} `true` if the control is still valid
     */
    UCF_ClientElement["prototype"]["isValid"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["isValid"]++;
        }
        ;
        return !this["isInvalidated"]() && this["isChildInvalidated"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["isValid"] = 0;
    }
    ;

    /**
     * Returns the root dom reference of the control that needs to be replaced if
     * the control is rerendered.
     *
     * @public
     * @return {HTMLElement} The dom element that is the root ref for the control.
     */
    UCF_ClientElement["prototype"]["getRootRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getRootRef"]++;
        }
        ;
        /** @type {string} */
        var sId = this["getId"]();

        return UCF_DomUtil["$"](sId + '-r') || UCF_DomUtil["$"](sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getRootRef"] = 0;
    }
    ;

    /**
     * Returns the current HTML of the element.
     *
     * @private
     * @return {string} the current HTML for the control and all sub controls
     */
    UCF_ClientElement["prototype"]["getHTML"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getHTML"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oRootRef = this["getRootRef"]();
        /** @type {HTMLDivElement} */
        var oDomHelper;

        if (oRootRef && !oRootRef["outerHTML"]) {
            oDomHelper = document["createElement"]('DIV');

            oDomHelper["appendChild"](oRootRef);

            return oDomHelper["innerHTML"];
        } else {
            return oRootRef["outerHTML"];
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getHTML"] = 0;
    }
    ;

    /**
     * Sets the new index in a parent aggregation
     * @param {number} iNewIndex The new index in the parent aggregation.
     * @param {boolean} [bSuppressRerendering] `true` to suppress rerendering
     * @public
     */
    UCF_ClientElement["prototype"]["setIndexInParentAggregation"] = function (iNewIndex, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setIndexInParentAggregation"]++;
        }
        ;
        /** @type {number} */
        var iIndex = this["indexInParentAggregation"]();
        /** @type {number} */
        var sName;
        /** @type {UCF_ClientElement} */
        var oParent;

        if (iIndex !== null) {
            sName = this["sAggregationName"];
            oParent = this["getParent"]();

            if (iIndex !== iNewIndex) {
                if (iNewIndex === -1) {
                    iNewIndex = oParent["getAggregation"](sName)["length"];
                }
                this["removeFromParent"]();
                oParent["insertAggregation"](sName, this, iNewIndex, bSuppressRerendering);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setIndexInParentAggregation"] = 0;
    }
    ;

    /**
     * Moves element in its aggregation
     *
     * @public
     * @param {UCF_ClientElement_AggregationPosition} sNewPosition position to move
     * the element to
     * @param {boolean} [bSuppressRerendering] `true` to suppress rerendering
     */
    UCF_ClientElement["prototype"]["moveInParentAggregation"] = function (sNewPosition, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["moveInParentAggregation"]++;
        }
        ;
        /** @type {boolean} */
        var iIndex = this["indexInParentAggregation"]();

        if (iIndex !== null) {
            switch (sNewPosition) {
                case 'START':
                    this["setIndexInParentAggregation"](0, bSuppressRerendering);
                    break;
                case 'END':
                    this["setIndexInParentAggregation"](-1, bSuppressRerendering);
                    break;
                case 'UP':
                    this["setIndexInParentAggregation"](iIndex + 1, bSuppressRerendering);
                    break;
                case 'DOWN':
                    this["setIndexInParentAggregation"](
                        Math["max"](iIndex - 1, 0),
                        bSuppressRerendering
                    );
                    break;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["moveInParentAggregation"] = 0;
    }
    ;

    /**
     * Traverses the aggregation with sName and calls a given fCallback method for
     * each instance with oElement and iIndex as parameters. In case of a single
     * aggregation the iIndex is not given.
     *
     * @private
     * @param {string} sName The name of the aggregation to traverse
     * @param {function(UCF_ClientElement, number): void} fCallback the callback
     * method called for each child
     */
    UCF_ClientElement["prototype"]["traverseAggregation"] = function (sName, fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["traverseAggregation"]++;
        }
        ;
        /** @type {UCF_ClientElement_Aggregation} */
        var oAggregation = this["mAggregations"][sName];
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();

        if (oAggregation) {
            if (oMetadata["aggregations"][sName]["multiple"]) {
                UCF_JsUtil["forEach"](oAggregation, fCallback);
            } else {
                fCallback(oAggregation);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["traverseAggregation"] = 0;
    }
    ;

    /**
     * Traverses all child aggregations and calls the given callback method for
     * each child. This is done recursivly for all inner client elements. If the
     * callback method returns true, further processing is stopped.
     *
     * @public
     * @param {function(UCF_ClientElement): boolean} fCallback The callback method
     * called for each child
     */
    UCF_ClientElement["prototype"]["traverseChildren"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["traverseChildren"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {UCF_ClientElement} */
        var self = this;

        UCF_JsUtil["each"](oMetadata["aggregations"], function (n, oAgg) {
            /** @type {UCF_ClientElement_Aggregation} */
            var oAggregation = self["mAggregations"][n];

            if (oAggregation) {
                if (oAgg["multiple"]) {
                    UCF_JsUtil["forEach"](oAggregation, function (o) {
                        if (!fCallback(o)) {
                            o["traverseChildren"](fCallback);
                        }
                    });
                } else if (!fCallback(oAggregation)) {
                    oAggregation["traverseChildren"](fCallback);
                }
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["traverseChildren"] = 0;
    }
    ;

    /**
     * Update the property in the model if two way data binding mode is enabled
     *
     * @private
     * @param {string} sName the name of the property to update
     * @param {T} oValue the new value to set for the property in the model
     * @param {T} oOldValue the old value
     * @template T
     */
    UCF_ClientElement["prototype"]["updateModelProperty"] = function (sName, oValue, oOldValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateModelProperty"]++;
        }
        ;
        /** @type {UCF_ClientElement_BindingInfo} */
        var oBindingInfo;
        /** @type {UCF_Binding} */
        var oBinding;
        /** @type {UCF_ClientInterfaces_Property} */
        var oPropertyInfo;
        /** @type {UCF_SimpleType} */
        var oType;
        /** @type {string} */
        var sInternalType;

        if (this["isBound"](sName)) {
            oBindingInfo = this["mBindingInfos"][sName];

            if (!this["mBindingInfos"]["skipModelUpdate"]) {
                oBinding = oBindingInfo["binding"];
                oPropertyInfo = this["getMetadata"]()["properties"][sName];
                oType = oBindingInfo["type"];
                sInternalType = oPropertyInfo["type"];

                if (!window["UCF_Binding"]) {
                    UCF_ClassLoader["oGetClass"]('UCF_Binding');
                }
                if (
                    oBindingInfo["mode"] === UCF_Binding["Mode"]["TwoWay"] &&
                    oBinding &&
                    !oBindingInfo["skipModelUpdate"] &&
                    !oBindingInfo["formatter"]
                ) {
                    if (oType) {
                        // eslint-disable-next-line max-depth
                        try {
                            oValue = oType["parseValue"](oValue, sInternalType);
                            oType["validateValue"](oValue);
                            oBindingInfo["binding"]["setValue"](oValue);
                            this["updateMergedObjects"](sName, oValue, oOldValue);
                            this["oLS"]["fireValidationSuccess"]({
                                "element": this,
                                "property": sName,
                                "type": oType,
                                "newValue": oValue,
                                "oldValue": oOldValue
                            });
                        } catch (oException) {
                            // eslint-disable-next-line max-depth
                            if (oException instanceof UCF_ParseException) {
                                this["oLS"]["fireParseError"]({
                                    "element": this,
                                    "property": sName,
                                    "type": oType,
                                    "newValue": oValue,
                                    "oldValue": oOldValue,
                                    "exception": oException
                                });
                            } else if (oException instanceof UCF_ValidateException) {
                                this["oLS"]["fireValidationError"]({
                                    "element": this,
                                    "property": sName,
                                    "type": oType,
                                    "newValue": oValue,
                                    "oldValue": oOldValue,
                                    "exception": oException
                                });
                            } else {
                                throw oException;
                            }
                        }
                    } else {
                        oBindingInfo["binding"]["setValue"](oValue);
                        this["updateMergedObjects"](sName, oValue, oOldValue);
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateModelProperty"] = 0;
    }
    ;

    /**
     * Updates the merged objects if any based on the parents binding context.
     * If a merge range exists the sub path of this element is also updated
     * all objects in the range. The change is only applied on the model not on the UI controls
     * as they might not be visible or bound.
     *
     * @private
     * @param {string} sName the name of the property to update
     * @param {T} oValue the new value to set for the property in the model
     * @param {T} oOldValue the old value for the property in the model
     * @template T
     */
    UCF_ClientElement["prototype"]["updateMergedObjects"] = function (sName, oValue, oOldValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["updateMergedObjects"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent = this; // eslint-disable-line consistent-this
        /** @type {UCF_ClientElement_MergeData} */
        var oMergedCells;
        /** @type {number} */
        var x;
        /** @type {number} */
        var y;
        /** @type {string} */
        var sMergePath;
        /** @type {T} */
        var oModelValue;
        /** @type {UCF_BindingContext} */
        var oBindingContext = this["getBindingContext"]();
        /** @type {UCF_Model} */
        var oModel = oBindingContext["getModel"]();
        /** @type {string} */
        var sPath = oBindingContext["getPath"]();
        /** @type {string} */
        var sBindingPath = this["getBinding"](sName)["getPath"]();

        while (oParent) {
            if (oParent["getBindingContext"]()) {
                oMergedCells = oParent
                    ["getBindingContext"]()
                    ["getModel"]()
                    ["_getObject"]('__merge', oParent["getBindingContext"]());

                if (oMergedCells) {
                    for (x = oMergedCells["from_x"]; x <= oMergedCells["to_x"]; x++) {
                        // eslint-disable-next-line max-depth
                        for (y = oMergedCells["from_y"]; y <= oMergedCells["to_y"]; y++) {
                            sMergePath = sPath["substring"](0, sPath["lastIndexOf"]('/') + 1) + x + '-' + y + '/' + sBindingPath;

                            oModelValue = oModel["_getObject"](sMergePath);
                            // eslint-disable-next-line max-depth
                            if (oModelValue !== oValue) {
                                oModel["setProperty"](sMergePath, oValue);
                            }
                        }
                    }
                    break;
                }
            }
            oParent = oParent["getParent"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["updateMergedObjects"] = 0;
    }
    ;

    /**
     * Convenient method to get JSON CustomData key
     *
     * @public
     * @param {string} sKey the key
     * @return {any} The value of the key in the CustomData JSON
     */
    UCF_ClientElement["prototype"]["getCustomDataKey"] = function (sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getCustomDataKey"]++;
        }
        ;
        var oCustomDataMap = this["getCustomDataMap"]();

        return this["getCustomData"] && oCustomDataMap
            ? oCustomDataMap[sKey]
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getCustomDataKey"] = 0;
    }
    ;

    /**
     * Convenient method to get JSON CustomData map
     *
     * @public
     * @return {Object} the JSON map contained in custom data or null
     */
    UCF_ClientElement["prototype"]["getCustomDataMap"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getCustomDataMap"]++;
        }
        ;
        /** @type {Object} */
        var oJson;

        if (this["getCustomData"] && this["getCustomData"]() && !this["_oCustomDataJson"]) {
            try {
                oJson = UCF_JsUtil["oJsonParse"](this["getCustomData"]());
                if (oJson) {
                    this["_oCustomDataJson"] = oJson;
                }
            } catch (ex) {
                this["_oCustomDataJson"] = null;
            }
        }

        return this["_oCustomDataJson"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getCustomDataMap"] = 0;
    }
    ;

    /**
     * Convenient method to set JSON CustomData key
     *
     * @public
     * @param {string} sKey the key
     * @param {T} oValue the value
     * @param {boolean} bSuppressRerendering `true` to suppress rerendering
     * @return {boolean} `true` if the value was set otherwise `false`
     * @template T
     */
    UCF_ClientElement["prototype"]["setCustomDataKey"] = function (sKey, oValue, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setCustomDataKey"]++;
        }
        ;
        /** @type {T} */
        var oOldValue;
        /** @type {boolean} */
        var bIncluded;
        /** @type {string} */
        var s;

        if (this["getCustomData"]) {
            if (!this["_oCustomDataJson"] && !this["getCustomData"]()) {
                this["setCustomData"]('{}', bSuppressRerendering);
            }
            if (this["_oCustomDataJson"]) {
                oOldValue = this["_oCustomDataJson"][sKey];
                bIncluded = sKey in this["_oCustomDataJson"];
                this["_oCustomDataJson"][sKey] = oValue;
                try {
                    s = UCF_JsUtil["sJsonStringify"](this["_oCustomDataJson"]);
                    this["setCustomData"](s, bSuppressRerendering);

                    return true;
                } catch (ex) {
                    if (bIncluded) {
                        this["_oCustomDataJson"][sKey] = oOldValue;
                    } else {
                        delete this["_oCustomDataJson"][sKey];
                    }
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setCustomDataKey"] = 0;
    }
    ;

    /**
     * Default empty implementation for onBeforeRendering
     * Override and call super
     *
     * @private
     */
    UCF_ClientElement["prototype"]["onBeforeRendering"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onBeforeRendering"]++;
        }
        ;
        this["_fireEvent"](this["E_EVENTS"]["BeforeRendering"], {"oElement": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onBeforeRendering"] = 0;
    }
    ;

    /**
     * Default empty implementation for onAfterRendering
     * Override and call super
     *
     * @private
     */
    UCF_ClientElement["prototype"]["onAfterRendering"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["onAfterRendering"]++;
        }
        ;
        this["_fireEvent"](this["E_EVENTS"]["AfterRendering"], {"oElement": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["onAfterRendering"] = 0;
    }
    ;

    /**
     * Returns the UCF Control instance of this client element if any.
     *
     * @private
     * @param {boolean} bForceRendering `true` to force rendering
     * @return {UCF_Control} The UCF_Control instance of the control
     */
    UCF_ClientElement["prototype"]["getUCFInstanceInternal"] = function (bForceRendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getUCFInstanceInternal"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oUCFInstance;

        if (!this["bIsDestroyed"] && UCF_DomUtil["$"](this["sId"])) {
            oUCFInstance = this["oLS"]["oControlFactory"]["oGetControlById"](this["sId"]) ||
                this["oLS"]["oControlFactory"]["oCreateControlById"](this["sId"]);

            if (oUCFInstance && !this["bInvalidated"]) {
                return oUCFInstance;
            }
            if (bForceRendering) {
                this["render"]();

                return this["getUCFInstanceInternal"]();
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getUCFInstanceInternal"] = 0;
    }
    ;

    /**
     * Returns the UCF Control instance of this client element if any.
     *
     * @public
     * @param {boolean} bForceRendering `true` to force rendering
     * @return {UCF_Interface<UCF_Control>} The UCF_Control instance of the control
     */
    UCF_ClientElement["prototype"]["getUCFInstance"] = function (bForceRendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getUCFInstance"]++;
        }
        ;
        // TODO wat? getUCFInstance should return the interface, not the actual control...
        return this["getUCFInstanceInternal"](bForceRendering); // .oGetInterface();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getUCFInstance"] = 0;
    }
    ;

    /**
     * Sets the given property on the corresponding UCF instance of the element.
     * Optional a method to be called can be given
     *
     * @private
     * @param {string} sName The name of the property
     * @param {any} oValue The value of the property
     * @param {boolean} bSuppressRerendering `true` to suppress rerendering
     * @param {string} sMethod The name of a method to be called to set the property
     * @param {Array} [aUCFParameters=oValue] The parameter array to pass to the
     * UCFMethod
     * @return {UCF_ClientElement} this, for chaining
     */
    UCF_ClientElement["prototype"]["setUCFProperty"] = function (sName, oValue, bSuppressRerendering, sMethod, aUCFParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setUCFProperty"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oUCF = this["getUCFInstance"](); // TODO shouldn't this be getUCFInstanceInternal?
        /** @type {boolean} */
        var bInvalidated = this["bInvalidated"]; //store the old invalidation state

        this["setProperty"](sName, oValue, bSuppressRerendering);
        // 1) bInvalidated - only set the value via fast setter if the control was not
        // invalidated before the setter is called. If that is the case then
        // content might be changed and the control needs rerendering anyhow.
        // 2) bSuppressRerendering - If the caller wants to suppress renderering we
        // suppress it really
        // 3) this.bInvalidated - If the control is invalidated after the previous
        // setProperty
        if (!bInvalidated && !bSuppressRerendering && this["bInvalidated"] && oUCF) {
            if (oValue == null) {
                oValue = this["getMetadata"]()["properties"][sName]["defaultValue"];
            }
            if (!aUCFParameters) {
                aUCFParameters = [oValue];
            }
            oUCF[sMethod]["apply"](oUCF, aUCFParameters);
            // set the old invalidation state again to force a rerendering
            this["setInvalidated"](false);
        }

        return this;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setUCFProperty"] = 0;
    }
    ;

    /**
     * Attaches the given handler to a children changed event that is called
     * whenever a child is added, removed.
     *
     * @private
     * @param {string} sAggregationName The name of the aggregation to be whatched
     * by the event, default is Content
     * @param {function(UCF_ClientElement_ChildrenChange): void} fHandler
     * function to be called
     */
    UCF_ClientElement["prototype"]["attachChildrenChanged"] = function (sAggregationName, fHandler) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["attachChildrenChanged"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata = this["getMetadata"]();
        /** @type {UCF_ClientElement_Aggregation} */
        var aContents;
        /** @type {UCF_ClientElement} */
        var self;
        /** @type {function(UCF_ClientElement): void} */
        var fPropagate;

        if (typeof sAggregationName !== 'string') {
            sAggregationName = 'Content';
        }
        if (oMetadata["aggregations"][sAggregationName]) {
            if (!this["mChangeHandlers"][sAggregationName]) {
                this["mChangeHandlers"][sAggregationName] = [];
            }
            this["mChangeHandlers"][sAggregationName]["push"](fHandler);
            aContents = this["getAggregation"](sAggregationName);

            if (aContents) {
                self = this;
                fPropagate = function (oControl) {
                    oControl["mContentChangedParents"][self["getId"]()] = {
                        "oObject": self,
                        "sParentAggregation": sAggregationName
                    };
                };
                if (UCF_JsUtil["bIsArray"](aContents)) {
                    UCF_JsUtil["forEach"](aContents, function (oContent) {
                        fPropagate(oContent);
                        oContent["traverseChildren"](fPropagate);
                    });
                } else {
                    fPropagate(aContents);
                    aContents["traverseChildren"](fPropagate);
                }
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Aggregation ' + sAggregationName + ' does not exist', "ClientElement.js(3978): attachChildrenChanged");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["attachChildrenChanged"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sAggregationName the name of the aggregation to detach from
     * @param {function(UCF_ClientElement_ChildrenChange): void} fHandler the
     * handler to detach
     * @see UCF_ClientElement.prototype.attachChildrenChanged
     */
    UCF_ClientElement["prototype"]["detachChildrenChanged"] = function (sAggregationName, fHandler) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["detachChildrenChanged"]++;
        }
        ;
        /** @type {Array<UCF_ClientElement_ChildrenChange>} */
        var aHandlers;
        /** @type {UCF_ClientElement_Aggregation} */
        var aContents;
        /** @type {UCF_ClientElement} */
        var self;
        /** @type {function(UCF_ClientElement): void} */
        var fPropagate;

        if (this["mChangeHandlers"][sAggregationName]) {
            aHandlers = this["mChangeHandlers"][sAggregationName];

            UCF_JsUtil["forEach"](aHandlers, function (_, i) {
                aHandlers["slice"](i, 1);
            });

            if (aHandlers["length"] === 0) {
                delete this["mChangeHandlers"][sAggregationName];
            }

            aContents = this["getAggregation"](sAggregationName);

            if (aContents) {
                self = this;
                fPropagate = function (oControl) {
                    delete oControl["mContentChangedParents"][self["getId"]()];
                };
                if (UCF_JsUtil["bIsArray"](aContents)) {
                    UCF_JsUtil["forEach"](aContents, function (oContent) {
                        oContent["traverseChildren"](fPropagate);
                    });
                } else {
                    aContents["traverseChildren"](fPropagate);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["detachChildrenChanged"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sHandlerAggregation the aggregation that changed
     * @param {UCF_ClientElement} oControl the control
     * @param {UCF_ClientElement} oOldParent the old parent
     * @param {UCF_ClientElement} oNewParent the new parent
     * @param {string} sParentAggregation the name of the parent aggregation
     * @param {boolean} bAdd `true` if added
     * @see UCF_ClientElement.prototype.attachChildrenChanged
     */
    UCF_ClientElement["prototype"]["fireChildrenChanged"] = function (sHandlerAggregation, oControl, oOldParent, oNewParent, sParentAggregation, bAdd) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["fireChildrenChanged"]++;
        }
        ;
        UCF_JsUtil["forEach"](
            this["mChangeHandlers"][sHandlerAggregation],
            function (fHandler) {
                fHandler({
                    "oControl": oControl,
                    "oOldParent": oOldParent,
                    "oNewParent": oNewParent,
                    "sParentAggregation": sParentAggregation,
                    "bAdd": bAdd
                });
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["fireChildrenChanged"] = 0;
    }
    ;

    /**
     * Sets whether the control is invisible or not.
     *
     * @public
     * @param {boolean} bInvisible `true` to set the element invisible
     * @param {boolean} bKeepWidth `true` to maintain the width of the invisible
     * element
     * @param {boolean} bSuppressRerendering `true` to suppress rerendering
     */
    UCF_ClientElement["prototype"]["setInvisibility"] = function (bInvisible, bKeepWidth, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setInvisibility"]++;
        }
        ;
        if (this["getVisibility"]) {
            if (this["getUCFInstanceInternal"]() && !bSuppressRerendering) {
                this["getUCFInstanceInternal"]()["setInvisibility"](bInvisible, bKeepWidth);
            }
            ;
            this["_bInvisibility"] = bInvisible;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setInvisibility"] = 0;
    }
    ;

    /**
     * Returns whether the control is currently invisible or not
     *
     * @public
     * @return {boolean} `true` if the control is currently invisible
     */
    UCF_ClientElement["prototype"]["getInvisibility"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getInvisibility"]++;
        }
        ;
        return this["getVisibility"] ? this["_bInvisibility"] : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getInvisibility"] = 0;
    }
    ;

    /**
     * Sets whether the content of this element will render the invisible controls
     * Used for Personas Editor.
     * @param {boolean} bValue The value
     */
    UCF_ClientElement["prototype"]["setRenderInvisibleContent"] = function (bValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["setRenderInvisibleContent"]++;
        }
        ;
        if (this["bRenderInvisibleContent"] !== bValue) {
            this["bRenderInvisibleContent"] = bValue;
            this["invalidate"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["setRenderInvisibleContent"] = 0;
    }
    ;

    /**
     * @protected
     * @return {boolean} `true` if the element content will render the invisible
     * controls. This is needed in Personas Editor to create a actual dom
     * representation for a control that is hidden after the rendering is completed
     * using setInvisility()
     */
    UCF_ClientElement["prototype"]["getRenderInvisibleContent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getRenderInvisibleContent"]++;
        }
        ;
        /** @type {boolean} */
        var bResult = this["bRenderInvisibleContent"];
        /** @type {UCF_ClientElement} */
        var oParent = this["getParent"]();

        if (oParent) {
            bResult = bResult || oParent["getRenderInvisibleContent"]();
        }

        return bResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getRenderInvisibleContent"] = 0;
    }
    ;

    /**
     * Returns the current style value (element.currentStyle / window.getComputedStyle) for a control for the given variables.
     * @param {string} sVariable Variable name
     * @return {string} The current value
     * @see #getCurrentCustomStyleValues
     */
    UCF_ClientElement["prototype"]["getCurrentCustomStyleValue"] = function (sVariable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getCurrentCustomStyleValue"]++;
        }
        ;
        /** @type {Object<string,string>} */
        var mResult = {};

        if (this["addCustomStyle"]) {
            mResult[sVariable] = '';
            mResult = this["getCurrentCustomStyleValues"](mResult);

            return mResult[sVariable];
        } else {
            return mResult;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getCurrentCustomStyleValue"] = 0;
    }
    ;

    /**
     * Returns the current style values (element.currentStyle /
     * window.getComputedStyle) for a control for the given variables
     *
     * @protected
     * @param {Object.<string,string>} mVariables Map of variables.
     * @return {Object.<string,string>} Variable name value pairs with the current
     * values in the DOM
     * @see #getCurrentCustomStyleValue
     * @see UCF_CustomStyleProvider
     */
    UCF_ClientElement["prototype"]["getCurrentCustomStyleValues"] = function (mVariables) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getCurrentCustomStyleValues"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var self = this;
        /** @type {UCF_CustomStyleProvider} */
        var oProvider;
        /** @type {HTMLElement} */
        var oRootRef;
        /** @type {Array<{oDomRef: HTMLElement, sSuffix: string}>} */
        var aDomRefs;
        /**
         * Used to iterate over this.mCustomStyleSuffix, which gets filled by
         * addCustomStyleSuffix() call in renderers. But this does not work for
         * suffixes containing cascaded selectors, like in CheckBox or RadioButton
         * (addCustomStyleSuffix() is not called) => Use all "classes" (identified by
         * suffix) from metadata and call querySelectorAll() to find the DomRefs
         * @type {Object<string,_StyleClass>}
         */
        var oStyleClasses;

        if (!this["addCustomStyle"] || !this["sCustomStyleCheckName"]) {
            return {};
        }

        oProvider = new (UCF_ClassLoader["oGetClass"]('UCF_CustomStyleProvider'))(this);
        oRootRef = this["getRootRef"]();

        if (!oRootRef ||
            !oRootRef["parentNode"] ||
            !oRootRef["parentNode"]["getElementsByClassName"] ||
            !oRootRef["parentNode"]["querySelectorAll"]
        ) {
            return {};
        }

        oStyleClasses = oProvider["oStyleMetadata"]["classes"];
        aDomRefs = UCF_JsUtil["reduce"](
            UCF_JsUtil["keys"](oStyleClasses || {}),
            function (aDomRefs, sSuffix) {
                /** @type {Array<HTMLElement>} */
                var aSuffixRefs = [];
                /** @type {Array<string>} */
                var aAllCSClasses;
                /** @type {Array<string>} */
                var aSuffixParts;
                /** @type {Array<HTMLElement>} */
                var aFound;
                /** @type {number} */
                var i;
                /** @type {number} */
                var y;
                /** @type {number} */
                var j;

                if (sSuffix["indexOf"]('.') > -1 && self["getCustomStyle"]()) {
                    // Assume it contains cascaded CSS selector(s), with or without
                    // "suffix", maybe comma-separated list. Examples from Checkbox:
                    // suffix="Err .lsCBStdTxt", suffix=" .lsCBImgStdInv", example from
                    // StickyNote: suffix="Root.lsSTNControl,Icon.lsSTNStickyIcon.lsSTNVisible"
                    aAllCSClasses = UCF_StringUtil["sTrim"](
                        self["getCustomStyle"]()["replace"](/[ ]+/g, ' ')
                    )["split"](' ');
                    aSuffixParts = sSuffix["split"](',');

                    for (i = 0; i < aAllCSClasses["length"]; i++) {
                        if (aAllCSClasses[i] !== '') {
                            for (y = 0; y < aSuffixParts["length"]; y++) {
                                aFound = UCF_JsUtil["arrayFrom"](
                                    oRootRef["parentNode"]["querySelectorAll"](
                                        UCF_StringUtil["bContains"](aSuffixParts[y], '@{CustomStyle}')
                                            ? aSuffixParts[y]["replace"](/\@\{CustomStyle\}/g, '.' + aAllCSClasses[i])
                                            : '.' + aAllCSClasses[i] + aSuffixParts[y]
                                    )
                                );
                                // eslint-disable-next-line max-depth
                                for (j = 0; j < aFound["length"]; j++) {
                                    // eslint-disable-next-line max-depth
                                    if (!UCF_JsUtil["contains"](aSuffixRefs, aFound[j]) ||
                                        UCF_DomUtil["sGetCurrentStyle"](aFound[j], 'visibility') !==
                                        'hidden'
                                    ) {
                                        aSuffixRefs["push"](aFound[j]);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    aSuffixRefs = UCF_JsUtil["arrayFrom"](
                        oRootRef["parentNode"]["getElementsByClassName"](
                            self["sCustomStyleCheckName"] + sSuffix
                        )
                    );
                }
                if (aSuffixRefs["length"] > 0) {
                    return aDomRefs["concat"](UCF_JsUtil["map"](
                        aSuffixRefs,
                        function (oSuffixRef) {
                            return {"oDomRef": oSuffixRef, "sSuffix": sSuffix};
                        }
                    ));
                } else {
                    return aDomRefs;
                }
            },
            UCF_JsUtil["map"](
                UCF_JsUtil["arrayFrom"](
                    oRootRef["parentNode"]["getElementsByClassName"](this["sCustomStyleCheckName"])
                ),
                function (oDomRef) {
                    return {"oDomRef": oDomRef, "sSuffix": ''};
                }
            )
        );

        return UCF_JsUtil["reduce"](
            UCF_JsUtil["keys"](mVariables || {}),
            function (oResult, sVariable) {
                /** @type {Object<_StyleVariableName,_StyleVariable>} */
                var oVariables = oProvider["mVariables"];
                /** @type {Array<string>} */
                var aVariableUsageSuffixes;

                // TODO: Condition for value || defaultValue: It seems parsing of
                // "ruleValue()" in CustomStyleProvider.addVariable() is broken. This
                // only worked for some variables, because in this case defaultValue
                // contains the string "null" ....
                if (oVariables && oVariables[sVariable]) {
                    aVariableUsageSuffixes = UCF_JsUtil["map"](
                        oProvider["aGetVariableOccurrence"](sVariable),
                        function (o) {
                            return o["classsuffix"];
                        }
                    );

                    return UCF_JsUtil["extend"](oResult, UCF_JsUtil["reduce"](
                        aDomRefs,
                        function (oValue, oEntry) {
                            if (!oValue[sVariable] &&
                                UCF_JsUtil["contains"](aVariableUsageSuffixes, oEntry["sSuffix"])
                            ) {
                                oValue[sVariable] = UCF_DomUtil["sGetCurrentStyle"](
                                    oEntry["oDomRef"],
                                    oVariables[sVariable]["property"]
                                );
                            }

                            return oValue;
                        }, {}
                    ));
                } else {
                    return oResult;
                }
            }, {}
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getCurrentCustomStyleValues"] = 0;
    }
    ;

    /**
     * Returns the metadata for the control as defined in the
     * UCF_ClientInterfaces.I json
     *
     * @return {UCF_ClientInterfaces_Interface} metadata structure for the control.
     */
    UCF_ClientElement["prototype"]["getMetadata"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["getMetadata"]++;
        }
        ;
        return this["mMetadata"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["getMetadata"] = 0;
    }
    ;

    /**
     * Creates a new instance of a control.
     *
     * @private
     * @static
     * @param {string} sClassName The class name of the instance that should be created
     * @param {UCF_LS} oLS The lightspeed instance that is managing this instance
     * @param {string} sId The id of the instance that is created
     * @param {Object} [oJson] optional The json settings for the control and subcontrols
     * @param {UCF_ClientElement} [oParent] parent of the new instance
     * @param {boolean} bSuppressRerendering `true` to suppress rerendering
     * @return {UCF_ClientElement} The new client element instance
     */
    UCF_ClientElement["createInstance"] = function (sClassName, oLS, sId, oJson, oParent, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["createInstance"]++;
        }
        ;
        /** @type {function(new:UCF_ClientElement)} */
        var oClass = UCF_ClientElement["extendClass"](sClassName);
        /** @type {UCF_ClientElement} */
        var oControl;
        /** @type {UCF_Page} */
        var oPage;
        /** @type {UCF_JSONModel} */
        var oModel;
        /** @type {UCF_ClientInterfaces_Interface} */
        var mMetadata;

        if (oClass) {
            oControl = new oClass(oLS, sId, oJson, oParent);

            if (!bSuppressRerendering && oControl["invalidate"]) {
                oControl["invalidate"]();
            }
            if (oJson) {
                mMetadata = oControl["getMetadata"]();

                UCF_JsUtil["forEach"](
                    UCF_JsUtil["filter"](
                        UCF_JsUtil["entries"](oJson || {}),
                        function (oEntry) {
                            /** @type {string} */
                            var n = oEntry[0];

                            return n !== 'Id' &&
                                n !== 'ModelId' &&
                                n !== 'PropertyBinding' &&
                                n !== 'ListBinding' &&
                                n !== 'GridBinding' &&
                                n !== 'TreeBinding';
                        }
                    ),
                    function (oEntry) {
                        /** @type {string} */
                        var n = oEntry[0];
                        /**
                         * There are controls where a parameter has the same name as an event
                         * (e.g. "Timeout" in the ACFAdapter). To circumvent name clashes,
                         * UCF_ClientControlTree.parse() replaces "Event" with "___Event" and
                         * "Timeout" with "___Timeout"
                         * @type {string}
                         */
                        var n_ = n["replace"]('___', '');
                        /** @type {Object} */
                        var oProperty = oEntry[1];
                        /** @type {UCF_ClientElement} */
                        var oContent;
                        /** @type {string} */
                        var m;

                        if (mMetadata["properties"] && (n in mMetadata["properties"])) {
                            if (n === 'CustomStyle' && mMetadata["properties"]["CustomStyle"]) {
                                oControl["mProperties"]["CustomStyle"] += ' ' + oProperty;
                            } else if (('set' + n) in oClass["prototype"]) {
                                oControl['set' + n](oProperty);
                            } else {
                                oControl["mProperties"][n] = oProperty;
                            }
                        } else if (mMetadata["associations"] && (n in mMetadata["associations"])) {
                            oControl["mAssociations"][n] = oProperty;
                        } else if (mMetadata["aggregations"] && (n in mMetadata["aggregations"])) {
                            if (mMetadata["aggregations"][n]["multiple"]) {
                                UCF_JsUtil["forEach"](oJson[n], function (oAggregation) {
                                    if (!oControl["mAggregations"][n]) {
                                        oControl["mAggregations"][n] = [];
                                    }
                                    if (oAggregation instanceof UCF_ClientElement) {
                                        oControl["mAggregations"][n]["push"](oAggregation);
                                        oAggregation["setParent"](oControl, n, true);
                                    } else {
                                        for (m in oAggregation) {
                                            if (UCF_ClientInterfaces["getInterface"](m)) {
                                                oContent = UCF_ClientElement["createInstance"](
                                                    m,
                                                    oLS,
                                                    oAggregation[m]["Id"],
                                                    oAggregation[m],
                                                    oControl,
                                                    bSuppressRerendering
                                                );
                                                oControl["mAggregations"][n]["push"](oContent);
                                                oContent["setParent"](oControl, n, true);
                                            }
                                        }
                                    }
                                });
                            } else if (oJson[n] instanceof UCF_ClientElement) {
                                oControl["mAggregations"][n] = oJson[n];
                                oJson[n]["setParent"](oControl, n, true);
                            } else {
                                for (m in oJson[n]) {
                                    oContent = UCF_ClientElement["createInstance"](
                                        m,
                                        oLS,
                                        oJson[n][m]["Id"],
                                        oJson[n][m],
                                        oControl,
                                        bSuppressRerendering
                                    );
                                    oControl["mAggregations"][n] = oContent;
                                    oContent["setParent"](oControl, n, true);
                                }
                            }
                        } else if (mMetadata["events"] && (n_ in mMetadata["events"])) {
                            oControl["setEventConfiguration"](
                                n_,
                                UCF_ClientElement["oGetEventConfiguration"](oProperty),
                                true
                            );
                        }
                    }
                );
                if (oJson["PropertyBinding"]) {
                    UCF_JsUtil["forEach"](oJson["PropertyBinding"], function (oBinding) {
                        UCF_JsUtil["forEach"](UCF_JsUtil["values"](oBinding), function (oElement) {
                            oControl["bindProperty"](oElement["Name"], UCF_JsUtil["extend"]({
                                    "path": UCF_ClientElement["sGetModelRelativePath"](
                                        oJson["ModelId"],
                                        oElement["Path"]
                                    )
                                },
                                oElement["Type"] ? {
                                    "datatype": oElement["Type"],
                                    "typeconfig": oElement["TypeConfiguration"]
                                } : {}
                            ));
                        });
                    });
                }
                if (oJson["ListBinding"]) {
                    UCF_JsUtil["forEach"](oJson["ListBinding"], function (oBinding) {
                        UCF_JsUtil["forEach"](UCF_JsUtil["values"](oBinding), function (oElement) {
                            oControl["bindAggregation"](oElement["Name"], {
                                "path": UCF_ClientElement["sGetModelRelativePath"](
                                    oJson["ModelId"],
                                    oElement["Path"]
                                ),
                                "template": UCF_ClientElement["oGetTemplateElement"](
                                    oElement["Template"],
                                    oControl,
                                    oLS,
                                    bSuppressRerendering
                                ),
                                "bindingtype": 'UCF_ListBinding',
                                "parameters": {"managerange": oElement["ManageRange"]},
                                "sorter": null,
                                "filters": null
                            });
                        });
                    });
                }
                if (oJson["GridBinding"]) {
                    UCF_JsUtil["forEach"](oJson["GridBinding"], function (oBinding) {
                        UCF_JsUtil["forEach"](UCF_JsUtil["values"](oBinding), function (oElement) {
                            oControl["bindAggregation"](oElement["Name"], {
                                "path": UCF_ClientElement["sGetModelRelativePath"](
                                    oJson["ModelId"],
                                    oElement["Path"]
                                ),
                                "template": UCF_ClientElement["oGetTemplateElement"](
                                    oElement["Template"],
                                    oControl,
                                    oLS,
                                    bSuppressRerendering
                                ),
                                "bindingtype": 'UCF_GridBinding',
                                "parameters": {"managerange": oElement["ManageRange"]},
                                "sorter": null,
                                "filters": null
                            });
                        });
                    });
                }
                if (oJson["ModelId"]) {
                    oPage = oLS["oGetPageInternal"]();

                    if (oPage) {
                        oModel = oPage["getModel"](oJson["ModelId"]);

                        oControl["sModelId"] = oJson["ModelId"];
                        oControl["setModel"](oModel, oJson["ModelId"]);
                    }
                }
            }

            return oControl;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["createInstance"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Object<string,T>} oProperty
     * @return {T}
     * @template T
     */
    UCF_ClientElement["oGetEventConfiguration"] = function (oProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["oGetEventConfiguration"]++;
        }
        ;
        /** @type {Array<Object>} */
        var aConf = ('UcfParameters' in oProperty) ? [oProperty["UcfParameters"]] : [];
        /** @type {string} */
        var m;

        for (m in oProperty) {
            if (m !== 'UcfParameters') {
                aConf["push"](oProperty[m]);
            }
        }

        return aConf;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["oGetEventConfiguration"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sModelId the id of the model
     * @param {string} sPath the path of the binding
     * @return {string} `${sModelId}>${sPath}` if sPath is not already a "direct
     * child" path (i.e. it does not have a ">" in it yet)
     */
    UCF_ClientElement["sGetModelRelativePath"] = function (sModelId, sPath) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["sGetModelRelativePath"]++;
        }
        ;
        return (
            sModelId &&
            !UCF_StringUtil["bContains"](sPath, '>') &&
            !UCF_StringUtil["bStartsWith"](sPath, '/')
        )
            ? sModelId + '>' + sPath
            : sPath;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["sGetModelRelativePath"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {Object} oTemplate the template in the clientcontroltree
     * @param {UCF_ClientElement} oTargetControl the control that is created
     * @param {UCF_LS} oLS the LS instance the control is created in
     * @param {boolean} [bSuppressRerendering] `true` to suppress rerendering
     * @return {UCF_ClientElement} the template element created from oTemplate
     */
    UCF_ClientElement["oGetTemplateElement"] = function (oTemplate, oTargetControl, oLS, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["oGetTemplateElement"]++;
        }
        ;
        /** @type {string} */
        var m;

        if (oTemplate) {
            for (m in oTemplate) {
                return UCF_ClientElement["createInstance"](
                    m,
                    oLS,
                    oTemplate[m]["Id"],
                    oTemplate[m],
                    oTargetControl,
                    bSuppressRerendering
                );
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["oGetTemplateElement"] = 0;
    }
    ;

    /**
     * Loads and extends the class for sClassName based on the interface definition.
     * The classes name will be UCF_ClientButton for sClassName = "Button".
     * Following methods are defined dynamically.
     * Methods for properties (set and get)
     * Methods for aggregations (set, get, clear) for single aggragations.
     * Methods for aggregations (add, get, insert, remove, clear) for iterator aggragations.
     * Methods for events (attach, detach, fire) for events will be defined.
     * Extenstion is only done once for each type.
     * As soon as the control is rendered and the user interacts with the control the Client instance is updated;
     *
     * @private
     * @param {string} sClassName The name of the control/element class that should be created
     * @param {Array} aWriter a writer array to collect multiple classes before
     * @return {function(new:UCF_ClientElement)} An class that derives from a given base class and has the given name
     */
    UCF_ClientElement["extendClass"] = function (sClassName, aWriter) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["extendClass"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oInterface;
        /** @type {string} */
        var sClientClassName;
        /** @type {function(new:UCF_ClientElement)} */
        var oClass;
        /** @type {boolean} */
        var bCreateMultiple;
        /** @type {string} */
        var sClientImplClassName;

        UCF_ClassLoader["oGetClass"]('UCF_ClientInterfaces');
        oInterface = UCF_ClientInterfaces["getInterface"](sClassName);

        if (!oInterface || !oInterface["name"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'No client interface found for ' + sClassName, "ClientElement.js(4613): sClientClassName");
            }
            ;

            return null;
        }

        sClientClassName = 'UCF_Client' + oInterface["name"];
        oClass = window[sClientClassName];
        bCreateMultiple = true;

        if (!aWriter) {
            bCreateMultiple = false;
            aWriter = [];
        }
        if (!oClass) {
            UCF_ClientElement["extendClassWorker"](
                oInterface,
                UCF_ClientInterfaces["hasRenderer"](oInterface["name"]),
                null,
                null,
                aWriter
            );
            if (UCF_ControlFactory["M_NAMES"]['UCF_' + oInterface["name"]]) {
                UCF_ClassLoader["oGetClass"]('UCF_' + oInterface["name"], null, true);
            }

            sClientImplClassName = UCF_ClientInterfaces["IMPL"][sClientClassName];
            if (sClientImplClassName) {
                aWriter["push"](UCF_ClassLoader["sGetClassString"](sClientClassName));
                aWriter["push"](';sap.ls.preload["' + sClientClassName + '"]();');
            }
            UCF_ClientInterfaces["loadRenderer"](oInterface["name"], aWriter);

            if (bCreateMultiple) {
                window[sClientClassName] = function () {
                };
            } else {
                UCF_JsUtil["rawEval"](aWriter["join"]('\n'));
            }
        }

        return window[sClientClassName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["extendClass"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_ClientInterfaces_Interface} oInterface the interface
     * @param {boolean} bHasRenderer `true` if the control has a renderer
     * @param {string} sRenderer the renderer
     * @param {string} sClientImpl the client implementation overrides
     * @param {Array<string>} [aWriter=[]] the writer to append the class to
     */
    UCF_ClientElement["extendClassWorker"] = function (oInterface, bHasRenderer, sRenderer, sClientImpl, aWriter) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["extendClassWorker"]++;
        }
        ;
        /** @type {string} */
        var sClientClassName;
        /** @type {string} */
        var sBaseClass;
        /** @type {string} */
        var sPrototypeString;

        if (oInterface && oInterface["name"]) {
            sClientClassName = 'UCF_Client' + oInterface["name"];
            if (!aWriter) {
                aWriter = [];
            }

            sBaseClass = bHasRenderer ? 'UCF_ClientControl' : 'UCF_ClientElement';
            sPrototypeString = sClientClassName + '.prototype';

            // constructor
            aWriter["push"]('window.' + sClientClassName + ' = function (oLS, sId, oJson, oParent) {');
            aWriter["push"]('\tif (arguments.length > 0) {');
            aWriter["push"]('\t\t' + sBaseClass + '.apply(this,[oLS, sId, oJson, oParent]);');
            aWriter["push"]('\t\tif (this.addCustomStyle) {');
            aWriter["push"]('\t\t\tthis.sCustomStyleCheckName = "LS_" + this.sClassName + (UCF_ClientElement.iUniqueIndex++);');
            aWriter["push"]('\t\t\tthis.addCustomStyle(this.sCustomStyleCheckName,true);');
            aWriter["push"]('\t\t}');
            aWriter["push"]('\t}');
            aWriter["push"]('};');
            aWriter["push"](sPrototypeString + ' = new ' + sBaseClass + '();');

            // public members
            aWriter["push"](sPrototypeString + '.sClassName = "' + oInterface["name"] + '";');
            aWriter["push"](sPrototypeString + '.mMetadata =  UCF_ClassLoader.oGetClass("UCF_ClientInterfaces").getInterface("' + oInterface["name"] + '");');

            // create property setter and getters
            UCF_JsUtil["forEach"](
                UCF_JsUtil["keys"](oInterface["properties"] || {}),
                function (sName) {
                    // get${sName}
                    aWriter["push"](sPrototypeString + '.get' + sName + ' = function() {');
                    aWriter["push"]('\treturn this.getProperty("' + sName + '");');
                    aWriter["push"]('};');
                    // set${sName}
                    aWriter["push"](sPrototypeString + '.set' + sName + ' = function(oValue, bSuppressRerendering) {');
                    aWriter["push"]('\treturn this.setProperty("' + sName + '", oValue, bSuppressRerendering);');
                    aWriter["push"]('};');
                    if (sName === 'CustomStyle') {
                        // hasCustomStyle
                        aWriter["push"](sPrototypeString + '.hasCustomStyle = function (oValue, bSuppressRerendering) {');
                        aWriter["push"]('\treturn UCF_StringUtil.bContains(" " + this.getCustomStyle() + " ", " " + oValue + " ");');
                        aWriter["push"]('};');
                        // addCustomStyle
                        aWriter["push"](sPrototypeString + '.addCustomStyle = function (oValue, bSuppressRerendering) {');
                        aWriter["push"]('\tif (!this.hasCustomStyle(oValue)) {');
                        aWriter["push"]('\t\tthis.setProperty("CustomStyle", this.getCustomStyle() + " " + oValue, bSuppressRerendering);');
                        aWriter["push"]('\t}');
                        aWriter["push"]('};');
                        // removeCustomStyle
                        aWriter["push"](sPrototypeString + '.removeCustomStyle = function (oValue, bSuppressRerendering) {');
                        aWriter["push"]('\tif (this.hasCustomStyle(oValue)) {');
                        aWriter["push"]('\t\tthis.setProperty("CustomStyle", UCF_StringUtil.sTrim((" " + this.getCustomStyle() + " ").replace(" " + oValue + " "," ")), bSuppressRerendering);');
                        aWriter["push"]('\t}');
                        aWriter["push"]('};');
                    }
                }
            );
            // create association setters and getters
            UCF_JsUtil["forEach"](
                UCF_JsUtil["keys"](oInterface["associations"] || {}),
                function (sName) {
                    // get${sName}
                    aWriter["push"](sPrototypeString + '.get' + sName + ' = function() {');
                    aWriter["push"]('\treturn this.getAssociation("' + sName + '");');
                    aWriter["push"]('};');
                    // set${sName}
                    aWriter["push"](sPrototypeString + '.set' + sName + ' = function(oValue, bSuppressRerendering) {');
                    aWriter["push"]('\treturn this.setAssociation("' + sName + '", oValue, bSuppressRerendering);');
                    aWriter["push"]('};');
                }
            );

            // remove the property and aggretion binding before
            if (oInterface["aggregations"] && oInterface["aggregations"]["PropertyBinding"]) {
                delete oInterface["aggregations"]["PropertyBinding"];
            }
            if (oInterface["aggregations"] && oInterface["aggregations"]["ListBinding"]) {
                delete oInterface["aggregations"]["ListBinding"];
            }
            if (oInterface["aggregations"] && oInterface["aggregations"]["GridBinding"]) {
                delete oInterface["aggregations"]["GridBinding"];
            }

            // adding setters and getters for single and multiple aggregations
            UCF_JsUtil["forEach"](
                UCF_JsUtil["entries"](oInterface["aggregations"] || {}),
                function (oEntry) {
                    /** @type {string} */
                    var sName = oEntry[0];
                    /** @type {UCF_ClientInterfaces_Aggregation} */
                    var oAggregation = oEntry[1];
                    /** @type {string} */
                    var sSingleName;

                    if (oAggregation["multiple"]) {
                        sSingleName = oAggregation["singularName"];
                        // check if there is a property with the same name
                        if (oInterface["properties"] && oInterface["properties"][sSingleName]) {
                            // get${sSingleName}
                            aWriter["push"](sPrototypeString + '.get' + sSingleName + ' = function(iIndex) {');
                            aWriter["push"]('\tif (typeof iIndex !== "number") {');
                            aWriter["push"]('\t\treturn this.getProperty("' + sSingleName + '")');
                            aWriter["push"]('\t} else {');
                            aWriter["push"]('\t\treturn this.getAggregation("' + sName + '", iIndex);');
                            aWriter["push"]('\t}');
                            aWriter["push"]('};');
                        } else {
                            // get{$sSingleName}
                            aWriter["push"](sPrototypeString + '.get' + sSingleName + ' = function(iIndex) {');
                            aWriter["push"]('\treturn this.getAggregation("' + sName + '", iIndex);');
                            aWriter["push"]('};');
                        }
                        // get${sName}
                        aWriter["push"](sPrototypeString + '.get' + sName + ' = function() {');
                        aWriter["push"]('\treturn this.getAggregation("' + sName + '");');
                        aWriter["push"]('};');
                        // clear${sName}
                        aWriter["push"](sPrototypeString + '.clear' + sName + ' = function(oValue, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.clearAggregation("' + sName + '", bSuppressRerendering);');
                        aWriter["push"]('};');
                        // add${sSingleName}
                        aWriter["push"](sPrototypeString + '.add' + sSingleName + ' = function(oValue, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.addAggregation("' + sName + '", oValue, bSuppressRerendering);');
                        aWriter["push"]('};');
                        // insert${sSingleName}
                        aWriter["push"](sPrototypeString + '.insert' + sSingleName + ' = function(oValue,iIndex, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.insertAggregation("' + sName + '", oValue, iIndex, bSuppressRerendering);');
                        aWriter["push"]('};');
                        // remove${sSingleName}
                        aWriter["push"](sPrototypeString + '.remove' + sSingleName + ' = function(iIndex, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.removeAggregation("' + sName + '", iIndex, bSuppressRerendering);');
                        aWriter["push"]('};');
                        // replace${sSingleName}
                        aWriter["push"](sPrototypeString + '.replace' + sSingleName + ' = function(oOld, oNew, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.replaceAggregation("' + sName + '", oOld, oNew, bSuppressRerendering);');
                        aWriter["push"]('};');
                    } else {
                        // get${sName}
                        aWriter["push"](sPrototypeString + '.get' + sName + ' = function() {');
                        aWriter["push"]('\treturn this.getAggregation("' + sName + '");');
                        aWriter["push"]('};');
                        // set${sName}
                        aWriter["push"](sPrototypeString + '.set' + sName + ' = function(oValue, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.setAggregation("' + sName + '", oValue, bSuppressRerendering);');
                        aWriter["push"]('};');
                        // clear${sName}
                        aWriter["push"](sPrototypeString + '.clear' + sName + ' = function(oValue, bSuppressRerendering) {');
                        aWriter["push"]('\treturn this.clearAggregation("' + sName + '", bSuppressRerendering);');
                        aWriter["push"]('};');
                    }
                }
            );

            // adding methods for events
            UCF_JsUtil["forEach"](
                UCF_JsUtil["keys"](oInterface["events"] || {}),
                function (sName) {
                    // attach${sName}
                    aWriter["push"](sPrototypeString + '.attach' + sName + ' = function(fFunction) {');
                    aWriter["push"]('\treturn this._attachEvent("' + sName + '", fFunction);');
                    aWriter["push"]('};');
                    // detach${sName}
                    aWriter["push"](sPrototypeString + '.detach' + sName + ' = function(fFunction) {');
                    aWriter["push"]('\treturn this._detachEvent("' + sName + '", fFunction);');
                    aWriter["push"]('};');
                    // fire${sName}
                    aWriter["push"](sPrototypeString + '.fire' + sName + ' = function(mParameters) {');
                    aWriter["push"]('\treturn this._fireEvent("' + sName + '", mParameters);');
                    aWriter["push"]('};');
                }
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["extendClassWorker"] = 0;
    }
    ;

    /**
     * Creates a unique id with pre and suffix
     *
     * @private
     * @static
     * @param {string} [sPrefix] the prefix added before the unique part of the id
     * @param {string} [sSuffix] the suffix added after the unique part of the id
     * @return {string} A unique id
     */
    UCF_ClientElement["createId"] = function (sPrefix, sSuffix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientElement["_"]["createId"]++;
        }
        ;
        return (sPrefix || '') + 'ls_id' + (UCF_ClientElement["iIdIndex"]++) + (sSuffix || '');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientElement["_"]["createId"] = 0;
    }
    ;

    UCF_ClientElement.prototype["aPublicMethods"] = ["getControlTree", "contains", "toJSON", "toJSONString", "addCustomObject", "removeCustomObject", "getCustomObject", "toLSXString", "render", "removeFromParent", "getId", "setParent", "getParent", "bindProperty", "setModel", "getModel", "hasModel", "findElements", "getBinding", "unbindProperty", "isBound", "bindAggregation", "unbindAggregation", "destroy", "removeFromDom", "setBindingContext", "getBindingContext", "invalidate", "isInvalidated", "isChildInvalidated", "getInvalidatedChildren", "setInvalidated", "resetInvalidated", "getRootRef", "setIndexInParentAggregation", "moveInParentAggregation", "traverseChildren", "getCustomDataKey", "getCustomDataMap", "setCustomDataKey", "getUCFInstance", "setInvisibility", "getInvisibility"].concat(UCF_ClientElement.prototype.aPublicMethods || []);
    /* global _trace, DEBUG */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_ClientControlTree */
/// <reference path="./ClientControlTree.js"/>
    /* global UCF_ClientElement */

/// <reference path="./ClientElement.js"/>

    /**
     * Base class for client controls that are managed on the client.
     * The server needs to send the client tree information in the current page.
     *
     *
     * @class
     * @version
     * @param {UCF_LS} oLS the Lightspeed instance
     * @param {string} sId the id of the control
     * @param {Object} oJson a Json representation of the control
     * @param {UCF_ClientElement} oParent the parent control
     */
    function UCF_ClientControl(oLS, sId, oJson, oParent) {
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["UCF_ClientControl"]++;
        }
        ;
        if (arguments["length"] > 0) {
            UCF_ClientElement["apply"](this, arguments);
            /** @type {HTMLElement} */
            this["oReplaceDomRef"] = null;
            /** @type {number} */
            this["iRenderTimer"] = null;
        }
    };window["UCF_ClientControl"] = UCF_ClientControl;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClientControl");
        UCF_ClientControl["_"] = {UCF_ClientControl: 0};
    }
    ;
    ;
    UCF_ClientControl["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_ClientElement"))();
    UCF_ClientControl.prototype["sClassName"] = "UCF_ClientControl";

    /** @override */
    UCF_ClientControl["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["destroy"]++;
        }
        ;
        this["oReplaceDomRef"] = null;
        if (this["iRenderTimer"]) {
            UCF_JsUtil["clearDelayedCall"](this["iRenderTimer"]);
            this["iRenderTimer"] = null;
        }

        UCF_ClientElement.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["destroy"] = 0;
    }
    ;

    /**
     * Returns the parent
     *
     * @override
     * @public
     * @param {UCF_ClientElement} oElement The client element that is the new
     * parent for this client element
     * @param {string} sAggregationName The name of the aggregation that this
     * client element is part of
     * @param {boolean} [bSuppressRerendering] `true` to suppress rerendering
     */
    UCF_ClientControl["prototype"]["setParent"] = function (oElement, sAggregationName, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["setParent"]++;
        }
        ;
        /** @type {UCF_ClientControlTree} */
        var oControlTree = this["getControlTree"]();
        /** @type {boolean} */
        var bRootControl = oControlTree && oControlTree["getRootControl"]() === this;

        UCF_ClientElement.prototype["setParent"]["apply"](this, arguments);

        if (bRootControl) {
            oControlTree["destroy"]();
            this["_oControlTree"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["setParent"] = 0;
    }
    ;

    /**
     * Invalidates the control and triggers rendering after via a timer
     *
     * @override
     * @public
     */
    UCF_ClientControl["prototype"]["invalidate"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["invalidate"]++;
        }
        ;
        if (!this["bInvalidated"]) {
            this["bInvalidated"] = true;
            if (!this["isParentInvalidated"]()) {
                if (this["iRenderTimer"]) {
                    UCF_JsUtil["clearDelayedCall"](this["iRenderTimer"]);
                }
                this["iRenderTimer"] = UCF_JsUtil["delayedCall"](0, this, 'render', [true]);
            } else if (this["oParent"]) {
                this["oParent"]["invalidate"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["invalidate"] = 0;
    }
    ;

    /**
     * Places the control inside the given DOM element. In case this
     * client-instance is already 'invalidated' the rendering is synchronous
     * (not 'delayed'), that means a UCF-instance will be available after calling
     * this function (in the same stack).
     *
     * @public
     * @param {string|HTMLElement} oDomRef the DOM element or the ID of the element
     */
    UCF_ClientControl["prototype"]["placeAt"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["placeAt"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oSpan;

        if (typeof oDomRef === 'string') {
            oDomRef = UCF_DomUtil["$"](oDomRef);
        }
        if (oDomRef) {
            oSpan = document["createElement"]('SPAN');

            oSpan["style"]["display"] = 'none';
            oDomRef["appendChild"](oSpan);
            this["replace"](oSpan);

            UCF_DomUtil["removeFromDom"](oSpan);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["placeAt"] = 0;
    }
    ;

    /**
     * Replaces the given dom element with the DOM representation of the control.
     * In case this client-instance is already 'invalidated' the rendering is
     * synchronous (not 'delayed'), that means a UCF-instance will be available
     * after calling this function (in the same stack).
     *
     * @public
     * @param {HTMLElement} oDomRef The dom element to replace
     * @param {boolean} bDelayed `true` to perform the replacement asynchronously
     */
    UCF_ClientControl["prototype"]["replace"] = function (oDomRef, bDelayed) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["replace"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oParent;
        /** @type {boolean} */
        var bRender;
        /** @type {UCF_ClientControlTree} */
        var oControlTree;

        if (bDelayed) {
            UCF_JsUtil["delayedCall"](0, this, 'replace', [oDomRef]);
        } else {
            if (typeof oDomRef === 'string') {
                oDomRef = UCF_DomUtil["$"](oDomRef + '-r') || UCF_DomUtil["$"](oDomRef);
            }
            if (oDomRef) {
                oParent = oDomRef["parentNode"];

                if (oParent) {
                    bRender = this["bInvalidated"] || oDomRef !== this["getRootRef"]();

                    this["oReplaceDomRef"] = oDomRef;
                    if (this["getParent"]()) {
                        this["removeFromParent"]();
                        oControlTree = new (UCF_ClassLoader["oGetClass"]("UCF_ClientControlTree"))(this["oLS"], this);
                        this["oLS"]["oControlFactory"]["updateClientControlTree"](oControlTree, true);
                    } else if (this["getControlTree"]()) {
                        // control is the root control of a controltree
                        // eslint-disable-next-line max-depth
                        if (oDomRef["id"] !== this["getControlTree"]()["getRootId"]()) {
                            this["removeFromDom"]();
                        }
                    } else {
                        oControlTree = new (UCF_ClassLoader["oGetClass"]("UCF_ClientControlTree"))(this["oLS"], this);
                        this["oLS"]["oControlFactory"]["updateClientControlTree"](oControlTree, true);
                    }
                    if (bRender) {
                        this["invalidate"]();
                        this["render"]();
                    }
                }
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["replace"] = 0;
    }
    ;

    /**
     * Renders the control. Rendering is only done if the UCFControl instance has a
     * RootRef. Special cases as an update of one control in the parent are done
     * here and in replaceAggregation. Also a check whether a parent was
     * invalidated is handled here to avoid double rendering and the method exits.
     * Highlighting is only done in Standardsmode for IE because outline style is
     * not supported in quirks
     *
     * @public
     * @param {boolean} bTimer
     */
    UCF_ClientControl["prototype"]["render"] = function (bTimer) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControl["_"]["render"]++;
        }
        ;
        /** @type {UCF_ClientControlTree} */
        var oControlTree;
        /** @type {HTMLElement} */
        var oUCFDomRef;
        /** @type {UCF_RenderManager} */
        var oRenderManager;
        /** @type {UCF_Control} */
        var oUCFControl;

        if (!this["bIsDestroyed"]) {
            // if render was called explicitly we need to clear any rerendering timer
            // of a control
            if (this["iRenderTimer"]) {
                UCF_JsUtil["clearDelayedCall"](this["iRenderTimer"]);
                this["iRenderTimer"] = null;
            }

            // Check the control tree. If it is inactive do not render
            oControlTree = this["getControlTree"]();
            if (!oControlTree || oControlTree["isActive"]()) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, this["sClassName"] + '.render triggered.', "ClientControl.js(205): render");
                }
                ;
                // first check whether in the meantime a parent was invalidated too. in
                // this case we do not need to rerender
                if (this["isParentInvalidated"]()) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, this["sClassName"] + '.render - parent already invalidated.', "ClientControl.js(209): render");
                    }
                    ;
                    if (bTimer) {
                        return;
                    } else if (this["getParent"]()) {
                        this["getParent"]()["render"]();

                        return;
                    }
                }
                if (this["getVisibility"] && this["getVisibility"]() === 'NONE') {
                    if (this["getParent"]()) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(DEBUG, this["sClassName"] + '.render - invalidate parent caused by visibility NONE.', "ClientControl.js(220): render");
                        }
                        ;
                        this["getParent"]()["invalidate"]();
                    } else {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(DEBUG, this["sClassName"] + '.render - did not find a parent to rerender caused by visibility NONE.', "ClientControl.js(223): render");
                        }
                        ;
                    }
                } else if (!bTimer || this["bInvalidated"]) {
                    oUCFDomRef = this["getRootRef"]();
                    oRenderManager = this["oLS"]["oGetRenderManager"]();

                    if (
                        oUCFDomRef &&
                        this["oReplaceDomRef"] &&
                        this["oReplaceDomRef"] !== oUCFDomRef
                    ) {
                        // the domref might include the replace dom ref. We need to avoid that the
                        // oReplaceDomRef is removed.
                        if (
                            UCF_DomUtil["bContains"](oUCFDomRef, this["oReplaceDomRef"]) &&
                            oUCFDomRef["parentNode"]
                        ) {
                            oUCFDomRef["parentNode"]["replaceChild"](
                                this["oReplaceDomRef"],
                                oUCFDomRef
                            );
                        }
                        this["removeFromDom"]();
                    } else if (oUCFDomRef) {
                        oUCFControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](
                            oUCFDomRef,
                            false
                        );

                        if (oUCFControl) {
                            oUCFControl["destroy"]();
                            delete this["oLS"]["oControlFactory"]["mControls"][oUCFControl["sId"]];
                        }
                    }
                    if (!this["oReplaceDomRef"] && oUCFDomRef) {
                        this["oReplaceDomRef"] = oUCFDomRef;
                    }
                    if (this["oReplaceDomRef"]) {
                        if (!this["oLS"]["fireRenderClientControl"](this)) {
                            if (this["updateHTML"]) {
                                this["updateHTML"](this["oReplaceDomRef"]);
                            } else {
                                oRenderManager["renderControl"](
                                    this["getRenderInfo"](),
                                    this["oReplaceDomRef"]
                                );
                            }
                        }
                        this["oReplaceDomRef"] = null;
                    } else if (this["getParent"]()) {
                        // no client ucf instance found, cannot render, do not know where
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(DEBUG, this["sClassName"] + '.render - because visiblity might be switched', "ClientControl.js(274): render");
                        }
                        ;
                        if (bTimer) {
                            this["getParent"]()["invalidate"]();
                        } else {
                            this["getParent"]()["render"]();
                        }
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControl["_"]["render"] = 0;
    }
    ;

    UCF_ClientControl.prototype["aPublicMethods"] = ["setParent", "invalidate", "placeAt", "replace", "render"].concat(UCF_ClientControl.prototype.aPublicMethods || []);
    /* global _trace, _measure, ERROR, START, STOP */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_RenderManager */
/// <reference path="../core/RenderManager.js"/>
    /* global UCF_System */
/// <reference path="../core/System.js"/>
    /* global UCF_ClientElement */

/// <reference path="./ClientElement.js"/>

    /**
     * ClientControlTree is the managing class for Client Side control and represents the root control
     * that can be placed at the HTML.
     *
     * @class
     * @param {UCF_LS} oLS the Lightspeed instance
     * @param {Object|UCF_ClientElement} oJsonOrControl a Json representation of a controltree or a control instance
     * @param {boolean} bInactive Inactive flag
     */
    function UCF_ClientControlTree(oLS, oJsonOrControl, bInactive) {
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["UCF_ClientControlTree"]++;
        }
        ;
        if (arguments["length"] === 0) return;

        UCF_EventProvider["apply"](this);

        this["defineEvents"](['AfterRendering']);

        if (oJsonOrControl instanceof UCF_ClientElement) {
            this["oRoot"] = oJsonOrControl;
            this["oJson"] = oJsonOrControl["toJSON"]();
        } else {
            this["oJson"] = oJsonOrControl;
        }
        this["oLS"] = oLS;
        this["bActive"] = true;
        if (bInactive) {
            this["bActive"] = false;
        }
    };window["UCF_ClientControlTree"] = UCF_ClientControlTree;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClientControlTree");
        UCF_ClientControlTree["_"] = {UCF_ClientControlTree: 0};
    }
    ;
    ;
    UCF_ClientControlTree["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_ClientControlTree.prototype["sClassName"] = "UCF_ClientControlTree";

    UCF_ClientControlTree["iPreloadCount"] = 0;

    /**
     * Returns the root id of the control tree
     * @return {string} The root id of the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["getRootId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getRootId"]++;
        }
        ;
        return UCF_ClientControlTree["getRootId"](this["toJSON"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getRootId"] = 0;
    }
    ;

    /**
     * Returns the root json object of the control tree
     * @return {JSON} The root json object of the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["getRootObject"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getRootObject"]++;
        }
        ;
        var oJson = this["toJSON"]();
        for (var n in oJson) {
            return oJson[n];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getRootObject"] = 0;
    }
    ;

    /**
     * Returns the root control of the control tree
     * @param {boolean} bAvoidCreation
     * @return {UCF_ClientElement} The root control of the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["getRootControl"] = function (bAvoidCreation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getRootControl"]++;
        }
        ;
        if (!this["oRoot"] && !bAvoidCreation) {
            this["oRoot"] = UCF_ClientElement["createInstance"](this["getRootClassName"](), this["oLS"], this["getRootId"](), this["getRootObject"]());
        }
        if (this["oRoot"]) {
            this["oRoot"]["setControlTree"](this);
        }
        return this["oRoot"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getRootControl"] = 0;
    }
    ;

    /**
     * Returns the class name of the root control of the form sap.ls.CONTROLCLASS
     * @return {string} The class name
     * @private
     */
    UCF_ClientControlTree["prototype"]["getRootClassName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getRootClassName"]++;
        }
        ;
        var oJson = this["toJSON"]();
        for (var n in oJson) {
            return n;
        }
        return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getRootClassName"] = 0;
    }
    ;
    /**
     * Returns whether the controltree contains the given element or id
     * @param {string|UCF_ClientElement} oControlOrId the control instance or the control id
     * @return {boolean} true is the element contains the given element or id
     * @private
     */
    UCF_ClientControlTree["prototype"]["contains"] = function (oControlOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["contains"]++;
        }
        ;
        var oRoot = this["getRootControl"]();
        if (oRoot) {
            if ((typeof (oControlOrId) == "string" && oRoot["getId"]() == oControlOrId) || oRoot == oControlOrId) {
                return oRoot;
            }
            return oRoot["contains"](oControlOrId);
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["contains"] = 0;
    }
    ;

    /**
     * Triggers rendering of the controltree
     * @private
     */
    UCF_ClientControlTree["prototype"]["render"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["render"]++;
        }
        ;
        var oRoot = this["getRootControl"]();
        if (!oRoot) {
            return;
        }
        oRoot["render"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["render"] = 0;
    }
    ;

    /**
     * Returns the JSON representation of the control tree
     * @return {JSON} The JSON representation of the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["toJSON"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["toJSON"]++;
        }
        ;
        var oRoot = this["oRoot"];
        if (!oRoot) {
            if (this["oJson"]) {
                return this["oJson"];
            }
            return null;
        }
        return oRoot["toJSON"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["toJSON"] = 0;
    }
    ;

    /**
     * Returns the JSON string representation of the control tree
     * @return {string} The JSON string representation of the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["toString"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["toString"]++;
        }
        ;
        var oRoot = this["getRootControl"]();
        if (!oRoot) {
            if (this["oJson"]) {
                return UCF_JsUtil["sJsonStringify"](this["oJson"]);
            }
            return null;
        }
        return UCF_JsUtil["sJsonStringify"](oRoot["toString"]());
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["toString"] = 0;
    }
    ;

    /**
     * Sets the control-tree inactive.
     * While inactive, changes of the control-tree are not rendered.
     * @private
     */
    UCF_ClientControlTree["prototype"]["setInactive"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["setInactive"]++;
        }
        ;
        if (!this["bActive"]) return;
        this["bActive"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["setInactive"] = 0;
    }
    ;

    /**
     * Sets the control-tree active. Pending changes are rendered.
     * @private
     */
    UCF_ClientControlTree["prototype"]["setActive"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["setActive"]++;
        }
        ;
        if (this["bActive"]) return;
        this["bActive"] = true;
        if (this["hasPendingChanges"]()) {
            this["render"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["setActive"] = 0;
    }
    ;

    /**
     * Returns whether the control-tree is active.
     * @return {boolean} Whether the control tree is active or not.
     */
    UCF_ClientControlTree["prototype"]["isActive"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["isActive"]++;
        }
        ;
        return this["bActive"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["isActive"] = 0;
    }
    ;

    /**
     * Replaces the root control of the controltree with a given new control
     * @param {UCF_ClientControl} oControl The new root control.
     * @private
     */
    UCF_ClientControlTree["prototype"]["replaceRootControl"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["replaceRootControl"]++;
        }
        ;
        var oRoot = this["getRootControl"]();
        if (oRoot) {
            oRoot["destroy"](true);
        }
        oControl["setControlTree"](this);
        this["oRoot"] = oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["replaceRootControl"] = 0;
    }
    ;

    /**
     * Fires an after rendering even
     * @private
     */
    UCF_ClientControlTree["prototype"]["fireAfterRendering"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["fireAfterRendering"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["AfterRendering"], {"oControlTree": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["fireAfterRendering"] = 0;
    }
    ;

    /**
     * Returns whether there are pending changes that are not rendered for this controltree
     * @private
     * @return {boolean} pending changes that are not rendered for this controltree
     */
    UCF_ClientControlTree["prototype"]["hasPendingChanges"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["hasPendingChanges"]++;
        }
        ;
        var oRoot = this["getRootControl"]();
        if (oRoot && (oRoot["isChildInvalidated"]() || oRoot["isInvalidated"]())) {
            return true;
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["hasPendingChanges"] = 0;
    }
    ;

    /**
     * Destroys the control tree
     * @private
     */
    UCF_ClientControlTree["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["destroy"]++;
        }
        ;
        if (this["bIsDestroyed"]) {
            return;
        }
        this["bIsDestroyed"] = true; // TODO remove and rely on _super()
        var oRoot = this["getRootControl"]();
        if (oRoot && !oRoot["getParent"]()) {
            oRoot["destroy"](true);
        }

        this["oLS"]["oControlFactory"]["deleteClientControlTree"](this);

        this["oJson"] = null;
        this["setInactive"]();

        this["oRoot"] = null;
        this["oLS"] = null;
        this["oRoot"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["destroy"] = 0;
    }
    ;

    /** Static methods **/

    /**
     * Returns the root id of the control tree
     * @param {JSON} oJson The json object tree where the id should be extracted from
     * @return {string} The root id of the control tree
     * @static
     * @private
     */
    UCF_ClientControlTree["getRootId"] = function (oJson) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getRootId"]++;
        }
        ;
        for (var n in oJson) {
            return oJson[n]["Id"];
        }
        return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getRootId"] = 0;
    }
    ;

    /**
     * Extracts the controltree for a given id from the currently rendered dom
     * The dom can contain an element with the id+"-controltree" where the innerHTML is the controltree json string representation or
     * an element with id+"-lsx" where the inner html is a serialized lsx representation of the control tree
     *
     * @static
     * @private
     * @param {HTMLElement} oDomRef dom node for which the Control Tree is caculated
     * @return {string} the control tree
     */
    UCF_ClientControlTree["getControlTreeStringFromDom"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["getControlTreeStringFromDom"]++;
        }
        ;
        if (!oDomRef) return "";
        var sControlTree = "";
        if (oDomRef["id"]["indexOf"]("-lsx") > -1) {
            sControlTree = UCF_ClientControlTree["sXMLtoJSON"](oDomRef["innerHTML"], oDomRef["getAttribute"]("applyto"));
        } else if (oDomRef["id"]["indexOf"]("-controltree") > -1) {
            sControlTree = UCF_StringUtil["sTrim"](oDomRef["innerHTML"]);
        }
        return sControlTree;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["getControlTreeStringFromDom"] = 0;
    }
    ;

    /**
     * Parses the given control tree string and returns the JSON object tree for it
     * @param {string} sControlTree The string representation of the control tree
     * @return {JSON} The JSON object tree
     * @static
     * @private
     */
    UCF_ClientControlTree["parse"] = function (sControlTree) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["parse"]++;
        }
        ;
        var oControlTree = null;
        try {
            //ACFAdapter has event and property with the same name and event called Event this will break the
            //creation of the corresponding client side class and needed to be worked around.
            if (sControlTree["indexOf"]("\"Event\":{\"UcfParameters") > -1) {
                sControlTree = sControlTree["replace"](/\"Event\":{\"UcfParameters/gi, "\"___Event\":{\"UcfParameters");
            }
            if (sControlTree["indexOf"]("\"Timeout\":{\"UcfParameters") > -1) {
                sControlTree = sControlTree["replace"](/\"Timeout\":{\"UcfParameters/gi, "\"___Timeout\":{\"UcfParameters");
            }
            oControlTree = UCF_JsUtil["oJsonParse"](UCF_StringUtil["sTrim"](sControlTree));
        } catch (ex) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "No valid JSON for ControlTree creation: " + UCF_StringUtil["sTrim"](sControlTree), "ClientControlTree.js(310): parse");
            }
            ;
        }
        UCF_ClientControlTree["preloadClasses"](oControlTree);

        return oControlTree;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["parse"] = 0;
    }
    ;

    UCF_ClientControlTree["preloadClasses"] = function (oJSONControlTree) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["preloadClasses"]++;
        }
        ;
        //Collecting all necessary clientside controls for this controltree at once.
        var aImpl = [],
            mClasses = {},
            aClasses = [];
        var fTraverse = function (oNode) {
            for (var n in oNode) {
                if (oNode[n] !== null && typeof (oNode[n]) == "object") {
                    if (n["indexOf"]("sap.ls.controls") === 0 && !mClasses[n]) {
                        var sClassName = n["replace"]("sap.ls.controls.", "");
                        mClasses[n] = sClassName;
                    }
                    //going on step down in the object tree!!
                    fTraverse(oNode[n]);
                }
            }
        };
        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(START, "ExtendControls", "Extending controls");
        }
        ;

        fTraverse(oJSONControlTree);
        for (var n in mClasses) {
            var sClass = mClasses[n];
            if (!window["UCF_Client" + sClass]) {
                if (__UCF_DEBUG__) {
                    aImpl["push"]("/**\n *\tUCF_Client" + sClass + "\n *\tUCF_Client" + sClass + "Renderer \n*/");
                }
                if (UCF_ClassLoader["mClassStrings"]["CSR__" + sClass]) {
                    aImpl["push"](UCF_ClassLoader["mClassStrings"]["CSR__" + sClass]);
                    if (UCF_ClassLoader["mClassStrings"]["UCF_" + sClass + "Renderer"]) {
                        aImpl["push"](UCF_ClassLoader["mClassStrings"]["UCF_" + sClass + "Renderer"]);
                    }
                    if (UCF_ClassLoader["mClassStrings"]["UCF_Client" + sClass]) {
                        aImpl["push"](UCF_ClassLoader["mClassStrings"]["UCF_Client" + sClass]);
                    }
                } else {
                    UCF_ClientElement["extendClass"](sClass, aImpl);
                }
                aClasses["push"](sClass);
            }
        }
        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(STOP, "ExtendControls", "Extending " + aClasses["length"] + " controls");
        }
        ;
        if (aClasses["length"] > 0) {
            UCF_ClientControlTree["iPreloadCount"]++;
            aImpl["push"]("\r\n//# sourceURL=" + document["location"]["protocol"] + "//" + document["location"]["host"] + "/ControlTreeStack" + UCF_ClientControlTree["iPreloadCount"]);
            //apply as new script tag for better debugging
            if (__UCF_DEBUG__) {
                var sDebugString = "/**\n\tJoined ClientControl, Client Renderer for the listed controls by UCF_ClientControlTree.preloadClasses\n\n\t\t" + aClasses["join"]("\n\t\t") + "\n*/\n";
                UCF_ClassLoader["applyScriptTag"](sDebugString + aImpl["join"]("\n"));
            } else {
                UCF_ClassLoader["applyScriptTag"](aImpl["join"]("\n"));
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["preloadClasses"] = 0;
    }
    ;

    /**
     * Builds JSON Control tree string representation of an of the LSX Sample XML Control Tree
     * TODO: Currently eventing is disabled
     * @param {string} sXML the XMLstring of the controltree
     * @param {string} sRootId The root id of the dom node where this controltree should be applied to
     * @return {string}
     */
    UCF_ClientControlTree["sXMLtoJSON"] = function (sXML, sRootId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientControlTree["_"]["sXMLtoJSON"]++;
        }
        ;
        var oXmlDoc = UCF_JsUtil["oParseXMLDocument"](sXML);
        var mControlTree;
        var oXmlDomNode = null;
        var sControlName = "";

        if (!oXmlDoc || !oXmlDoc["documentElement"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "Invalid XML", "ClientControlTree.js(385): sXMLtoJSON");
            }
            ;
            return "";
        }

        oXmlDomNode = oXmlDoc["documentElement"];
        mControlTree = !mControlTree ? {} : mControlTree;
        sControlName = oXmlDomNode["tagName"];

        mControlTree["sClassName"] = sControlName["charAt"](0)["toUpperCase"]() + sControlName["substring"](1);
        var aJSONString = [],
            iIdIndex = 1;

        var fTraverseXML = function (oNode, bRoot) {
            var i = 0,
                sTagName = "",
                sMethod = "",
                sValue,
                oInterface = null,
                mProperties = null,
                mAssociations = null,
                bDefinedId = false,
                bWritten = false,
                mChildMethod = {},
                oAttribute = null,
                sName = "",
                oChildNode = null,
                aNodes = null;

            if (oNode && bRoot) {
                aJSONString["push"]("[");
            }
            sTagName = oNode["tagName"];
            sTagName = sTagName["substring"](0, 1)["toUpperCase"]() + sTagName["substring"](1);
            aJSONString["push"]("{\"sap.ls.controls." + sTagName + "\":{");
            oInterface = UCF_ClassLoader["oGetClass"]("UCF_ClientInterfaces")["I"][sTagName];
            mProperties = oInterface["properties"];
            mAssociations = oInterface["associations"];

            if (oInterface) {
                for (i = 0; i < oNode["attributes"]["length"]; i++) {
                    oAttribute = oNode["attributes"][i];
                    sName = oAttribute["name"];
                    sName = sName["substring"](0, 1)["toUpperCase"]() + sName["substring"](1);
                    if (mProperties && sName == "Id") {
                        bDefinedId = true;
                        if (bWritten) {
                            aJSONString["push"](",");
                        }
                        aJSONString["push"]("\"Id\":\"" + oAttribute["value"] + "\"");
                        bWritten = true;
                        continue;
                    }
                    if ((mProperties && sName in mProperties) || (mAssociations && sName in mAssociations)) {
                        if (bWritten) {
                            aJSONString["push"](",");
                        }
                        sValue = oAttribute["value"];
                        if (mAssociations && mAssociations[sName]) {
                            sValue = "\"" + sValue + "\"";
                        } else if (mProperties && mProperties[sName]) {
                            if (mProperties[sName]["type"] == "string" || mProperties[sName]["type"]["indexOf"]("UCF_") > -1) {
                                sValue = "\"" + UCF_RenderManager["sGetEscaped"](sValue, "jsattribute") + "\"";
                            } else if (mProperties[sName]["type"] == "boolean") {
                                sValue = sValue === "true" ? "true" : "false";
                            } else if (mProperties[sName]["type"] == "number") {
                                sValue = isNaN(parseFloat(sValue)) ? "" : sValue;
                            }
                        }
                        if (sValue !== "") {
                            aJSONString["push"]("\"" + sName + "\":" + sValue);
                            bWritten = true;
                        }
                    }

                }
                if (mProperties && !bDefinedId) {
                    if (bWritten) {
                        aJSONString["push"](",");
                    }
                    if (bRoot && sRootId) {
                        aJSONString["push"]("\"Id\":\"" + sRootId + "\"");

                    } else {
                        aJSONString["push"]("\"Id\":\"ls.id." + iIdIndex + "\"");
                        iIdIndex++;
                    }
                    bWritten = true;
                }
                mChildMethod = {};
                for (i = 0; i < oNode["childNodes"]["length"]; i++) {
                    oChildNode = oNode["childNodes"][i];
                    if (oChildNode["nodeType"] != 1) {
                        continue;
                    }
                    if (oChildNode["tagName"] == "method") {
                        //there is a method tag
                        sMethod = oChildNode["getAttribute"]("name")["substring"](3);
                        sMethod = sMethod["substring"](0, 1)["toUpperCase"]() + sMethod["substring"](1);
                        for (var j = 0; j < oChildNode["childNodes"]["length"]; j++) {
                            var oInnerNode = oChildNode["childNodes"][j];
                            if (oInnerNode["nodeType"] != 1) {
                                continue;
                            } else {
                                if (!mChildMethod[sMethod]) {
                                    mChildMethod[sMethod] = [];
                                }
                                mChildMethod[sMethod]["push"](oInnerNode);
                            }
                        }
                    } else if (oChildNode["getAttribute"]("method")) {
                        sMethod = oChildNode["getAttribute"]("method")["substring"](3);
                        if (!mChildMethod[sMethod]) {
                            mChildMethod[sMethod] = [];
                        }
                        mChildMethod[sMethod]["push"](oChildNode);
                    }
                }
                for (var n in mChildMethod) {
                    aNodes = mChildMethod[n];
                    if (bWritten) {
                        aJSONString["push"](",");
                    }
                    aJSONString["push"]("\"" + n + "\":");
                    if (oInterface["aggregations"][n]) {
                        if (oInterface["aggregations"][n]["multiple"]) {
                            aJSONString["push"]("[");
                            for (i = 0; i < aNodes["length"]; i++) {
                                if (i > 0) {
                                    aJSONString["push"](",");
                                }
                                aJSONString["push"](fTraverseXML(aNodes[i]));
                            }
                            aJSONString["push"]("]");
                        } else {
                            aJSONString["push"](fTraverseXML(aNodes[0]));
                        }
                    }
                }
            }
            aJSONString["push"]("}}");
            if (oNode && bRoot) {
                aJSONString["push"]("]");
            }
        };
        fTraverseXML(oXmlDomNode, true);
        return aJSONString["join"]("");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientControlTree["_"]["sXMLtoJSON"] = 0;
    }
    ;

    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_Interface */
/// <reference path="../../core/Interface.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global _assert, _trace, DEBUG, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_KeyCodes */
/// <reference path="../../core/enums/KeyCodes.js"/>
    /* global UCF_Rectangle */
/// <reference path="../../core/types/Rectangle.js"/>
    /* global UCF_AriaStateHelper */
/// <reference path="../../core/util/AriaStateHelper.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_FocusInfo */
/// <reference path="./FocusInfo.js"/>
    /* global UCF_LS */
/// <reference path="./LS.js"/>
    /* global UCF_SemanticEvent */
/// <reference path="./SemanticEvent.js"/>
    /* global UCF_System */
/// <reference path="./System.js"/>
    /* global UCF_BrowserEvent */
/// <reference path="../browser/BrowserEvent.js"/>
    /* global UCF_DataTip */
/// <reference path="../controls/DataTip.js"/>
    /* global UCF_DTExtension */
/// <reference path="../controls/designtime/DTExtension.js"/>
    /* global UCF_AccessibilityHelper */
/// <reference path="../helper/AccessibilityHelper.js"/>

    /**
     * @typedef {Object} UCF_Control_Dimension
     * @property {number} height in px
     * @property {number} width in px
     */
    /**
     * @typedef {Object} UCF_Control_TooltipNode
     * @property {string} attribute
     * @property {HTMLElement} domref
     * @property {string} text
     */
    /**
     * @typedef {Object} UCF_Control_HighlightInfo
     * @property {number|Array<number>} iStart
     * @property {number|Array<number>} iLength
     * @property {string} sAccDescription
     * @property {string} [sTextProperty]
     */
    /**
     * @typedef {Object} UCF_Control_TestData
     * @property {Object} properties
     * @property {Object} methods
     * @property {Object} client
     * @property {Object} dom
     * @property {Object} internals
     * @property {string} sClassName
     * @property {string} sControlId
     * @property {string} sBindingPath
     * @property {string} sBindingContextPath
     * @property {boolean} bClone
     */
    /**
     * @typedef {Object} UCF_Control_ConditionalStyleRule
     * @property {string} name
     * @property {string} match
     * @property {function(string):boolean} func
     * @property {Object<string,string>} variables
     * @param {Object<string,UCF_Control_ConditionalStyle>} mStyles
     */

    /**
     * @typedef {Object} UCF_Control_ConditionalStyle
     * @property {string} customStyle
     * @property {string} classPrefix
     * @property {string} type
     * @property {Object<string,string>} variables
     */

    /**
     * Base class for all controls. Represents a specific control on the screen.
     * All events occuring on this control will be handled here, any pre- or
     * postprocessing of the control as well as firing semantic UR Events is done
     * here.
     *
     * @class UCF_Control
     * @extends UCF_EventProvider
     *
     *
     * @param {HTMLElement} oDomRef the DOM reference of the control
     * @param {UCF_LS} oLS the LS instance
     * @param {string} sId the ID of the control
     */
    function UCF_Control(oDomRef, oLS, sId) {
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["UCF_Control"]++;
        }
        ;
        if (arguments["length"] > 0) {
            UCF_EventProvider["apply"](this);

            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "Control.js(107): UCF_Control");
            }
            ;

            /**
             * ATTENTION: Do not null this in #destroy(), otherwise DataGrids won't
             * display their cell editors ?!?
             *
             * @type {string} The id of the control
             */
            // eslint-disable-next-line ur/no-missing-setClientProperty, ur/no-memory-leaks
            this["sId"] = sId;

            /** @type {UCF_LS} The reference to the main LightSpeed object */
            this["oLS"] = oLS;

            /**
             * @private
             * @type {Array.<UCF_Object>} An array of delegate controls that do also
             * handle events for this control
             */
            this["aDelegates"] = null;

            /**
             * @private
             * @type {Array.<UCF_Object>} An array of defore delegate controls that
             * do also handle events for this control before the actual control
             */
            this["aBeforeDelegates"] = null;

            /**
             * The map of semantic events the framework has registered
             * @type {Object}
             */
            // Don't null mEvents in #destroy(). A control may be destroyed while
            // firing an event from the ClientControl. It then throws a
            // NullPointerException when accessing this.mEvents[sName].
            // eslint-disable-next-line ur/no-memory-leaks
            this["mEvents"] = {};

            /**
             * @type {boolean} Whether the control should be kept alive, even if the
             * HTML has been updated
             */
            this["bKeepAlive"] = false;

            /** @type {boolean} Whether the control should ignore the default button */
            this["bIgnoreDefaultButton"] = false;

            /** @type {string} Id of the active default button */
            this["sActiveDefaultButtonId"] = '';

            /**
             * @type {boolean} Whether the control should allow text selection within
             * this control
             */
            this["bAllowTextSelection"] = false;

            /**
             * If a pending request is defined, semantic events will be added to
             * the pending request instead of being fired
             * @type {UCF_PendingRequest}
             */
            this["oPendingRequest"] = null;

            /** @type {UCF_Control} The parent control, created lazy in oGetParent */
            this["oParentControl"] = null;

            /**
             * @type {HTMLElement} The DOM reference of the HTML Element that will get
             * the focus while forward navigation
             */
            this["oFocusDomRef"] = null;

            /**
             * @type {HTMLElement} The DOM reference of the HTML Element that will get
             * the focus while backward or forward navigation
             */
            this["oLastFocusDomRef"] = null;

            /** @type {HTMLElement} */
            this["oFirstFocusDomRef"] = null;

            if (oDomRef) {
                this["connectToDom"](oDomRef);
            }

            /** @type {UCF_ClientControl} */
            this["oClientControl"] = null;

            /**
             * @type {Array.<UCF_Control_TooltipNode>} The nodes that
             * need to be updated if a tooltip for a control is hidden
             */
            this["aTooltipNodes"] = [];

            /** @type {UCF_Control_HighlightInfo} */
            this["mHighlightInfo"] = null;

            this["oDTExtension"] = null;
            this["bInvisibility"] = false;
            this["bAncestorInvisible"] = false;

            // set the draggable property for the case that there is a DragSourceInfo
            // assigned which is configured to use BrowserDragDrop
            this["bDraggable"] = false;
            this["setDraggable"]();

            /** @type {Object<number,true>} */
            this["oAnimationFrames"] = {};
        }
    };window["UCF_Control"] = UCF_Control;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Control");
        UCF_Control["_"] = {UCF_Control: 0};
    }
    ;
    ;
    UCF_Control["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_Control.prototype["sClassName"] = "UCF_Control";

    /** @const {string} */
    UCF_Control["ARIA_HIGHLIGHTED_SUFFIX"] = '-aria-highlighted';

    /**
     * Returns an interface for the object. Controls use the interface as defined
     * in the control interface XML.
     *
     * @private
     * @param {Array.<string>} aMethodNames list of public methods
     * @return {UCF_Interface} The interface for the object.
     */
    UCF_Control["prototype"]["oGetInterface"] = function (aMethodNames) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetInterface"]++;
        }
        ;
        if (!aMethodNames) {
            aMethodNames = this["aMethodNames"] || [];
        }

        aMethodNames["push"]('sGetId');
        aMethodNames["push"]('getClientControl');
        aMethodNames["push"]('sGetCustomData');
        aMethodNames["push"]('getCustomData');
        aMethodNames["push"]('oGetParentControl');

        if ('sVisibility' in this) {
            aMethodNames["push"]('setVisibility');
        }

        return new (UCF_ClassLoader["oGetClass"]("UCF_Interface"))(this, aMethodNames);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetInterface"] = 0;
    }
    ;

    /**
     * @public
     * @return {string}
     */
    UCF_Control["prototype"]["sGetId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetId"]++;
        }
        ;
        return this["sId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetId"] = 0;
    }
    ;

    /**
     * Connects the control to its DOM representation.
     * Find DOM reference of the control, update attributes and events from the
     * DOM
     * @param {HTMLElement} oDomRef the DOM reference of the control
     * @private
     */
    UCF_Control["prototype"]["connectToDom"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["connectToDom"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "Control.js(264): connectToDom");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "Control.js(265): connectToDom");
        }
        ;

        /**
         * The id of the control
         * @type {string}
         */
        this["sId"] = oDomRef["getAttribute"]('id'); // eslint-disable-line ur/no-missing-setClientProperty

        /**
         * The DOM reference of the control in the HTML
         * @type {HTMLElement}
         */
        this["oDomRef"] = oDomRef;

        /**
         * The root DOM reference ('id-r') in the HTML
         * @type {HTMLElement}
         */
        this["oRootRef"] = UCF_DomUtil["$"](this["sId"] + '-r');
        if (!this["oRootRef"]) {
            this["oRootRef"] = oDomRef;
        }

        // Set the oFocusDomRef to enable focus method
        this["oFocusDomRef"] = this["oGetFocusDomRef"]();

        // Read attributes and events from the DOM
        this["updateAttributes"]();
        this["updateEvents"]();

        // create a datatip for the control, if it exists
        this["initializeDataTip"]();

        // create a RichTooltip for the control, if it exists
        this["initializeRichTooltip"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["connectToDom"] = 0;
    }
    ;

    /**
     * Destructor
     */
    UCF_Control["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["destroy"]++;
        }
        ;
        /** @type {UCF_Object} */
        var oDelegate;
        /** @type {number} */
        var i;

        if (!this["bIsDestroyed"]) {
            UCF_JsUtil["forEach"](UCF_JsUtil["keys"](this["oAnimationFrames"]), function (iAnimationFrameId) {
                UCF_JsUtil["cancelAnimationFrame"](iAnimationFrameId);
            });
            this["oAnimationFrames"] = null;

            if (UCF_Control["oLayoutRectControl"] === this) {
                this["hideLayoutRect"]();
            }

            // ARIA - remove highlight information from sapur-aria-dynamic-texts
            UCF_DomUtil["removeFromDom"](
                // if this element is not available, removeFromDom() will do nothing
                UCF_DomUtil["$"](this["sId"] + UCF_Control["ARIA_HIGHLIGHTED_SUFFIX"])
            );

            this["bIsDestroyed"] = true; // TODO remove and rely on _super()

            // Detach all controls to the visibility change event
            if (this["oDTExtension"]) {
                this["oDTExtension"]["destroy"]();
            }

            if (this["oLS"]) {
                this["oLS"]["fireControlDestroy"]({"sId": this["sId"]});
            }
            this["removeDataTip"]();
            this["removeRichTooltip"]();
            this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["ControlCreate"], this, 'onControlCreate');
            this["oDomRef"] = null;
            this["oRootRef"] = null;
            this["oFocusDomRef"] = null;
            this["oParentControl"] = null;
            this["oDragHandleDomRef"] = null;
            if (this["aDelegates"]) {
                for (i = 0; i < this["aDelegates"]["length"]; i++) {
                    oDelegate = this["aDelegates"][i];
                    if (!UCF_JsUtil["bInstanceOf"](oDelegate, 'UCF_Control')) {
                        // others are purged by control factory
                        oDelegate["destroy"]();
                    }
                }
            }
            if (this["aBeforeDelegates"]) {
                for (i = 0; i < this["aBeforeDelegates"]["length"]; i++) {
                    oDelegate = this["aBeforeDelegates"][i];
                    if (!UCF_JsUtil["bInstanceOf"](oDelegate, 'UCF_Control')) {
                        // others are purged by control factory
                        oDelegate["destroy"]();
                    }
                }
            }
            this["aDelegates"] = null;
            this["aBeforeDelegates"] = null;
            this["hideBoundaries"]();

            this["_forwardBlur"] = null;

            this["sVisibility"] = null;
            this["sSavedStyleAttribute"] = null;
            this["bDTHidden"] = null;
            this["sName"] = null;
            this["oDTExtension"] = null;
            this["mHighlightInfo"] = null;
            this["sActiveDefaultButtonId"] = null;

            this["oLS"] = null;

            UCF_EventProvider.prototype["destroy"]["apply"](this, arguments); // call event provider destroy
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["destroy"] = 0;
    }
    ;

    /**
     * Reconnects the control to its DOM representation, used for keepalive
     * controls
     */
    UCF_Control["prototype"]["reconnectToDom"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["reconnectToDom"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"]);

        this["bIsDestroyed"] = false;
        this["oParentControl"] = null;
        this["setDefaultValues"]();
        this["connectToDom"](oDomRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["reconnectToDom"] = 0;
    }
    ;

    /** @return {boolean} whether the control should be kept alive */
    UCF_Control["prototype"]["bDoKeepAlive"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bDoKeepAlive"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oNewDomRef = UCF_DomUtil["$"](this["sId"]);

        return this["bKeepAlive"] && oNewDomRef;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bDoKeepAlive"] = 0;
    }
    ;

    /**
     * Updates the attributes of the control with the given String representation
     * of a JS object taken from the HTML attribute 'lsdata'.
     *
     * @private
     */
    UCF_Control["prototype"]["updateAttributes"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["updateAttributes"]++;
        }
        ;
        UCF_JsUtil["extend"](this, UCF_Control["oGetPackedAttribute"](
            this["oDomRef"],
            'lsdata',
            this["aAttributeNames"]
        ));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["updateAttributes"] = 0;
    }
    ;

    /**
     * Adds an client side event listener to the control
     * @param {string} sEventName The name of the event
     * @param {Object} oObject The object of the sListener fnction
     * @param {string} sListener The name of the method that listens
     *
     * @public
     */
    UCF_Control["prototype"]["addClientListener"] = function (sEventName, oObject, sListener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["addClientListener"]++;
        }
        ;
        this["mEvents"][sEventName] = {
            "ClientListener": {
                "oObject": oObject,
                "sListener": sListener
            }
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["addClientListener"] = 0;
    }
    ;

    /**
     * Removes a client side event listener to the control
     * @param {string} sEventName The name of the event
     *
     * @public
     */
    UCF_Control["prototype"]["removeClientListener"] = function (sEventName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeClientListener"]++;
        }
        ;
        delete this["mEvents"][sEventName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeClientListener"] = 0;
    }
    ;

    /**
     * Binds a single semantic event to the control
     * The event object representation corresponds to the JSON representation of an single event in HTML attribute 'lsevents'.
     * @param {string} sEventName The name of the event
     * @param {Object} oEvent The event to be bound - to unbind pass undefined
     *
     * @public
     */
    UCF_Control["prototype"]["updateEvent"] = function (sEventName, oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["updateEvent"]++;
        }
        ;
        this["mEvents"][sEventName] = oEvent;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["updateEvent"] = 0;
    }
    ;

    /**
     * Updates the semantic events of the control with the given String
     * representation of a JS object taken from the HTML attribute 'lsevents'.
     *
     * @private
     */
    UCF_Control["prototype"]["updateEvents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["updateEvents"]++;
        }
        ;
        this["mEvents"] = UCF_Control["oGetPackedAttribute"](
            this["oDomRef"],
            'lsevents',
            this["aEventNames"]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["updateEvents"] = 0;
    }
    ;

    /**
     * @protected
     * @static
     * @param {Element} oDomRef the element that has the packed attribute
     * @param {string} sAttribute the attribute name to unpack
     * @param {string[]} aNames list of names for the keys in the JSON-object of
     * the attribute
     * @return {Object<string,Object>}
     */
    UCF_Control["oGetPackedAttribute"] = function (oDomRef, sAttribute, aNames) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetPackedAttribute"]++;
        }
        ;
        /** @type {Object<string,Object>} */
        var mProperties;
        /** @type {string} */
        var sProperty;
        /** @type {number} */
        var iLength = aNames ? aNames["length"] : -1;
        /** @type {number} */
        var iPropertyIndex;
        /** @type {string} */
        var sAttributeValue;

        if (oDomRef) {
            sAttributeValue = UCF_DomUtil["sGetAttribute"](oDomRef, sAttribute) || '';

            mProperties = UCF_JsUtil["oJsonParse"](
                __UCF_IE6__
                    ? sAttributeValue["replace"](/&lsqb;/g, '[')["replace"](/&rsqb;/g, ']')
                    : sAttributeValue
            ) || {};

            if (mProperties) {
                for (sProperty in mProperties) {
                    iPropertyIndex = parseInt(sProperty);

                    if (
                        !isNaN(iPropertyIndex) &&
                        0 <= iPropertyIndex &&
                        iPropertyIndex < iLength
                    ) {
                        mProperties[aNames[iPropertyIndex]] = mProperties[sProperty];
                        delete mProperties[sProperty];
                    }
                }
            }
        }

        return mProperties;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetPackedAttribute"] = 0;
    }
    ;

    /**
     * Adds a delegate control that is notified for all events occuring on this
     * control
     *
     * @param {UCF_Object} oDelegate the object that should also handle events
     * for this control (implements handlers for DOM events, e.g. 'onmouseover')
     * @param {boolean} bBefore optional whether the delegate gets should handle
     * the events before the actual control or nor
     */
    UCF_Control["prototype"]["addDelegate"] = function (oDelegate, bBefore) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["addDelegate"]++;
        }
        ;
        if (oDelegate instanceof UCF_Object) {
            if (bBefore) {
                if (this["aBeforeDelegates"] == null) {
                    this["aBeforeDelegates"] = [];
                }
                this["aBeforeDelegates"]["push"](oDelegate);
            } else {
                if (this["aDelegates"] == null) {
                    this["aDelegates"] = [];
                }
                this["aDelegates"]["push"](oDelegate);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["addDelegate"] = 0;
    }
    ;

    /**
     * Removes a delegate control that is notified for all events occuring on this
     * control
     *
     * @param {UCF_Object} oDelegate the object that should also handle events
     * for this control
     */
    UCF_Control["prototype"]["removeDelegate"] = function (oDelegate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeDelegate"]++;
        }
        ;
        /** @type {number} */
        var i;

        if (oDelegate instanceof UCF_Object) {
            if (this["aDelegates"]) {
                for (i = 0; i < this["aDelegates"]["length"]; i++) {
                    if (this["aDelegates"][i] === oDelegate) {
                        this["aDelegates"]["splice"](i, 1);

                        return;
                    }
                }
            }
            if (this["aBeforeDelegates"]) {
                for (i = 0; i < this["aBeforeDelegates"]["length"]; i++) {
                    if (this["aBeforeDelegates"][i] === oDelegate) {
                        this["aBeforeDelegates"]["splice"](i, 1);

                        return;
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeDelegate"] = 0;
    }
    ;

    /**
     * Returns all delegates that have been defined for this control or null.
     *
     * @param {boolean} bBefore optional whether the before delegate should be
     * returned
     * @return {Array.<UCF_Object>|null} list of delegates for this control or null.
     */
    UCF_Control["prototype"]["aGetDelegates"] = function (bBefore) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["aGetDelegates"]++;
        }
        ;
        return bBefore ? this["aBeforeDelegates"] : this["aDelegates"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["aGetDelegates"] = 0;
    }
    ;

    /**
     * Checks whether a RichTooltip exists for the given control. If this is
     * the case, the RichTooltip control is created and added as a delegate
     */
    UCF_Control["prototype"]["initializeRichTooltip"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["initializeRichTooltip"]++;
        }
        ;
        /** @type {UCF_RichTooltip} */
        var oRichTooltip = this["oGetRichTooltipById"](this["sId"]);

        if (oRichTooltip) {
            this["connectRichTooltip"](oRichTooltip);

            // 2020-04-03: after cleaning up memory leaks, a RichTooltip that is
            // destroyed by e.g. UCF_ControlFactory#purgeControls may remain as the
            // delegate of a control. We have to remove it during LS:ControlDestroy
            // and re-add it if it is created anywhere else (e.g. by
            // UCF_ClientControl#getUCFInstance()). Therefore listening to
            // LS:ControlCreate and LS:ControlDestroy.
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["ControlCreate"], this, 'onControlCreate');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["initializeRichTooltip"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_RichTooltip} oRichTooltip
     */
    UCF_Control["prototype"]["connectRichTooltip"] = function (oRichTooltip) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["connectRichTooltip"]++;
        }
        ;
        this["oRichTooltip"] = oRichTooltip || this["oGetRichTooltipById"](this["sId"]);
        if (this["oRichTooltip"]) {
            this["oRichTooltip"]["setOpenerId"](this["sId"]);
            this["oRichTooltip"]["setOpenerRef"](this["oDomRef"]);
            this["addDelegate"](this["oRichTooltip"]);
            if (!this["oRichTooltip"]["bKeepTooltip"]()) {
                this["oDomRef"]["title"] = '';
            }
            this["oRichTooltip"]["handleRichTooltipInit"](this["oDomRef"]);
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["ControlDestroy"], this, 'onControlDestroy');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["connectRichTooltip"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event<{sId: string}>} oEvent
     */
    UCF_Control["prototype"]["onControlDestroy"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onControlDestroy"]++;
        }
        ;
        if (this["oRichTooltip"] && oEvent["oGetParam"]('sId') === this["oRichTooltip"]["sId"]) {
            this["removeDelegate"](this["oRichTooltip"]);
            this["oRichTooltip"] = null;
            this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["ControlDestroy"], this, 'onControlDestroy');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onControlDestroy"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event<{Id: string}>} oEvent
     */
    UCF_Control["prototype"]["onControlCreate"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onControlCreate"]++;
        }
        ;
        if (oEvent["oGetParam"]('Id') === this["sId"] + '-tt') {
            this["connectRichTooltip"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onControlCreate"] = 0;
    }
    ;

    /**
     * Checks whether a RichTooltip exists for the given control or a prent control
     * of it. If this is the case, the RichTooltip control is created.
     * @param {string} sId the id of the RichTooltip
     * @return {UCF_Richtooltip}
     */
    UCF_Control["prototype"]["oGetRichTooltipById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetRichTooltipById"]++;
        }
        ;
        /** @type {UCF_ClientControl} */
        var oClientControl = this["getClientControl"]();

        if (oClientControl) {
            sId = oClientControl["getTemplateId"]() || sId;
        }

        return this["oLS"]["oControlFactory"]["mControls"][sId + '-tt'] ||
            this["oLS"]["oControlFactory"]["oGetControlById"](sId + '-tt') ||
            null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetRichTooltipById"] = 0;
    }
    ;

    /**
     * Removes the RichTooltip of this control from the DOM, if it exists
     */
    UCF_Control["prototype"]["removeRichTooltip"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeRichTooltip"]++;
        }
        ;
        if (this["oRichTooltip"]) {
            this["oRichTooltip"]["remove"]();
            this["oRichTooltip"] = null;
        }
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["ControlDestroy"], this, 'onControlDestroy');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeRichTooltip"] = 0;
    }
    ;

    /** @param {HTMLElement} oOpenerDomRef the opener */
    UCF_Control["prototype"]["handleRichTooltipInit"] = function (oOpenerDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["handleRichTooltipInit"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["handleRichTooltipInit"] = 0;
    }
    ;

    /**
     * Checks whether a datatip exists for the given control. If this is the case,
     * the datatip control is created and added as a delegate
     */
    UCF_Control["prototype"]["initializeDataTip"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["initializeDataTip"]++;
        }
        ;
        this["oDataTip"] = this["oGetDataTipById"](this["sId"]);
        if (this["oDataTip"]) {
            this["oDataTip"]["setOpenerRef"](this["oDomRef"]);
            this["addDelegate"](this["oDataTip"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["initializeDataTip"] = 0;
    }
    ;

    /**
     * Creates and return a new datatip for the control and initializes it. If no
     * parameters are given an existing datatip is used otherwise the framework
     * will create a datatip and connect it to the control.
     *
     * @param {string} [sType] The type of the datatip that should be created
     * @param {string} [sText] The text of the datatip that should be created
     * @return {UCF_DataTip} The newly created datatip
     */
    UCF_Control["prototype"]["createDataTip"] = function (sType, sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["createDataTip"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDataTipDomRef;

        if (!sType && !this["oDataTip"]) {
            oDataTipDomRef = UCF_DomUtil["$"](this["sId"] + '-dtip');
            if (!oDataTipDomRef) {
                UCF_ClassLoader["oGetClass"]('UCF_DataTip');
                UCF_DataTip["render"](this["sId"], this["oLS"]);
            }
            this["initializeDataTip"](this["sId"]);

            return this["oDataTip"];
        } else if (sType) {
            if (this["oDataTip"]) {
                // There is already a datatip for this control, what should be done now
                this["oDataTip"]["setType"](sType);
                this["oDataTip"]["setText"](sText);
                if (this["bHasFocus"]()) {
                    this["oDataTip"]["open"]();
                }

                return this["oDataTip"];
            } else {
                this["oLS"]["oCreateClientControl"](
                    'DataTip',
                    this["sId"] + '-dtip', {
                        "Type": sType,
                        "Text": sText,
                        "ConnectedControlId": this["sId"]
                    }
                )["placeAt"](this["oLS"]["oGetAssociatedAreaRef"]());

                return this["createDataTip"]();
            }
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["createDataTip"] = 0;
    }
    ;

    /**
     * Removes the DataTip of this control from the DOM, if it exists
     */
    UCF_Control["prototype"]["removeDataTip"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeDataTip"]++;
        }
        ;
        if (this["oDataTip"]) {
            this["removeDelegate"](this["oDataTip"]);
            this["oDataTip"]["remove"]();
            this["oDataTip"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeDataTip"] = 0;
    }
    ;

    /**
     * Checks whether a datatip exists for the given control. If this is the case,
     * the datatip control is created. This function is also used by other control.
     *
     * @param {string} sId the id of the DataTip
     * @return {UCF_DataTip}
     */
    UCF_Control["prototype"]["oGetDataTipById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetDataTipById"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDataTipRef;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Control.js(769): oGetDataTipById");
        }
        ;

        oDataTipRef = UCF_DomUtil["$"](sId + '-dtip');

        return (oDataTipRef == null)
            ? null
            : this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oDataTipRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetDataTipById"] = 0;
    }
    ;

    /**
     * Attaches a browser event for this control in the central event handling
     *
     * @param {string} sName the name of the event to attach
     * @param {HTMLElement} oDomRef the dom reference where to attach the event
     */
    UCF_Control["prototype"]["attachBrowserEvent"] = function (sName, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["attachBrowserEvent"]++;
        }
        ;
        this["oLS"]["oBrowserWindow"]["attachBrowserEvent"](sName, oDomRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["attachBrowserEvent"] = 0;
    }
    ;

    /**
     * Detaches a browser event from the central event handling
     *
     * @param {string} sName the name of the event to detach
     * @param {HTMLElement} oDomRef the dom reference where to detach the event
     */
    UCF_Control["prototype"]["detachBrowserEvent"] = function (sName, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["detachBrowserEvent"]++;
        }
        ;
        this["oLS"]["oBrowserWindow"]["detachBrowserEvent"](sName, oDomRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["detachBrowserEvent"] = 0;
    }
    ;

    /**
     * Attaches a internal LS event for this control
     *
     * @param {number} iEvent the event to listen for
     * @param {string} sFunction the function to call if the event occurs
     */
    UCF_Control["prototype"]["attachLSEvent"] = function (iEvent, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["attachLSEvent"]++;
        }
        ;
        this["oLS"]["attachEvent"](iEvent, this, sFunction);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["attachLSEvent"] = 0;
    }
    ;

    /**
     * Detaches a internal LS event for this control
     *
     * @param {integer} iEvent the event to listen for
     */
    UCF_Control["prototype"]["detachLSEvent"] = function (iEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["detachLSEvent"]++;
        }
        ;
        this["oLS"]["detachEvent"](iEvent, this);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["detachLSEvent"] = 0;
    }
    ;

    /**
     * Attaches an additional event handler for an existing semantic event with sName
     * This is needed if controls like to reuse other controls within their code and like to register to the
     * semantic events. As the server does not know about these controls the control can handle the events internally
     *
     * @param {string} sName The name of the semantic event
     * @param {Object} oObject The object where to fire the handler function
     * @param {string} sHandler The name of callback function that is triggered before the actual event is processed.
     */
    UCF_Control["prototype"]["attachSemanticEvent"] = function (sName, oObject, sHandler) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["attachSemanticEvent"]++;
        }
        ;
        this["attachEvent"]('SemanticEvent.' + sName, oObject, sHandler);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["attachSemanticEvent"] = 0;
    }
    ;

    /**
     * Detaches the additional event handler for an existing semantic event with sName
     *
     * @param {string} sName The name of the semantic event
     * @param {Object} oObject The object where to fire the handler function
     * @param {string} sHandler The name of callback function that is triggered before the actual event is processed.
     */
    UCF_Control["prototype"]["detachSemanticEvent"] = function (sName, oObject, sHandler) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["detachSemanticEvent"]++;
        }
        ;
        this["detachEvent"]('SemanticEvent.' + sName, oObject, sHandler);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["detachSemanticEvent"] = 0;
    }
    ;

    /**
     * Fires a semantic event for the framework. Only events that have been subscribed by
     * the framework (and so are listed in the mEvents map) are fired. Do not call this
     * method directly, but use the generated, typed fireXYZ method instead!
     * If a pending request is defined, instead of firing the event it is added to the
     * pending request.
     *
     * @param {string} sControl the control classname (e.g. "Button")
     * @param {string} sName the name of the semantic event that is fired
     * @param {Object} mParameters the map of parameters for this event as defined
     * in the control interface
     * @param {boolean} bDelay generated from delay="true|false" in the interface
     * @param {boolean} bMarkDirty generated from markDirty="true|false" in the
     * interface
     * @param {boolean} bSyncExecution generated from syncExecution="true|false"
     * in the interface
     */
    UCF_Control["prototype"]["fireSemanticEvent"] = function (sControl, sName, mParameters, bDelay, bMarkDirty, bSyncExecution) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["fireSemanticEvent"]++;
        }
        ;
        /** @type {UCF_SemanticEvent} */
        var oSemanticEvent;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControl === 'string', "typeof sControl === 'string'", "Control.js(864): fireSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControl !== '', "sControl !== ''", "Control.js(865): fireSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "Control.js(866): fireSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName !== '', "sName !== ''", "Control.js(867): fireSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(mParameters instanceof Object, "mParameters instanceof Object", "Control.js(868): fireSemanticEvent");
        }
        ;

        if (this["bAncestorInvisible"] || this["bInvisibility"] || this["bIsDestroyed"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, this["sClassName"] + ' "' + this["sId"] + '" is invisible or already destroyed. Semantic event "' + sName + '" is not fired', "Control.js(871): fireSemanticEvent");
            }
            ;

            return;
        }

        // fire the semantic event handler internally. This is needed if controls
        // like to reuse other controls within their code and like to register to the
        // semantic events
        if (this["hasListeners"]('SemanticEvent.' + sName)) {
            mParameters["SemanticEventConfig"] = {
                "Control": sControl,
                "Name": sName,
                "Delay": bDelay,
                "MarkDirty": bMarkDirty,
                "SyncExecution": bSyncExecution,
                "UcfConfiguration": this["mEvents"][sName]
            };
            mParameters["CancelEvent"] = false;
            this["fireEvent"]('SemanticEvent.' + sName, mParameters);
            if (mParameters["CancelEvent"] === true) { //return if canceled
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, this["sClassName"] + ' "' + this["sId"] + '" fired "' + sName + '" internally and was flagged as cancel, therefore no event is not propagated for further handling', "Control.js(891): fireSemanticEvent");
                }
                ;

                return;
            }
            bDelay = mParameters["SemanticEventConfig"]["Delay"];
            bMarkDirty = mParameters["SemanticEventConfig"]["MarkDirty"];
            bSyncExecution = mParameters["SemanticEventConfig"]["SyncExecution"];
            delete mParameters["CancelEvent"];
        }
        if (this["getClientControl"]() && !this["bIsDestroyed"]) {
            oSemanticEvent = new (UCF_ClassLoader["oGetClass"]("UCF_SemanticEvent"))(
                sControl,
                sName,
                mParameters,
                this["mEvents"][sName] || {}
            );
            oSemanticEvent["setSourceLS"](this["oLS"]);
            if (!mParameters) {
                mParameters = {};
            }
            mParameters["oSemanticEvent"] = oSemanticEvent;
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, this["sClassName"] + ' "' + this["sId"] + '" fired "' + sName + '" to client side handler', "Control.js(912): fireSemanticEvent");
            }
            ;
            this["getClientControl"]()['fire' + sName](mParameters);
            delete mParameters["oSemanticEvent"];
        }
        if (this["mEvents"][sName]) {
            oSemanticEvent = new (UCF_ClassLoader["oGetClass"]("UCF_SemanticEvent"))(
                sControl,
                sName,
                mParameters,
                this["mEvents"][sName]
            );
            oSemanticEvent["setSourceLS"](this["oLS"]);
            // set special flags but only when differing from their default values
            if (bDelay) {
                oSemanticEvent["setDelay"](bDelay);
            }
            if (bSyncExecution) {
                oSemanticEvent["setSyncExecution"](bSyncExecution);
            }
            if (bMarkDirty) {
                this["oLS"]["markDirty"](true);
            }

            if (oSemanticEvent["bIsCompositeEvent"]()) {
                // Notify all parent controls about the event which is about to be
                // populated
                for (oControl = this["oGetParent"](); oControl; oControl = oControl["oGetParent"]()) {
                    if (oControl["handleCompositeEvent"]) {
                        oControl["handleCompositeEvent"](this, oSemanticEvent);

                        return;
                    }
                }
            }

            oSemanticEvent["setForm"](this["oGetQueueForm"]());
            //add parameters for data binding
            this["enrichSemanticEventParamsWithBindingContext"](mParameters, 'Id');

            if (this["oPendingRequest"]) {
                this["oPendingRequest"]["addSemanticEvent"](oSemanticEvent);
            } else {
                this["oLS"]["processSemanticEvent"](oSemanticEvent);
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, this["sClassName"] + ' "' + this["sId"] + '" fired "' + sName + '" but event is not registered by the framework', "Control.js(957): fireSemanticEvent");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["fireSemanticEvent"] = 0;
    }
    ;

    /**
     * Adds parameters to identify the control by the template id and the binding
     * path.
     *
     * @param {Object} mParams Parameter Map of the semantic event that is about
     * to be fired.
     * @param {string} sName the name of the binding
     * @param {UCF_ClientControl} oClientControl the client control to enrich
     */
    UCF_Control["prototype"]["enrichSemanticEventParamsWithBindingContext"] = function (mParams, sName, oClientControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["enrichSemanticEventParamsWithBindingContext"]++;
        }
        ;
        /** @type {UCF_BindingContext} */
        var oBindingContext;
        /** @type {string} */
        var sContextData;
        /** @type {UCF_Control} */
        var oParent;

        if (!oClientControl) {
            oClientControl = this["getClientControl"]();
        }
        if (oClientControl) {
            // add new event parameters for the control
            // TemplateId for the that is used to create a clone.
            // BindingContextPath path to the currently bound object in the model that
            // was used to create the clone.
            oBindingContext = oClientControl["getBindingContext"]();
            oParent = this["oGetParent"]();

            if (oBindingContext && oClientControl["getTemplateId"]()) {
                sContextData = oBindingContext["getModel"]()["getId"]() + '>' + oBindingContext["getPath"]();

                if (oClientControl["getTemplateId"]()) {
                    mParams[sName + '.TemplateId'] = oClientControl["getTemplateId"]();
                }
                mParams[sName + '.BindingContextPath'] = sContextData;
            } else if (oParent) {
                oParent["enrichSemanticEventParamsWithBindingContext"](mParams, sName);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["enrichSemanticEventParamsWithBindingContext"] = 0;
    }
    ;

    /**
     * Returns a control with the given id, if this control exists on the current
     * page
     *
     * @param {string} sId the ID of the control
     * @return {UCF_Control} control with the given ID
     */
    UCF_Control["prototype"]["oGetControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetControlById"]++;
        }
        ;
        return this["oLS"]["oControlFactory"]["oGetControlById"](sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetControlById"] = 0;
    }
    ;

    /**
     * Returns the control instance of the control identified by its DOM reference.
     *
     * @param {HTMLElement} oDomRef A DOM reference to the root HTML tag of the
     * control
     * @param {boolean} bCreate `true` to create the control if it does not exist
     * @return {UCF_Control} the control instance
     */
    UCF_Control["prototype"]["oGetControlByDomRef"] = function (oDomRef, bCreate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetControlByDomRef"]++;
        }
        ;
        return this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oDomRef, bCreate);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetControlByDomRef"] = 0;
    }
    ;

    /**
     * Returns the id of the clicked control.
     * Should be overridden by controls that have subcontrols which do not
     * have own JS control objects
     *
     * @param {HTMLElement} oDomRef the dom reference
     * @return {string} the control id
     */
    UCF_Control["prototype"]["sGetId"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetId"]++;
        }
        ;
        return this["sId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetId"] = 0;
    }
    ;

    /**
     * Returns the parent control of the control
     * Keepalive controls must not cache their parent
     * @param {boolean} [bSubControls=false] Also consider sub-controls as parents, e.g. SapTableCell
     * @return {UCF_Control} the parent control
     */
    UCF_Control["prototype"]["oGetParent"] = function (bSubControls) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetParent"]++;
        }
        ;
        if (this["oRootRef"]) {
            if (!this["oParentControl"] || this["bKeepAlive"]) {
                this["oParentControl"] = this["oFindParent"](this["oRootRef"], bSubControls);
            }

            return this["oParentControl"];
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetParent"] = 0;
    }
    ;

    /**
     * Returns the attribute value for the given QTP property name
     *
     * @param {string} sName the name of the QTP property
     * @return {Object} the value
     */
    UCF_Control["prototype"]["oGetQTPProperty"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetQTPProperty"]++;
        }
        ;
        /** @type {Object} */
        var oValue;
        /** @type {UCF_Control} */
        var self = this;

        if (!this["mQTPProperties"]) {
            this["mQTPProperties"] = {};
            UCF_JsUtil["forEach"](this["aAttributeNames"], function (sAttributeName) {
                self["mQTPProperties"][sAttributeName["substr"](1)["toLowerCase"]()] = sAttributeName;
            });
        }

        oValue = this[this["mQTPProperties"][sName]];

        return typeof oValue === 'object' || typeof oValue === 'function'
            ? null
            : oValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetQTPProperty"] = 0;
    }
    ;

    /**
     * Returns the DOM element that should be focussed if the controls focus method
     * is called. Please do overide if the DOM element is other than the oRootRef
     * or the oDomRef.
     *
     * @return {HTMLElement} the DOM element that should be focussed if the
     * controls focus method is called.
     */
    UCF_Control["prototype"]["oGetFocusDomRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFocusDomRef"]++;
        }
        ;
        return this["oDomRef"]["getAttribute"]('ti') === '0'
            ? this["oDomRef"]
            : (this["oRootRef"]["getAttribute"]('ti') === '0' ? this["oRootRef"] : null);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFocusDomRef"] = 0;
    }
    ;

    /**
     * Returns the DOM element that should be focussed if the controls focus method
     * is called and the control was navigated using focusPreviousControl. Then the
     * focus method of the control is called with the parameter bFormBackNavigation
     * Please do overide if the DOM element is other than the oRootRef or the
     * oDomRef.
     *
     * @return {HTMLElement} the DOM element that should be focussed if the
     * controls focus method is called.
     */
    UCF_Control["prototype"]["oGetLastFocusDomRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastFocusDomRef"]++;
        }
        ;
        return this["oLastFocusDomRef"] || this["oGetFocusDomRef"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastFocusDomRef"] = 0;
    }
    ;

    /**
     * Returns the DOM element that should be focussed if the controls focus method
     * is called and the control was navigated using focusNextControl. Then the
     * focus method of the control is called with the parameter bFormBackNavigation
     * Please do overide if the DOM element is other than the oRootRef or the
     * oDomRef.
     *
     * @return {HTMLElement} the DOM element that should be focussed if the
     * controls focus method is called.
     */
    UCF_Control["prototype"]["oGetFirstFocusDomRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstFocusDomRef"]++;
        }
        ;
        return this["oFirstFocusDomRef"] || this["oGetFocusDomRef"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstFocusDomRef"] = 0;
    }
    ;

    /**
     * Finds a parent control by going up the parent elements starting from the
     * given DOM element
     *
     * @param {HTMLElement} oDomRef the element to start the search from
     * @param {boolean} [bFindSubControls=false] Search also for sub-controls
     * @return {UCF_Control} the parent control
     */
    UCF_Control["prototype"]["oFindParent"] = function (oDomRef, bFindSubControls) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oFindParent"]++;
        }
        ;
        /** @type {Node} */
        var oParentRef = oDomRef["parentNode"];
        /** @type {UCF_Control} */
        var oParentControl;

        while (
            oParentRef &&
            oParentRef["getAttribute"] &&
            oParentRef !== document["body"]
            ) {
            if (oParentRef["getAttribute"]('ct') || oParentRef["getAttribute"]('subct') && bFindSubControls === true) {
                oParentControl = this["oGetControlByDomRef"](oParentRef, true);
                if (oParentControl != null) {
                    // oGetControlByDomRef returns null if no Id was set on the control
                    return oParentControl;
                }
            }
            oParentRef = oParentRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oFindParent"] = 0;
    }
    ;

    /**
     * Returns whether the control is a child control of another control
     *
     * @param {UCF_Control} oParent the possible parent control
     * @return {boolean} `true` if the control is a child of the parent
     */
    UCF_Control["prototype"]["bIsChildOf"] = function (oParent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsChildOf"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl = this["oGetParent"]();

        while (oControl) {
            if (oControl === oParent) {
                return true;
            }

            oControl = oControl["oGetParent"]();
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsChildOf"] = 0;
    }
    ;

    /**
     * Get rectangle for the given DOM element
     *
     * @param {HTMLElement} [oDomRef=this.oRootRef] the element to get the rect for
     * @return {_ObjectRect} a rectangle of the given DOM object or of the root
     * element of this control
     */
    UCF_Control["prototype"]["oGetObjectRect"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetObjectRect"]++;
        }
        ;
        if (!oDomRef) {
            oDomRef = this["oRootRef"];
        }

        return oDomRef
            ? UCF_DomUtil["oGetObjectRect"](oDomRef)
            : {"top": 0, "left": 0, "width": 0, "height": 0};
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetObjectRect"] = 0;
    }
    ;

    /**
     * Get the dimension of the control
     *
     * @param {HTMLElement} [oDomRef=this.oRootRef] the element
     * @return {UCF_Control_Dimension} dimension of the given DOM object or of the
     * root element of this control
     */
    UCF_Control["prototype"]["oGetDimension"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetDimension"]++;
        }
        ;
        if (!oDomRef) {
            oDomRef = this["oRootRef"];
        }

        return oDomRef
            ? {"width": oDomRef["offsetWidth"], "height": oDomRef["offsetHeight"]}
            : {"width": 0, "height": 0};
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetDimension"] = 0;
    }
    ;

    /**
     * Returns the first focusable child control of the current control
     *
     * @return {UCF_Control} the first focusable child
     */
    UCF_Control["prototype"]["oGetFirstFocusableChild"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstFocusableChild"]++;
        }
        ;
        return this["oGetFirstFocusableChildRecursive"](this["oRootRef"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstFocusableChild"] = 0;
    }
    ;

    /**
     * Returns the first focusable child control of the current control
     *
     * @return {UCF_Control} the first focusable child
     */
    UCF_Control["prototype"]["oGetFirstChild"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstChild"]++;
        }
        ;
        return this["oGetFirstChildRecursive"](this["oRootRef"], false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstChild"] = 0;
    }
    ;

    /**
     * Returns the first focusable child control of the current control
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @return {UCF_Control} the first focusable child
     */
    UCF_Control["prototype"]["oGetFirstFocusableChildRecursive"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstFocusableChildRecursive"]++;
        }
        ;
        return this["oGetFirstChildRecursive"](oDomRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstFocusableChildRecursive"] = 0;
    }
    ;

    /**
     * Returns the first child control of the current control
     *
     * @param {Object} oDomRef HTML element where to start the search
     * @param {boolean} bFocusable Whether the child needs to be focusable
     * @return {UCF_Control} the first child
     */
    UCF_Control["prototype"]["oGetFirstChildRecursive"] = function (oDomRef, bFocusable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstChildRecursive"]++;
        }
        ;
        /** @type {NodeList} */
        var aChildren;
        /** @type {number} */
        var i;
        /** @type {Node} */
        var oTmp;
        /** @type {UCF_Control} */
        var oControl;

        if (oDomRef && UCF_DomUtil["bIsVisible"](oDomRef)) {
            aChildren = oDomRef["childNodes"];

            if (aChildren) {
                for (i = 0; i < aChildren["length"]; i++) {
                    oTmp = aChildren["item"](i);

                    if (oTmp["nodeType"] === 1 && !oTmp["bIsCollectorContainer"]) {
                        // eslint-disable-next-line max-depth
                        if (oTmp["getAttribute"]('ct')) {
                            oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oTmp, true);

                            // eslint-disable-next-line max-depth
                            if (
                                oControl &&
                                (!bFocusable || (bFocusable && oControl["bIsFocusable"]()))
                            ) {
                                // check the visibility at control level instead of dom level
                                // (oControl.bIsVisible takes rootRef); checkBox, radioButton,
                                // ... do render hidden ct elements; todo: adjust getLastChild,
                                // getNextControl, ... methods accordngly

                                return oControl["bIsVisible"]() ? oControl : null;
                            }
                        }

                        oControl = this["oGetFirstChildRecursive"](oTmp, bFocusable);

                        if (oControl) { // eslint-disable-line max-depth
                            return oControl;
                        }
                    }
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstChildRecursive"] = 0;
    }
    ;

    /**
     * Returns the last focusable child control of the current control
     *
     * @return {UCF_Control} the last focusable child
     */
    UCF_Control["prototype"]["oGetLastFocusableChild"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastFocusableChild"]++;
        }
        ;
        return this["oGetLastFocusableChildRecursive"](this["oRootRef"], true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastFocusableChild"] = 0;
    }
    ;

    /**
     * Returns the last child control of the current control
     *
     * @return {UCF_Control} the last child
     */
    UCF_Control["prototype"]["oGetLastChild"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastChild"]++;
        }
        ;
        return this["oGetLastChildRecursive"](this["oRootRef"], false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastChild"] = 0;
    }
    ;

    /**
     * Returns the the last focusable child control of the current control
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @return {UCF_Control} the last focusable child
     */
    UCF_Control["prototype"]["oGetLastFocusableChildRecursive"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastFocusableChildRecursive"]++;
        }
        ;
        return this["oGetLastChildRecursive"](oDomRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastFocusableChildRecursive"] = 0;
    }
    ;

    /**
     * Returns the last focusable child control of the current control
     *
     * @param {Object} oDomRef HTML element where to start the search
     * @param {boolean} bFocusable Whether the child needs to be focusable
     * @return {UCF_Control} the last focusable child
     */
    UCF_Control["prototype"]["oGetLastChildRecursive"] = function (oDomRef, bFocusable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastChildRecursive"]++;
        }
        ;
        /** @type {NodeList} */
        var aChildren;
        /** @type {number} */
        var i;
        /** @type {Node} */
        var oTmp;
        /** @type {UCF_Control} */
        var oControl;

        if (oDomRef && UCF_DomUtil["bIsVisible"](oDomRef)) {
            aChildren = oDomRef["childNodes"];

            if (aChildren) {
                for (i = aChildren["length"] - 1; i >= 0; i--) {
                    oTmp = aChildren["item"](i);

                    if (
                        oTmp["nodeType"] === 1
                        && UCF_DomUtil["bIsVisible"](oTmp)
                        && !oTmp["bIsCollectorContainer"]
                    ) {
                        oControl = this["oGetLastChildRecursive"](oTmp, bFocusable);

                        if (oControl) { // eslint-disable-line max-depth
                            return oControl;
                        }

                        if (oTmp["getAttribute"]('ct')) { // eslint-disable-line max-depth
                            oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](
                                oTmp,
                                true
                            );

                            if ( // eslint-disable-line max-depth
                                oControl &&
                                (!bFocusable || (bFocusable && oControl["bIsFocusable"]()))
                            ) {
                                return oControl;
                            }
                        }
                    }
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastChildRecursive"] = 0;
    }
    ;

    /**
     * Returns the next focusable control after the current control. If there is
     * tab sequence added it is used
     *
     * @see UCF_LS.prototype.addTabSequence
     * @return {UCF_Control} the next focusable control
     */
    UCF_Control["prototype"]["oGetNextFocusableControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetNextFocusableControl"]++;
        }
        ;
        // Special handling for tab sequences
        /** @type {UCF_Control} */
        var oControl = this["processTabSequences"](true);

        if (oControl) {
            return oControl;
        }

        //Default handling
        oControl = this["oGetNextFocusableControlRecursive"](this["oRootRef"]);
        if (!oControl) {
            this["bIsLastControl"] = true;
        }

        return oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetNextFocusableControl"] = 0;
    }
    ;

    /**
     * Returns the the next control after the current control
     *
     * @return {UCF_Control} the next control
     */
    UCF_Control["prototype"]["oGetNextControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetNextControl"]++;
        }
        ;
        return this["oGetNextControlRecursive"](this["oRootRef"], false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetNextControl"] = 0;
    }
    ;

    /**
     * Returns the the next focusable control after the current control
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @return {UCF_Control} the next focusable control
     */
    UCF_Control["prototype"]["oGetNextFocusableControlRecursive"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetNextFocusableControlRecursive"]++;
        }
        ;
        return this["oGetNextControlRecursive"](oDomRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetNextFocusableControlRecursive"] = 0;
    }
    ;

    /**
     * Returns the next control after the given dom ref
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @param {boolean} bFocusable Whether the child needs to be focusable
     * @return {UCF_Control} the next  control
     */
    UCF_Control["prototype"]["oGetNextControlRecursive"] = function (oDomRef, bFocusable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetNextControlRecursive"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "Control.js(1433): oGetNextControlRecursive");
        }
        ;

        if (oDomRef && oDomRef !== this["oLS"]["oGetRootRef"]()) {
            while (oDomRef["nextSibling"]) {
                oDomRef = oDomRef["nextSibling"];

                if (
                    oDomRef["nodeType"] === 1 &&
                    UCF_DomUtil["bIsVisible"](oDomRef) &&
                    !oDomRef["bIsCollectorContainer"]
                ) {
                    if (oDomRef["getAttribute"]('ct')) {
                        oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oDomRef, true);

                        if ( // eslint-disable-line max-depth
                            oControl &&
                            (!bFocusable || (bFocusable && oControl["bIsFocusable"]()))
                        ) {
                            return oControl;
                        }
                    }

                    oControl = this["oGetFirstChildRecursive"](oDomRef, bFocusable);
                    if (oControl) {
                        return oControl;
                    }
                }
            }

            if (oDomRef["parentNode"] != null) {
                oControl = this["oGetNextControlRecursive"](oDomRef["parentNode"], bFocusable);

                if (oControl) {
                    return oControl;
                }
            }
        }

        return null;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetNextControlRecursive"] = 0;
    }
    ;

    /**
     * Returns the previous focusable control before the current control
     * If there is tab sequence added it is used
     *
     * @see UCF_LS.prototype.addTabSequence
     * @return {UCF_Control} the previous focusable control
     */
    UCF_Control["prototype"]["oGetPreviousFocusableControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetPreviousFocusableControl"]++;
        }
        ;
        // Special handling for tab sequences
        /** @type {UCF_Control} */
        var oControl = this["processTabSequences"](false);

        if (oControl) {
            return oControl;
        }

        //Default handling
        oControl = this["oGetPreviousFocusableControlRecursive"](this["oRootRef"]);

        if (!oControl) {
            this["bIsFirstControl"] = true;
        }

        return oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetPreviousFocusableControl"] = 0;
    }
    ;

    /**
     * Returns the the previous control before the current control
     *
     * @return {UCF_Control} the previous control
     */
    UCF_Control["prototype"]["oGetPreviousControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetPreviousControl"]++;
        }
        ;
        return this["oGetPreviousControlRecursive"](this["oRootRef"], false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetPreviousControl"] = 0;
    }
    ;

    /**
     * Returns the previous focusable control after the given dom ref
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @return {UCF_Control} the previous focusable control
     */
    UCF_Control["prototype"]["oGetPreviousFocusableControlRecursive"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetPreviousFocusableControlRecursive"]++;
        }
        ;
        return this["oGetPreviousControlRecursive"](oDomRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetPreviousFocusableControlRecursive"] = 0;
    }
    ;

    /**
     * Returns the previous control after the given dom ref
     *
     * @param {HTMLElement} oDomRef HTML element where to start the search
     * @param {boolean} bFocusable Whether the child needs to be focusable
     * @return {UCF_Control} the next control
     */
    UCF_Control["prototype"]["oGetPreviousControlRecursive"] = function (oDomRef, bFocusable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetPreviousControlRecursive"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "Control.js(1531): oGetPreviousControlRecursive");
        }
        ;

        if (oDomRef && oDomRef !== this["oLS"]["oGetRootRef"]()) {
            // TODO replace by UCF_DomUtil.oGetPreviousSibling
            while (oDomRef["previousSibling"]) {
                oDomRef = oDomRef["previousSibling"];

                if (
                    oDomRef["nodeType"] === 1 &&
                    UCF_DomUtil["bIsVisible"](oDomRef) &&
                    !oDomRef["bIsCollectorContainer"]
                ) {
                    if (oDomRef["getAttribute"]('ct')) {
                        oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](
                            oDomRef,
                            true
                        );

                        if ( // eslint-disable-line max-depth
                            oControl &&
                            (!bFocusable || (bFocusable && oControl["bIsFocusable"]()))
                        ) {
                            return oControl;
                        }
                    }

                    oControl = this["oGetLastChildRecursive"](oDomRef, bFocusable);
                    if (oControl) {
                        return oControl;
                    }
                }
            }

            if (oDomRef["parentNode"] != null) {
                if (oDomRef["parentNode"]["getAttribute"]('ct')) {
                    oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](
                        oDomRef["parentNode"],
                        true
                    );

                    if (
                        oControl &&
                        (!bFocusable || (bFocusable && oControl["bIsFocusable"]()))
                    ) {
                        return oControl;
                    }
                }

                oControl = this["oGetPreviousControlRecursive"](
                    oDomRef["parentNode"],
                    bFocusable
                );

                if (oControl) {
                    return oControl;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetPreviousControlRecursive"] = 0;
    }
    ;

    /**
     * Return a parent form, which has queueing enabled
     *
     * @return {UCF_Form}
     */
    UCF_Control["prototype"]["oGetQueueForm"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetQueueForm"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl = this; // eslint-disable-line consistent-this

        while (oControl != null) {
            // stop search when form with allocated queue is found
            if (
                UCF_JsUtil["bInstanceOf"](oControl, 'UCF_Form') &&
                oControl["bHasEventQueue"]
            ) {
                break;
            }
            oControl = oControl["oGetParent"]();
        }

        return oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetQueueForm"] = 0;
    }
    ;

    /**
     * Sets the focus to the first child control of the actual control
     *
     * @return {boolean} whether a control to focus was found
     */
    UCF_Control["prototype"]["focusFirstChildControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["focusFirstChildControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oFirstControl = this["oGetFirstFocusableChild"]();

        if (oFirstControl) {
            oFirstControl["focus"]();

            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["focusFirstChildControl"] = 0;
    }
    ;

    /**
     * Sets the focus to last child control of the actual control
     *
     * @return {boolean} whether a control to focus was found
     */
    UCF_Control["prototype"]["focusLastChildControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["focusLastChildControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oLastControl = this["oGetLastFocusableChild"]();

        if (oLastControl) {
            oLastControl["focus"]();

            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["focusLastChildControl"] = 0;
    }
    ;

    /**
     * Sets the focus to the next control after the actual control
     *
     * @return {boolean} whether a control to focus was found
     */
    UCF_Control["prototype"]["focusNextControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["focusNextControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oNextControl = this["oGetNextFocusableControl"]();

        if (oNextControl) {
            oNextControl["moveFocus"](false, /* backNavigation = */ false);

            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["focusNextControl"] = 0;
    }
    ;

    /**
     * Sets the focus to the previous control before the actual control
     *
     * @return {boolean} whether a control to focus was found
     */
    UCF_Control["prototype"]["focusPreviousControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["focusPreviousControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oPreviousControl = this["oGetPreviousFocusableControl"]();

        if (oPreviousControl) {
            oPreviousControl["moveFocus"](false, /* backNavigation = */ true);

            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["focusPreviousControl"] = 0;
    }
    ;

    /**
     * Checks if the control can get the focus or not
     *
     * @return {boolean} Whether the control can get the focus
     */
    UCF_Control["prototype"]["bIsFocusable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsFocusable"]++;
        }
        ;
        return this["oFocusDomRef"] != null
            && UCF_DomUtil["bIsVisible"](this["oFocusDomRef"], true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsFocusable"] = 0;
    }
    ;

    /**
     * Checks whether the control currently has the focus
     *
     * @return {boolean} whether the control currently has the focus
     */
    UCF_Control["prototype"]["bHasFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bHasFocus"]++;
        }
        ;
        return UCF_DomUtil["oGetActiveElement"]() === this["oGetFocusDomRef"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bHasFocus"] = 0;
    }
    ;

    /**
     * Checks if the control has a valid DOM reference.
     * This can be used for timeout methods, that may be called after the HTML
     * of the control has already been removed.
     *
     * @return {boolean} Whether the control has a valid DOM reference
     */
    UCF_Control["prototype"]["bIsValid"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsValid"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"]);

        return oDomRef != null && oDomRef === this["oDomRef"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsValid"] = 0;
    }
    ;

    /**
     * Checks if the control is currently visible.
     *
     * @return {boolean} Whether the control has a valid DOM reference
     */
    UCF_Control["prototype"]["bIsVisible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsVisible"]++;
        }
        ;
        return this["bIsValid"]() && UCF_DomUtil["bIsVisible"](this["oRootRef"], true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsVisible"] = 0;
    }
    ;

    /**
     * Focusses the control if a oFocusDomRef was maintained or detected
     * otherwise it gives the focus to the oDomRef of the control
     * A tabindex is given to the element.
     * If there was no tabindex on the element and the dom element is blured the
     * tabindex is taken away.
     *
     * @public
     * @param {boolean} bFormBackNavigation Indicates whether the focus method was
     * called from a back navigation - explicit false if it comes from a forward
     * navigation
     * @param {boolean} bIsExternalTabSequence Indicates that the TabSequence
     * feature is used
     */
    UCF_Control["prototype"]["focus"] = function (bFormBackNavigation, bIsExternalTabSequence) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["focus"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Focus ' + this["sClassName"] + ' "' + this["sId"] + '"', "Control.js(1748): focus");
        }
        ;

        if (this["bIsVisible"]()) {
            oDomRef = this["oFocusDomRef"];

            if (bFormBackNavigation && this["oLastFocusDomRef"]) {
                // explicit forward navigation triggered this focus call
                oDomRef = this["oLastFocusDomRef"];
            }
            if (bFormBackNavigation === false && this["oFirstFocusDomRef"]) {
                // explicit forward navigation triggered this focus call
                oDomRef = this["oFirstFocusDomRef"];
            }
            if (!oDomRef) {
                oDomRef = this["oDomRef"];
            }
            if (oDomRef && UCF_DomUtil["bIsVisible"](this["oRootRef"], true)) {
                if (!UCF_DomUtil["bHasTabIndex"](oDomRef)) {
                    // in this case force that the browser can set the focus to the dom
                    // ref once
                    this["addForcedFocus"](oDomRef);
                }
                UCF_DomUtil["focusDomElement"](oDomRef);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["focus"] = 0;
    }
    ;

    /**
     * Resets the tabindex that was set in focus method and detaches the
     * blur handler
     *
     * @private
     * @param {HTMLElement} oDomRef the dom reference where the tabindex was set
     */
    UCF_Control["prototype"]["addForcedFocus"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["addForcedFocus"]++;
        }
        ;
        /** @type {UCF_Control} */
        var self = this;

        this["bTabIndexSet"] = true;
        UCF_DomUtil["setTabIndex"](oDomRef, 0);

        // reset the tabindex after the element is blured (previously implemented
        // in onlsblur)
        this["_forwardBlur"] = function (oDomEvent) {
            self["removeForcedFocus"](oDomEvent["srcElement"] || oDomEvent["target"]);
        };
        UCF_DomUtil["attachEvent"](oDomRef, 'blur', this["_forwardBlur"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["addForcedFocus"] = 0;
    }
    ;

    /**
     * Resets the tabindex that was set in addForcedFocus method and detaches the
     * blur handler
     *
     * @private
     * @param {HTMLElement} oDomRef the dom reference where the tabindex was set
     */
    UCF_Control["prototype"]["removeForcedFocus"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeForcedFocus"]++;
        }
        ;
        UCF_DomUtil["resetTabIndex"](oDomRef);
        UCF_DomUtil["detachEvent"](oDomRef, 'blur', this["_forwardBlur"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeForcedFocus"] = 0;
    }
    ;

    /**
     * Forwards the focus
     * @param {boolean} bDirect Is used to redirect call. For internal use only
     * @param {boolean} bBackNavigation Is used to indicate whether the move focus
     * was triggered by a back navigation (shift tab). For internal use only.
     * @param {boolean} bIsExternalTabSequence Indicates that TabSequence feature
     * is used - see onlstabsequencenext()
     */
    UCF_Control["prototype"]["moveFocus"] = function (bDirect, bBackNavigation, bIsExternalTabSequence) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["moveFocus"]++;
        }
        ;
        // It can happen that a focus is requested and delayed but while processing
        // the delayed focus the control is destroyed in the meantime (see CSN
        // E-488768 2012). This self call with bDirect makes the method more robust
        if (bDirect) {
            if (this["oDomRef"]) {
                this["focus"](bBackNavigation, bIsExternalTabSequence);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Focus ' + this["sClassName"] + ' "' + this["sId"] + '" failed because control is in the meantime destroyed', "Control.js(1825): moveFocus");
                }
                ;
            }
        } else {
            UCF_JsUtil["delayedCall"](
                0,
                this,
                'moveFocus', [true, bBackNavigation, bIsExternalTabSequence]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["moveFocus"] = 0;
    }
    ;

    /**
     * Refocuses a given dom element
     *
     * @param {HTMLElement} oDomRef Dom Element to refocus
     */
    UCF_Control["prototype"]["refocus"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["refocus"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oSpan;

        // refocus if 508 mode is on
        if (this["oLS"]["oSystem"]["bIs508"]) {
            oSpan = UCF_DomUtil["$"]('ur-accfocus');

            if (oSpan == null) {
                oSpan = document["createElement"]('span');
                oSpan["setAttribute"]('id', 'ur-accfocus');
                oSpan["style"]["position"] = 'absolute';
                UCF_DomUtil["append"](document["body"], oSpan);
                oSpan = UCF_DomUtil["$"]('ur-accfocus');
            }

            oSpan["tabIndex"] = '2';
            oSpan["focus"]();

            if (oDomRef) {
                oDomRef["focus"]();
            } else {
                this["focus"]();
            }

            oSpan["tabIndex"] = '-1';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["refocus"] = 0;
    }
    ;

    /**
     * Handle lsblur, reset the tab index if it was set
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_Control["prototype"]["onlsblur"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlsblur"]++;
        }
        ;
        // reset the tabindex fro. this.focus was removed and added to this.focus
        // method directly (see comment there) this was done because onlsblur is
        // often handled in controls without a super call while focus is not
        // implemented. This leads to tabindex on elements that should not have one.
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlsblur"] = 0;
    }
    ;

    /**
     * Enriches the FocusInfo with additional information. This
     * Method is called for the focssed control and its containers
     *
     * @example
     * oFocusInfo.setApplyControl(this);
     * oFocusInfo.addParam('myKey', 'myVale');
     *
     * @param {UCF_FocusInfo} oFocusInfo
     */
    UCF_Control["prototype"]["collectFocusInfo"] = function (oFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["collectFocusInfo"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oFocusInfo instanceof UCF_FocusInfo, "oFocusInfo instanceof UCF_FocusInfo", "Control.js(1893): collectFocusInfo");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["collectFocusInfo"] = 0;
    }
    ;

    /**
     * Sets the focus corrersponding to the information contained in
     * oFocusInfo. This method is called on the control X when the
     * focus needs to be applied and the ApplyControl is set by
     * UCF_FocusInfo.setApplyControl(X).
     *
     * @example
     * var myParam = oFocusInfo.oGetParam('myKey');
     * var myCalculatedFocusDomRef = ...
     * UCF_DomUtil.focusDomElement(myCalculatedFocusDomRef);
     *
     * @param {UCF_FocusInfo} oFocusInfo
     */
    UCF_Control["prototype"]["applyFocusInfo"] = function (oFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["applyFocusInfo"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oFocusInfo instanceof UCF_FocusInfo, "oFocusInfo instanceof UCF_FocusInfo", "Control.js(1910): applyFocusInfo");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["applyFocusInfo"] = 0;
    }
    ;

    /**
     * Handles the skip forward event for the control
     * This function should be used in the onlsskipforward handler of the
     * specialized class
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_Control["prototype"]["handleSkipForward"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["handleSkipForward"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {HTMLElement} */
        var oResult;
        /** @type {UCF_Control} */
        var oParent;
        /** @type {HTMLDivElement} */
        var oAssoAreaRef = this["oLS"]["oGetAssociatedAreaRef"]();
        /** @type {HTMLDivElement} */
        var oStaticAreaRef = this["oLS"]["oGetStaticAreaRef"]();

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(1932): handleSkipForward");
        }
        ;

        oDomRef = UCF_DomUtil["oGetNextSibling"](this["oRootRef"], true);
        oParent = this["oGetParent"]();

        if (oParent && oParent["focusNextCellControl"]) {
            oParent["focusNextCellControl"](oBrowserEvent);
        } else {
            // End of parent containers have to be skipped as well
            while (oDomRef != null) {
                oResult = UCF_DomUtil["oGetTabbableElementForward"](oDomRef, true);

                if (oDomRef !== oAssoAreaRef && oDomRef !== oStaticAreaRef &&
                    !UCF_DomUtil["bIsCTInstanceOf"](oResult, 'TSW') &&
                    !UCF_DomUtil["bIsCTInstanceOf"](oResult, 'HI')) {
                    if (!this["bIsEndContainerDomRef"](oResult) &&
                        oResult &&
                        UCF_DomUtil["bDomElementFocused"](oResult)
                    ) {
                        oBrowserEvent["cancelBubble"]();
                        oBrowserEvent["cancel"]();
                        break;
                    }
                }

                if (oResult) {
                    oDomRef = UCF_DomUtil["oGetNextSibling"](oResult, true);
                } else {
                    break;
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["handleSkipForward"] = 0;
    }
    ;

    /**
     * Handles the skip back event for the control
     * This function should be used in the onlsskipback handler of the
     * specialized class
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_Control["prototype"]["handleSkipBack"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["handleSkipBack"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {HTMLElement} */
        var oResult;
        /** @type {UCF_Control} */
        var oParent;
        /** @type {HTMLDivElement} */
        var oAssoAreaRef = this["oLS"]["oGetAssociatedAreaRef"]();
        /** @type {HTMLDivElement} */
        var oStaticAreaRef = this["oLS"]["oGetStaticAreaRef"]();

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(1985): handleSkipBack");
        }
        ;

        oDomRef = UCF_DomUtil["oGetPreviousSibling"](this["oRootRef"], true);
        oParent = this["oGetParent"]();

        if (oParent && oParent["focusPreviousCellControl"]) {
            oParent["focusPreviousCellControl"](oBrowserEvent);
        } else {
            // CSN: 772609
            // For skipping it must be possible to know whether an element is focusable
            // or not, i.e. whether it has recieved the focus or not. Hidden elements,
            // that have been placed in a container with diplay:none or visibility
            // hidden are not recognized as not focusable by the skipping
            // functionality. These elements do not expose the visibility of their
            // parent. Therefore we can not ask for their own visibility to know if
            // they can recieve the focus. Skipping breaks here and the focus gets
            // lost. Therefore we use now the function bDomElementFocused that returns
            // a bool telling us if focusing an element was successfull. If an element
            // could not be focused because it is hidden, the function should keep on
            // searching.
            //
            // End of parent containers have to be skipped as well
            while (oDomRef != null) {
                oResult = UCF_DomUtil["oGetTabbableElementBackward"](oDomRef, true);

                if (oDomRef !== oAssoAreaRef && oDomRef !== oStaticAreaRef &&
                    !UCF_DomUtil["bIsCTInstanceOf"](oResult, 'TSW') &&
                    !UCF_DomUtil["bIsCTInstanceOf"](oResult, 'HI')) {
                    if (!this["bIsEndContainerDomRef"](oResult)) {
                        if (oResult && UCF_DomUtil["bDomElementFocused"](oResult)) {
                            oBrowserEvent["cancelBubble"]();
                            oBrowserEvent["cancel"]();
                            break;
                        }
                    }
                }

                if (oResult) {
                    oDomRef = UCF_DomUtil["oGetPreviousSibling"](oResult, true);
                } else {
                    break;
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["handleSkipBack"] = 0;
    }
    ;

    /**
     * Checks if the given reference is a end tab for containers
     *
     * @param {HTMLElement} oDomRef
     * @return {boolean}
     */
    UCF_Control["prototype"]["bIsEndContainerDomRef"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsEndContainerDomRef"]++;
        }
        ;
        /** @type {string} */
        var sId;
        /** @type {string} */
        var sTp;

        if (this["oLS"]["oSystem"]["bIs508"] && oDomRef && oDomRef["getAttribute"]) {
            sId = oDomRef["getAttribute"]('id');
            sTp = oDomRef["getAttribute"]('tp');

            return (sId && UCF_StringUtil["bEndsWith"](sId, '-end')) || (sTp === 'END');
        } else {
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsEndContainerDomRef"] = 0;
    }
    ;

    /**
     * Sets the default button id for the control
     *
     * @param {string} sDefaultButtonId string Id of the button that is executed
     * if the user presses enter
     */
    UCF_Control["prototype"]["setDefaultButtonId"] = function (sDefaultButtonId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setDefaultButtonId"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oDefaultButton;

        this["sActiveDefaultButtonId"] = '';

        if (sDefaultButtonId) {
            oDefaultButton = this["oLS"]["oControlFactory"]["oGetControlById"](
                sDefaultButtonId
            );

            if (
                oDefaultButton &&
                (
                    UCF_JsUtil["bInstanceOf"](oDefaultButton, 'UCF_Button') ||
                    UCF_JsUtil["bInstanceOf"](oDefaultButton, 'UCF_LargeButton')
                )
            ) {
                this["sActiveDefaultButtonId"] = sDefaultButtonId;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setDefaultButtonId"] = 0;
    }
    ;

    /**
     * Checks if a control has a enter hotkey bound
     *
     * @return {boolean}
     */
    UCF_Control["prototype"]["bHasEnterHotkey"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bHasEnterHotkey"]++;
        }
        ;
        /** @type {UCF_Hotkeys} */
        var oHotkeys;

        // check if container has a bound enter hotkey
        if (this["sHotkeysId"] == null || this["sHotkeysId"] === '') {
            return false;
        } else {
            oHotkeys = this["oGetControlById"](this["sHotkeysId"]);

            return oHotkeys != null
                && oHotkeys["oGetHotkey"](UCF_KeyCodes["ENTER"], false, false, false);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bHasEnterHotkey"] = 0;
    }
    ;

    /**
     * Marks the Lightspeed instance as dirty for the work protect mode.
     *
     * @param {boolean} bFromEvent Defines whether the call originates from a
     * browser event or if the caller wants to set the dirty flag expcitly.
     */
    UCF_Control["prototype"]["markDirty"] = function (bFromEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["markDirty"]++;
        }
        ;
        this["oLS"]["markDirty"](bFromEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["markDirty"] = 0;
    }
    ;

    /**
     * Sets whether there are pending changes that would need to be submitted
     * with the next event queue. This flag should be set if the user started to
     * enter text. If the next change event occured the flag should be reset.
     *
     * @private
     * @param {boolean} bPending the pending change flag to set.
     */
    UCF_Control["prototype"]["setPendingChange"] = function (bPending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setPendingChange"]++;
        }
        ;
        this["oLS"]["setPendingChange"](bPending);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setPendingChange"] = 0;
    }
    ;

    /**
     * Handles the lscontainerfocus event for the control and removes the default
     * button visualization if the focused control does handle the onlsenter event
     * itself or adds the visualization if the container has registered with
     * this.initializeDefaultButton method
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the lscontainerfocus
     */
    UCF_Control["prototype"]["onlscontainerfocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlscontainerfocus"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(2133): onlscontainerfocus");
        }
        ;

        if (!oBrowserEvent["oGetData"]()["bSkipDefaultButtonHandling"]) {
            this["oLS"]["highlightDefaultButton"](null);

            if (this["bHasEnterHotkey"]()) {
                // check if container has a hotkey enter and stop default button handling
                oBrowserEvent["oGetData"]()["bSkipDefaultButtonHandling"] = true;
            }

            if (this["bIgnoreDefaultButton"]) {
                oBrowserEvent["oGetData"]()["bSkipDefaultButtonHandling"] = true;
            } else if (this["sActiveDefaultButtonId"]) {
                this["oLS"]["highlightDefaultButton"](this["sActiveDefaultButtonId"]);
                oBrowserEvent["oGetData"]()["bSkipDefaultButtonHandling"] = true;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlscontainerfocus"] = 0;
    }
    ;

    /**
     * Default implementation to get the short name of a given control.
     * @return {string}
     */
    UCF_Control["prototype"]["sGetAccControlName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetAccControlName"]++;
        }
        ;
        /** @type {UCF_AccessibilityHelper} */
        var oAccessibilityHelper = new (UCF_ClassLoader["oGetClass"]("UCF_AccessibilityHelper"))(this["oLS"]);
        /** @type {string} */
        var sText;

        oAccessibilityHelper["setControlType"](this["oDomRef"]["getAttribute"]('ct'));
        sText = oAccessibilityHelper["sGetControlTypeShortText"]();

        return sText ? sText : this["oLS"]["sGetText"]('SAPUR_TYPE_UNKNOWN');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetAccControlName"] = 0;
    }
    ;

    /**
     * Handle acchierarchy, announces either the parent or the direct children
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the lsacchierarchy
     */
    UCF_Control["prototype"]["onlsacchierarchy"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlsacchierarchy"]++;
        }
        ;
        /** @type {number} */
        var iKey;
        /** @type {string} */
        var sText;
        /** @type {UCF_Control} */
        var oParent;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(2181): onlsacchierarchy");
        }
        ;

        iKey = oBrowserEvent["iKeyCode"]();
        sText = '';

        oBrowserEvent["cancelBubble"]();
        oBrowserEvent["cancel"]();

        if (iKey === UCF_KeyCodes["_1"]) {
            // _1: announce parent
            oParent = this["oGetParent"]();

            while (oParent && !oParent["onlsaccessibility"]) {
                oParent = oParent["oGetParent"]();
            }

            sText = oParent
                ? this["oLS"]["sGetText"]('SAPUR_PARENT') + ' ' + oParent["sGetAccControlName"]()
                : this["oLS"]["sGetText"]('SAPUR_NO_PARENT');
        } else {
            // _2:  announce children
            sText = this["sGetAccChildren"](oBrowserEvent);
        }

        if (sText !== '') {
            alert(sText); // WAT
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlsacchierarchy"] = 0;
    }
    ;

    /**
     * Default implementation to retrieve the direct accessibile relevant children
     * & calculate a string containing get the amount of identical controls and
     * there names.
     *
     * @see aGetAccChildrenRecursive
     * @return {string} String to be announced
     */
    UCF_Control["prototype"]["sGetAccChildren"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetAccChildren"]++;
        }
        ;
        /** @type {Array<UCF_Control>} */
        var aAccChildren = this["aGetAccChildrenRecursive"](this["oDomRef"], []);
        /** @type {string} */
        var sText = this["sGetAccControlName"]();

        if (sText !== '') {
            sText += ': ';
        }

        return sText + this["sGetAccChildrenText"](aAccChildren);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetAccChildren"] = 0;
    }
    ;

    /**
     * Counts identical controls types in a given array. Returns a string
     * containing the amount of identical controls and there names.
     *
     * @see aGetAccChildren
     * @param {Array<UCF_Control>} aAccChildren Array of controls
     * @return {string} String to be announced
     */
    UCF_Control["prototype"]["sGetAccChildrenText"] = function (aAccChildren) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetAccChildrenText"]++;
        }
        ;
        return aAccChildren == null || aAccChildren["length"] === 0
            ? this["oLS"]["sGetText"]('SAPUR_NO_CHILDREN')
            : [this["oLS"]["sGetText"]('SAPUR_CHILDREN') + '\n\n']["concat"](
                UCF_JsUtil["map"](
                    UCF_JsUtil["entries"](UCF_JsUtil["reduce"](
                        aAccChildren,
                        function (oSums, oChild) {
                            /** @type {string} */
                            var sControlName = oChild["sGetAccControlName"]();

                            if (sControlName) {
                                if (!(sControlName in oSums)) {
                                    oSums[sControlName] = 0;
                                }
                                oSums[sControlName] += 1;
                            }

                            return oSums;
                        }, {}
                    )),
                    function (oEntry) {
                        return oEntry[1] + ' ' + oEntry[0];
                    }
                )
            )["join"]('\n');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetAccChildrenText"] = 0;
    }
    ;

    /**
     * Default implementation to get the direct accessibility relevant children.
     *
     * @see sGetAccChildren
     * @param {HTMLElement} oDomRef the element
     * @param {Array<UCF_Control>} aAccChildren relevant acc children
     * @return {Array<UCF_Control>} containing direct acc relevant children
     */
    UCF_Control["prototype"]["aGetAccChildrenRecursive"] = function (oDomRef, aAccChildren) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["aGetAccChildrenRecursive"]++;
        }
        ;
        /** @type {NodeList} */
        var aChildren;
        /** @type {number} */
        var i;
        /** @type {Node} */
        var oTmp;
        /** @type {UCF_Control} */
        var oControl;

        if (
            oDomRef &&
            oDomRef["childNodes"] != null &&
            UCF_DomUtil["bIsVisible"](oDomRef)
        ) {
            aChildren = oDomRef["childNodes"];

            for (i = 0; i < aChildren["length"]; i++) {
                oTmp = aChildren[i];
                if (oTmp["nodeType"] === 1 && UCF_DomUtil["bIsVisible"](oTmp)) {
                    if (oTmp["getAttribute"]('ct')) {
                        oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oTmp, true);

                        if (oControl["onlsaccessibility"]) { // eslint-disable-line max-depth
                            // acc relevant children found. Add the array and stop recursion
                            aAccChildren["push"](oControl);
                            continue;
                        }
                    }
                    aAccChildren["concat"](this["aGetAccChildrenRecursive"](oTmp, aAccChildren));
                }
            }

            return aAccChildren;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["aGetAccChildrenRecursive"] = 0;
    }
    ;

    /**
     * Fires a click on the default button
     *
     * @param {UCF_BrowserEvent} oBrowserEvent Event object of the lsenter event
     */
    UCF_Control["prototype"]["onlsenter"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlsenter"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oDefaultButton;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(2321): onlsenter");
        }
        ;

        if (
            this["bIgnoreDefaultButton"] ||
            (this["bHasEnterHotkey"]() && !this["sActiveDefaultButtonId"])
        ) {
            oBrowserEvent["cancelBubble"]();
        } else if (this["sActiveDefaultButtonId"]) {
            oDefaultButton = this["oLS"]["oControlFactory"]["oGetControlById"](
                this["sActiveDefaultButtonId"]
            );
            if (oDefaultButton) {
                oDefaultButton["onclick"](oBrowserEvent);
                oBrowserEvent["cancelBubble"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlsenter"] = 0;
    }
    ;

    /**
     * Makes the browser selection visible
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent the select
     */
    UCF_Control["prototype"]["onselect"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onselect"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(2346): onselect");
        }
        ;

        if (this["bAllowTextSelection"]) {
            oBrowserEvent["oDomEvent"]["returnValue"] = true;
        }

        oBrowserEvent["cancelBubble"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onselect"] = 0;
    }
    ;

    /**
     * Makes the browser selection visible
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent the selectstart
     */
    UCF_Control["prototype"]["onselectstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onselectstart"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(2362): onselectstart");
        }
        ;

        if (this["bAllowTextSelection"]) {
            oBrowserEvent["oDomEvent"]["returnValue"] = true;
        } else if (
            // eslint-disable-next-line no-magic-numbers
            UCF_UserAgent["bIsTrident"](7) ||
            UCF_UserAgent["bIsEdgeHtml"]() ||
            UCF_UserAgent["bIsSafari"]() ||
            UCF_UserAgent["bIsFirefox"]() ||
            UCF_UserAgent["bIsChromium"]()
        ) {
            // BrowserWindow does not cancel selectstart for standards IE11, Edge,
            // Firefox, Safari => cancel it here *if !bAllowTextSelection*
            oBrowserEvent["cancel"]();
        }

        oBrowserEvent["cancelBubble"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onselectstart"] = 0;
    }
    ;

    /**
     * @param {HTMLElement|Array<HTMLElement>} [oDomRef=this.oDomRef] the dom
     * element(s) to allow text selection on
     */
    UCF_Control["prototype"]["allowTextSelection"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["allowTextSelection"]++;
        }
        ;
        this["bAllowTextSelection"] = true;

        if (UCF_UserAgent["bIsSafari"]() && UCF_UserAgent["bIsIOS"]()) {
            if (UCF_JsUtil["bIsArray"](oDomRef)) {
                UCF_JsUtil["forEach"](oDomRef, function (oRef) {
                    UCF_DomUtil["addClass"](oRef, 'lsControl--text-selection');
                });
            } else {
                UCF_DomUtil["addClass"](oDomRef || this["oDomRef"], 'lsControl--text-selection');
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["allowTextSelection"] = 0;
    }
    ;

    /**
     * returns the drag source info
     * to be overridden e.g. by runtime authoring layouts
     *
     * @return {UCF_DragSourceInfo}
     */
    UCF_Control["prototype"]["sGetDragSourceInfo"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetDragSourceInfo"]++;
        }
        ;

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetDragSourceInfo"] = 0;
    }
    ;

    /**
     * returns the next parent which is a drag source (for runtime authoring)
     *
     * @return {UCF_Control}
     */
    UCF_Control["prototype"]["oGetDragParent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetDragParent"]++;
        }
        ;
        if (this["sGetDragSourceInfo"]()) {
            return this;
        } else if (this["oGetParent"]()) {
            return this["oGetParent"]()["oGetDragParent"]();
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetDragParent"] = 0;
    }
    ;

    /**
     * applies a move cursor to the given dom ref,
     * if this control is drag handle and is within a drag cell
     *
     * @param {HTMLElement} oHandleDomRef
     */
    UCF_Control["prototype"]["initializeHandle"] = function (oHandleDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["initializeHandle"]++;
        }
        ;
        if (this["bIsDragHandle"]) {

            if (this["oGetDragParent"]()) {
                oHandleDomRef["style"]["cursor"] = 'move';
                oHandleDomRef["unselectable"] = true;
                oHandleDomRef["style"]["mozUserSelect"] = 'none';

                //store the handle dom ref for more precise handling
                this["oDragHandleDomRef"] = oHandleDomRef;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["initializeHandle"] = 0;
    }
    ;

    /**
     * Helper function to fire the LayoutChange on the BrowserWindow. Should be
     * used by controls like TabStrip or Tray, which influence the visiblity or
     * position of other controls
     */
    UCF_Control["prototype"]["notifyLayoutChange"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["notifyLayoutChange"]++;
        }
        ;
        // When called delayed, e.g. with feedMassNotificationFilter(), control can
        // already be destroyed
        if (this["oLS"]) {
            this["oLS"]["oBrowserWindow"]["notifyLayoutChange"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["notifyLayoutChange"] = 0;
    }
    ;

    /**
     * Fire LayoutChange with information about the source control
     */
    UCF_Control["prototype"]["notifyLayoutChangeFrom"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["notifyLayoutChangeFrom"]++;
        }
        ;
        if (this["oLS"]) {
            this["oLS"]["oBrowserWindow"]["notifyLayoutChangeFrom"](this["sId"], this["sClassName"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["notifyLayoutChangeFrom"] = 0;
    }
    ;

    /**
     * Helper function to notify that a layer is currently displayed
     * Should be used by all controls which display layered content
     */
    UCF_Control["prototype"]["notifyLayerVisible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["notifyLayerVisible"]++;
        }
        ;
        this["oLS"]["oBrowserWindow"]["notifyLayerVisible"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["notifyLayerVisible"] = 0;
    }
    ;

    /**
     * Helper function to notify that a layer is hidden again
     * Should be used by all controls which display layered content
     */
    UCF_Control["prototype"]["notifyLayerHidden"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["notifyLayerHidden"]++;
        }
        ;
        this["oLS"]["oBrowserWindow"]["notifyLayerHidden"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["notifyLayerHidden"] = 0;
    }
    ;

    /**
     * creates drag delegate lazy
     * @param {UCF_BrowserEvent} oBrowserEvent the lsdragstart
     */
    UCF_Control["prototype"]["onlsdragstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlsdragstart"]++;
        }
        ;
        this["createDragDelegate"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlsdragstart"] = 0;
    }
    ;

    /**
     * creates drag delegate lazy
     * @param {UCF_BrowserEvent} oBrowserEvent the dragstart
     */
    UCF_Control["prototype"]["ondragstart"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["ondragstart"]++;
        }
        ;
        this["createDragDelegate"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["ondragstart"] = 0;
    }
    ;

    /**
     * creates drop delegate lazy
     * @param {UCF_BrowserEvent} oBrowserEvent the lsdragenter
     */
    UCF_Control["prototype"]["onlsdragenter"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlsdragenter"]++;
        }
        ;
        this["createDropDelegate"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlsdragenter"] = 0;
    }
    ;

    /**
     * creates drop delegate lazy
     * @param {UCF_BrowserEvent} oBrowserEvent the dragenter
     */
    UCF_Control["prototype"]["ondragenter"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["ondragenter"]++;
        }
        ;
        this["createDropDelegate"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["ondragenter"] = 0;
    }
    ;

    /**
     * 'abstract' method for creating drag delegate lazy
     * to be implemented by subclasses
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the lsdragstart/dragstart
     */
    UCF_Control["prototype"]["createDragDelegate"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["createDragDelegate"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["createDragDelegate"] = 0;
    }
    ;

    /**
     * 'abstract' method for creating drop delegate lazy
     * to be implemented by subclasses
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the lsdragenter/dragenter
     */
    UCF_Control["prototype"]["createDropDelegate"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["createDropDelegate"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["createDropDelegate"] = 0;
    }
    ;

    /**
     * Receives a string HTML fragment to update the control partially
     *
     * @param {string} sHTML string The HTML data as a string
     */
    UCF_Control["prototype"]["updateHTML"] = function (sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["updateHTML"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["updateHTML"] = 0;
    }
    ;

    /**
     * Returns the text which is displayed on the screen
     *
     * @return {string} the displayed
     */
    UCF_Control["prototype"]["sGetDisplayedText"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetDisplayedText"]++;
        }
        ;
        return '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetDisplayedText"] = 0;
    }
    ;

    /**
     * @private
     * @return {number} The parents z index in case of a PopupWindow
     */
    UCF_Control["prototype"]["iGetParentZIndex"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["iGetParentZIndex"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oRef = UCF_DomUtil["oGetParentByAttribute"](this["oDomRef"], 'ct', 'PW');

        return oRef ? parseInt(oRef["style"]["zIndex"], 10) : 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["iGetParentZIndex"] = 0;
    }
    ;

    /**
     * Plays a given animation
     *
     * @public
     * @param {string} sId the id of the element
     * @param {UCF_Animation} oAnimation the animation to play
     */
    UCF_Control["prototype"]["playAnimation"] = function (sId, oAnimation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["playAnimation"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef = document["getElementById"](sId)["firstChild"];

        while (oDomRef && oDomRef["nodeType"] !== 1) {
            oDomRef = oDomRef["nextSibling"];
        }

        if (oDomRef) {
            oAnimation["setDomRef"](oDomRef);
            oAnimation["run"](true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["playAnimation"] = 0;
    }
    ;

    /**
     * Returns the first child control within the dom ref of the control.
     * Calling this function might have performance impact.
     *
     * @private
     * @return {UCF_Control} the first child control
     */
    UCF_Control["prototype"]["oGetFirstChildControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetFirstChildControl"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef = UCF_DomUtil["oGetFirstChildByAttribute"](this["oDomRef"], 'ct');
        /** @type {UCF_Control} */
        var oControl;

        if (oDomRef) {
            oControl = this["oLS"]["oGetControlByDomRef"](oDomRef);

            if (oControl) {
                return oControl;
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetFirstChildControl"] = 0;
    }
    ;

    /**
     * Returns the last child control within the dom ref of the control.
     * Calling this function might have performance impact.
     *
     * @private
     * @return {UCF_Control} the last child control
     */
    UCF_Control["prototype"]["oGetLastChildControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetLastChildControl"]++;
        }
        ;
        /**
         * @type {HTMLElement} considered to be the right starting point for the deep
         * search
         */
        var oDomRef = UCF_DomUtil["oGetLastChildByAttribute"](this["oDomRef"], 'ct');
        /** @type {UCF_Control} */
        var oControl;

        if (oDomRef) {
            oControl = this["oLS"]["oGetControlByDomRef"](oDomRef);

            if (oControl) {
                return oControl;
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetLastChildControl"] = 0;
    }
    ;

    /**
     * Returns the pixel size that this control needs
     * to be display in an optimal way as in a table column.
     * Default implementation will get the current offset width of the root cantainer
     * and does not consider margins of the root ref.
     *
     * Please override this method to be more specific.
     *
     * @private
     * @return {number} pixels width
     */
    UCF_Control["prototype"]["iGetOptimalWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["iGetOptimalWidth"]++;
        }
        ;
        // Consider the margin as well is not that easy and also time consuming,
        // therefore we skip it for the control:
        // 1. Most controls do not have a margin.
        // 2. Controls can overwrite the method to react on margin individually

        /** @type {number} default optimal width is 20 */
        var iWidth = 20;
        /** @type {HTMLDivElement} */
        var oCloneDomRef;
        /** @type {string} */
        var sCurrentWidthStyle;

        if (this["oRootRef"]) {
            sCurrentWidthStyle = UCF_DomUtil["sGetCurrentStyle"](this["oRootRef"], 'width');

            if (UCF_StringUtil["bContains"](sCurrentWidthStyle, 'px')) {
                iWidth = parseInt(sCurrentWidthStyle);
            } else if (this["oRootRef"]["offsetWidth"] > 0) {
                oCloneDomRef = document["createElement"]('div');

                oCloneDomRef["style"]["position"] = 'absolute';
                oCloneDomRef["style"]["top"] = '-1000px';
                // eslint-disable-next-line no-unsanitized/property
                oCloneDomRef["innerHTML"] = this["oRootRef"]["innerHTML"];

                UCF_DomUtil["prepend"](document["body"], oCloneDomRef);

                iWidth = Math["max"](oCloneDomRef["offsetWidth"], iWidth);

                UCF_DomUtil["removeFromDom"](oCloneDomRef);
                oCloneDomRef = null;
            }
        }

        return iWidth;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["iGetOptimalWidth"] = 0;
    }
    ;

    /**
     * Removes the tooltips for the given control and all parent controls to avoid
     * that a tooltip comes up if the user hovers the control. This should be used
     * if a layered control is opened and a tooltip might overlap the layer. Ensure
     * that you call addTooltips if the layer is closed.
     *
     * If no oDomRef is given the the dom ref and all parent nodes are used. Ensure
     * to remove inner tooltips of the control (like the alt text on button icon).
     * Therefore override this method in your control.
     *
     * @private
     * @param {HTMLElement} [oDomRef=this.oDomRef||this.oRootRef] the starting
     * point for the tooltip removal, if not given the the dom ref and all parent
     * nodes are used.
     */
    UCF_Control["prototype"]["removeTooltips"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeTooltips"]++;
        }
        ;
        /** @type {NodeListOf<HTMLImageElement>} */
        var aInnerImages;
        /** @type {string} */
        var sAltText;
        /** @type {number} */
        var i;

        if (!oDomRef) {
            oDomRef = this["oDomRef"] || this["oRootRef"];
        }

        if (
            oDomRef["getAttribute"] &&
            (
                oDomRef["getAttribute"]('title') === '' ||
                oDomRef["getAttribute"]('title') == null
            ) &&
            oDomRef["parentNode"]
        ) {
            this["hideTooltip"](oDomRef["parentNode"]);
        } else {
            if (oDomRef["getElementsByTagName"]) {
                aInnerImages = oDomRef["getElementsByTagName"]('IMG');

                for (i = 0; i < aInnerImages["length"]; i++) {
                    sAltText = aInnerImages[i]["getAttribute"]('alt');
                    if (sAltText) {
                        this["aTooltipNodes"]["push"]({
                            "attribute": 'alt',
                            "domref": aInnerImages[i],
                            "text": sAltText
                        });
                        aInnerImages[i]["setAttribute"]('alt', '');
                    }
                }
            }
            if (oDomRef["getAttribute"] && oDomRef["getAttribute"]('title') !== '') {
                sAltText = oDomRef["getAttribute"]('title');
                oDomRef["setAttribute"]('title', '');
                this["aTooltipNodes"]["push"]({
                    "attribute": 'title',
                    "domref": oDomRef,
                    "text": sAltText
                });
                if (oDomRef["parentNode"]) {
                    this["hideTooltip"](oDomRef["parentNode"]);
                }
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeTooltips"] = 0;
    }
    ;

    /**
     * Resets the tooltips for the given control again after they were removed
     * using removeTooltips
     *
     * @private
     */
    UCF_Control["prototype"]["resetTooltips"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["resetTooltips"]++;
        }
        ;
        /** @type {UCF_Control_TooltipNode} */
        var oObject;

        while (this["aTooltipNodes"]["length"] > 0) {
            oObject = this["aTooltipNodes"]["pop"]();

            if (oObject["domref"]) {
                oObject["domref"]["setAttribute"](oObject["attribute"], oObject["text"]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["resetTooltips"] = 0;
    }
    ;

    /**
     * Highlights a text by a given index
     *
     * @param {number|Array<number>} iStart The start index from which the on the
     * text is highlighted. Optionally can be an Array of start indices
     * @param {number|Array<number>} iLength  The length of the highlighted text.
     * Optionally can be an Array of lenghts
     * @param {string} sAccDescription The accessibility decription of the
     * highlighted text
     * @param {string} [sTextProperty] The related name of API property if the
     * control provides several text properties which can be highlighted
     * @param {boolean} bFocused `true` if text is focused
     */
    UCF_Control["prototype"]["setHighlightTextByIndex"] = function (iStart, iLength, sAccDescription, sTextProperty, bFocused) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setHighlightTextByIndex"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oAriaHighlightedRef;
        /** @type {HTMLDivElement} */
        var oAriaDiv;

        if (this["oLS"]["oSystem"]["bIs508"] || window["UCF_System"]["bIsAria"]) {
            this["mHighlightInfo"] = {
                "iStart": iStart,
                "iLength": iLength,
                "sAccDescription": sAccDescription,
                "sTextProperty": sTextProperty
            };
            oAriaDiv = document["getElementById"]('sapur-aria-dynamic-texts');

            if (oAriaDiv) {
                oAriaHighlightedRef = document["createElement"]('span');
                oAriaHighlightedRef["id"] = this["sId"] + UCF_Control["ARIA_HIGHLIGHTED_SUFFIX"];
                oAriaHighlightedRef["textContent"] = sAccDescription;
                oAriaDiv["appendChild"](oAriaHighlightedRef);
                UCF_AriaStateHelper["addDescribedby"](
                    this["oFocusRef"] || this["oDomRef"],
                    this["sId"] + UCF_Control["ARIA_HIGHLIGHTED_SUFFIX"] + ' ARIA_HIGHLIGHTED'
                );
            }
        }

        this["colorizeHighlightedText"](iStart, iLength, sTextProperty, bFocused);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setHighlightTextByIndex"] = 0;
    }
    ;

    /**
     * Takes care that about the right visualization of the highlighted text in the
     * DOM
     *
     * @param {number|Array<number>} iStart The start index from which the on the
     * text is highlighted. Optionally can be an Array of start indices
     * @param {number|Array<number>} iLength The length of the highlighted text.
     * Optionally can be an Array of lenghts
     * @param {string} [sTextProperty] The related name of API property if the
     * control provides several text properties which can be highlighted
     * @param {boolean} bFocused `true` if text should be focussed
     */
    UCF_Control["prototype"]["colorizeHighlightedText"] = function (iStart, iLength, sTextProperty, bFocused) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["colorizeHighlightedText"]++;
        }
        ;
        // default implementation is adding a class to the rootref to identify at
        // least that the control contains the search string if this corrupt a
        // control the control should override this method
        if (bFocused) {
            if (!UCF_DomUtil["bHasClass"](this["oRootRef"], 'lsHighlightTextFocus')) {
                UCF_DomUtil["addClass"](this["oRootRef"], 'lsHighlightTextFocus');
            }
        } else if (!UCF_DomUtil["bHasClass"](this["oRootRef"], 'lsHighlightText')) {
            UCF_DomUtil["addClass"](this["oRootRef"], 'lsHighlightText');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["colorizeHighlightedText"] = 0;
    }
    ;

    /**
     * Returns the highlight information
     *
     * @return {UCF_Control_HighlightInfo}
     */
    UCF_Control["prototype"]["mGetHighlightInfo"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["mGetHighlightInfo"]++;
        }
        ;
        return (this["oLS"]["oSystem"]["bIs508"] && this["mHighlightInfo"])
            ? this["mHighlightInfo"]
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["mGetHighlightInfo"] = 0;
    }
    ;

    /**
     * Returns the CustomData string of the control
     *
     * @public
     * @return {string} the CustomData string of the control
     */
    UCF_Control["prototype"]["sGetCustomData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetCustomData"]++;
        }
        ;
        return this["sCustomData"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetCustomData"] = 0;
    }
    ;

    /**
     * Returns the JSON property with the given sName in case the CustomData string
     * is a json string or null if it does not exist
     *
     * @public
     * @param {string} [sName] the key in the CustomData JSON
     * @return {any} the CustomData for the given sName property or the whole JSON
     */
    UCF_Control["prototype"]["getCustomData"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getCustomData"]++;
        }
        ;
        /** @type {Object} */
        var oJSON = null;

        if (this["sCustomData"]) {
            if (typeof this["sCustomData"] === 'object') {
                oJSON = this["sCustomData"];
            } else {
                try {
                    oJSON = UCF_JsUtil["oJsonParse"](this["sCustomData"]);
                } catch (ex) {
                }

            }
            if (!sName) {
                return oJSON || null;
            }
            if (oJSON) {
                return oJSON[sName];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getCustomData"] = 0;
    }
    ;

    /**
     * Returns the public interface of the parent of the control
     *
     * @public
     * @return {UCF_Interface<UCF_Control>} The public interface of the parent
     * control or null if no parent exists.
     */
    UCF_Control["prototype"]["oGetParentControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetParentControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oParent = this["oGetParent"]();

        return oParent ? oParent["oGetInterface"]() : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetParentControl"] = 0;
    }
    ;

    /**
     * Returns the client ControlTree Reference of this control
     *
     * @private
     * @return {UCF_ClientElement} The ClientControl of this UCF Instance
     */
    UCF_Control["prototype"]["getClientControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getClientControl"]++;
        }
        ;
        return this["oLS"]
            ? this["oLS"]["oControlFactory"]["oGetClientControlById"](this["sId"])
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getClientControl"] = 0;
    }
    ;

    /**
     * Sets a property of the client control instance.
     *
     * Normally setting a property of the client control instance can cause a
     * rerendering even if the parent of that control. Ensure to set the
     * `bSuppressRerendering` parameter to true in all cases where the HTML of the
     * control is already up to date and does not need be rendered again. Otherwise
     * large part of the UI might be redrawn accidently.
     *
     * @private
     * @param {string} sName name of the property
     * @param {Object} oValue value for the property
     * @param {boolean} bSuppressRerendering whether rerendeing of the client
     * control should be suppressed
     */
    UCF_Control["prototype"]["setClientProperty"] = function (sName, oValue, bSuppressRerendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setClientProperty"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oClientControl = this["getClientControl"]();

        if (oClientControl) {
            if (oClientControl['set' + sName] && oClientControl['get' + sName]) {
                // eslint-disable-next-line eqeqeq
                if (oClientControl['get' + sName]() != oValue) {
                    oClientControl['set' + sName](oValue, bSuppressRerendering);
                }
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Client property ' + sName + ' does not exist in ' + oClientControl["sClassName"], "Control.js(2946): setClientProperty");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setClientProperty"] = 0;
    }
    ;

    /**
     * Gets value of a property of the client control instance.
     *
     * @private
     * @param {string} sName name of the property
     * @return {Object} value for the the property
     */
    UCF_Control["prototype"]["getClientProperty"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getClientProperty"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oClientControl = this["getClientControl"]();

        return oClientControl && oClientControl['get' + sName]
            ? oClientControl['get' + sName]()
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getClientProperty"] = 0;
    }
    ;

    /**
     * Returns data JSON that will be used in the SeleniumRecorder and
     * SeleniumRuntime to test the control. Ensure that methods do not need any
     * parameters. Default methods are the public methods that have 'get' in the
     * name, have no parameters and have a simple type as a result.
     *
     * Override this method to provide more internals (property 'internals').
     *
     * @see {UCF_SeleniumRuntime},{UCF_SeleniumRecorder}
     * @private
     * @return {UCF_Control_TestData} A JSON object containing test data
     */
    UCF_Control["prototype"]["oGetTestData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetTestData"]++;
        }
        ;
        /** @type {UCF_Control_TestData} */
        var o = {
            "properties": {},
            "methods": {},
            "client": {},
            "dom": {},
            "internals": {},
            "sClassName": this["sClassName"],
            "sControlId": this["sId"],
            "sBindingPath": '',
            "sBindingContextPath": '',
            "bClone": false
        };
        /** @type {Array<string>} */
        var aAttributeName;
        /** @type {Array<string>} */
        var aDomAttributes = [
            'offsetHeight', 'offsetWidth', 'offsetTop', 'offsetLeft', 'className',
            'tagName', 'title', 'value', 'scrollTop', 'scrollLeft'
        ];
        /** @type {Array<string>} */
        var aDomComputedStyleAttribtes = ['zIndex', 'visibility'];
        /** @type {Array<string>} */
        var aDomComputedStyleAttribteNames = ['z-index', 'visibility'];
        /** @type {number} */
        var i;
        /** @type {string} */
        var sName;
        /** @type {Array<string>} */
        var aPublicMethods;
        /** @type {Object} */
        var oValue;
        /** @type {string} */
        var sType;
        /** @type {CSSStyleDeclaration} */
        var cs;
        /** @type {UCF_ClientElement} */
        var oClientControl;
        /** @type {UCF_BindingContext} */
        var oBindingContext;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oMetadata;
        /** @type {Array<UCF_ClientInterfaces_Property>} */
        var aClientProperties;
        /** @type {string} */
        var n;

        if (this["aAttributeNames"]) {
            aAttributeName = this["aAttributeNames"]["concat"]([]);
            aAttributeName["sort"]();
            for (i = 0; i < aAttributeName["length"]; i++) {
                sName = aAttributeName[i];
                o["properties"][sName] = this[sName] + '';
            }
        }

        if (this["aPublicMethods"]) {
            aPublicMethods = this["aPublicMethods"]["concat"]([]);
            aPublicMethods["sort"]();

            for (i = 0; i < aPublicMethods["length"]; i++) {
                sName = aPublicMethods[i];

                // Avoid endless loop (This was one of my all-time-favorite bugs)
                if (sName !== 'oGetTestData' && sName !== 'getDisplayValue') {
                    if (
                        (sName["indexOf"]('get') === 0 || sName["indexOf"]('Get') === 1)
                        && this[sName]
                    ) {
                        try { // eslint-disable-line max-depth
                            oValue = this[sName]();
                        } catch (oEx) {
                            if (__UCF_TRACE__) {
                                UCF_Tracer.trace(DEBUG, 'Execution of method:' + sName + ' on ' + this["sClassName"] + ' caused an exception: ' + oEx["message"], "Control.js(3052): oGetTestData");
                            }
                            ;
                            continue;
                        }
                        sType = typeof oValue;
                        if ( // eslint-disable-line max-depth
                            sType === 'string' ||
                            sType === 'number' ||
                            sType === 'undefined'
                        ) {
                            o["methods"][sName] = oValue + '';
                        }
                    }
                }
            }
        }

        aDomAttributes["sort"]();
        if (this["oRootRef"] && this["oDomRef"] !== this["oRootRef"]) {
            for (i = 0; i < aDomAttributes["length"]; i++) {
                if (this["oRootRef"][aDomAttributes[i]] !== undefined) {
                    o["dom"]['RootRef.' + aDomAttributes[i]] =
                        this["oRootRef"][aDomAttributes[i]] + '';
                }
            }
            o["dom"]['RootRef.ct'] = this["oRootRef"]["getAttribute"]('ct');
            if (window["getComputedStyle"]) {
                cs = window["getComputedStyle"](this["oRootRef"]);

                for (i = 0; i < aDomComputedStyleAttribtes["length"]; i++) {
                    o["dom"]['RootRef.style.' + aDomComputedStyleAttribtes[i]] =
                        cs["getPropertyValue"](aDomComputedStyleAttribteNames[i]) + '';
                }
            }
        }
        if (this["oDomRef"]) {
            for (i = 0; i < aDomAttributes["length"]; i++) {
                if (this["oDomRef"][aDomAttributes[i]] !== undefined) {
                    o["dom"]['DomRef.' + aDomAttributes[i]] =
                        this["oDomRef"][aDomAttributes[i]] + '';
                }
            }
            o["dom"]['DomRef.ct'] = this["oDomRef"]["getAttribute"]('ct');
            if (window["getComputedStyle"]) {
                cs = window["getComputedStyle"](this["oDomRef"]);

                for (i = 0; i < aDomComputedStyleAttribtes["length"]; i++) {
                    o["dom"]['DomRef.style.' + aDomComputedStyleAttribtes[i]] =
                        cs["getPropertyValue"](aDomComputedStyleAttribteNames[i]) + '';
                }
            }
        }

        if (this["oGetParent"]()) {
            o["parent"] = this["oGetParent"]()["oGetTestData"]();
            o["methods"]['oGetParent.sGetId'] = this["oGetParent"]()["sGetId"]();
        }
        if (this["sClassName"] === 'UCF_DTElement' && this["oGetConnectedControl"]()) {
            o["dtcc"] = this["oGetConnectedControl"]()["oGetTestData"]();
        }
        if (this["bIsClone"]()) {
            o["bClone"] = true;
        }

        oClientControl = this["getClientControl"]();
        if (oClientControl) {
            oBindingContext = oClientControl["getBindingContext"]();
            if (oBindingContext) {
                o["oBindingContextObject"] = {
                    "sBindingContext": oBindingContext["getPath"](),
                    "sClassName": this["sClassName"],
                    "parent": o["parent"]["oBindingContextObject"]
                };
            }
            oMetadata = oClientControl["getMetadata"]();
            aClientProperties = [];
            for (n in oMetadata["properties"]) {
                aClientProperties["push"](n);
            }
            aClientProperties["sort"]();
            for (i = 0; i < aClientProperties["length"]; i++) {
                sName = aClientProperties[i];
                o["client"][sName] = {
                    "type": oMetadata["properties"][sName]["type"],
                    "value": oClientControl['get' + sName]() + ''
                };
            }
        }

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetTestData"] = 0;
    }
    ;

    /**
     * Returns the dom reference used for inplace edit with DTElement
     *
     * @return {HTMLElement} the dom reference used for inplace edit with DTElement
     */
    UCF_Control["prototype"]["oGetInplaceEditDomRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetInplaceEditDomRef"]++;
        }
        ;
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetInplaceEditDomRef"] = 0;
    }
    ;

    /**
     * Sets the text after a inplace edit
     * Controls need to implement this method.
     *
     * @param {string} sText The text to set
     */
    UCF_Control["prototype"]["setInplaceEditText"] = function (sText) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setInplaceEditText"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setInplaceEditText"] = 0;
    }
    ;

    /**
     * Gets the text for inplace edit in DT Elements.
     *
     * return {string} the text for inplace edit.
     */
    UCF_Control["prototype"]["sGetInplaceEditText"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["sGetInplaceEditText"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["sGetInplaceEditText"] = 0;
    }
    ;

    /**
     * Returns the parent scroll area dom reference if the control is inside a
     * ScrollArea.
     *
     * @private
     * @return {HTMLElement}
     */
    UCF_Control["prototype"]["oGetParentScrollAreaDomRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetParentScrollAreaDomRef"]++;
        }
        ;
        return UCF_DomUtil["oGetParentByAttribute"](
            this["oRootRef"] && this["oRootRef"]["parentNode"],
            'lsscrl',
            'true'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetParentScrollAreaDomRef"] = 0;
    }
    ;

    /**
     * Returns the parent control with a scroll area if this control is inside a
     * ScrollArea.
     *
     * @private
     * @return {UCF_Control}
     */
    UCF_Control["prototype"]["oGetParentScrollAreaControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetParentScrollAreaControl"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oParentSC = this["oGetParentScrollAreaDomRef"]();
        /** @type {HTMLElement} */
        var oAccContent;
        /** @type {HTMLElement} */
        var oAccHeader;

        if (oParentSC) {
            // Unfortunately we need a hack for the AccordionItem because the 'content'
            // is not part of the DOM of the control but a sibling element
            // (<TR ct='ACRI'>...header...</TR><TR tp='ACRIC'>...content...</TR>)
            oAccContent = UCF_DomUtil["oGetParentByAttribute"](oParentSC, 'tp', 'ACRIC');
            if (oAccContent) {
                oAccHeader = UCF_DomUtil["oGetPreviousSibling"](oAccContent, false);
                if (oAccHeader) {
                    return this["oGetControlByDomRef"](oAccHeader, true);
                }
            }

            if (oParentSC["getAttribute"] && oParentSC["getAttribute"]('ct')) {
                // The control root element is the scrollarea-element (e.g. SplitterCell)
                return this["oGetControlByDomRef"](oParentSC, true);
            } else {
                return this["oFindParent"](oParentSC);
            }
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetParentScrollAreaControl"] = 0;
    }
    ;

    /**
     * Returns whether the instance is a clone or not.
     *
     * @private
     * @return {boolean} Whether the instnace is a clone.
     */
    UCF_Control["prototype"]["bIsClone"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsClone"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oClientControl = this["getClientControl"]();

        return oClientControl ? oClientControl["isClone"]() : false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsClone"] = 0;
    }
    ;

    /**
     * Handles the tabsequencenext event. It will overrule tab-chain for Control
     * that implement lstabnext() and use Control.focusNextElement(). It is
     * currently not possible to overrule the tab-sequence inside containers that
     * implement lstabnext() but do NOT use Control.focusNextControl(), e.g.
     * SapTable.
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent the lstabsequencenext
     */
    UCF_Control["prototype"]["onlstabsequencenext"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlstabsequencenext"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oAE;
        /** @type {UCF_Control} */
        var oNextControl;
        /** @type {UCF_Control} */
        var oNextFocusable;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(3255): onlstabsequencenext");
        }
        ;

        oAE = UCF_DomUtil["oGetActiveElement"]();

        if (
            oAE === this["oDomRef"] ||
            oAE === this["oRootRef"] ||
            oAE === this["oFocusDomRef"]
        ) {
            oNextControl = this["processTabSequences"](true);
            if (oNextControl) {
                this["onBeforeLsTabSequenceNext"](oBrowserEvent);
                oNextControl["moveFocus"](false, /*backward=*/ false, /*external=*/ true);
            }

            oBrowserEvent["cancelBubble"]();

            oNextFocusable = this["oGetNextFocusableControlRecursive"](this["oRootRef"]);
            if (oNextFocusable == null) {
                oBrowserEvent["cancel"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlstabsequencenext"] = 0;
    }
    ;

    /**
     * Lifecycle hook that will be called when the focus has moved
     *
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent the lstabsequencenext
     */
    UCF_Control["prototype"]["onBeforeLsTabSequenceNext"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onBeforeLsTabSequenceNext"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onBeforeLsTabSequenceNext"] = 0;
    }
    ;

    /**
     * Handles the tabsequenceprevious event - see onlstabsequencenext().
     *
     * @private
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event object that occurred
     */
    UCF_Control["prototype"]["onlstabsequenceprevious"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onlstabsequenceprevious"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oAE;
        /** @type {UCF_Control} */
        var oPreviousControl;
        /** @type {UCF_Control} */
        var oPreviousFocusable;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Control.js(3303): onlstabsequenceprevious");
        }
        ;

        oAE = UCF_DomUtil["oGetActiveElement"]();

        if (
            oAE === this["oDomRef"] ||
            oAE === this["oRootRef"] ||
            oAE === this["oFocusDomRef"]
        ) {
            oPreviousControl = this["processTabSequences"](false);
            if (oPreviousControl) {
                this["onBeforeLsTabSequencePrevious"](oBrowserEvent);
                oPreviousControl["moveFocus"](false, /*backward=*/ true, /*external=*/ true);
            }

            oBrowserEvent["cancelBubble"]();

            oPreviousFocusable = this["oGetPreviousFocusableControlRecursive"](
                this["oRootRef"]
            );
            if (oPreviousFocusable == null) {
                oBrowserEvent["cancel"]();
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onlstabsequenceprevious"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oBrowserEvent the lstabsequenceprevious
     */
    UCF_Control["prototype"]["onBeforeLsTabSequencePrevious"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["onBeforeLsTabSequencePrevious"]++;
        }
        ;
        // abstract
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["onBeforeLsTabSequencePrevious"] = 0;
    }
    ;

    /**
     * determines whether the dom element of the given sId is tabable
     * @param {string} sId
     * @return {boolean}
     */
    UCF_Control["bIsTabbable"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsTabbable"]++;
        }
        ;
        var oDomRef;
        if (sId
            && UCF_StringUtil["bIsEmpty"](sId) === false
            && UCF_DomUtil["$"](sId)) {
            oDomRef = UCF_DomUtil["$"](sId);
        } else {
            return false;
        }
        return UCF_DomUtil["bIsVisible"](oDomRef, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsTabbable"] = 0;
    }
    ;

    /**
     * determines whether the id points to a focusable
     * dom element and finds the next focusable
     * unless not available, then it returns null
     * @param { Object } map
     * @param {string} sKey
     * @return {Control}
     */
    UCF_Control["prototype"]["oFindNextTabbable"] = function (map, sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oFindNextTabbable"]++;
        }
        ;
        /** @type {string} */
        var sValue;
        /** @type {UCF_Control} */
        var oNextTabbable = null;

        if (map[sKey]) {
            sValue = map[sKey];
            if (UCF_Control["bIsTabbable"](sValue)) {
                return this["oLS"]["oControlFactory"]["oGetControlById"](sValue);
            } else {
                oNextTabbable = this["oFindNextTabbable"](map, sValue);
            }
        }
        return oNextTabbable;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oFindNextTabbable"] = 0;
    }
    ;

    /**
     * Find a previous or next control based on the defined TabSequences
     * @private
     * @param {boolean} bForward
     * @return {UCF_Control}
     */
    UCF_Control["prototype"]["processTabSequences"] = function (bForward) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["processTabSequences"]++;
        }
        ;
        /** @type {Object<string,string>} */
        var mSequences = this["oLS"]["oBrowserWindow"]["mTabSequences"];
        /** @type {string} */
        var n;

        // -- navigation logic that finds suceeding element
        if (mSequences) {
            for (n in mSequences) {
                if (bForward === true && n["indexOf"]('_shift') === -1 ||
                    bForward === false && n["indexOf"]('_shift') > -1) {
                    return this["oFindNextTabbable"](mSequences[n], this["sId"]);
                }
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["processTabSequences"] = 0;
    }
    ;

    /**
     * Checks whether this control's ID is contained in an external tab-sequence.
     *
     * @return {boolean} `true` if this controls ID is contained in an external
     * tab-sequence.
     */
    UCF_Control["prototype"]["bIsContainedInTabSequence"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsContainedInTabSequence"]++;
        }
        ;
        /** @type {Object<string,string>} */
        var mSequences = this["oLS"]["oBrowserWindow"]["mTabSequences"];
        /** @type {string} */
        var n;

        if (mSequences) {
            for (n in mSequences) {
                if (mSequences[n][this["sId"]]) {
                    return true;
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsContainedInTabSequence"] = 0;
    }
    ;

    /**
     * Returns an array of contained UCF_Control or UCF_ControlInfo (sub-controls)
     * within this control. Uses querySelectorAll(): The spec. states that the
     * order is "a depth-first pre-order traversal of the DOM tree or subtree in
     * question"
     *
     * @private
     * @param {function(UCF_ControlInfo): boolean} [fCallBack] function called for
     * each control before added to the list, can return true to insert, false
     * ignore the child control.
     * @return {Array<UCF_Control|UCF_ControlInfo>} The array of contained
     * UCF_Control or UCF_ControlInfo (sub-controls) within this control.
     */
    UCF_Control["prototype"]["aGetContainedControls"] = function (fCallBack) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["aGetContainedControls"]++;
        }
        ;
        /** @type {Array<UCF_Control|UCF_ControlInfo>} */
        var aResult = [];
        /** @type {HTMLElement} */
        var oRoot = this["oRootRef"];
        /** @type {NodeList} */
        var aContainedControls;
        /** @type {number} */
        var i;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {UCF_Control} */
        var oParentControl;
        /** @type {UCF_ControlInfo} */
        var oControlInfo;

        // Workaround Part 1:
        // Unfortunately PopupMenus are sometimes rendered outside of the page,
        // into the body (e.g. button-menus in ITS) and so
        // UCF_LS.oGetControlByCustomData(), which uses this function, would not
        // return them...
        if (this["sClassName"] === 'UCF_Page') {
            oRoot = document["body"];
        }

        if (oRoot) {
            aContainedControls = oRoot["querySelectorAll"]
                ? oRoot["querySelectorAll"]('*[lsdata]')
                : oRoot["getElementsByTagName"]('*');

            for (i = 0; i < aContainedControls["length"]; i++) {
                if (
                    oRoot["querySelectorAll"] ||
                    UCF_DomUtil["sGetAttribute"](aContainedControls[i], 'lsdata')
                ) {
                    oDomRef = aContainedControls[i];
                    // Workaround Part 2: Ignore System control outside of page...
                    if (
                        this["sClassName"] !== 'UCF_Page' ||
                        oDomRef["getAttribute"]('ct') !== 'SY'
                    ) {
                        oControl = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](
                            oDomRef,
                            true
                        );
                        if (!oControl) { // eslint-disable-line max-depth
                            oParentControl = this["oLS"]["oGetControlByDomRef"](oDomRef);

                            if (oParentControl) { // eslint-disable-line max-depth
                                oControlInfo = oParentControl["oGetContainedControlInfo"](oDomRef);

                                if ( // eslint-disable-line max-depth
                                    oControlInfo &&
                                    (!fCallBack || (fCallBack && fCallBack(oControlInfo)))
                                ) {
                                    aResult["push"](oControlInfo);
                                }
                            }
                        }

                        if ( // eslint-disable-line max-depth
                            oControl &&
                            oControl !== this &&
                            (!fCallBack || (fCallBack && fCallBack(oControl)))
                        ) {
                            aResult["push"](oControl);
                        }
                    }
                }
            }
        }

        return aResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["aGetContainedControls"] = 0;
    }
    ;

    /**
     * Returns a ControlInfo object for the given dom ref if the dom ref is a sub
     * control. The control info should contain the lsdata that has client access.
     * To be overwritten by the control that likes to return a control info based
     * on a dom ref contained in the control
     *
     * @private
     * @param {HTMLElement} oDomRef the element
     * @return {UCF_ControlInfo} The ControlInfo of a contained sub element within
     * this control.
     */
    UCF_Control["prototype"]["oGetContainedControlInfo"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetContainedControlInfo"]++;
        }
        ;
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetContainedControlInfo"] = 0;
    }
    ;

    /**
     * @private
     * @param {boolean} bHidden `true` to set the element to DTHidden
     */
    UCF_Control["prototype"]["setDTHidden"] = function (bHidden) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setDTHidden"]++;
        }
        ;
        this["bDTHidden"] = bHidden;
        if (this["oRootRef"]) {
            this["oRootRef"]["style"]["opacity"] = bHidden ? '0.3' : '1';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setDTHidden"] = 0;
    }
    ;

    /**
     * Returns the default implementation of UCF_DTExtension. A control may return
     * an object that provides more specific extension. If the extension returns
     * true in the bIsDelegate method the extension is registered as a delegate and
     * gets informed about all events on th DTElement instance.
     *
     * @private
     * @param {UCF_DTElement} oDTElement The DTElement for this control.
     * @param {function(new:UCF_Control)} oClass
     * @return {UCF_DTExtension}
     */
    UCF_Control["prototype"]["oGetDTExtension"] = function (oDTElement, oClass) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetDTExtension"]++;
        }
        ;
        if (this["oDTExtension"] == null || this["oDTExtension"]["bDestroyed"]) {
            this["oDTExtension"] = new (
                oClass ||
                UCF_ClassLoader["oGetClass"]('UCF_DTExtension')
            )(
                this["oLS"],
                this,
                oDTElement
            );

            if (this["oDTExtension"]["bIsDelegate"]() && oDTElement) {
                oDTElement["addDelegate"](this["oDTExtension"]);
            }
        }

        return this["oDTExtension"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetDTExtension"] = 0;
    }
    ;

    /**
     * Returns the design-time extension of another control or sub-control with the
     * given ID.
     *
     * @private
     * @param {string} sId A valid ID of a DOM element that represents a control or
     * sub-control.
     * @param {UCF_DTElement} oDTElement The DTElement for this control.
     * @return {UCF_DTExtension} The design-time extension implementation that was
     * found or null.
     */
    UCF_Control["prototype"]["oGetDTExtensionForId"] = function (sId, oDTElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetDTExtensionForId"]++;
        }
        ;
        /** @type {UCF_Control} */
        var c = this["oGetControlById"](sId);
        /** @type {HTMLElement} */
        var o;

        if (c == null) {
            o = UCF_DomUtil["$"](sId);
            if (o && o["getAttribute"]('subct')) {
                c = this["oFindParent"](o);
            }
        }

        return c ? c["oGetDTExtension"](oDTElement) : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetDTExtensionForId"] = 0;
    }
    ;

    /**
     * Generic handler of the visibility change event. This event is fired on each
     * child control if a parent gets invisible. To be overwritten for controls
     * that have popupmenu of picker controls open while the parent gets invisible.
     *
     * @see UCF_ClientInterfaces.E.Visibility
     * @param {string} sVisibility the new visibility
     */
    UCF_Control["prototype"]["changeVisibility"] = function (sVisibility) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["changeVisibility"]++;
        }
        ;
        if (sVisibility !== 'VISIBLE') {
            this["removeRichTooltip"]();
            this["removeDataTip"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["changeVisibility"] = 0;
    }
    ;

    /**
     * Sets the visibility for a control
     *
     * @see UCF_ClientInterfaces.E.Visibility
     * @public
     * @param {string} sVisibility The visibility of the control
     */
    UCF_Control["prototype"]["setVisibility"] = function (sVisibility) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setVisibility"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oActiveElement = UCF_DomUtil["oGetActiveElement"]();
        /** @type {Array<UCF_Control>} */
        var aChildren;
        /** @type {number} */
        var i;
        /** @type {UCF_Control} */
        var oChild;

        if (oActiveElement && UCF_DomUtil["bContains"](this["oRootRef"], oActiveElement)) {
            this["focusNextControl"]();
        }

        // inform the children about the visibility change
        aChildren = this["aGetContainedControls"]();
        for (i = 0; i < aChildren["length"]; i++) {
            oChild = aChildren[i];
            if (oChild !== this && oChild["changeVisibility"]) {
                oChild["changeVisibility"](sVisibility);
            }
        }

        this["changeVisibility"](sVisibility);
        UCF_DomUtil["setVisibility"](this["oRootRef"], sVisibility);
        this["sVisibility"] = sVisibility;
        this["setClientProperty"]('Visibility', sVisibility, true);

        this["oLS"]["fireEvent"](this["oLS"]["E_EVENTS"]["ControlVisibilityChange"], {
            "sId": this["sId"],
            "sVisibility": sVisibility
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setVisibility"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sSavedStyleAttribute
     */
    UCF_Control["prototype"]["intializeInvisibilityAfterRerendering"] = function (sSavedStyleAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["intializeInvisibilityAfterRerendering"]++;
        }
        ;
        this["sSavedStyleAttribute"] = sSavedStyleAttribute;
        this["bInvisibility"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["intializeInvisibilityAfterRerendering"] = 0;
    }
    ;

    /**
     * bSwitch=true: Control is rendered in DOM with visibility:hidden but the root
     * element is modified so that it will also take mininmal or no space in the
     * page. This way it is looks like display:none but Designtime is still able to
     * calculate the position by calling UCF_DomUtil.oGetObjectRect().
     *
     * bSwitch=false: Back to normal rendering.
     *
     * This is a generic default implementation that can be overwritten by a
     * control class.
     *
     * @param {boolean} bSwitch `true` to make invisible, `false` to restore
     * @param {boolean} bKeepWidth
     */
    UCF_Control["prototype"]["setInvisibility"] = function (bSwitch, bKeepWidth) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setInvisibility"]++;
        }
        ;
        /** @type {string} */
        var sCurrentDisplay;
        /** @type {UCF_ClientElement} */
        var oClientControl;
        /** @type {string} */
        var sWidth;
        /** @type {UCF_Control} */
        var oParent;

        if (bSwitch && this["bAncestorInvisible"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Ancestor control is already in invisibility mode, id=' + this["sId"], "Control.js(3687): setInvisibility");
            }
            ;
        }

        if (bSwitch && !this["sSavedStyleAttribute"]) {
            this["sSavedStyleAttribute"] = this["oRootRef"]["style"]["cssText"] + ' ';
        }
        // BLANK: visibility:hidden, display:''
        this["setVisibility"](bSwitch ? 'BLANK' : 'VISIBLE');

        oClientControl = this["getClientControl"]();
        if (oClientControl) {
            oClientControl["setInvisibility"](bSwitch, bKeepWidth, true);
        }
        if (bSwitch) {
            sCurrentDisplay = UCF_DomUtil["sGetCurrentStyle"](this["oRootRef"], 'display');
            sWidth = bKeepWidth ? this["oRootRef"]["offsetWidth"] + 'px' : '0px';

            this["oRootRef"]["style"]["cssText"] = /inline/["test"](sCurrentDisplay)
                ? 'overflow:hidden!important;width:' + sWidth + ';height:0;padding:0!important;display:inline-block!important'
                : 'overflow:hidden!important;width:' + sWidth + ';height:0;padding:0!important;display:block!important';
            this["bInvisibility"] = true;

            // Note: depends on traversal algorithm in aGetContainedControls() - must
            // visit parents first
            UCF_JsUtil["forEach"](this["aGetContainedControls"](), function (oChild) {
                oChild["bAncestorInvisible"] = true;
            });
        } else {
            if (this["sSavedStyleAttribute"]) {
                this["oRootRef"]["style"]["cssText"] = this["sSavedStyleAttribute"];
            }
            this["bInvisibility"] = false;
            this["sSavedStyleAttribute"] = null;

            oParent = this["oGetParent"]();
            UCF_JsUtil["forEach"](this["aGetContainedControls"](), function (oChild) {
                oChild["bAncestorInvisible"] =
                    oParent["bInvisibility"] || oParent["bAncestorInvisible"];
            });
        }

        this["oLS"]["fireEvent"](this["oLS"]["E_EVENTS"]["InvisibilityChanged"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setInvisibility"] = 0;
    }
    ;

    /**
     * @see #setInvisibility()
     * @return {boolean}
     */
    UCF_Control["prototype"]["bGetInvisibility"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bGetInvisibility"]++;
        }
        ;
        return this["bInvisibility"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bGetInvisibility"] = 0;
    }
    ;

    /**
     * Returns whether the ancestor is visible
     * @return {boolean}
     */
    UCF_Control["prototype"]["bIsAncestorInvisible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsAncestorInvisible"]++;
        }
        ;
        return this["bAncestorInvisible"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsAncestorInvisible"] = 0;
    }
    ;

    /**
     * Determines whether the control has event listeners for a given semantic
     * event handler name
     *
     * @param {string} sEvent The name of the semantic event handler
     * @return {boolean} true if there are listeners attached to this semantic event
     */
    UCF_Control["prototype"]["bHasEventListeners"] = function (sEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bHasEventListeners"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oClientControl = this["getClientControl"]();

        return ( // server side listeners
                this["mEvents"] &&
                (this["mEvents"][sEvent] || this["hasListeners"]('SemanticEvent.' + sEvent))
            ) || // client side listeners
            (oClientControl && oClientControl["hasListeners"](sEvent));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bHasEventListeners"] = 0;
    }
    ;

    /**
     * Returns a sub control of the controls for the given dom ref
     * To be implemented for controls that contain sub controls
     *
     * @private
     * @param {HTMLElement} oDomRef the dom ref
     * @return {UCF_ControlInfo} a sub control of the controls for the given dom ref else null
     */
    UCF_Control["prototype"]["oGetSubControlByDomRef"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetSubControlByDomRef"]++;
        }
        ;
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetSubControlByDomRef"] = 0;
    }
    ;

    /**
     * Convenience function to get a sub-control instance for any given ID
     * @return {UCF_ControlInfo} The sub-control instance if available
     * @param {string} sId ID of a DOM reference of a sub-control of any control (not just this instance)
     */
    UCF_Control["prototype"]["oGetSubControl"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetSubControl"]++;
        }
        ;
        var oResult = null;
        var oDomRef = UCF_DomUtil["$"](sId);
        var oControl;

        if (oDomRef) {
            oControl = this["oFindParent"](oDomRef);

            if (oControl) {
                oResult = oControl["oGetContainedControlInfo"](oDomRef);
            }
        }

        return oResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetSubControl"] = 0;
    }
    ;

    /**
     * Activates native browser dragging by setting draggable attribute
     *
     * @private
     */
    UCF_Control["prototype"]["setDraggable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["setDraggable"]++;
        }
        ;
        /** @type {UCF_DragSourceInfo} */
        var oDragSourceInfo;

        if (this["sDragSourceInfo"]) {
            oDragSourceInfo = this["oLS"]["oControlFactory"]["oGetControlById"](
                this["sDragSourceInfo"]
            );

            if (oDragSourceInfo && oDragSourceInfo["bBrowserDragDrop"]) {
                this["bDraggable"] = true;
                this["oRootRef"]["setAttribute"]('draggable', true);
                // eslint-disable-next-line no-magic-numbers
                this["oRootRef"]["setAttribute"]('iDDThreshold', 10000);
                this["oRootRef"]["ondragstart"] = null;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["setDraggable"] = 0;
    }
    ;

    /** */
    UCF_Control["prototype"]["showLayoutRect"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["showLayoutRect"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oLayoutPosRect;
        /** @type {HTMLDivElement} */
        var oPos;
        /** @type {HTMLDivElement} */
        var oTopLeftCornerRef;
        /** @type {HTMLDivElement} */
        var oTopRightCornerRef;
        /** @type {HTMLDivElement} */
        var oBottomRightCornerRef;
        /** @type {HTMLDivElement} */
        var oBottomLeftCornerRef;
        /** @type {HTMLDivElement} */
        var oLayoutRectSpacerRef;
        /** @type {_ObjectRect} */
        var oRect;
        /** @type {HTMLDivElement} */
        var oPadRect;
        /** @type {CSSStyleDeclaration} */
        var oComputedStyle;

        if (UCF_Control["oLayoutRectControl"] !== this && this["bIsVisible"]()) {
            oLayoutPosRect = UCF_DomUtil["$"]('ls-control-layout-rect');

            if (!oLayoutPosRect) {
                oPos = document["createElement"]('DIV');

                oPos["setAttribute"]('id', 'ls-control-layout-rect');
                UCF_DomUtil["setStyle"](oPos, {
                    "boxSizing": 'border-box',
                    "position": 'absolute',
                    "visibility": 'hidden',
                    "top": '-1000px'
                });
                oLayoutPosRect = oPos;

                oTopLeftCornerRef = document["createElement"]('div');
                UCF_DomUtil["addClass"](oTopLeftCornerRef, 'lsDTParentCorner');
                UCF_DomUtil["setStyle"](oTopLeftCornerRef, {
                    "borderStyle": 'dotted none none dotted',
                    "top": 0,
                    "left": 0
                });
                oPos["appendChild"](oTopLeftCornerRef);

                oTopRightCornerRef = document["createElement"]('div');
                UCF_DomUtil["addClass"](oTopRightCornerRef, 'lsDTParentCorner');
                UCF_DomUtil["setStyle"](oTopRightCornerRef, {
                    "borderStyle": 'dotted dotted none none',
                    "top": 0,
                    "right": 0
                });
                oPos["appendChild"](oTopRightCornerRef);

                oBottomRightCornerRef = document["createElement"]('div');
                UCF_DomUtil["addClass"](oBottomRightCornerRef, 'lsDTParentCorner');
                UCF_DomUtil["setStyle"](oBottomRightCornerRef, {
                    "borderStyle": 'none dotted dotted none',
                    "bottom": 0,
                    "right": 0
                });
                oPos["appendChild"](oBottomRightCornerRef);

                oBottomLeftCornerRef = document["createElement"]('div');
                UCF_DomUtil["addClass"](oBottomLeftCornerRef, 'lsDTParentCorner');
                UCF_DomUtil["setStyle"](oBottomLeftCornerRef, {
                    "borderStyle": 'none none dotted dotted',
                    "bottom": 0,
                    "left": 0
                });
                oPos["appendChild"](oBottomLeftCornerRef);

                oLayoutRectSpacerRef = document["createElement"]('div');
                oLayoutRectSpacerRef["id"] = 'ls-control-layout-rect-pad';
                UCF_DomUtil["addClass"](oLayoutRectSpacerRef, 'lsDTParentPadding');
                oPos["appendChild"](oLayoutRectSpacerRef);

                (this["oLS"]["oGetStaticAreaRef"]() || document["body"])["appendChild"](oPos);
            }

            this["oRootRef"]["getClientRects"]();
            oRect = this["oGetObjectRect"](this["oRootRef"]);
            oLayoutPosRect["style"]["display"] = '';
            oLayoutPosRect["style"]["top"] = (oRect["top"]) + 'px';
            oLayoutPosRect["style"]["left"] = (oRect["left"]) + 'px';
            oLayoutPosRect["style"]["width"] = (oRect["width"]) + 'px';
            oLayoutPosRect["style"]["height"] = (oRect["height"]) + 'px';

            // highlight paddings
            oPadRect = UCF_DomUtil["$"]('ls-control-layout-rect-pad');
            oComputedStyle = UCF_DomUtil["oGetComputedStyle"](this["oRootRef"]);
            UCF_DomUtil["setStyle"](oPadRect, {
                "borderLeftWidth": oComputedStyle["paddingLeft"],
                "borderRightWidth": oComputedStyle["paddingRight"],
                "borderTopWidth": oComputedStyle["paddingTop"],
                "borderBottomWidth": oComputedStyle["paddingBottom"],
                "visibility": 'visible'
            });

            UCF_Control["oLayoutRectControl"] = this;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["showLayoutRect"] = 0;
    }
    ;

    /** */
    UCF_Control["prototype"]["hideLayoutRect"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["hideLayoutRect"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oLayoutPosRect = UCF_DomUtil["$"]('ls-control-layout-rect');

        if (oLayoutPosRect) {
            UCF_DomUtil["setStyle"](oLayoutPosRect, {
                "visibility": 'hidden',
                "display": 'none'
            });
        }

        UCF_Control["oLayoutRectControl"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["hideLayoutRect"] = 0;
    }
    ;

    /**
     * Returns the display value of the control
     *
     * @return {string}
     */
    UCF_Control["prototype"]["getDisplayValue"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getDisplayValue"]++;
        }
        ;
        return UCF_DomUtil["sGetVisibleTextContent"](this["oDomRef"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getDisplayValue"] = 0;
    }
    ;

    /**
     * Returns the surrounding PopupWindow control or null.
     * This function works for IFrame- and DIV-PopupWindow.
     * @param {HTMLElement} [oDomRef=this.oRootRef] the element to get the parent
     * popup window for
     * @return {UCF_PopupWindow} The parent popup instance or null
     */
    UCF_Control["prototype"]["oGetParentPopupWindow"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetParentPopupWindow"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oPopupWindowDomRef;
        /** @type {HTMLDivElement} */
        var oPageDomRef;
        /** @type {UCF_Page} */
        var oPage;
        /** @type {UCF_PopupWindow} */
        var oPopupWindow;

        if (this["oLS"]) {
            oPopupWindowDomRef = UCF_DomUtil["oGetParentByAttribute"](
                oDomRef || this["oRootRef"],
                'ct',
                'PW'
            );
            if (!oPopupWindowDomRef) {
                oPage = this["oLS"]["oGetPageInternal"]();

                if (oPage) {
                    oPageDomRef = oPage["oDomRef"];

                    if (oPageDomRef) {
                        oPopupWindowDomRef = UCF_DomUtil["oGetFirstElement"](oPageDomRef);

                        // eslint-disable-next-line max-depth
                        if (oPopupWindowDomRef["getAttribute"]('ct') !== 'PW') {
                            return null;
                        }
                    }
                }
            }

            if (oPopupWindowDomRef) {
                oPopupWindow = this["oGetControlByDomRef"](oPopupWindowDomRef, false);
                if (oPopupWindow) {
                    return oPopupWindow;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetParentPopupWindow"] = 0;
    }
    ;

    /**
     * Returns true if the given element is contained in the content of a PopupWindow.
     * In contrast to `UCF_Control.oGetParentPopupWindow()`, this function also
     * works during the constructor/initialize phase of an update, when the DOM
     * exists but the PopupWindow instance might not exist yet (because it is
     * created and initialized after this control)
     *
     * @param {HTMLElement} [oDomRef=this.oRootRef] the element to inspect
     * @return {boolean} `true` if this control is contained in the content of a
     * PopupWindow.
     */
    UCF_Control["prototype"]["bHasParentPopupWindow"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bHasParentPopupWindow"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oPopupWindowDomRef;
        /** @type {UCF_Page} */
        var oPage;
        /** @type {HTMLDivElement} */
        var oPageDomRef;

        if (this["oLS"]) {
            oPopupWindowDomRef = UCF_DomUtil["oGetParentByAttribute"](
                oDomRef || this["oRootRef"],
                'ct',
                'PW'
            );

            if (oPopupWindowDomRef) {
                return true;
            } else {
                oPage = this["oLS"]["oGetPageInternal"]();

                if (oPage) {
                    oPageDomRef = oPage["oDomRef"];

                    if (oPageDomRef) {
                        oPopupWindowDomRef = UCF_DomUtil["oGetFirstElement"](oPageDomRef);

                        // eslint-disable-next-line max-depth
                        if (oPopupWindowDomRef["getAttribute"]('ct') !== 'PW') {
                            return false;
                        }
                    }
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bHasParentPopupWindow"] = 0;
    }
    ;

    /**
     * @private
     * @return {string}
     */
    UCF_Control["prototype"]["getConditionValue"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getConditionValue"]++;
        }
        ;
        /** @type {string} */
        var sCFValue = this["getCustomData"]('CFValue');

        return sCFValue || this["getDisplayValue"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getConditionValue"] = 0;
    }
    ;

    /**
     * @private
     */
    UCF_Control["prototype"]["removeConditionalStyles"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["removeConditionalStyles"]++;
        }
        ;
        /** @type {string} */
        var sClassPrefix = 'CFS' + this["sClassName"]["substring"]('UCF_'["length"]);

        UCF_DomUtil["setClass"](
            this["oRootRef"],
            UCF_JsUtil["filter"](
                UCF_DomUtil["sGetClass"](this["oRootRef"])["split"](' '),
                function (sClass) {
                    return !UCF_StringUtil["bStartsWith"](sClass, sClassPrefix);
                }
            )["join"](' ')
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["removeConditionalStyles"] = 0;
    }
    ;

    /**
     * @private
     * @param {{rules: string[]}} mControlRuleOptions
     * @param {Object<string, UCF_Control_ConditionalStyleRule>} mConditionalRules
     * @return {UCF_Control_ConditionalStyle[]}
     */
    UCF_Control["prototype"]["getMatchingConditionalStyles"] = function (mControlRuleOptions, mConditionalRules) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["getMatchingConditionalStyles"]++;
        }
        ;
        /** @type {UCF_Control_ConditionalStyle[]} */
        var aMatchingStyles = [];
        /** @type {string} */
        var sClassPrefix = 'CFS' + this["sClassName"]["substring"]('UCF_'["length"]);
        /** @type {string} */
        var sSeparation = '';
        /** @type {string} */
        var sClass;
        /** @type {Array<UCF_Control_ConditionalStyleRule>} */
        var aRules;
        /** @type {Array<UCF_Control_ConditionalStyleRule>} */
        var aMatchingRules;
        /** @type {Array<string>} */
        var aMatchingRuleNames;
        /** @type {number} */
        var i;
        /** @type {UCF_Control_ConditionalStyleRule} */
        var oRule;
        /** @type {UCF_Control_ConditionalStyle} */
        var oStyle;

        this["removeConditionalStyles"]();

        sClass = UCF_DomUtil["sGetClass"](this["oRootRef"]);
        if (!UCF_StringUtil["bContains"](sClass, ' CFS') &&
            !UCF_StringUtil["bContains"](sClass, 'CFS ')
        ) {
            // the custom style class is not part of the root element, need to create
            // casade
            sSeparation = ' ';
        }

        if (mControlRuleOptions["rules"]) {
            aRules = mControlRuleOptions["rules"];
            aMatchingRules = [];
            aMatchingRuleNames = [];

            for (i = 0; i < aRules["length"]; i++) {
                oRule = mConditionalRules[aRules[i]];

                if (oRule) {
                    oRule["name"] = aRules[i];

                    if (!oRule["func"]) {
                        // create a function for match on the fly
                        oRule["func"] = function (sValue) {
                            return UCF_JsUtil["eval"]('return ' + oRule["match"], {
                                "value": sValue
                            });
                        };
                    }
                    if (oRule["func"](this["getConditionValue"]())) {
                        //store the matching rule
                        aMatchingRules["push"](oRule);
                        aMatchingRuleNames["push"](oRule["name"]);
                        UCF_DomUtil["addClass"](this["oRootRef"], sClassPrefix + oRule["name"]);
                    }
                }
            }

            for (i = 0; i < aMatchingRules["length"]; i++) {
                oRule = aMatchingRules[i];
                oStyle = {
                    "customStyle": 'CFS',
                    "classPrefix": '.' + sClassPrefix + oRule["name"] + sSeparation,
                    "type": this["sClassName"]["substring"]('UCF_'["length"]),
                    "variables": oRule["style"]
                };
                if (!oRule["mStyles"]) {
                    oRule["mStyles"] = {};
                }
                oRule["mStyles"][oStyle["classPrefix"]] = oStyle;
                aMatchingStyles["push"](oStyle);
            }
            this["oRootRef"]["setAttribute"]('CFR', aMatchingRuleNames["join"](' '));
        }

        return aMatchingStyles;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["getMatchingConditionalStyles"] = 0;
    }
    ;

    /**
     * Shows the boundaries of the control
     * @param {map} mStyles optional map of css styles {backgroundColor:"red"}
     * @param {map} sClassName optional map of css styles {backgroundColor:"red"}
     * @param {int} iOffset Additional offset to be added surrounding the element.
     * @public
     *
     */
    UCF_Control["prototype"]["showBoundaries"] = function (mStyles, sClassName, iOffset) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["showBoundaries"]++;
        }
        ;
        this["oLS"]["highlightBoundaries"](this["oRootRef"], mStyles, sClassName, iOffset);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["showBoundaries"] = 0;
    }
    ;

    /**
     * Hide the boundaries of the control
     */
    UCF_Control["prototype"]["hideBoundaries"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["hideBoundaries"]++;
        }
        ;
        this["oLS"]["highlightBoundaries"](null);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["hideBoundaries"] = 0;
    }
    ;

    /**
     * Returns the current control height of root DOM ref in pixel
     *
     * @return {number}
     */
    UCF_Control["prototype"]["iGetWidthPx"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["iGetWidthPx"]++;
        }
        ;
        return this["oRootRef"]["offsetWidth"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["iGetWidthPx"] = 0;
    }
    ;

    /**
     * Returns the current control width of root DOM ref in pixel
     *
     * @return {number}
     */
    UCF_Control["prototype"]["iGetHeightPx"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["iGetHeightPx"]++;
        }
        ;
        return this["oRootRef"]["offsetHeight"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["iGetHeightPx"] = 0;
    }
    ;

    /**
     * Prepare ARIA for Controls in SAPTable
     * @param {Object} oBrowserEvent
     * @return {boolean}
     */
    UCF_Control["prototype"]["bPrepareAria"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bPrepareAria"]++;
        }
        ;
        /** @type {NodeList} */
        var aSiblings;
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oSapTableInfo;

        if (this["bNeedsAriaGeneric"] === undefined) {
            this["bNeedsAriaGeneric"] = false;

            oSapTableInfo = this["oInSapTable"]();
            if (oSapTableInfo) {
                this["bNeedsAriaGeneric"] = true;

                if (
                    this["oDomRef"]["getAttribute"]('role') != null
                ) {

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, this["sClassName"] + ' "' + this["sId"] + '" does not implement bPrepareAria.', "Control.js(4228): bPrepareAria");
                    }
                    ;

                    UCF_Control["addAriaGeneric"](this["oDomRef"], oSapTableInfo);

                    return true;
                }

                if (this["sClassName"]["indexOf"]('UCF_SapTable') === 0) {
                    UCF_Control["addAriaGeneric"](this["oDomRef"]);
                }

                aSiblings = this["oDomRef"]["parentNode"]["childNodes"];
                for (i = 0; i < aSiblings["length"]; i++) {
                    if (
                        aSiblings[i]["getAttribute"] &&
                        aSiblings[i]["getAttribute"]('role') != null
                    ) {
                        UCF_Control["addAriaGeneric"](aSiblings[i], oSapTableInfo);

                        return true;
                    }
                }
            }
        }

        return this["bNeedsAriaGeneric"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bPrepareAria"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {HTMLElement} oRef the element
     * @param {Object} oSapTableInfo
     */
    UCF_Control["addAriaGeneric"] = function (oRef, oSapTableInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["addAriaGeneric"]++;
        }
        ;
        /** @type {string} */
        var sOldDescribedBy = oRef["getAttribute"]('aria-describedby');

        oRef["setAttribute"](
            'aria-describedby',
            (sOldDescribedBy && sOldDescribedBy !== '')
                ? sOldDescribedBy + ' ARIA_GENERIC'
                : 'ARIA_GENERIC'
        );

        if (oSapTableInfo && oSapTableInfo["bValidIndexes"] === true) {
            oRef["setAttribute"]('aria-colindex', oSapTableInfo["iColIndex"]);
            oRef["setAttribute"]('aria-rowindex', oSapTableInfo["iRowIndex"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["addAriaGeneric"] = 0;
    }
    ;

    /**
     * roughly `this.bEnabled && !this.bReadonly`
     * @return {boolean}
     */
    UCF_Control["prototype"]["bIsWriteable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsWriteable"]++;
        }
        ;
        /** @type {'boolean'} */
        var sBoolean = 'boolean'; // once sBoolean gets mangled, this is shorter

        if (typeof this["bEnabled"] === sBoolean) {
            if (this["bEnabled"]) {
                if (typeof this["bReadonly"] === sBoolean) {
                    return !this["bReadonly"];
                } else if (typeof this["bReadOnly"] === sBoolean) {
                    return !this["bReadOnly"];
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (typeof this["bReadonly"] === sBoolean) {
            return !this["bReadonly"];
        } else if (typeof this["bReadOnly"] === sBoolean) {
            return !this["bReadOnly"];
        } else if (typeof this["sInterAction"] === 'string') {
            return this["sInterAction"] === 'ENABLED';
        } else {
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsWriteable"] = 0;
    }
    ;

    /**
     * Check for Controls in SAPTable
     * @return {boolean}
     */
    UCF_Control["prototype"]["bIsInSaptable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsInSaptable"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oParent;

        if (
            this["bUsedInSapTable"] ||
            UCF_StringUtil["bStartsWith"](this["sClassName"], 'UCF_SapTable')
        ) {
            return true;
        }

        oParent = this; // eslint-disable-line consistent-this

        while ((oParent = oParent["oGetParent"]()) != null) {
            if (
                UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_SapTable') ||
                UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_DataGridSegment') ||
                oParent["sClassName"] === 'DGSC'
            ) {
                return true;
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsInSaptable"] = 0;
    }
    ;

    /**
     * Check for Controls in SAPTable and return colindex, rowindex
     * @return {boolean}
     */

    UCF_Control["prototype"]["oInSapTable"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oInSapTable"]++;
        }
        ;
        var oParent = this; // eslint-disable-line consistent-this

        if (UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_SapTable') ||
            UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_DataGrid')) {
            return {"bValidIndexes": false};
        }
        if (
            this["oGetParent"]() &&
            this["oGetParent"]()["sClassName"] === 'UCF_Toolbar'
        ) {
            return false;
        }

        while ((oParent = oParent["oGetParent"]()) != null) {
            if (UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_SapTable')) {
                //adjust rowIndex to native JAWS calculation
                if (window["UCF_System"]["sAccessibility"] === 'ARIA1.1') {
                    var iColOffset = oParent["bHasLeadingSelectionColumn"]() ? 1 : 0;
                    var iRowOffset = oParent["bHasHeaderRow"]() ? 1 : 0;
                    return {
                        "bValidIndexes": true,
                        "iColIndex": oParent["mCellInfoMatrixHeadData"]["iFocussedCellColIndex"] + iColOffset,
                        "iRowIndex": oParent["mCellInfoMatrixHeadData"]["iFocussedCellRowIndex"] + iRowOffset
                    };
                } else {
                    return {
                        "bValidIndexes": true,
                        "iColIndex": oParent["mCellInfoMatrixHeadData"]["iFocussedCellColIndex"],
                        "iRowIndex": oParent["mCellInfoMatrixHeadData"]["iFocussedCellRowIndex"]
                    };
                }
            } else if (UCF_StringUtil["bStartsWith"](oParent["sClassName"], 'UCF_DataGridSegment') ||
                oParent["sClassName"] === 'DGSC') {
                return {
                    "bValidIndexes": false
                };
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oInSapTable"] = 0;
    }
    ;

    /**
     * @protected
     * @return {boolean} `true` if the control text is selected (by the user),
     * `false` otherweise
     */
    UCF_Control["prototype"]["bIsUserTextSelection"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bIsUserTextSelection"]++;
        }
        ;
        return UCF_DomUtil["sGetSelectionText"](this["oDomRef"]) ? true : false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bIsUserTextSelection"] = 0;
    }
    ;

    /**
     * @typedef {Object} UCF_Control_TouchContextMenuEntry
     * @property {'TOOLTIP'|'TEXT'|'DATATIP'|'DOUBLECLICK'|'QUICKVIEW'} sType
     * @property {string} sText
     * @property {function(): void} fTrigger
     */
    /**
     * Base implementation for calculation of touch-contextmenu entries for this
     * control. A control implementation that overwrites this function should call
     * _super() first and can choose to add or replace items.
     * @param {Object<string,number>} oEventData Position properties of the original BrowserEvet that triggered the context-menu:
     *    iClientX/Y, iOffsetX/Y, iPageX/Y, iScreenX/Y
     * @param {UCF_ControlInfo} [oSubControl] Needed for controls that have a special double-click event for sub-controls, e.g. SapTable cells
     * @return {UCF_Control_TouchContextMenuEntry[]}
     * List of entries defining the context menu items and the order
     */
    UCF_Control["prototype"]["aGetTouchContextMenuEntries"] = function (oEventData, oSubControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["aGetTouchContextMenuEntries"]++;
        }
        ;
        /** @type {Array} */
        var aResult = [];
        /** @type {UCF_Control} */
        var self;
        /** @type {UCF_Control} */
        var oParent = this; // eslint-disable-line consistent-this
        /** @type {UCF_SapTableCell} */
        var oSapTableCell = null;
        /** @type {UCF_SapTable} */
        var oSapTable = null;
        /** @type {Array} */
        var aTableEntries;

        if (this["sTooltip"]) {
            aResult["push"]({
                "sType": 'TOOLTIP',
                "sText": this["sTooltip"]
            });
        }

        if (this["bHasEventListeners"]('DoubleClick')) {
            self = this;
            aResult["push"]({
                "sType": 'DOUBLECLICK',
                "sText": this["oLS"]["sGetText"]('SAPUR_POMN_CX_DLB_CLICK') || 'Trigger double click',
                "fTrigger": function () {
                    self["fireDoubleClick"](self["sId"]);
                }
            });
        } else {
            // SapTable: If the control does not handle a DoubleClick it will be dispatched to the SapTable
            // which could fire a CellDoubleClick
            while ((oParent = oParent["oGetParent"](true)) != null && oSapTable === null) {
                if (oParent["sClassName"] === 'SapTableCell') {
                    oSapTableCell = oParent;
                } else if (oParent["sClassName"] === 'UCF_SapTable' || oParent["sClassName"] === 'UCF_SapTableCS') {
                    oSapTable = oParent;
                }
            }
            if (oSapTable && oSapTableCell) {
                // We are only interested in a DOUBLECLICK entry provided by the parent table for
                // the given table cell...
                aTableEntries = oSapTable["aGetTouchContextMenuEntries"](oEventData, oSapTableCell);
                aResult = aResult["concat"](UCF_JsUtil["filter"](aTableEntries, function (oEntry) {
                    return oEntry["sType"] === 'DOUBLECLICK';
                }));
            }
        }
        // Ask all Delegates, e.g. DataTip, QuickView
        UCF_JsUtil["forEach"](
            UCF_JsUtil["filter"](
                // TODO what happens with BeforeDelegates?
                this["aGetDelegates"]() || [],
                function (oDelegate) {
                    return UCF_JsUtil["bIsFunction"](oDelegate["aChangeTouchContextMenuEntries"]);
                }
            ),
            function (oDelegate) {
                oDelegate["aChangeTouchContextMenuEntries"](aResult, oEventData);
            }
        );

        return aResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["aGetTouchContextMenuEntries"] = 0;
    }
    ;
    /**
     * @protected
     * @return {Object}
     */
    UCF_Control["prototype"]["oGetJSON"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["oGetJSON"]++;
        }
        ;
        /** @type {string} */
        var sLocalName = this["sClassName"]["slice"](4); // eslint-disable-line no-magic-numbers
        /** @type {Object} */
        var oResult = {};
        /** @type {Object} */
        var oJSON = {};
        /** @type {UCF_Control} */
        var self = this;
        /** @type {UCF_ClientInterfaces_Interface} */
        var oInterface = UCF_ClassLoader["oGetClass"]('UCF_ClientInterfaces')["getInterface"](sLocalName);

        // properties => default values
        UCF_JsUtil["forEach"](UCF_JsUtil["entries"](oInterface["properties"] || {}), function (aEntry) {
            oJSON[aEntry[0]] = aEntry[1]["defaultValue"];
        });
        // properties => client values
        UCF_JsUtil["extend"](oJSON, UCF_JsUtil["reduce"](this["aAttributeNames"], function (oValues, sKey) {
            if (sKey in self) {
                oValues[sKey["slice"](1)] = self[sKey];
            }

            return oValues;
        }, {}));

        // aggregations => [] // TODO
        UCF_JsUtil["forEach"](UCF_JsUtil["keys"](oInterface["aggregations"] || {}), function (sKey) {
            oJSON[sKey] = [];
        });

        UCF_JsUtil["forEach"](UCF_JsUtil["keys"](oInterface["associations"] || {}), function (sKey) {
            oJSON[sKey] = null;
        });
        // events
        UCF_JsUtil["each"](this["mEvents"], function (sName, oEvent) {
            oJSON[sName] = oEvent;
        });
        oResult[sLocalName] = oJSON;

        return oResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["oGetJSON"] = 0;
    }
    ;
    /**
     * @return {boolean} `true` if the control is displayed in overlay mode,
     * otherwise `false`
     * @protected
     */
    UCF_Control["prototype"]["bShouldDisplayOverlay"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["bShouldDisplayOverlay"]++;
        }
        ;
        return UCF_BrowserEvent["bTouchInteraction"] &&
            UCF_UserAgent["bMatchesResponsiveBreakpoint"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]["S"], this["oLS"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["bShouldDisplayOverlay"] = 0;
    }
    ;

    /**
     * @protected
     * @param {function():void} fAnimationFrame
     * @return {number}
     */
    UCF_Control["prototype"]["requestAnimationFrame"] = function (fAnimationFrame) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["requestAnimationFrame"]++;
        }
        ;
        /** @type {UCF_Control} */
        var self = this;
        /** @type {number} */
        var iAnimationFrameId = UCF_JsUtil["requestAnimationFrame"](function () {
            delete self["oAnimationFrames"][iAnimationFrameId];
            fAnimationFrame["apply"](null, arguments);
        });

        this["oAnimationFrames"][iAnimationFrameId] = true;

        return iAnimationFrameId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["requestAnimationFrame"] = 0;
    }
    ;

    /**
     * @protected
     * @param {number} iAnimationFrameId
     */
    UCF_Control["prototype"]["cancelAnimationFrame"] = function (iAnimationFrameId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Control["_"]["cancelAnimationFrame"]++;
        }
        ;
        delete this["oAnimationFrames"][iAnimationFrameId];

        UCF_JsUtil["cancelAnimationFrame"](iAnimationFrameId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Control["_"]["cancelAnimationFrame"] = 0;
    }
    ;

    UCF_Control.prototype["aPublicMethods"] = ["sGetId", "addClientListener", "removeClientListener", "updateEvent", "focus", "playAnimation", "sGetCustomData", "getCustomData", "oGetParentControl", "setVisibility", "showBoundaries"].concat(UCF_Control.prototype.aPublicMethods || []);
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global _assert, _trace, _measure, DEBUG, INFO, ERROR, START, STOP */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_PlaceHolder */
/// <reference path="../controls/base/PlaceHolder.js"/>
    /* global UCF_ControlModel */
/// <reference path="../model/control/ControlModel.js"/>
    /* global UCF_ClientElement */
/// <reference path="./ClientElement.js"/>
    /* global UCF_Control */
/// <reference path="./Control.js"/>
    /* global UCF_LS */
/// <reference path="./LS.js"/>
    /* global UCF_System */

/// <reference path="./System.js"/>

    /**
     * Class UCF_ControlFactory
     *
     * Creates control instances, and takes care about their lifecycle. Control
     * instances may either be needed when the control is first displayed on the
     * screen (e.g. needs to react on resizing or need initial processing) or are
     * created when an event on a control occurs.
     *
     *
     *
     * @class
     * @param {UCF_LS} oLS
     */
    function UCF_ControlFactory(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["UCF_ControlFactory"]++;
        }
        ;
        /** @type {string} */
        var n;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "ControlFactory.js(45): UCF_ControlFactory");
        }
        ;

        UCF_Object["apply"](this);

        this["oLS"] = oLS;

        /** @type {Object<string,UCF_Control>} */
        this["mControls"] = {};
        /** @type {Object<string,UCF_ClientElement>} */
        this["mClientControls"] = {};
        /** @type {Object<string,boolean>} */
        this["mCreateControls"] = {};
        /** @type {Object<string,UCF_ClientElement>} */
        this["mClientControlTrees"] = {};
        /** @type {boolean} */
        this["bClientRenderingStarted"] = false;

        /** @type {Object<string,string>} */
        UCF_ControlFactory["M_NAMES"] = {};
        for (n in UCF_ControlFactory["prototype"]["M_TYPES"]) {
            UCF_ControlFactory["M_NAMES"][UCF_ControlFactory["prototype"]["M_TYPES"][n]] = n;
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'ControlFactory created', "ControlFactory.js(68): UCF_ControlFactory");
        }
        ;
    };window["UCF_ControlFactory"] = UCF_ControlFactory;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ControlFactory");
        UCF_ControlFactory["_"] = {UCF_ControlFactory: 0};
    }
    ;
    ;
    UCF_ControlFactory["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_ControlFactory.prototype["sClassName"] = "UCF_ControlFactory";

    /**
     * Mapping table of ct to control class name
     * @private
     * @enum {string}
     */
    UCF_ControlFactory["prototype"]["M_TYPES"] = {
        "ACR": 'UCF_Accordion',
        "ACRI": 'UCF_AccordionItem',
        "B": 'UCF_Button',
        "BR": 'UCF_ButtonRow',
        "BRC": 'UCF_BreadCrumb',
        "BRCI": 'UCF_BreadCrumbItem',
        "Calculator": 'UCF_Calculator',
        "CP": 'UCF_Caption',
        "SC": 'UCF_ScrollContainer',
        "IT": 'UCF_InputTokenizer',
        "TOKEN": 'UCF_Token',
        "TOKENIZER": 'UCF_Tokenizer',
        "InputAssistant": 'UCF_InputAssistant',
        "C_ie6": 'UCF_CheckBox_ie6',
        "C_standards": 'UCF_CheckBox_standards',
        "CG": 'UCF_CheckBoxGroup',
        "RM": 'UCF_RoadMap',
        "RMI": 'UCF_RoadMapItem',
        "RI": 'UCF_RatingIndicator',
        "IMG": 'UCF_Image',
        "IMGM": 'UCF_ImageMap',
        "IMGMA": 'UCF_ImageMapArea',
        "MNB": 'UCF_MenuBar',
        "MNBI": 'UCF_MenuBarItem',
        "ML": 'UCF_MatrixLayout',
        "PHM": 'UCF_PageHeader',
        "PG": 'UCF_Paginator',
        "PGR": 'UCF_Pager',
        "PHI": 'UCF_PhaseIndicator',
        "PRI": 'UCF_ProgressIndicator',
        "PHII": 'UCF_PhaseIndicatorItem',
        "CXP": 'UCF_ContextualPanel',
        "HCNP": 'UCF_HorizontalContextualPanel',
        "HCNPI": 'UCF_HorizontalContextualPanelItem',
        "HCNPMI": 'UCF_HorizontalContextualPanelMenuItem',
        "HCNP_standards": 'UCF_HorizontalContextualPanel_standards',
        "HCNPI_standards": 'UCF_HorizontalContextualPanelItem_standards',
        "HCNPMI_standards": 'UCF_HorizontalContextualPanelMenuItem_standards',
        "HCNP_ie6": 'UCF_HorizontalContextualPanel_ie6',
        "HCNPI_ie6": 'UCF_HorizontalContextualPanelItem_ie6',
        "HCNPMI_ie6": 'UCF_HorizontalContextualPanelMenuItem_ie6',
        "FRA": 'UCF_FreeContextualArea',
        "I": 'UCF_InputField',
        "IHB": 'UCF_InputFieldHelpButton',
        "II": 'UCF_InputFieldInplaceEdit',
        "NL": 'UCF_NavigationList',
        "NLI": 'UCF_NavigationListItem',
        "NLG": 'UCF_NavigationListGroup',
        "CB": 'UCF_ComboBox',
        "CBS": 'UCF_SuggestBox',
        "CBILB": 'UCF_ComboBoxListBox',
        "CBSLB": 'UCF_SuggestBoxListBox',
        "ILBS": 'UCF_SelectListBox',
        "ILBM": 'UCF_SelectListBox',
        "ILBAI": 'UCF_ItemListBoxActionItem',
        "ILBI": 'UCF_ItemListBoxItem_ie6',
        "ST": 'UCF_SapTable',
        "STCS": 'UCF_SapTableCS',
        "SCB": 'UCF_Scrollbar',
        "TS_standards": 'UCF_TabStrip_standards',
        "TSITM_standards": 'UCF_TabStripItem_standards',
        "TS_ie6": 'UCF_TabStrip_ie6',
        "TSITM_ie6": 'UCF_TabStripItem_ie6',
        "VS": 'UCF_ViewSwitch',
        "VSI": 'UCF_ViewSwitchItem',
        "TV": 'UCF_TextView',
        "TXB": 'UCF_TextBar',
        "HTV": 'UCF_HTMLTextView',
        "FOR": 'UCF_Form',
        "POMN": 'UCF_PopupMenu',
        "POMNI": 'UCF_PopupMenuItem',
        "L": 'UCF_Label',
        "LP": 'UCF_LoadingPlaceHolder',
        "LN": 'UCF_Link',
        "LNC": 'UCF_LinkChoice',
        "SP": 'UCF_Splitter',
        "SPC": 'UCF_SplitterCol',
        "SPR": 'UCF_SplitterRow',
        "SPCE": 'UCF_SplitterCell',
        "SY": 'UCF_System',
        "DatePicker": 'UCF_DatePicker',
        "DatePickerSlider": 'UCF_DatePickerSlider',
        "PickerSlider": 'UCF_PickerSlider',
        "POTRG": 'UCF_PopupTrigger',
        "R": 'UCF_RadioButton',
        "R_standards": 'UCF_RadioButton_standards',
        "R_ie6": 'UCF_RadioButton_ie6',
        "RG": 'UCF_RadioButtonGroup',
        "TRI": 'UCF_TriStateCheckBox',
        "TRI_standards": 'UCF_TriStateCheckBox_standards',
        "TRI_ie6": 'UCF_TriStateCheckBox_ie6',
        "FU": 'UCF_FileUpload',
        "TY": 'UCF_Tray',
        "DT": 'UCF_DataTip',
        "CAL_YEAR": 'UCF_CalendarYearView',
        "CAL_MONTH": 'UCF_CalendarMonthView',
        "CAL_DAY": 'UCF_CalendarDayView',
        "CAL_ENTRY": 'UCF_CalendarEntry',
        "CAL_RH": 'UCF_CalendarRowHeader',
        "PCTIT": 'UCF_PatternContainerTitle',
        "PCTAB": 'UCF_PatternContainerTab',
        "PCTABITM": 'UCF_PatternContainerTabItem',
        "PCSEQ": 'UCF_PatternContainerSequence',
        "PCSEQITM": 'UCF_PatternContainerSequenceItem',
        "PCI": 'UCF_PatternContainerIconButton',
        "PL": 'UCF_PageLayout',
        "PI": 'UCF_PopIn',
        "DN": 'UCF_DateNavigator',
        "TE": 'UCF_TextEdit',
        "TEI": 'UCF_TextEditInplaceEdit',
        "TGL": 'UCF_ToggleLink',
        "PW": 'UCF_PopupWindow',
        "TR": 'UCF_Tree',
        "TRN": 'UCF_TreeNode',
        "G": 'UCF_Group',
        "SHC": 'UCF_Shuttle',
        "RTE": 'UCF_RichTextEdit',
        "T": 'UCF_Toolbar_standards',
        "T_ie6": 'UCF_Toolbar_ie6',
        "MB": 'UCF_MessageBar',
        "IL": 'UCF_ItemList',
        "ILI": 'UCF_ItemListItem',
        "IF": 'UCF_Iframe',
        "AX": 'UCF_ActiveXContainer',
        "AP": 'UCF_AppletContainer',
        "FLC": 'UCF_FlashContainer',
        "SLC": 'UCF_SilverlightContainer',
        "PDF": 'UCF_PDFContainer',
        "IFO": 'UCF_InteractiveForm',
        "IFA": 'UCF_InteractiveFormAbap',
        "TTR": 'UCF_TimeTrigger',
        "MTR": 'UCF_MessageTrigger',
        "CL": 'UCF_ColumnLayout',
        "GM": 'UCF_GeoMap',
        "LA": 'UCF_LoadingAnimation',
        "VC": 'UCF_ValueComparison',
        "LEG": 'UCF_Legend',
        "FTV": 'UCF_FormattedTextView',
        "PAGE": 'UCF_Page',
        "DSI": 'UCF_DragSourceInfo',
        "DTI": 'UCF_DropTargetInfo',
        "DRT": 'UCF_DropTarget',
        "SL": 'UCF_SingleColumnLayout',
        "MG": 'UCF_MeltingGroup',
        "TAGCLOUD": 'UCF_TagCloud',
        "TAGCLOUDITEM": 'UCF_TagCloudItem',
        "CO": 'UCF_Container',
        "TL": 'UCF_TileLayout',
        "GL": 'UCF_GridLayout',
        "GLC": 'UCF_GridLayoutCell',
        "MLC": 'UCF_MatrixLayoutCell',
        "HKC": 'UCF_Hotkeys',
        "SH": 'UCF_SectionHeader',
        "THSL": 'UCF_ThresholdSlider',
        "THP": 'UCF_ThresholdPoint',

        "THSL_dynamic": 'UCF_ThresholdSlider_dynamic',
        "THP_dynamic": 'UCF_ThresholdPoint_dynamic',

        "THSL_static": 'UCF_ThresholdSlider_static',
        "THP_static": 'UCF_ThresholdPoint_static',

        "TSW": 'UCF_TrackSwitch',
        "W": 'UCF_WebWidget',
        "WA": 'UCF_WebWidgetParameter',

        "INPL": 'UCF_InplaceEdit',
        "IHUB": 'UCF_IHub',
        "IHUBEVENTING": 'UCF_IHubEventing',
        "IHUBNAVIGATION": 'UCF_IHubNavigation',
        "IHUBWORKPROTECT": 'UCF_IHubWorkProtect',

        "IHUBMESSAGING": 'UCF_IHubMessaging',
        "IHUBFRAMEPROTECT": 'UCF_IHubFrameProtect',
        "IHUBPOSTMESSAGE": 'UCF_IHubPostMessage',
        "IHUBWEBSOCKET": 'UCF_IHubWebSocketPcp',
        "MSGT": 'UCF_MessagingTrigger',
        "IHUBLEGACYWDJ": 'UCF_IHubLegacyWDJ',
        "BIAF": 'UCF_BiApplicationFrame',
        "HAR": 'UCF_HeaderArea',
        "CTAR": 'UCF_ContentArea',
        "P": 'UCF_Panel',
        "PST": 'UCF_PanelStack',
        "ACF": 'UCF_AcfAdapter',
        "COI": 'UCF_ColorItem',
        "RTT": 'UCF_RichTooltip',
        "SR": 'UCF_StarRater',
        "DTC": 'UCF_DTContainer',
        "DTE": 'UCF_DTElement',
        "FLL": 'UCF_FluidLayout',
        "FLCL": 'UCF_FluidLayoutCell',
        "FLCO": 'UCF_FluidLayoutContainer',
        "FL": 'UCF_FlowLayout',
        "LB": 'UCF_LargeButton',
        "AL": 'UCF_AbapList',
        "ALC": 'UCF_AbapListCheckBox',
        "ALT": 'UCF_AbapListText',
        "ALI": 'UCF_AbapListImage',
        "ALCO": 'UCF_AbapListContainer',
        "ALTA": 'UCF_AbapListTabActor',
        "CI": 'UCF_ClientInspector',
        "QV": 'UCF_QuickView',
        "POPOVERCONTAINER": 'UCF_PopoverContainer',
        "HI": 'UCF_HtmlIsland',
        "DG": 'UCF_DataGrid',
        "DGS": 'UCF_DataGridSegment',
        "DGSC": 'UCF_DataGridSegmentCell',
        "MODELCONTROL": 'UCF_ModelControl',
        "CHART": 'UCF_Chart',
        "VIZFRAME": 'UCF_VizFrame',
        "DECO": 'UCF_Decorator',
        "RLI": 'UCF_RasterLayoutItem',
        "RL": 'UCF_RasterLayout',
        "STN": 'UCF_StickyNote',
        "PERSONASFACADE": 'UCF_PersonasFacade',
        "ViewContainer": 'UCF_ViewContainer',
        "TBARSEP": 'UCF_ToolbarSeparator',
        "MA": 'UCF_MessageArea',
        "MSG": 'UCF_Message',
        "OC": 'UCF_ObjectContainer',
        "OH": 'UCF_ObjectHeader',
        "ON": 'UCF_ObjectNavigation',
        "ONI": 'UCF_ObjectNavigationItem',
        "SBG": 'UCF_SegmentedButtonGroup',
        "SB": 'UCF_SegmentedButton',
        "SWITCH": 'UCF_Switch',
        //SWG: 'UCF_SwitchGroup',
        "CARS": 'UCF_SingleCarousel',
        "CARM": 'UCF_MultiCarousel',
        "PMSS": 'UCF_PostMessageServices',
        "PMSDIRTY": 'UCF_PMServiceDirty',
        "PMSGENRESP": 'UCF_PMServiceGenericResponder',
        "PMSTIMEOUT": 'UCF_PMServiceTimeout',
        "PMSTHEMECHANGE": 'UCF_PMServiceThemeChange',
        "PMSUSHELLSESSION": 'UCF_PMServiceUShellSessionHandler',
        "PMSWEBASSIST": 'UCF_PMServiceWebAssistant',
        "LIB_S": 'UCF_Listbox_SingleSelect',
        "LIB_M": 'UCF_Listbox_MultiSelect',
        "LIB_P": 'UCF_Listbox_Popup',
        "LIB_PJ": 'UCF_Listbox_JsonPopup',
        "LIB_PS": 'UCF_Listbox_Popup', // not UCF_Listbox_Suggest, this is "mixed in"
        "LIB_PJS": 'UCF_Listbox_JsonSuggest',
        "LIB_I": 'UCF_Listbox_Item',
        "LIB_AI": 'UCF_Listbox_ActionItem',
        "HV": 'UCF_HierarchicalView',
        "SPW": 'UCF_SidePopup',
        "CGR": 'UCF_CSSGrid',
        "CGRI": 'UCF_CSSGridItem',
        "BCR": 'UCF_BarcodeReader'
    };

    /**
     * Destructor
     * @private
     */
    UCF_ControlFactory["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["destroy"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oLS"]["oGetPageInternal"]();
        /** @type {number} */
        var i = 0;

        // Client controls
        this["deleteClientControlTrees"]();

        // purging is not sufficient .. delte all leftovers
        for (i in this["mClientControls"]) {
            this["mClientControls"][i]["destroy"](false);
            delete this["mClientControls"][i];
        }

        this["mClientControls"] = null;
        this["mCreateControls"] = null;

        if (oPage) {
            oPage["unregisterModel"]('$');
        }
        if (this["oControlModel"]) {
            this["oControlModel"]["destroy"]();
            this["oControlModel"] = null; // How to cleanup a model?
        }

        for (i in this["mControls"]) {
            this["mControls"][i]["destroy"]();
            delete this["mControls"][i];
        }
        this["mControls"] = null;
        this["mClientControlTrees"] = null;
        this["aClientControlTree"] = null;
        this["oLS"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["destroy"] = 0;
    }
    ;

    /**
     * Returns the control instance of the control enclosing the oDomRef
     * (i.e. throw in an arbitrary DOM element and get the control it belongs to)
     *
     * @example
     * <div ct="EXAMPLE" id="example">
     *   <p id="target"></p>
     * </div>
     *
     * this.oLS.oControlFactory.oGetEnclosingControlByDomRef(UCF_DomUtil.$('target'))
     * // => UCF_Example
     *
     * @param {Node} oDomRef the DOM element that's control should be found
     * @param {boolean} [bCreate=false] `true` to create the control if it is not
     * already created
     * @return {UCF_Control} the control enclosing {{oDomRef}}
     */
    UCF_ControlFactory["prototype"]["oGetEnclosingControlByDomRef"] = function (oDomRef, bCreate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetEnclosingControlByDomRef"]++;
        }
        ;
        /** @type {Node} */
        var oCurrentRef = oDomRef;
        /** @type {Node} */
        var oIdRef;

        while (oCurrentRef) {
            // special logic for checkBox, tristateCheckBox and radioButton
            // needed because of special dom structure
            if (UCF_DomUtil["bHasClass"](oCurrentRef, 'urCWhl')) {
                return this["oGetControlByDomRef"](oCurrentRef["firstChild"], bCreate || false);
            }

            // ct on ref => ref defines control
            if (oCurrentRef["getAttribute"]('ct')) {
                return this["oGetControlByDomRef"](oCurrentRef, bCreate || false);
            }

            // -r on ref => ct somewhere inside
            if (UCF_StringUtil["bEndsWith"](oCurrentRef["id"], '-r')) {
                oIdRef = UCF_DomUtil["$"](oCurrentRef["id"]["slice"](0, -'-r'["length"]));

                if (oIdRef && oIdRef["getAttribute"]('ct')) {
                    return this["oGetControlByDomRef"](
                        oIdRef,
                        bCreate || false
                    );
                }
            }

            oCurrentRef = oCurrentRef["parentElement"];
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetEnclosingControlByDomRef"] = 0;
    }
    ;

    /**
     * Returns the control instance of the control identified by its DOM reference.
     *
     * @param {HTMLElement} oDomRef A DOM reference to the root HTML tag of the control
     * @param {boolean} bCreate Whether the control should be created, if it does not exist yet
     * @return {UCF_Control} the control instance
     */
    UCF_ControlFactory["prototype"]["oGetControlByDomRef"] = function (oDomRef, bCreate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetControlByDomRef"]++;
        }
        ;
        /** @type {string} */
        var sId;
        /** @type {string} */
        var sCt;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "ControlFactory.js(439): oGetControlByDomRef");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "ControlFactory.js(440): oGetControlByDomRef");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bCreate === 'boolean', "typeof bCreate === 'boolean'", "ControlFactory.js(441): oGetControlByDomRef");
        }
        ;

        sId = oDomRef["getAttribute"]('id');
        sCt = oDomRef["getAttribute"]('ct');
        // eslint-disable-next-line eqeqeq
        if (sId == '' || sId == null || sCt == '' || sCt == null) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Can\'t create control from DomRef with ct ' + sCt + ' and id ' + sId + '.', "ControlFactory.js(447): oGetControlByDomRef");
            }
            ;

            return null;
        }

        // if we already have it in the cache, return it otherwise create it
        oControl = this["mControls"][sId];

        // if this is an outdated control instance properly destroy it and remove it
        // from the collection
        if (oControl) {
            if (!oControl["bIsValid"]()) {
                this["purgeControl"](oControl);
                oControl = this["mControls"][sId];
                // Do not create the control, if dom reference is invalid after purge
                if (!UCF_DomUtil["bIsInActiveDom"](oDomRef)) {
                    bCreate = false;
                }
            }
        }

        // if control does not exist and should be created call create
        if (!oControl && bCreate) {
            oControl = this["oCreateControlByDomRef"](oDomRef);
        }

        return oControl;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetControlByDomRef"] = 0;
    }
    ;

    /**
     * Returns the control instance of the control identified by its ID. May return
     * null, if no DOM element with the specified ID is found
     *
     * @param {string} sId The ID of the control
     * @return {UCF_Control} the control instance
     */
    UCF_ControlFactory["prototype"]["oGetControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetControlById"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "ControlFactory.js(488): oGetControlById");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId !== '', "sId !== ''", "ControlFactory.js(489): oGetControlById");
        }
        ;

        // if we already have it in the cache, return it otherwise create it
        oControl = this["mControls"][sId];

        // if this is an outdated control instance properly destroy it and remove it
        // from the collection
        if (oControl) {
            if (!oControl["bIsValid"]()) {
                this["purgeControl"](oControl);
                oControl = this["mControls"][sId];
            }
        }

        // if control does not exist and should be created call create
        if (!oControl) {
            oControl = this["oCreateControlById"](sId);
        }

        return oControl;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetControlById"] = 0;
    }
    ;

    /**
     * Returns the control instance of the control identified by its ID. May return
     * null, if no DOM element with the specified ID is found
     *
     * @param {string} sClassName The class name of the control
     * @param {string} sId The ID of the control
     * @return {UCF_Control} the control instance
     */
    UCF_ControlFactory["prototype"]["oGetControl"] = function (sClassName, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "ControlFactory.js(524): oGetControl");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId !== '', "sId !== ''", "ControlFactory.js(525): oGetControl");
        }
        ;

        // if we already have it in the cache, return it otherwise create it
        oControl = this["mControls"][sId];
        if (!oControl) {
            oControl = this["oCreateControl"]["apply"](this, arguments);
        }

        return oControl;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetControl"] = 0;
    }
    ;

    /**
     * Returns the control instances of a given class name as an array.
     *
     * @param {string} sClassName The class name of the controls
     * @param {boolean} bSearchSuperClasses
     * @return {Array<UCF_Control>} the control instances
     */
    UCF_ControlFactory["prototype"]["oGetCurrentControlsByClassName"] = function (sClassName, bSearchSuperClasses) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetCurrentControlsByClassName"]++;
        }
        ;
        /** @type {Array<UCF_Control>} */
        var aControlList = [];
        /** @type {string} */
        var n;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sClassName === 'string', "typeof sClassName === 'string'", "ControlFactory.js(552): oGetCurrentControlsByClassName");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sClassName !== '', "sClassName !== ''", "ControlFactory.js(553): oGetCurrentControlsByClassName");
        }
        ;

        for (n in this["mControls"]) {
            oControl = this["mControls"][n];

            if (oControl["sClassName"]) {
                if (bSearchSuperClasses) {
                    if (UCF_JsUtil["bInstanceOf"](oControl, sClassName)) {
                        aControlList["push"](oControl);
                    }
                } else if (oControl["sClassName"] === sClassName) {
                    aControlList["push"](oControl);
                }
            }
        }

        return aControlList;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetCurrentControlsByClassName"] = 0;
    }
    ;

    /**
     * Creates a new instance of a control identified by its DOM reference.
     *
     * @param {HTMLElement} oDomRef A DOM reference to the root HTML tag of the
     * control
     * @return {UCF_Control} the control instance
     */
    UCF_ControlFactory["prototype"]["oCreateControlByDomRef"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oCreateControlByDomRef"]++;
        }
        ;
        /** @type {string} */
        var sId;
        /** @type {string} */
        var sCt;
        /** @type {string} */
        var sType;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {function(new: UCF_Control)} */
        var oClass;
        /** @type {number} */
        var iClassStart;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "ControlFactory.js(593): oCreateControlByDomRef");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "ControlFactory.js(594): oCreateControlByDomRef");
        }
        ;

        sId = oDomRef["getAttribute"]('id');
        sCt = oDomRef["getAttribute"]('ct');

        // eslint-disable-next-line eqeqeq
        if (sId == '' || sId == null || sCt == '' || sCt == null) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Can\'t create control from DomRef with ct ' + sCt + ' and id ' + sId + '.', "ControlFactory.js(601): oCreateControlByDomRef");
            }
            ;

            return null;
        }
        //check whether constructor recursion is implemented
        if (this["mCreateControls"][sId] && __UCF_DEBUG__) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Recursion of control constructor. Please correct this issue. Never call a method that accesses the parent controls in the constructor. Use initialize', "ControlFactory.js(607): oCreateControlByDomRef");
            }
            ;
        }

        sType = this["M_TYPES"][sCt];
        if (!sType) {
            //MS: Control Library Enhancement
            if (sCt["indexOf"]('.') > -1) {
                sType = sCt;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'No control mapping found for CT "' + sCt + '"!', "ControlFactory.js(616): oCreateControlByDomRef");
                }
                ;
                sType = 'UCF_Control';
            }
        }

        oClass = UCF_ClassLoader["oGetClass"](sType);
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oClass != null, "oClass != null", "ControlFactory.js(622): oCreateControlByDomRef");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Create instance of ' + sType + ' with id "' + sId + '".', "ControlFactory.js(624): oCreateControlByDomRef");
        }
        ;

        if (__UCF_DEBUG__) {
            // remember id to check whether constructor recursion is implemented
            this["mCreateControls"][sId] = true;
        }
        oControl = new oClass(oDomRef, this["oLS"]);

        if (__UCF_DEBUG__) {
            // erase id to check whether constructor recursion is implemented after
            // control was instantiated.
            delete this["mCreateControls"][sId];
        }
        this["mControls"][oDomRef["getAttribute"]('id')] = oControl;

        //MS: TODO - hack - don't rewrite sClassName
        if (sCt["indexOf"]('.') > -1) {
            iClassStart = sType["lastIndexOf"]('.');
            oControl["sClassName"] = 'UCF_' + sType["substr"](iClassStart + 1);
        } else {
            oControl["sClassName"] = sType;
        }
        this["oLS"]["fireControlCreate"]({"Id": sId});

        return oControl;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oCreateControlByDomRef"] = 0;
    }
    ;

    /**
     * Creates a new instance of a control identified by its ID. May return null,
     * if no DOM element for the specified ID is found
     *
     * @param {string} sId The ID of the control
     * @return {UCF_Control} the control instance
     */
    UCF_ControlFactory["prototype"]["oCreateControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oCreateControlById"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {number} */
        var iRootIndex;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "ControlFactory.js(667): oCreateControlById");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId !== '', "sId !== ''", "ControlFactory.js(668): oCreateControlById");
        }
        ;

        iRootIndex = UCF_StringUtil["bEndsWith"](sId, '-r')
            ? sId["lastIndexOf"]('-r')
            : -1;

        // Fallback if method is called with rootref id
        if (iRootIndex > 0) {
            sId = sId["substring"](0, sId["length"] - iRootIndex);
        }

        // Find dom reference of the control
        oDomRef = this["oGetControlDomRef"](sId);

        if (oDomRef) {
            oControl = this["oCreateControlByDomRef"](oDomRef);
        }

        return oControl;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oCreateControlById"] = 0;
    }
    ;

    /**
     * Creates a control instance of the given control class and given ID.
     * This instance does not have a DOM representation yet, the render
     * method must be used to create the needed HTML.
     *
     * @param {string} sClassName the class name of the control to create
     * @param {string} sId the ID of the control
     * @return {UCF_Control} the control
     */
    UCF_ControlFactory["prototype"]["oCreateControl"] = function (sClassName, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oCreateControl"]++;
        }
        ;
        /** @type {function(new: UCF_Control)} */
        var oClass = UCF_ClassLoader["oGetClass"](sClassName);
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oClass != null, "oClass != null", "ControlFactory.js(705): oCreateControl");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Create instance of ' + sClassName + ' with id "' + sId + '".', "ControlFactory.js(707): oCreateControl");
        }
        ;

        // TODO no one calls oCreateControl() with more than 2 args...
        // eslint-disable-next-line no-magic-numbers
        oControl = new oClass(null, this["oLS"], sId, arguments[2], arguments[3]);
        this["mControls"][sId] = oControl;

        oControl["sClassName"] = sClassName;

        return oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oCreateControl"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the control with the given id.
     * @param {string} sId the ID of the control
     * @return {HTMLElement} DOM reference of the control with the given id
     */
    UCF_ControlFactory["prototype"]["oGetControlDomRef"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetControlDomRef"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef = UCF_DomUtil["$"](sId) || UCF_DomUtil["$"](sId + '-r');
        /** @type {HTMLXmpElement} */
        var oXMPRef;
        /** @type {boolean} */
        var bIsControl;
        /** @type {boolean} */
        var bIsPlaceHolder;
        /** @type {HTMLDivElement} */
        var oTemp;
        /** @type {DocumentFragment} */
        var oFragment;

        if (oDomRef && oDomRef["firstChild"] && oDomRef["firstChild"]["tagName"] === 'XMP') {
            oXMPRef = oDomRef["firstChild"];
            bIsControl = oXMPRef["getAttribute"]('ct');

            // ignore xmp tags that are sub LS controls, they are used for data
            // transport and should not be used as placeholders
            if (!bIsControl) {
                bIsPlaceHolder = oXMPRef["getAttribute"]('ph');

                if (bIsPlaceHolder) {
                    UCF_ClassLoader["oGetClass"]('UCF_PlaceHolder');
                    // Also load AcfAdapter to avoid timing issues if notifyLoad is called
                    // early
                    UCF_ClassLoader["oGetClass"]('UCF_AcfAdapter');
                    UCF_PlaceHolder["createContent"](
                        sId,
                        oXMPRef,
                        this["oLS"]["oGetStaticAreaRef"]()
                    );
                } else if (oDomRef["childNodes"]["length"] === 1) { //only one child
                    // for controls that have an adapter we need to check if there are more
                    // children
                    // eslint-disable-next-line no-unsanitized/property
                    oDomRef["innerHTML"] = oXMPRef["innerHTML"];
                } else { //more children
                    oTemp = document["createElement"]('div');
                    // eslint-disable-next-line no-unsanitized/property
                    oTemp["innerHTML"] = oXMPRef["innerHTML"];
                    // Create a documentfragment containing all nodes
                    oFragment = document["createDocumentFragment"]();
                    while (oTemp["firstChild"]) {
                        oFragment["appendChild"](oTemp["firstChild"]);
                    }
                    // Replace existing node with fragment
                    oDomRef["replaceChild"](oFragment, oXMPRef);
                }

                return UCF_DomUtil["$"](sId);
            }
        }

        return oDomRef;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetControlDomRef"] = 0;
    }
    ;

    /**
     * Remove all controls from the repository, that don't have a valid
     * DOM reference. If bKeepAlive is set on the control, look whether
     * a new DOM reference with the same ID exists and update the control.
     * @private
     */
    UCF_ControlFactory["prototype"]["purgeControls"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["purgeControls"]++;
        }
        ;
        /** @type {Object<string,UCF_Control>} */
        var mControls = this["mControls"];
        /** @type {UCF_Control} */
        var oControl;
        /** @type {number} */
        var iAll = 0;
        /** @type {number} */
        var iDestroyed = 0;
        /** @type {number} */
        var iKept = 0;
        /** @type {number} */
        var i;
        /** @type {Object<string,UCF_Control>} */
        var mNewControlsObject;

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(START, 'purge', 'Purging controls...');
        }
        ;

        for (i in mControls) {
            oControl = mControls[i];
            this["purgeControl"](oControl);

            iAll++;
            if (mControls[i]) {
                iKept++;
            } else {
                iDestroyed++;
            }
        }
        for (i in mControls) {
            oControl = mControls[i];
            if (oControl && oControl["bIsDestroyed"]) {
                delete mControls[i];
            }
        }

        // Workaround for mem leak in IE docMode 5
        if (UCF_UserAgent["bIsIE"]() && window["UCF_System"]["sDevice"] !== 'standards') {
            mNewControlsObject = {};
            for (i in mControls) {
                mNewControlsObject[i] = mControls[i];
            }
            this["mControls"] = mNewControlsObject;
        }

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(STOP, 'purge', 'Checked ' + iAll + ' controls, kept ' + iKept + ', destroyed ' + iDestroyed + ', within');
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["purgeControls"] = 0;
    }
    ;

    /**
     * Remove control from the repository, if it doesn't have a valid
     * DOM reference. If bKeepAlive is set on the control, look whether
     * a new DOM reference with the same ID exists and update the control.
     * @param {UCF_Control} oControl control to purge
     * @private
     */
    UCF_ControlFactory["prototype"]["purgeControl"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["purgeControl"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "ControlFactory.js(844): purgeControl");
        }
        ;

        if (!oControl["bIsValid"]()) {

            // If control should be kept alive even if the HTML has been replaced
            // call connectToDom if there is a new DOM element with the same id
            if (oControl["bDoKeepAlive"]()) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Keeping control "' + oControl["sId"] + '"alive.', "ControlFactory.js(851): purgeControl");
                }
                ;
                oControl["reconnectToDom"]();
            } else {
                // Otherwise destroy control and remove it from the collection
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Destroying control "' + oControl["sId"] + '".', "ControlFactory.js(855): purgeControl");
                }
                ;
                if (oControl["getClientControl"]()) {
                    this["purgeClientControl"](oControl["getClientControl"]());
                }
                if (!oControl["bIsDestroyed"]) {
                    oControl["destroy"]();
                }

                delete this["mControls"][oControl["sId"]];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["purgeControl"] = 0;
    }
    ;

    /**
     * Decide, whether the given DOM reference is a control reference
     *
     * @param {HTMLElement} oDomRef A DOM reference to the root HTML tag of the
     * control
     * @return {boolean} whether it is a control
     */
    UCF_ControlFactory["prototype"]["bIsControlDomRef"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["bIsControlDomRef"]++;
        }
        ;
        /** @type {string} */
        var sId;
        /** @type {string} */
        var sCt;

        if (
            oDomRef == null || // eslint-disable-line eqeqeq
            oDomRef == window || // eslint-disable-line eqeqeq
            oDomRef == document || // eslint-disable-line eqeqeq
            oDomRef == document["body"] // eslint-disable-line eqeqeq
        ) {
            return false;
        }

        sId = oDomRef["getAttribute"]('id');
        sCt = oDomRef["getAttribute"]('ct');

        // eslint-disable-next-line eqeqeq
        if (sId == '' || sId == null || sCt == '' || sCt == null) {
            return false;
        }

        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["bIsControlDomRef"] = 0;
    }
    ;

    /**
     * Checks whether a control instance already exists and if it has an initialize
     * method. Should be called after the screen was initially rendered by the
     * server and initialized.
     * @param {string} sId the id of the control.
     * @return {boolean}
     */
    UCF_ControlFactory["prototype"]["bControlNeedsInitialization"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["bControlNeedsInitialization"]++;
        }
        ;
        return (this["mControls"][sId] && this["mControls"][sId]["initialize"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["bControlNeedsInitialization"] = 0;
    }
    ;

    /**
     * Register a new {UCF_Control} type. The {UCF_ClassLoader} has to know the
     * library at first.
     *
     * Examples:
     * UCF_ControlFactory.registerControlType("sap_pioneer_", "P", "Pivottable");
     * HTML: &lt;div id="id1" ct="sap_pioneer_P" tabindex="0" ti="02 />
     * The control factory loads the class sap_pioneer_Pivottable
     *
     * The used HTML has to full fill the general requirements of Lightspeed
     * {UCF_Control}s. This includes the contructor/destructor pattern, a valid id
     * attribute to reference the {UCF_Control} and a ct attribute like in the
     * example above.
     *
     * It is recommended to define a "tabindex=0 ti=0" if the control wants to
     * receive focus. We strictly recommend to make a code review with a expert
     * from the Lightspeed team.
     *
     * Hint: the current mechanism is not compliant to OpenAJAX and HTML5 custom
     * data. Therfore some efforts have to be planned in the future.
     *
     * @param {string} sPrefix class name prefix used to identify the library
     * @param {string} sCT the string in the HTML to identify the type (without the
     * prefix for the library)
     * @param {string} sType the class name of the control
     *
     * @see UCF_ControlFactory#registerControlType
     * @see UCF_ClassLoader#registerLibrary
     */
    UCF_ControlFactory["prototype"]["registerControlType"] = function (sPrefix, sCT, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["registerControlType"]++;
        }
        ;
        /** @type {string} */
        var sKey;
        /** @type {string} */
        var sValue;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sPrefix === 'string', "typeof sPrefix === 'string'", "ControlFactory.js(947): registerControlType");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sPrefix != null && sPrefix !== '', "sPrefix != null && sPrefix !== ''", "ControlFactory.js(948): registerControlType");
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sCT === 'string', "typeof sCT === 'string'", "ControlFactory.js(950): registerControlType");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sCT != null && sCT !== '', "sCT != null && sCT !== ''", "ControlFactory.js(951): registerControlType");
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sType === 'string', "typeof sType === 'string'", "ControlFactory.js(953): registerControlType");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sType != null && sType !== '', "sType != null && sType !== ''", "ControlFactory.js(954): registerControlType");
        }
        ;

        sKey = sPrefix + sCT;
        sValue = sPrefix + sType;
        if (this["M_TYPES"][sKey]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, sPrefix + ' was already registered! A change is not allowed', "ControlFactory.js(959): registerControlType");
            }
            ;

            return;
        }

        this["M_TYPES"][sKey] = sValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["registerControlType"] = 0;
    }
    ;

    /** @protected */
    UCF_ControlFactory["prototype"]["purgeClientControls"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["purgeClientControls"]++;
        }
        ;
        /** @type {string} */
        var n;

        for (n in this["mClientControls"]) {
            this["purgeClientControl"](this["mClientControls"][n]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["purgeClientControls"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_ClientElement} oControl the client control to purge
     */
    UCF_ControlFactory["prototype"]["purgeClientControl"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["purgeClientControl"]++;
        }
        ;
        /** @type {string} */
        var sId;

        if (oControl) {
            sId = oControl["getId"]();
            if (this["mClientControls"][sId] === oControl) {
                if (oControl["getParent"]() == null && !oControl["oReplaceDomRef"]) {
                    if (this["mClientControlTrees"][sId]) {
                        this["mClientControlTrees"][sId]["destroy"]();
                    }
                }
                if (
                    this["mClientControls"][sId] &&
                    this["mClientControls"][sId]["bIsDestroyed"]
                ) {
                    delete this["mClientControls"][sId];
                }
            } else {
                oControl["destroy"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["purgeClientControl"] = 0;
    }
    ;

    /**
     * Deletes all control trees
     * Used after a full update
     */
    UCF_ControlFactory["prototype"]["deleteClientControlTrees"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["deleteClientControlTrees"]++;
        }
        ;
        /** @type {string} */
        var n;

        for (n in this["mClientControlTrees"]) {
            this["mClientControlTrees"][n]["destroy"]();
        }
        this["updateDeprecatedClientControlTreeAPI"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["deleteClientControlTrees"] = 0;
    }
    ;

    /** @protected */
    UCF_ControlFactory["prototype"]["deleteControlTrees"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["deleteControlTrees"]++;
        }
        ;
        this["deleteClientControlTrees"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["deleteControlTrees"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_ClientControlTree} oControlTree the control tree to delete
     */
    UCF_ControlFactory["prototype"]["deleteClientControlTree"] = function (oControlTree) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["deleteClientControlTree"]++;
        }
        ;
        if (oControlTree["bIsDestroyed"]) {
            delete this["mClientControlTrees"][oControlTree["getRootId"]()];
            this["updateDeprecatedClientControlTreeAPI"]();
        } else {
            oControlTree["destroy"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["deleteClientControlTree"] = 0;
    }
    ;

    /**
     * Returns the currently managed controltrees
     * @return {Object<string,UCF_ClientControlTree>} A map with all currently
     * managed controltrees
     */
    UCF_ControlFactory["prototype"]["mGetClientControlTrees"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["mGetClientControlTrees"]++;
        }
        ;
        return this["mClientControlTrees"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["mGetClientControlTrees"] = 0;
    }
    ;

    /**
     * Returns the currently managed controltree that contains the given control or
     * the control with the given id
     *
     * @private
     * @param {object} oControlOrId control or the id of the control
     * @return {UCF_ClientControlTree} The currently managed controltree that
     * contains the given control or the control with the given id
     */
    UCF_ControlFactory["prototype"]["oGetClientControlTree"] = function (oControlOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetClientControlTree"]++;
        }
        ;
        if (typeof oControlOrId === 'string') {
            oControlOrId = this["mClientControls"][oControlOrId];
        }

        return oControlOrId ? oControlOrId["getControlTree"]() : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetClientControlTree"] = 0;
    }
    ;

    /** @private */
    UCF_ControlFactory["prototype"]["updateDeprecatedClientControlTreeAPI"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["updateDeprecatedClientControlTreeAPI"]++;
        }
        ;
        /** @type {string} */
        var n;
        /** @type {Object} */
        var o;

        this["aClientControlTree"] = [];
        for (n in this["mClientControlTrees"]) {
            if (!this["mClientControlTrees"][n]["bIsDestroyed"]) {
                o = this["mClientControlTrees"][n]["oJson"];
                o["_root"] = this["mClientControlTrees"][n]["getRootControl"](true);
                this["aClientControlTree"]["push"](o);
            }
        }
        if (this["aClientControlTree"]["length"] === 0) {
            this["aClientControlTree"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["updateDeprecatedClientControlTreeAPI"] = 0;
    }
    ;

    /**
     * Updates the client control tree with a new control tree. Checks whether one
     * control tree is contained in another control tree and deletes the nested
     * ones. Adds a new control tree is the controls was not initally on the page.
     * @param {UCF_ClientControlTree} oControlTree the control tree to update
     * @param {boolean} bSuppressRendering Suppress rendering
     */
    UCF_ControlFactory["prototype"]["updateClientControlTree"] = function (oControlTree, bSuppressRendering) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["updateClientControlTree"]++;
        }
        ;
        /** @type {string} get the first element in the controltree */
        var sRootId = oControlTree["getRootId"]();
        /** @type {UCF_ClientControlTree} */
        var oExistingControlTree;
        /** @type {UCF_Control} */
        var oUCFControl;
        /** @type {UCF_ClientElement} */
        var oClientControl;
        /** @type {UCF_ClientElement} */
        var oNewClientControl;
        /** @type {UCF_ClientElement} */
        var oParent;
        /** @type {string} */
        var sAggregationName;

        if (sRootId) {
            this["oLS"]["prepareClientSideRendering"]();

            oExistingControlTree = this["mClientControlTrees"][sRootId];
            oUCFControl = this["oGetControlById"](sRootId);

            //root control of an existing control tree, destroy it first
            if (oExistingControlTree) {
                //prevent dom removal of purge at this point
                this["bPreventDomRemoval"] = true;
                this["deleteClientControlTree"](oExistingControlTree);
                this["bPreventDomRemoval"] = false;
            }

            oClientControl = this["oGetClientControlById"](sRootId);
            if (oUCFControl) {
                oClientControl = oUCFControl["getClientControl"]();
                if (oClientControl && oClientControl["bIsDestroyed"]) {
                    oClientControl = null;
                }
            }

            oNewClientControl = oControlTree["getRootControl"]();

            if (oClientControl && oClientControl["getParent"]()) {
                oParent = oClientControl["getParent"]();
                //replace an existing control
                sAggregationName = oClientControl["getAggregationName"]();
                if (oParent && sAggregationName) {
                    oParent["replaceAggregation"](
                        sAggregationName,
                        oClientControl,
                        oNewClientControl,
                        bSuppressRendering
                    );
                }
            } else {
                this["mClientControlTrees"][sRootId] = oControlTree;
                if (!bSuppressRendering) {
                    oNewClientControl["render"]();
                }
            }

            if (this["oControlModel"]) {
                this["oControlModel"]["setData"](this["mClientControls"]);
                this["updateControlTreeBindings"](null, false);
            }

            this["updateDeprecatedClientControlTreeAPI"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["updateClientControlTree"] = 0;
    }
    ;

    /**
     * Creates a model for the client controls to enable control property binding.
     * @return {UCF_ControlModel}
     */
    UCF_ControlFactory["prototype"]["createClientControlModel"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["createClientControlModel"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage;

        if (!this["oControlModel"]) {
            this["oControlModel"] = new (UCF_ClassLoader["oGetClass"]("UCF_ControlModel"))();
            oPage = this["oLS"]["oGetPageInternal"]();

            if (oPage) {
                oPage["registerModel"]('$', this["oControlModel"]);
            }
        }

        return this["oControlModel"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["createClientControlModel"] = 0;
    }
    ;

    /**
     * Updates the bindings of all controls that have a control tree binding.
     * This is called whenever an control tree was created or updated.
     * @param {string} sModel
     * @param {boolean} bRecreate
     */
    UCF_ControlFactory["prototype"]["updateControlTreeBindings"] = function (sModel, bRecreate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["updateControlTreeBindings"]++;
        }
        ;
        /** @type {string} */
        var n;

        for (n in this["mClientControlTrees"]) {
            this["mClientControlTrees"][n]["getRootControl"]()["updateBindings"](
                true,
                sModel,
                bRecreate
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["updateControlTreeBindings"] = 0;
    }
    ;

    /**
     * Returns the client control instance with the given id
     *
     * @private
     * @param {string} sId The id of the control
     * @return {UCF_ClientElement} The client control instance with the given id
     */
    UCF_ControlFactory["prototype"]["oGetClientControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oGetClientControlById"]++;
        }
        ;
        return this["mClientControls"] ? this["mClientControls"][sId] : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oGetClientControlById"] = 0;
    }
    ;

    /**
     * Creates a client control
     *
     * @param {string} sClassName the classname of the control to create
     * @param {string} sId optional The id of the control
     * @param {object} oJson an optional JSON for properties of the control and its content
     * @return {UCF_ClientElement} The instance of the newly created control
     *
     * @private
     */
    UCF_ControlFactory["prototype"]["oCreateClientControl"] = function (sClassName, sId, oJson) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlFactory["_"]["oCreateClientControl"]++;
        }
        ;
        /** @type {string} */
        var n;

        // allow a parsed control tree from the server to be created.
        if (typeof sClassName === 'object') {
            for (n in sClassName) {
                oJson = sClassName[n];
                sId = oJson["Id"];
                sClassName = n;
                break;
            }
        }

        if (sId && this["mClientControls"][sId]) {
            this["mClientControls"][sId]["destroy"]();
        }

        return UCF_ClientElement["createInstance"](sClassName, this["oLS"], sId, oJson);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlFactory["_"]["oCreateClientControl"] = 0;
    }
    ;


    /* global _assert */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_Control */

/// <reference path="../core/Control.js"/>

    /**
     * Base class for Sub-controls. Instances are only accessible via
     * <code>UCF_Control.oGetContainedControlInfo()</code> if the control
     * implementation provide it.
     * @class
     * @param {HTMLElement} oDomRef
     * @param {UCF_LS} oLS
     */
    function UCF_ControlInfo(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["UCF_ControlInfo"]++;
        }
        ;

        if (arguments["length"] === 0) return;

        if (oDomRef) {
            this["oDomRef"] = oDomRef;
            this["updateAttributes"]();
        }
        this["oLS"] = oLS;
        this["sId"] = oDomRef["getAttribute"]("id");
    };window["UCF_ControlInfo"] = UCF_ControlInfo;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ControlInfo");
        UCF_ControlInfo["_"] = {UCF_ControlInfo: 0};
    }
    ;
    ;
    UCF_ControlInfo["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_ControlInfo.prototype["sClassName"] = "UCF_ControlInfo";

    /** @override */
    UCF_ControlInfo["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["destroy"]++;
        }
        ;
        this["oDomRef"] = null;
        this["oLS"] = null;
        this["sId"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["destroy"] = 0;
    }
    ;

    /**
     * @private
     */
    UCF_ControlInfo["prototype"]["updateAttributes"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["updateAttributes"]++;
        }
        ;
        UCF_JsUtil["extend"](this, UCF_Control["oGetPackedAttribute"](
            this["oDomRef"],
            'lsdata',
            this["aAttributeNames"]
        ));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["updateAttributes"] = 0;
    }
    ;

    /**
     * @public
     * Returns the CustomData string of the control
     * @return {string} the CustomData string of the control
     */
    UCF_ControlInfo["prototype"]["sGetCustomData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["sGetCustomData"]++;
        }
        ;
        return this["sCustomData"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["sGetCustomData"] = 0;
    }
    ;

    /**
     * @public
     * Returns the id of the control info
     * @return {string}  the id  of the control info else null
     */
    UCF_ControlInfo["prototype"]["sGetId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["sGetId"]++;
        }
        ;
        return this["sId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["sGetId"] = 0;
    }
    ;

    /**
     * @public
     * Returns the JSON property with the given sName in case the CustomData string is a json string or null if it does not exist
     * @param {string} sName The property name to search for
     * @return {any} the CustomData for the given sName property
     */
    UCF_ControlInfo["prototype"]["getCustomData"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["getCustomData"]++;
        }
        ;
        var oJSON = null;
        if (!this["sCustomData"]) return null;
        if (typeof (this["sCustomData"]) === "object") {
            oJSON = this["sCustomData"];
        } else {
            try {
                oJSON = UCF_JsUtil["oJsonParse"](this["sCustomData"]);
            } catch (ex) {
            }

        }
        if (!sName) {
            return oJSON || null;
        }
        if (oJSON) {
            return oJSON[sName];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["getCustomData"] = 0;
    }
    ;

    /**
     * @public
     * The client control instance for the control info
     * @return {UCF_ClientElement} the client element instance or null
     */
    UCF_ControlInfo["prototype"]["getClientControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["getClientControl"]++;
        }
        ;
        return this["oLS"]["oGetClientControlById"](this["sId"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["getClientControl"] = 0;
    }
    ;

    /**
     * @see UCF_Control#aGetTouchContextMenuEntries
     */
    UCF_ControlInfo["prototype"]["aGetTouchContextMenuEntries"] = function (oEventData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["aGetTouchContextMenuEntries"]++;
        }
        ;
        /** @type {Array} */
        var aResult = [];

        if (this["sTooltip"]) {
            aResult["push"]({
                "sType": 'TOOLTIP',
                "sText": this["sTooltip"]
            });
        }

        return aResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["aGetTouchContextMenuEntries"] = 0;
    }
    ;

    /**
     * Returns data JSON that will be used in the UCF_SeleniumRecorder and UCF_SeleniumRuntime to test the
     * control.
     *
     * Override this method to provide more internals (property 'internals').
     * @see {UCF_SeleniumRuntime}, {UCF_SeleniumRecorder}
     * @return {object} A JSON object containing test data
     * @private
     */
    UCF_ControlInfo["prototype"]["oGetTestData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlInfo["_"]["oGetTestData"]++;
        }
        ;
        var o = {
            "properties": {},
            "dom": {},
            "internals": {},
            "sClassName": "UCF_ControlInfo",
            "sControlId": this["sId"],
            "bClone": false
        };
        var i = 0;

        if (this["aAttributeNames"]) {
            var aAttributeName = this["aAttributeNames"]["concat"]([]);
            aAttributeName["sort"]();
            for (i = 0; i < aAttributeName["length"]; i++) {
                var sName = aAttributeName[i],
                    oValue = this[sName];
                //sType = typeof(oValue);
                //if (sType === "string" || sType === "number" || sType === "undefined") {
                o["properties"][sName] = oValue + "";
                //}
            }
        }
        var aDomAttributes = ["offsetHeight", "offsetWidth", "offsetTop", "offsetLeft", "className", "tagName", "title", "value", "scrollTop", "scrollLeft"];
        aDomAttributes["sort"]();
        if (this["oDomRef"]) {
            for (i = 0; i < aDomAttributes["length"]; i++) {
                if (this["oDomRef"][aDomAttributes[i]] !== undefined) {
                    o["dom"]["DomRef." + aDomAttributes[i]] = this["oDomRef"][aDomAttributes[i]] + "";
                }
            }
            o["dom"]["DomRef.subct"] = this["oDomRef"]["getAttribute"]("subct");
        }
        var oControlDom = UCF_DomUtil["oGetParentByAttribute"](this["oDomRef"], "ct");
        if (oControlDom) {
            o["parent"] = this["oLS"]["oControlFactory"]["oGetControlByDomRef"](oControlDom)["oGetTestData"]();
        }

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlInfo["_"]["oGetTestData"] = 0;
    }
    ;

    UCF_ControlInfo.prototype["aPublicMethods"] = ["sGetCustomData", "sGetId", "getCustomData", "getClientControl"].concat(UCF_ControlInfo.prototype.aPublicMethods || []);
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global _measure, _trace, START, STOP, DEBUG, INFO, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="../../core/util/XSSEncoder.js"/>
    /* global UCF_ClientElement */
/// <reference path="./ClientElement.js"/>

    /** @typedef {string} _ControlId `${sId}` */
    /** @typedef {string} _StyleId `${customStyle}${classPrefix}` */
    /** @typedef {string} _StyleVariableName */
    /** @typedef {string} _StylePropertyName */
    /** @typedef {string} _StyleClassSuffix */
    /** @typedef {Object} _ControlInterface */
    /**
     * @typedef {Object} _ControlReference
     * @property {HTMLElement} oDomRef
     */
    /**
     * @typedef {Object} _ControlStyleMetadata
     * @property {Array<_StyleVariable>} variables
     * @property {Object<string,_StyleClass>} classes
     */
    /**
     * @typedef {Object} _StyleDefinition
     * @property {string} type
     * @property {string} customStyle
     * @property {string} [classPrefix]
     * @property {Object} variables
     * @property {Object} values
     */
    /**
     * @typedef {Object} _StyleVariable
     * @property {_StyleVariableName} name
     * @property {string} value
     * @property {_StylePropertyName} property
     * @property {string} expression
     * @property {string} defaultValue
     * @property {string} [defaultExpression]
     * @property {string} docu
     * @property {string} [evaluatedExpression]
     * @property {boolean} calculated
     */
    /**
     * @typedef {Object} _StyleClass
     * @property {string} suffix
     * @property {Object<_StylePropertyName,_StyleProperty>} properties
     * @property {string} scope
     * @property {_StyleClassSuffix} classsuffix
     */
    /**
     * @typedef {Object} _StyleProperty
     * @property {_StylePropertyName} name
     * @property {string} [value]
     * @property {string} expression
     * @property {boolean} important
     */
    /** @typedef {Object<_ControlId,_ControlReference>} _ControlRegistry */
    /** @typedef {Object<_ControlId,Object<_StyleId,_StyleDefinition>>} _StyleRegistry */
    /**
     * @typedef {function} _LessParsedCallback
     * @param {Error} parseError
     * @param {Object} root
     */

    /**
     * @typedef {Object} _LessParser
     * @property {function(string, _LessParsedCallback): void} parse
     */

    /**
     * The custom style factory creates the css class for a custom style class
     * based on the control interface definitions of a control.
     *
     * @param {string|UCF_ClientElement} control The control name or a
     * client-control instance.
     * @constructor
     *
     */
    function UCF_CustomStyleProvider(control) {
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["UCF_CustomStyleProvider"]++;
        }
        ;
        /** @type {UCF_ClientElement} */
        var oControl;

        if (arguments["length"] > 0) {
            UCF_Object["apply"](this);

            /** @type {Array<string>} */
            this["aCssClassNames"] = [];
            if (control instanceof UCF_ClientElement) {
                oControl = control;

                if (oControl["getCustomStyle"]()) {
                    // initialize the classname that is used for the generated css classes
                    // from the control is given
                    this["setClassName"](oControl["getCustomStyle"]());
                    this["setControlName"](oControl["getMetadata"]()["name"]);
                    this["initialize"](this["getCustomStyleDefinition"]());
                }
            } else {
                this["setControlName"](control);
            }
        }
    };window["UCF_CustomStyleProvider"] = UCF_CustomStyleProvider;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_CustomStyleProvider");
        UCF_CustomStyleProvider["_"] = {UCF_CustomStyleProvider: 0};
    }
    ;
    ;
    UCF_CustomStyleProvider["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_CustomStyleProvider.prototype["sClassName"] = "UCF_CustomStyleProvider";

    /** @type {number} The rule index that was already read */
    UCF_CustomStyleProvider["iRuleIndex"] = 0;
    /**
     * @type {Object} The reference to the theme stylesheet that is currently
     * used
     */
    UCF_CustomStyleProvider["oStyleSheet"] = null;
    /**
     * @type {_StyleRegistry} store the currently applied
     * styles
     */
    UCF_CustomStyleProvider["mStyleRegistry"] = {};

    /**
     * @private
     * @return {_StyleRegistry}
     */
    UCF_CustomStyleProvider["getStyleRegistry"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getStyleRegistry"]++;
        }
        ;
        /** @type {_StyleRegistry} */
        var mRegistered = {};
        /** @type {_ControlId} */
        var sControlId;
        /** @type {_StyleId} */
        var sStyleId;

        for (sControlId in this["mStyleRegistry"]) {
            mRegistered[sControlId] = [];

            for (sStyleId in this["mStyleRegistry"][sControlId]) {
                mRegistered[sControlId]["push"](this["mStyleRegistry"][sControlId][sStyleId]);
            }
        }

        return mRegistered;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getStyleRegistry"] = 0;
    }
    ;

    /** @return {Object} */
    UCF_CustomStyleProvider["oGetLessParser"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["oGetLessParser"]++;
        }
        ;
        return new window["less"]["Parser"]({"javascriptEnabled": false});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["oGetLessParser"] = 0;
    }
    ;

    /**
     * @private
     */
// UCF_CustomStyleProvider.prototype.destroy = function() {
// 	/** @type {HTML element} */
// 	var oDIV;

// 	oDIV = UCF_DomUtil.$(UCF_CustomStyleProvider.oThemeValueRef.id);

// 	if (oDIV){
// 		UCF_DomUtil.removeFromDom(oDIV);
// 	}

// 	if (UCF_CustomStyleProvider.oThemeValueRef) {
// 		UCF_CustomStyleProvider.oThemeValueRef = null;
// 		delete UCF_CustomStyleProvider.oThemeValueRef;
// 	}

// 	_super();
// };

    /**
     * @protected
     * @static
     */
    UCF_CustomStyleProvider["destroyStatic"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["destroyStatic"]++;
        }
        ;
        UCF_CustomStyleProvider["removeAllStyles"]();

        UCF_CustomStyleProvider["mStyleRegistry"] = null;
        UCF_CustomStyleProvider["oStyleSheet"] = null;
        UCF_CustomStyleProvider["mCustomStyles"] = null;
        UCF_CustomStyleProvider["mThemeValueCache"] = null;
        if (UCF_CustomStyleProvider["oThemeValueRef"]) {
            UCF_DomUtil["removeFromDom"](UCF_CustomStyleProvider["oThemeValueRef"]);
            UCF_CustomStyleProvider["oThemeValueRef"] = null;
        }

        window["less"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["destroyStatic"] = 0;
    }
    ;

    /** @override */
    UCF_CustomStyleProvider["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["destroy"]++;
        }
        ;
        this["sClassPrefix"] = null;
        this["oControl"] = null;
        this["sCss"] = null;
        this["aVariables"] = null;
        this["oStyleMetadata"] = null;
        this["oMetadata"] = null;
        this["aCssClassNames"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["destroy"] = 0;
    }
    ;

    /**
     * Initializes the instance with a previously serialized string or JSON object.
     * @private
     * @param {string|_StyleDefinition} oObject The serialized
     * or object representation of the Custom Style
     */
    UCF_CustomStyleProvider["prototype"]["initialize"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["initialize"]++;
        }
        ;
        /** @type {_StyleDefinition} */
        var oObj = typeof oObject === 'string'
            ? UCF_JsUtil["oJsonParse"](oObject)
            : oObject;
        /** @type {_StyleId} */
        var sStyleId;
        /** @type {string} */
        var sValue;

        if (oObj["type"] && oObj["customStyle"]) {
            this["setControlName"](oObj["type"]);
            this["setClassName"](oObj["customStyle"]);
            this["setClassPrefix"](oObj["classPrefix"]);
            if (oObj["variables"]) {
                for (sStyleId in oObj["variables"]) {
                    this["setVariable"](sStyleId, oObj["variables"][sStyleId]);
                }
            }
            if (oObj["values"]) {
                for (sStyleId in oObj["values"]) {
                    for (sValue in oObj["values"][sStyleId]) {
                        this["setProperty"](sStyleId, sValue, oObj["values"][sStyleId][sValue]);
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["initialize"] = 0;
    }
    ;

    /**
     * Registers the style to the global custom style reprository
     * @private
     * @param {_ControlId} sId the id of the custom style,
     * @param {string|_StyleDefinition} oStyle  The serialized
     * or object representation of the customstyle
     */
    UCF_CustomStyleProvider["prototype"]["registerStyle"] = function (sId, oStyle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["registerStyle"]++;
        }
        ;
        if (!UCF_CustomStyleProvider["mStyleRegistry"][sId]) {
            UCF_CustomStyleProvider["mStyleRegistry"][sId] = {};
        }

        if (typeof oStyle === 'string') {
            oStyle = UCF_JsUtil["oJsonParse"](oStyle);
        }

        if (oStyle["customStyle"]) {
            UCF_CustomStyleProvider["mStyleRegistry"][sId][this["sGetStyleId"](oStyle)] =
                oStyle;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["registerStyle"] = 0;
    }
    ;

    /**
     * @private
     * @param {_StyleDefinition} oStyle the style
     * @return {string}
     */
    UCF_CustomStyleProvider["prototype"]["sGetStyleId"] = function (oStyle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["sGetStyleId"]++;
        }
        ;
        return oStyle["customStyle"] + (oStyle["classPrefix"] ? oStyle["classPrefix"] : '');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["sGetStyleId"] = 0;
    }
    ;

    /**
     * Registers the styles to the global custom style reprository
     * @private
     * @param {string} sId the id of the custom style
     * @param {string|Array<string|_StyleDefinition>} aStyles
     * list of the serialized or object representation of the customstyle
     */
    UCF_CustomStyleProvider["prototype"]["registerStyles"] = function (sId, aStyles) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["registerStyles"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;

        if (typeof aStyles === 'string') {
            aStyles = UCF_JsUtil["oJsonParse"](aStyles);

            if (typeof aStyles["length"] !== 'number') {
                aStyles = [aStyles];
            }
        }

        if (aStyles && aStyles["length"] > 0) {
            UCF_JsUtil["forEach"](
                aStyles,
                function (oStyle) {
                    self["registerStyle"](sId, oStyle);
                }
            );
        } else {
            this["unregisterStyles"](sId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["registerStyles"] = 0;
    }
    ;

    /**
     * Unegisters the styles to the global custom style reprository
     * @private
     * @param {string} sId the id of the custom style,
     * @param {_StyleDefinition} oStyle the customstyle
     */
    UCF_CustomStyleProvider["prototype"]["unregisterStyle"] = function (sId, oStyle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["unregisterStyle"]++;
        }
        ;
        /** @type {string} */
        var sStyleId;

        if (UCF_CustomStyleProvider["mStyleRegistry"][sId]) {
            sStyleId = this["sGetStyleId"](oStyle);

            delete UCF_CustomStyleProvider["mStyleRegistry"][sId][sStyleId];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["unregisterStyle"] = 0;
    }
    ;

    /**
     * Unregisters the styles from the global custom style reprository
     * @private
     * @param {string} sId the id of the custom style,
     */
    UCF_CustomStyleProvider["prototype"]["unregisterStyles"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["unregisterStyles"]++;
        }
        ;
        /** @type {_ControlId} */
        var sControlId;
        /** @type {_StyleId} */
        var sStyleId;

        if (!sId) {
            for (sControlId in UCF_CustomStyleProvider["mStyleRegistry"]) {
                this["unregisterStyles"](sControlId);
            }

        }
        if (UCF_CustomStyleProvider["mStyleRegistry"][sId]) {
            for (sStyleId in UCF_CustomStyleProvider["mStyleRegistry"][sId]) {
                delete UCF_CustomStyleProvider["mStyleRegistry"][sId][sStyleId];
            }
            delete UCF_CustomStyleProvider["mStyleRegistry"][sId];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["unregisterStyles"] = 0;
    }
    ;

    /**
     * Removes all custom styles from the global registry
     * @private
     */
    UCF_CustomStyleProvider["removeAllStyles"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["removeAllStyles"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var oProvider = new (UCF_ClassLoader["oGetClass"]("UCF_CustomStyleProvider"))();

        oProvider["unregisterStyles"]();
        oProvider["updateStyles"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["removeAllStyles"] = 0;
    }
    ;

    /**
     * @protected
     * @param {_ControlId} sId the control
     */
    UCF_CustomStyleProvider["prototype"]["deleteStorage"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["deleteStorage"]++;
        }
        ;
        if (UCF_JsUtil["bSupportsLocalStorage"]()) {
            window["localStorage"]["setItem"]('lscustomstyle-' + sId, '');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["deleteStorage"] = 0;
    }
    ;

    /**
     * Updates the custom style with the given id
     * @param {string} sId The id of the custom style to update
     * @private
     */
    UCF_CustomStyleProvider["prototype"]["updateStyles"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["updateStyles"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;
        /** @type {_ControlId} */
        var sControlId;
        /** @type {string} */
        var sCssString = '';
        /** @type {boolean} */
        var bForce = false;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {HTMLStyleElement} */
        var oStyleRef;

        if (!sId) {
            for (sControlId in UCF_CustomStyleProvider["mCustomStyles"]) {
                this["updateStyles"](sControlId);
            }
            for (sControlId in UCF_CustomStyleProvider["mStyleRegistry"]) {
                if (!UCF_CustomStyleProvider["mCustomStyles"] ||
                    !UCF_CustomStyleProvider["mCustomStyles"][sControlId]
                ) {
                    this["updateStyles"](sControlId);
                }
            }
        }

        if (!UCF_CustomStyleProvider["mCustomStyles"]) {
            /** @type {_ControlRegistry} */
            UCF_CustomStyleProvider["mCustomStyles"] = {};
        }

        if (!UCF_CustomStyleProvider["mStyleRegistry"][sId] &&
            UCF_CustomStyleProvider["mCustomStyles"][sId]
        ) {
            // styles were unregistered. Remove the domref
            oDomRef = UCF_CustomStyleProvider["mCustomStyles"][sId]["oDomRef"];

            if (oDomRef) {
                oDomRef["parentNode"]["removeChild"](oDomRef);
                delete UCF_CustomStyleProvider["mCustomStyles"][sId];
            }
        } else {
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(START, '_applyCustomStyles', 'Start CustomStyle classes');
            }
            ;
            sCssString = UCF_JsUtil["reduce"](
                UCF_JsUtil["values"](UCF_CustomStyleProvider["mStyleRegistry"][sId] || {}),
                function (aCss, oStyle) {
                    if (typeof oStyle === 'string') {
                        oStyle = UCF_JsUtil["oJsonParse"](oStyle);
                    }
                    if (oStyle["type"]) {
                        self["initialize"](oStyle);
                        aCss["push"](self["getCssText"]());
                    }

                    return aCss;
                }, []
            )["join"]('\n');

            if (sCssString !== '') {
                if (this["sLocalStorageCss"] !== sCssString || bForce) {
                    if (
                        UCF_JsUtil["bSupportsLocalStorage"]() &&
                        this["sLocalStorageCss"] !== sCssString
                    ) {
                        // eslint-disable-next-line max-depth
                        try {
                            window["localStorage"]["setItem"]('lscustomstyle-' + sId, sCssString);
                        } catch (ex) {
                            if (__UCF_TRACE__) {
                                UCF_Tracer.trace(INFO, 'Storing custom style in local storage failed for ' + sId, "CustomStyleProvider.js(443): updateStyles");
                            }
                            ;
                        }
                    }
                    if (UCF_CustomStyleProvider["mCustomStyles"][sId]) {
                        // eslint-disable-next-line max-depth
                        try {
                            // eslint-disable-next-line no-unsanitized/property
                            UCF_CustomStyleProvider["mCustomStyles"][sId]["oDomRef"]["innerHTML"] =
                                sCssString;
                        } catch (error) {
                            UCF_CustomStyleProvider["mCustomStyles"][sId]["oDomRef"]
                                ["styleSheet"]["cssText"] = sCssString;
                        }
                    } else {
                        // eslint-disable-next-line max-depth
                        if (UCF_CustomStyleProvider["mCustomStyles"][sId]) {
                            UCF_JsUtil["removeFromDom"](
                                UCF_CustomStyleProvider["mCustomStyles"][sId]["oDomRef"]
                            );
                            delete UCF_CustomStyleProvider["mCustomStyles"][sId];
                        }

                        oStyleRef = document["createElement"]('DIV');
                        // eslint-disable-next-line no-unsanitized/property
                        oStyleRef["innerHTML"] = '<style type="text/css" id="customstyle-' +
                            UCF_XSSEncoder["encodeHTML"](sId) + '">' +
                            sCssString + '</style>';
                        UCF_CustomStyleProvider["mCustomStyles"][sId] = {
                            "oDomRef": oStyleRef["firstChild"]
                        };
                        (document["getElementsByTagName"]('HEAD')[0] || document["body"])
                            ["appendChild"](oStyleRef["firstChild"]);
                    }
                }
            }
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, '_applyCustomStyles', 'Stop CustomStyle classes');
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["updateStyles"] = 0;
    }
    ;

    /**
     * Returns and array of the Custom Styles Definitions for all style classes.
     * @todo remove (unused in lightspeed sources, marked as private)
     * @private
     * @return {Array<_StyleDefinition>} array of the Custom
     * Styles Definitions for all classes.
     */
    UCF_CustomStyleProvider["prototype"]["getCustomStyleDefinitions"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCustomStyleDefinitions"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;

        return UCF_JsUtil["map"](
            this["aCssClassNames"],
            function (sName) {
                return self["getCustomStyleDefinition"](sName);
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCustomStyleDefinitions"] = 0;
    }
    ;

    /**
     * Returns the Custom Style with a given name
     * @todo remove (unused in lightspeed sources except in
     * #getCustomStyleDefinitions which should be removed as well, marked as
     * private)
     * @private
     * @param {_StyleId} sName The name of the custom style
     * class
     * @return {_StyleDefinition}
     */
    UCF_CustomStyleProvider["prototype"]["getCustomStyleDefinition"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCustomStyleDefinition"]++;
        }
        ;
        /** @type {_ControlId} */
        var sControlId;

        if (!sName) {
            sName = this["aCssClassNames"][this["aCssClassNames"]["length"] - 1];
        }

        for (sControlId in UCF_CustomStyleProvider["mStyleRegistry"]) {
            if (UCF_CustomStyleProvider["mStyleRegistry"][sControlId][sName]) {
                return UCF_CustomStyleProvider["mStyleRegistry"][sControlId][sName];
            }
        }

        return this["getCustomStyle"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCustomStyleDefinition"] = 0;
    }
    ;

    /**
     * Sets the control name
     * @private
     * @param {string} sControlName The name of the control to use for this provider
     */
    UCF_CustomStyleProvider["prototype"]["setControlName"] = function (sControlName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["setControlName"]++;
        }
        ;
        /** @type {UCF_ClientInterfaces} */
        var UCF_ClientInterfaces = UCF_ClassLoader["oGetClass"]('UCF_ClientInterfaces');
        /** @type {UCF_CustomStyleProvider} */
        var self;
        /** @type {Obect} */
        var mOldClasses;
        /** @type {string} */
        var n;
        /** @type {_StyleClass} */
        var oClass;

        if (sControlName && UCF_ClientInterfaces["I"][sControlName]) {
            self = this;

            /**
             * @type {_ControlInterface} the control the style
             * provider is working with
             */
            this["oMetadata"] = UCF_ClientInterfaces["I"][sControlName];
            /**
             * @type {_ControlStyleMetadata} the original metadata
             * of the controls custom style definition
             */
            this["oStyleMetadata"] = this["oMetadata"]["styles"];
            /**
             * @type {Object<_StyleVariableName,_StyleVariable>} variables of
             * the style definition
             */
            this["mVariables"] = {};
            /**
             * @type {Array<_StyleVariable>} variable name to be
             * sorted by length for variable replace
             */
            this["aVariables"] = [];

            if (!this["oStyleMetadata"]) {
                this["oMetadata"]["styles"] = {"variables": {}, "classes": {}};
                this["oStyleMetadata"] = this["oMetadata"]["styles"];
            }

            // create the variables
            if (this["oStyleMetadata"]["variables"]) {
                this["aVariables"] = this["oStyleMetadata"]["variables"];
                UCF_JsUtil["forEach"](
                    this["aVariables"],
                    function (oVariable) {
                        self["addVariable"](
                            oVariable["name"],
                            oVariable["property"],
                            null,
                            oVariable["expression"],
                            oVariable["defaultValue"],
                            oVariable["docu"]
                        );
                    }
                );
            }

            // create the classes
            mOldClasses = this["mClasses"];
            /** @type {Object<_StyleClassSuffix,_StyleClass>} */
            this["mClasses"] = {};
            if (this["oStyleMetadata"]["classes"]) {
                for (n in this["oStyleMetadata"]["classes"]) {
                    oClass = this["oStyleMetadata"]["classes"][n];
                    this["mClasses"][n] = {
                        "suffix": n,
                        "properties": {},
                        "scope": oClass["scope"],
                        "classsuffix": n === '_default' || n === '_' ? '' : n
                    };
                    UCF_JsUtil["forEach"](
                        UCF_JsUtil["values"](oClass["properties"]),
                        /** @param {_StyleProperty} oProp */
                        function (oProp) {
                            /** @type {_StylePropertyName} */
                            var sPropertyName = oProp["name"];

                            if (
                                mOldClasses &&
                                n in mOldClasses &&
                                mOldClasses[n]["properties"] &&
                                sPropertyName in mOldClasses[n]["properties"]
                            ) {
                                oProp["value"] = mOldClasses[n]["properties"][sPropertyName]["value"]
                                    || null;
                            }

                            self["addProperty"](
                                self["mClasses"][n],
                                sPropertyName,
                                oProp["value"] || null,
                                oProp["expression"],
                                oProp["important"]
                            );
                        }
                    );
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["setControlName"] = 0;
    }
    ;

    /**
     * Sets the value of a variable
     * @private
     * @param {_StyleVariableName} sName the name of the variable
     * @param {string} sValue the new value for the variable
     */
    UCF_CustomStyleProvider["prototype"]["setVariable"] = function (sName, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["setVariable"]++;
        }
        ;
        if (sName in this["mVariables"]) {
            this["mVariables"][sName]["value"] = sValue;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["setVariable"] = 0;
    }
    ;

    /**
     * Adds a variable if it does not exist otherwise returns the current variable
     * object
     * @private
     * @param {_StyleVariableName} sName the name of the variable
     * @param {string} sProperty the name of the property for this variable
     * @param {string} sValue the value for this variable
     * @param {string} sExpression the expression for this variable
     * @param {string} sDefaultValue the default value or expression for this
     * variable
     * @param {string} sDocu The documentation to be picked up by a tool.
     * @return {_StyleVariable} The newly created or the
     * already existing variable object.
     */
    UCF_CustomStyleProvider["prototype"]["addVariable"] = function (sName, sProperty, sValue, sExpression, sDefaultValue, sDocu) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["addVariable"]++;
        }
        ;
        /** @type {_StyleVariable} */
        var oVariable;
        /** @type {string} */
        var sDefault;
        /** @type {number} */
        var iStart;
        /** @type {number} */
        var iEnd;
        /** @type {Array<string>} */
        var aParameter;

        if (!(sName in this["mVariables"])) {
            oVariable = {
                "name": sName,
                "property": sProperty,
                "value": sValue || null,
                "expression": sExpression || null,
                "defaultValue": sDefaultValue || null,
                "docu": sDocu
            };
            this["mVariables"][sName] = oVariable;

            if (oVariable["defaultValue"]) {
                if (UCF_StringUtil["bContains"](oVariable["defaultValue"], 'ruleValue')) {
                    sDefault = oVariable["defaultValue"];
                    iStart = sDefault["indexOf"]('ruleValue');
                    iEnd = iStart;

                    sDefault = sDefault["substring"](iStart + 'ruleValue('["length"]);
                    iEnd = sDefault["indexOf"](')');

                    sDefault = sDefault["substring"](0, iEnd);
                    iEnd = iStart + 'ruleValue('["length"] + iEnd;

                    aParameter = sDefault["split"](',');
                    sValue = this["ruleValue"](aParameter[0], aParameter[1]);

                    sDefault = oVariable["defaultValue"];
                    sDefault = sDefault["substring"](0, iStart - 1) +
                        sValue +
                        sDefault["substring"](iEnd + 1);

                    oVariable["defaultExpression"] = oVariable["defaultValue"];
                    oVariable["defaultValue"] = sDefault;
                } else if (UCF_StringUtil["bContains"](oVariable["defaultValue"], 'themeValue')) {
                    // ...
                    sDefault = oVariable["defaultValue"];
                    iStart = sDefault["indexOf"]('themeValue');
                    iEnd = iStart;

                    sDefault = sDefault["substring"](iStart + 'themeValue('["length"]);
                    iEnd = sDefault["indexOf"](')');

                    sDefault = sDefault["substring"](0, iEnd);
                    iEnd = iStart + 'themeValue('["length"] + iEnd;

                    aParameter = sDefault["split"](',');
                    sValue = this["themeValue"](aParameter[0], aParameter[1]);

                    sDefault = oVariable["defaultValue"];
                    sDefault = sDefault["substring"](0, iStart - 1) +
                        sValue +
                        sDefault["substring"](iEnd + 1);

                    oVariable["defaultExpression"] = oVariable["defaultValue"];
                    oVariable["defaultValue"] = sDefault;
                }
            }
        }

        return this["mVariables"][sName];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["addVariable"] = 0;
    }
    ;

    /**
     * Returns an array of the custom styles for all even multiple custom styles
     * applied
     * @todo remove (unused in lightspeed sources, marked as private)
     * @private
     * @return {Array<_StyleDefinition>} An array of custom style objects
     */
    UCF_CustomStyleProvider["prototype"]["getCustomStyles"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCustomStyles"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;

        return UCF_JsUtil["map"](
            this["aCssClassNames"],
            function (sClassName) {
                return self["getCustomStyle"](sClassName);
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCustomStyles"] = 0;
    }
    ;

    /**
     * Returns the custom style if there are multiple custom styles applied only
     * the last one is used in this method.
     * @param {_ControlId} [sName=this.aCssClassNames[this.aCssClassNames.length-1]]
     * the name of the custom style to get
     * @return {_StyleDefinition} The custom style object
     * @private
     */
    UCF_CustomStyleProvider["prototype"]["getCustomStyle"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCustomStyle"]++;
        }
        ;
        /** @type {Object<_StyleClassSuffix,_StyleClass>} */
        var mClasses = this["mClasses"];
        /** @type {_ControlInterface} */
        var oMetadata = this["oMetadata"];
        /** @type {_StyleDefinition} */
        var o;
        /** @type {boolean} */
        var bVars;
        /** @type {boolean} */
        var bValues;
        /** @type {_StyleVariableName} */
        var n;
        /** @type {_StyleClassSuffix} */
        var sSuffix;
        /** @type {_StyleClass} */
        var oClass;
        /** @type {boolean} */
        var bEmpty;
        /** @type {_StylePropertyName} */
        var sPropertyName;
        /** @type {string} */
        var sValue;

        mClasses = this["mClasses"];
        oMetadata = this["oMetadata"];
        o = {
            "type": oMetadata["name"],
            "customStyle": sName || this["aCssClassNames"][this["aCssClassNames"]["length"] - 1],
            "variables": {},
            "values": {}
        };
        bVars = false;
        bValues = false;

        if (this["mVariables"]) {
            for (n in this["mVariables"]) {
                if (this["mVariables"][n]["value"]) {
                    o["variables"][n] = this["mVariables"][n]["value"];
                    bVars = true;
                }
            }
        }

        if (mClasses) {
            for (sSuffix in mClasses) {
                oClass = mClasses[sSuffix];
                o["values"][sSuffix] = {};

                bEmpty = true;
                for (sPropertyName in oClass["properties"]) {
                    sValue = this["getProperty"](oClass, sPropertyName, true, true);
                    if (sValue) {
                        o["values"][sSuffix][sPropertyName] = sValue;
                        bEmpty = false;
                        bValues = true;
                    }
                }
                if (bEmpty) {
                    delete o["values"][sSuffix];
                }
            }
        }
        if (!bVars) {
            delete o["variables"];
        }
        if (!bValues) {
            delete o["values"];
        }

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCustomStyle"] = 0;
    }
    ;

    /**
     * Serializes the current settings of the provider for further usage.
     * The settings can be restored from a serialized object;
     * @private
     * @return {string} Serialized string of the current settings of the provider
     */
    UCF_CustomStyleProvider["prototype"]["serialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["serialize"]++;
        }
        ;
        /** @type {_StyleDefinition} */
        var o = this["getCustomStyle"]();

        return o ? UCF_JsUtil["sJsonStringify"](o) : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["serialize"] = 0;
    }
    ;

    /**
     * Tokenizes a given expression and returns the variable tokens
     * within this expression as a string array
     * @private
     * @param {string} sExpression The expression to tokenize
     * @return {Array<string>} Strings of the variable tokens
     */
    UCF_CustomStyleProvider["prototype"]["tokenizeExpression"] = function (sExpression) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["tokenizeExpression"]++;
        }
        ;
        /** @type {string} */
        var sStopChars = '), ';
        /** @type {string} */
        var sCurrentStopChars = sStopChars;
        /** @type {boolean} */
        var bIsStopChar;
        /** @type {Array<string>} */
        var aTokens = [];
        /** @type {string} */
        var sToken = null;
        /** @type {number} */
        var i;
        /** @type {string} */
        var sChar;

        for (i = 0; i < sExpression["length"]; i++) {
            sChar = sExpression["charAt"](i);
            if (sChar === '@') {
                sToken = '';
            } else if (sToken === '' && sChar === '{') {
                sCurrentStopChars += '}';
            } else if (sToken !== null) {
                bIsStopChar = UCF_StringUtil["bContains"](sCurrentStopChars, sChar);
                if (!bIsStopChar) {
                    sToken += sChar;
                }
                if (bIsStopChar || i === sExpression["length"] - 1) {
                    aTokens["push"](sToken);
                    sToken = null;
                    sCurrentStopChars = sStopChars;
                }
            }
        }

        return aTokens;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["tokenizeExpression"] = 0;
    }
    ;

    /**
     * Returns the CSS representation for a given expression
     * using the less parser
     * @private
     * @param {string} sExpression The expression to be evaluated by the less
     * parser
     * @return {string} The string of css value for the given expression
     */
    UCF_CustomStyleProvider["prototype"]["getCssValueForExpression"] = function (sExpression) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCssValueForExpression"]++;
        }
        ;
        /** @type {less.Parser} */
        var oParser = UCF_CustomStyleProvider["oGetLessParser"]();
        /** @type {string} */
        var sResult = '';

        oParser["parse"](
            '@result:' + sExpression + ';',
            function (error, root) {
                if (error) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'getCssValueForExpression("' + sExpression + '") parsing failed with error: ' + error["message"], "CustomStyleProvider.js(908): getCssValueForExpression");
                    }
                    ;
                } else {
                    try {
                        sResult = root["variable"]('@result')["value"]["eval"]()["toCSS"]();
                    } catch (e) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(ERROR, 'getCssValueForExpression("' + sExpression + '") toCSS() failed with error: ' + e["message"], "CustomStyleProvider.js(913): getCssValueForExpression");
                        }
                        ;
                    }
                }
            }
        );

        return sResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCssValueForExpression"] = 0;
    }
    ;

    /**
     * Returns the CSS values for a given expression array
     * using the less parser
     * @param {Array.<string>} aExpressions The expressions to be evaluated by the
     * less parser
     * @return {Array<string>} The array of css values for each given expression
     */
    UCF_CustomStyleProvider["prototype"]["getCssValueForExpressions"] = function (aExpressions) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCssValueForExpressions"]++;
        }
        ;
        /** @type {less.Parser} */
        var oParser = UCF_CustomStyleProvider["oGetLessParser"]();
        /** @type {Array<string>} */
        var aResults = [];
        /** @type {string} */
        var sLess = UCF_JsUtil["reduce"](
            aExpressions,
            function (sLess, sExpression, i) {
                return sLess + '@result' + i + ':' + sExpression + ';';
            },
            ''
        );

        oParser["parse"](
            sLess,
            function (error, root) {
                if (error) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'getCssValueForExpressions(' + UCF_JsUtil["sJsonStringify"](aExpressions) + ') parsing failed with error: ' + error["message"], "CustomStyleProvider.js(947): getCssValueForExpressions");
                    }
                    ;
                } else {
                    aResults = UCF_JsUtil["map"](
                        aExpressions,
                        function (_, i) {
                            try {
                                return root["variable"]('@result' + i)["value"]["eval"]()["toCSS"]();
                            } catch (e) {
                                if (__UCF_TRACE__) {
                                    UCF_Tracer.trace(ERROR, 'getCssValueForExpressions(' + UCF_JsUtil["sJsonStringify"](aExpressions) + ') toCSS() failed with error: ' + e["message"], "CustomStyleProvider.js(955): getCssValueForExpressions");
                                }
                                ;

                                return '';
                            }
                        }
                    );
                }
            }
        );

        return aResults;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCssValueForExpressions"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sExpression The expression
     * @return {string} The less expression for the given expression
     */
    UCF_CustomStyleProvider["prototype"]["getExpressionLessValue"] = function (sExpression) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getExpressionLessValue"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;

        UCF_JsUtil["forEach"](
            this["tokenizeExpression"](sExpression),
            /** @param {_StyleVariableName} sToken */
            function (sToken) {
                /** @type {string} */
                var sValue = self["mVariables"][sToken]["value"];

                if (sValue) {
                    sExpression = sExpression["replace"](
                        new RegExp('@' + sToken, 'g'),
                        sValue
                    );
                }
            }
        );

        return sExpression;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getExpressionLessValue"] = 0;
    }
    ;

    /**
     * Evaluates the given expression
     * @param {string} sExpression The expression to evaluate
     * @param {Array<string>} aExpressionCycle the already evaluated expressions to
     * avoid cycles
     * @return {string} The value of the expression
     * @private
     */
    UCF_CustomStyleProvider["prototype"]["evaluateExpression"] = function (sExpression, aExpressionCycle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["evaluateExpression"]++;
        }
        ;
        /** @type {Array<string>} */
        var aExpressions;
        /** @type {Array<string>} */
        var aParentExpressions;
        /** @type {number} */
        var i;
        /** @type {number} */
        var ii;
        /** @type {string} */
        var sInternalExpression;
        /** @type {Array<string>} */
        var aTokens;
        /** @type {Array<string>} */
        var aValidValues;
        /** @type {_StyleVariableName} */
        var sToken;
        /** @type {_StyleVariable} */
        var oVariable;
        /** @type {string} */
        var sParentExpression;
        /** @type {boolean} */
        var bCycle;

        if (sExpression) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Evaluating expression ' + sExpression, "CustomStyleProvider.js(1029): evaluateExpression");
            }
            ;

            if (!aExpressionCycle) {
                aExpressionCycle = [];
            }
            aExpressionCycle["push"](sExpression);

            aExpressions = sExpression["split"]('||');
            aParentExpressions = [];

            for (i = 0; i < aExpressions["length"]; i++) {
                sInternalExpression = UCF_StringUtil["sTrim"](aExpressions[i]);
                aTokens = this["tokenizeExpression"](sInternalExpression);
                aValidValues = [];

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Evaluating expression part ' + sInternalExpression, "CustomStyleProvider.js(1044): evaluateExpression");
                }
                ;

                for (ii = 0; ii < aTokens["length"]; ii++) {
                    sToken = aTokens[ii];

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Evaluating expression part token ' + sToken, "CustomStyleProvider.js(1049): evaluateExpression");
                    }
                    ;

                    if (sToken in this["mVariables"]) {
                        oVariable = this["mVariables"][sToken];
                        if (oVariable) { // eslint-disable-line max-depth
                            // eslint-disable-next-line max-depth
                            if (oVariable["value"] === 'ignore') {
                                return 'ignore';
                            }
                            if (oVariable["value"]) { // eslint-disable-line max-depth
                                aValidValues["push"](sToken);
                            } else if (oVariable["expression"]) {
                                aParentExpressions["push"](oVariable["expression"]);
                            } else if (oVariable["defaultValue"] && oVariable["defaultValue"] !== 'null') {
                                aValidValues["push"](sToken);
                            }
                        }
                    }
                }
                if (aTokens["length"] === aValidValues["length"]) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Found valid expression part token for ' + sInternalExpression + ' returning ' + sInternalExpression, "CustomStyleProvider.js(1069): evaluateExpression");
                    }
                    ;

                    return sInternalExpression;
                }
            }

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'No valid expression part tokens found for ' + sExpression, "CustomStyleProvider.js(1075): evaluateExpression");
            }
            ;

            if (aParentExpressions["length"] > 0) {
                for (i = 0; i < aParentExpressions["length"]; i++) {
                    sParentExpression = aParentExpressions[i];

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(DEBUG, 'Checking parent expression ' + sParentExpression, "CustomStyleProvider.js(1081): evaluateExpression");
                    }
                    ;

                    bCycle = false;
                    if (aExpressionCycle) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(DEBUG, 'Checking For Cycles of ' + sParentExpression, "CustomStyleProvider.js(1085): evaluateExpression");
                        }
                        ;

                        for (ii = 0; ii < aExpressionCycle["length"]; ii++) {
                            // eslint-disable-next-line max-depth
                            if (aExpressionCycle[ii] === sParentExpression) {
                                if (__UCF_TRACE__) {
                                    UCF_Tracer.trace(DEBUG, 'Cycles detected ' + sParentExpression + ' Cycles with ' + aExpressionCycle[ii], "CustomStyleProvider.js(1090): evaluateExpression");
                                }
                                ;

                                bCycle = true;
                                break;
                            }
                        }
                    }
                    if (bCycle) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(DEBUG, 'Ignoring Cycle ' + sParentExpression + ' Cycles with ' + aExpressionCycle[ii], "CustomStyleProvider.js(1098): evaluateExpression");
                        }
                        ;
                        continue;
                    }

                    return this["evaluateExpression"](
                        aParentExpressions[i],
                        aExpressionCycle
                    );
                }
            }

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'No Valid Expression found for ' + sExpression, "CustomStyleProvider.js(1109): evaluateExpression");
            }
            ;

            return null;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["evaluateExpression"] = 0;
    }
    ;

    /**
     * Returns the less format of the CSS to be compiled for the custom style.
     * @private
     * @param {string} [sUnique]
     * @return {string} The less format of the CSS to be compiled for the custom style.
     */
    UCF_CustomStyleProvider["prototype"]["getLessText"] = function (sUnique) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getLessText"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;
        /** @type {Object<_StyleClassSuffix,_StyleClass>} */
        var mClasses = this["mClasses"];
        /** @type {string} */
        var sValue = null;
        /** @type {Array<string>} */
        var aLess = UCF_JsUtil["map"](
            this["aVariables"],
            /**
             * @param {_StyleVariable} oVar
             * @return {string}
             */
            function (oVar) {
                /** @type {_StyleVariableName} */
                var sVariableName = oVar["name"];
                /** @type {_StyleVariable} */
                var oVariable = self["mVariables"][sVariableName];
                /** @type {string} */
                var sValue = oVariable["value"];

                oVariable["evaluatedExpression"] = null;

                // eslint-disable-next-line eqeqeq
                if (sValue == oVariable["defaultValue"]) {
                    return '@' + sVariableName + ' : ' + oVariable["defaultValue"] + ';';
                } else {
                    if (!sValue && oVariable["expression"]) {
                        sValue = self["evaluateExpression"](oVariable["expression"]);
                        oVariable["expressionValue"] = sValue === 'ignore' ? '' : sValue;
                    }
                    if (sValue === 'ignore') {
                        sValue = 'null';
                    } else if (!sValue && oVariable["defaultValue"]) {
                        sValue = oVariable["defaultValue"];
                    }

                    return (
                        sVariableName === 'backgroundImage' &&
                        sValue !== 'none' &&
                        sValue !== 'inherit'
                    )
                        ? '@' + sVariableName + ' : url("' + sValue + '");'
                        : '@' + sVariableName + ' : ' + sValue + ';';
                }
            }
        );
        /** @type {string} */
        var sLastCssClassName = this["aCssClassNames"][this["aCssClassNames"]["length"] - 1];
        /** @type {string} */
        var sPrefix = this["sClassPrefix"] || '';
        /** @type {string} */
        var sLess;

        if (sLastCssClassName) {
            UCF_JsUtil["forEach"](
                UCF_JsUtil["values"](mClasses),
                /** @param {_StyleClass} oClass */
                function (oClass) {
                    /** @type {boolean} */
                    var bWritten = false;
                    /** @type {_StylePropertyName} */
                    var sProperty;

                    if (UCF_UserAgent["bIsFirefox"]()) {
                        self["rewriteBackgroundPosition"](oClass);
                    }
                    for (sProperty in oClass["properties"]) {
                        if (!self["bShouldSkipLessGenerationForProperty"](sProperty)) {
                            if (!bWritten) { // eslint-disable-line max-depth
                                bWritten = true;
                                aLess["push"](
                                    UCF_JsUtil["map"](
                                        oClass["classsuffix"]["split"](','),
                                        function (sClass) {
                                            return UCF_StringUtil["bContains"](sClass, '@{CustomStyle}')
                                                ? sPrefix + sClass
                                                : sPrefix + '@{CustomStyle}' + sClass;
                                        }
                                    )
                                        ["join"](',')
                                        ["replace"](/\@\{CustomStyle\}/g, '.' + sLastCssClassName) + '{'
                                );
                            }
                            sValue = self["getProperty"](oClass, sProperty);
                            if (sValue) { // eslint-disable-line max-depth
                                aLess["push"]('  ' + sProperty + ':' + sValue + ';');
                            }
                        }
                    }
                    if (bWritten) {
                        aLess["push"]('}');
                    }
                }
            );
        }

        sLess = aLess["join"]('\n');
        if (sUnique) {
            sLess = sLess["replace"](/@/gi, '@' + sUnique);
        }

        return sLess;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getLessText"] = 0;
    }
    ;

    /**
     * JIRA:PERSONAS30-2916:Firefox does not suport x and y for background
     * position. Transform to background-position for this case.
     * @param {_StyleClass} oClass
     */
    UCF_CustomStyleProvider["prototype"]["rewriteBackgroundPosition"] = function (oClass) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["rewriteBackgroundPosition"]++;
        }
        ;
        if (
            oClass["properties"]['background-position-x'] ||
            oClass["properties"]['background-position-y']
        ) {
            oClass["properties"]['background-position'] = {
                "name": 'background-position',
                "expression": '',
                "important": false,
                "value": null
            };
            if (oClass["properties"]['background-position-x']) {
                oClass["properties"]['background-position']["expression"] =
                    oClass["properties"]['background-position-x']["expression"];
                oClass["properties"]['background-position']["important"] =
                    oClass["properties"]['background-position-x']["important"];
            }
            if (oClass["properties"]['background-position-y']) {
                oClass["properties"]['background-position']["expression"] =
                    oClass["properties"]['background-position']["expression"] + ' ' +
                    oClass["properties"]['background-position-y']["expression"];
                oClass["properties"]['background-position']["important"] =
                    oClass["properties"]['background-position']["important"] ||
                    oClass["properties"]['background-position-y']["important"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["rewriteBackgroundPosition"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sProperty the property
     * @return {boolean}
     */
    UCF_CustomStyleProvider["prototype"]["bShouldSkipLessGenerationForProperty"] = function (sProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["bShouldSkipLessGenerationForProperty"]++;
        }
        ;
        return (
                sProperty === 'background-position-x' ||
                sProperty === 'background-position-x'
            ) &&
            UCF_UserAgent["bIsFirefox"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["bShouldSkipLessGenerationForProperty"] = 0;
    }
    ;

    /**
     * Compiles the less style and applies it to the document after less
     * compilation is done.
     * @see applyStyle
     * @private
     * @param {string} [sLess=this.getLessText()] the less text
     * @return {string}
     */
    UCF_CustomStyleProvider["prototype"]["getCssText"] = function (sLess) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCssText"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var self = this;
        /** @type {string} */
        var sResult = '';

        if (!sLess) {
            sLess = this["getLessText"]();
        }

        try {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Getting css from less: ' + sLess, "CustomStyleProvider.js(1294): getCssText");
            }
            ;
            UCF_CustomStyleProvider["oGetLessParser"]()["parse"](
                sLess,
                function (error, root) {
                    if (error) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(ERROR, 'getCssText("' + sLess + '") parsing failed with error: ' + UCF_JsUtil["sJsonStringify"](error), "CustomStyleProvider.js(1299): getCssText");
                        }
                        ;
                    } else {
                        try {
                            self["sCss"] = root["toCSS"]();
                            sResult = self["sCss"];
                        } catch (e) {
                            if (__UCF_TRACE__) {
                                UCF_Tracer.trace(ERROR, 'getCssText("' + sLess + '") toCSS() failed with error: ' + e["message"], "CustomStyleProvider.js(1305): getCssText");
                            }
                            ;
                            sResult = '';
                        }
                    }
                }
            );
        } catch (ex) {
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Getting css from less results in: ' + sResult, "CustomStyleProvider.js(1313): getCssText");
        }
        ;

        return sResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCssText"] = 0;
    }
    ;

    /**
     * Creates a new style element on the page for the controls custom style and
     * injects it to the documet. If there is already
     * @todo remove (only used in lsx but marked as private)
     * @private
     * @param {UCF_ClientControl} oControl
     */
    UCF_CustomStyleProvider["prototype"]["applyStyle"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["applyStyle"]++;
        }
        ;
        /** @type {string} */
        var sLastCssClassName;

        if (oControl) {
            this["oControl"] = oControl;
            if (!this["oMetadata"]) {
                this["oMetadata"] = oControl["getMetadata"]();
            }
            this["setClassName"](oControl["getCustomStyle"]());
        }

        sLastCssClassName = this["aCssClassNames"][this["aCssClassNames"]["length"] - 1];

        if (sLastCssClassName && this["oControl"]) {
            this["registerStyle"]('edit-' + sLastCssClassName, this["getCustomStyle"]());
            this["updateStyles"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["applyStyle"] = 0;
    }
    ;

    /**
     * Sets a property sName for a given class to a value sValue.
     * @private
     * @param {string|_StyleClass} oClass A suffix classname or a class object
     * returned by getCSSClass
     * @param {string} sName The name of the property to set.
     * @param {string} [sValue] The value for the property.
     * @param {string} [sExpression] the expression to use
     * @param {boolean} [bImportant] `true` if the property is important
     */
    UCF_CustomStyleProvider["prototype"]["setProperty"] = function (oClass, sName, sValue, sExpression, bImportant) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["setProperty"]++;
        }
        ;
        /** @type {_StyleProperty} */
        var oProperty;

        if (typeof oClass === 'string') {
            if (oClass in this["mClasses"]) {
                oClass = this["mClasses"][oClass];
            }
        }

        if (oClass) {
            if (sName in oClass["properties"]) {
                oProperty = oClass["properties"][sName];
                if (sValue || sValue === null) {
                    oProperty["value"] = sValue;
                }
                if (sExpression) {
                    oProperty["expression"] = sExpression;
                }
                if (bImportant) {
                    oProperty["important"] = bImportant;
                }
            } else {
                this["addProperty"](oClass, sName, sValue, sExpression, bImportant);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["setProperty"] = 0;
    }
    ;

    /**
     * Adds a property to the given class
     * @private
     * @param {string|_StyleClass} oClass A suffix classname or
     * a class object returned by getCSSClass
     * @param {string} sName The name of the property to set.
     * @param {string} sValue optional The value for the property.
     * @param {string} sExpression optional the expression to use
     * @param {boolean} bImportant optional Whether the property is important or not
     */
    UCF_CustomStyleProvider["prototype"]["addProperty"] = function (oClass, sName, sValue, sExpression, bImportant) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["addProperty"]++;
        }
        ;
        if (typeof oClass === 'string') {
            if (oClass in this["mClasses"]) {
                oClass = this["mClasses"][oClass];
            }
        }

        if (oClass) {
            oClass["properties"][sName] = {
                "expression": sExpression,
                "name": sName,
                "value": sValue,
                "important": bImportant
            };
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["addProperty"] = 0;
    }
    ;

    /**
     * Returns the copy of the map of variables that is currently defined
     * Structure of a variable is
     * {name:string,property:string,value:string,defaultValue:string,docu:string}
     * To add variables use the addVariable method
     * To remove variables use the removeVariable method
     * @todo remove (only used in lsx but marked as private)
     * @private
     * @param {string|Array<string>} [aFilterProperty=[]] filters the map for given
     * css property
     * @return {Object<string,_StyleVariable>} The map of
     * variables indexed by name
     */
    UCF_CustomStyleProvider["prototype"]["getVariables"] = function (aFilterProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getVariables"]++;
        }
        ;
        /** @type {Object<_StyleVariableName,_StyleVariable>} */
        var oVariableCopy = UCF_CustomStyleProvider["oCloneJSON"](this["mVariables"]);
        /** @type {_StyleVariableName} */
        var sVariableName;
        /** @type {string} */
        var sProperty;

        if (typeof aFilterProperty === 'string') {
            aFilterProperty = [aFilterProperty];
        }

        if (aFilterProperty) {
            for (sVariableName in oVariableCopy) {
                sProperty = oVariableCopy[sVariableName]["property"];
                UCF_JsUtil["forEach"](
                    aFilterProperty,
                    function (sFilterProperty) {
                        if (sProperty !== sFilterProperty) {
                            delete oVariableCopy[sVariableName];
                        }
                    }
                );
            }
        }

        return oVariableCopy;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getVariables"] = 0;
    }
    ;

    /**
     * Returns the value of a variable with the given name
     * @todo remove (unused in lightspeed sources and marked as default visibility)
     * @param {_StyleVariableName} sVariableName The name of the variable
     * @return {string} the value or an empty string.
     */
    UCF_CustomStyleProvider["prototype"]["getVariableValue"] = function (sVariableName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getVariableValue"]++;
        }
        ;
        return this["mVariables"][sVariableName]
            ? this["mVariables"][sVariableName]["value"]
            : '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getVariableValue"] = 0;
    }
    ;

    /**
     * Returns the expression of a variable with the given name
     * @todo remove (unused in lightspeed sources and marked as default visibility)
     * @param {_StyleVariableName} sVariableName The name of the variable
     * @return {string} the value or an empty string.
     */
    UCF_CustomStyleProvider["prototype"]["getVariableExpression"] = function (sVariableName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getVariableExpression"]++;
        }
        ;
        return this["mVariables"][sVariableName]
            ? this["mVariables"][sVariableName]["expression"] || ''
            : '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getVariableExpression"] = 0;
    }
    ;

    /**
     * Returns the copy of the map of CSS classes that is currently defined
     * @todo remove (only used lsx but marked as private)
     * @private
     * @return {Object<string,_StyleClass>} The map of classes indexed by suffix
     */
    UCF_CustomStyleProvider["prototype"]["getCSSClasses"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCSSClasses"]++;
        }
        ;
        return UCF_CustomStyleProvider["oCloneJSON"](this["mClasses"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCSSClasses"] = 0;
    }
    ;

    /**
     * Returns the copy of the map of CSS classes that is currently defined
     * @todo remove (only used in lsx but marked as private)
     * @private
     * @param {_StyleClassSuffix|_StyleClass} oClass the class to get the
     * properties for
     * @return {Object<_StylePropertyName,_StyleProperty>} The map of properties
     * indexed by name
     */
    UCF_CustomStyleProvider["prototype"]["getProperties"] = function (oClass) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getProperties"]++;
        }
        ;
        if (typeof oClass === 'string') {
            if (oClass in this["mClasses"]) {
                oClass = this["mClasses"][oClass];
            }
        }

        return oClass
            ? UCF_CustomStyleProvider["oCloneJSON"](oClass["properties"])
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getProperties"] = 0;
    }
    ;

    /**
     * @private
     * @param {T} oJSON the object to clone
     * @return {T}
     * @template T
     */
    UCF_CustomStyleProvider["oCloneJSON"] = function (oJSON) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["oCloneJSON"]++;
        }
        ;
        return UCF_JsUtil["oJsonParse"](UCF_JsUtil["sJsonStringify"](oJSON));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["oCloneJSON"] = 0;
    }
    ;

    /**
     * Returns the CSS class definition for a given suffix
     * @todo remove (unused in lightspeed sources)
     * @private
     * @param {string} sSuffix The suffix
     * @return {Object} the CSS class definition for a given suffix
     */
    UCF_CustomStyleProvider["prototype"]["getCSSClass"] = function (sSuffix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCSSClass"]++;
        }
        ;
        return this["mClasses"][sSuffix]
            ? UCF_CustomStyleProvider["oCloneJSON"](this["mClasses"][sSuffix])
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCSSClass"] = 0;
    }
    ;

    /**
     * Returns the property value or the less expression for a given sName property
     * in a CSS class oClass. The default value of the theme for this parameter is
     * not taken into account and is not returned.
     * @todo remove (only used in lsx but marked as private)
     * @private
     * @param {_StyleClassSuffix|_StyleClass} oClass The internal class object, can
     * be retrieved by getCSSClass
     * @param {_StylePropertyName} sName The name of the property
     * @param {boolean} bIgnoreExpression `true` to ignore expressions
     * @param {boolean} bIgnoreImportant `true` to ignore !important
     * @return {string} The value of the property or null if not defined.
     */
    UCF_CustomStyleProvider["prototype"]["getProperty"] = function (oClass, sName, bIgnoreExpression, bIgnoreImportant) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getProperty"]++;
        }
        ;
        /** @type {_StyleProperty} */
        var oProperty;
        /** @type {string} */
        var sImportant;
        /** @type {string} */
        var sValue;

        if (typeof oClass === 'string') {
            if (oClass in this["mClasses"]) {
                oClass = this["mClasses"][oClass];
            }
        }

        if (oClass && sName in oClass["properties"]) {
            oProperty = oClass["properties"][sName];
            sImportant = oProperty["important"] && !bIgnoreImportant ? '!important' : '';
            sValue = oProperty["value"];

            if (!bIgnoreExpression && !sValue) {
                sValue = this["evaluateExpression"](oProperty["expression"]);
            }

            return sValue ? sValue + sImportant : null;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getProperty"] = 0;
    }
    ;

    /**
     * Sets the class name that is used to generate the custom style class
     * @private
     * @param {string} sName The name of the CSS class used as prefix
     */
    UCF_CustomStyleProvider["prototype"]["setClassName"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["setClassName"]++;
        }
        ;
        this["aCssClassNames"] = UCF_StringUtil["sTrim"](sName)
            ["replace"](/\s{2,}/g, ' ')
            ["split"](' ');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["setClassName"] = 0;
    }
    ;

    /**
     * Sets the class prefix that is used for conditional fomatting
     * A class prefix is added to every generated rule
     * @private
     * @param {string} sClassPrefix the class prefix that is used for conditional
     * fomatting
     */
    UCF_CustomStyleProvider["prototype"]["setClassPrefix"] = function (sClassPrefix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["setClassPrefix"]++;
        }
        ;
        this["sClassPrefix"] = sClassPrefix || '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["setClassPrefix"] = 0;
    }
    ;

    /** @type {Object<string,Object<string,string>>} */
    UCF_CustomStyleProvider["mThemeValueCache"] = {};
    /** @type {HTMLDivElement} */
    UCF_CustomStyleProvider["oThemeValueRef"] = null;

    /**
     * @private
     * @param {string} sSelector the css selector that contains the background-image
     * with the theme value json as data-uri (text/plain;utf8)
     * @param {string} sProperty the property in the theme value json to read
     * @return {string?} the value of sProperty in the json of sSelector
     */
    UCF_CustomStyleProvider["prototype"]["themeValue"] = function (sSelector, sProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["themeValue"]++;
        }
        ;
        /** @type {_StyleProperty} */
        var sMetaData;
        /** @type {Object} */
        var oMetaData;

        if (!(sSelector in UCF_CustomStyleProvider["mThemeValueCache"])) {
            if (!UCF_CustomStyleProvider["oThemeValueRef"]) {
                UCF_CustomStyleProvider["oThemeValueRef"] = document["createElement"]('div');
                UCF_CustomStyleProvider["oThemeValueRef"]["id"] = 'ls-customstyleprovider-themevalue';

                UCF_DomUtil["setStyle"](UCF_CustomStyleProvider["oThemeValueRef"], {
                    "position": 'absolute',
                    "top": '-10000px',
                    "right": '10000px',
                    "visibility": 'hidden'
                });
                UCF_DomUtil["prepend"](document["body"], UCF_CustomStyleProvider["oThemeValueRef"]);
            }

            sSelector = sSelector["split"]('.')[1];
            UCF_DomUtil["setClass"](UCF_CustomStyleProvider["oThemeValueRef"], sSelector);

            try {
                sMetaData = decodeURIComponent(UCF_DomUtil["sGetCurrentStyle"](
                    UCF_CustomStyleProvider["oThemeValueRef"],
                    'background-image'
                ));

                sMetaData = sMetaData["slice"](sMetaData["indexOf"]('{'), sMetaData["lastIndexOf"]('}') + 1);
                oMetaData = UCF_JsUtil["oJsonParse"](sMetaData);
                UCF_CustomStyleProvider["mThemeValueCache"][sSelector] = oMetaData;

                // UCF_CustomStyleProvider.mThemeValueCache[sSelector] = UCF_JsUtil.oJsonParse(
                // 	decodeURIComponent(UCF_DomUtil.sGetCurrentStyle(
                // 			UCF_DomUtil.sGetCurrentStyle(
                // 				UCF_CustomStyleProvider.oThemeValueRef,
                // 				'background-image'
                // 			)).slice('data:text/plain;utf8,'.length);

            } catch (e) {
                console["error"](e["message"]);
                UCF_CustomStyleProvider["mThemeValueCache"][sSelector] = null;
            }
        }

        return UCF_CustomStyleProvider["mThemeValueCache"][sSelector][sProperty];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["themeValue"] = 0;
    }
    ;

    /**
     * Returns the current value of a certain CSS property for a style rule. The
     * selector text is i.e .className:hover. This API can be used by the editor to
     * determine the currently applied value for the theme for a certain selector.
     * @todo remove (unused in lightspeed sources, marked private, not implemented)
     * @private
     * @param {string} sSelector The selector text
     * @param {string} sProperty The CSS property in css notation (e.g.
     * 'font-family', not 'fontFamily')
     * @return {string} The value or null
     */
    UCF_CustomStyleProvider["prototype"]["ruleValue"] = function (sSelector, sProperty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["ruleValue"]++;
        }
        ;
        return null;
        // /** @type {string} */
        // var sCleanedSelector;
        // /** @type {string} */
        // var sPseudoElement;
        // /** @type {Array<string>} */
        // var aParts;

        // if (!this.mCachedRuleValues) {
        // 	this.mCachedRuleValues = {};
        // }
        // if (!(sSelector in this.mCachedRuleValues)) {
        // 	this.mCachedRuleValues[sSelector] = {};
        // }
        // if (!(sProperty in this.mCachedRuleValues[sSelector])) {
        // 	if (!this.oRuleValueDiv) {
        // 		this.oRuleValueDiv = document.createElement('div');
        // 		this.oRuleValueDiv.setAttribute('id', 'ruleHelper');
        // 		UCF_DomUtil.prepend(document.body, this.oRuleValueDiv);
        // 	}

        // 	if (sSelector.indexOf('.') === 0) {
        // 		sCleanedSelector = sSelector.split('.')[1];
        // 	}

        // 	if (sCleanedSelector.indexOf(':') > -1) {
        // 		aParts = sCleanedSelector.split(':');
        // 		sPseudoElement = ':' + aParts[2];
        // 		sCleanedSelector = aParts[0];
        // 	}

        // 	UCF_DomUtil.setClass(this.oRuleValueDiv, sCleanedSelector);

        // 	this.mCachedRuleValues[sSelector][sProperty] = window.getComputedStyle(
        // 		this.oRuleValueDiv,
        // 		sPseudoElement
        // 	).getPropertyValue(sProperty);
        // }

        // return this.mCachedRuleValues[sSelector][sProperty];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["ruleValue"] = 0;
    }
    ;

    /**
     * Returns the css rule as defined in the stylesheet with the given selector
     * The theme stylesheet is looked up by the UCF_System.sCSSURL parameter
     * There is a lazy indexing used that always looks up the rule with the
     * sSelector and stops if found to avoid indexing the whole CSS.
     * @todo remove (unused in lightspeed sources, marked private, not implemented)
     * @private
     * @param {string} sSelector The selector to search inthe stylesheet
     * @return {Rule|CSSRule} The browsers rule object (Rule for Quirks)
     */
    UCF_CustomStyleProvider["prototype"]["getRule"] = function (sSelector) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getRule"]++;
        }
        ;
        return null;
        // if (!UCF_CustomStyleProvider.oStyleSheet) {
        // 	UCF_CustomStyleProvider.oStyleSheet = UCF_ResourceUtil.oGetLightspeedCssStylesheet();
        // }
        // if (!UCF_CustomStyleProvider.oStyleSheet) {
        // 	_trace(WARNING, "No Theme CSS found");
        // 	return;
        // }
        // if (sSelector in UCF_CustomStyleProvider.mRules) {
        // 	return UCF_CustomStyleProvider.mRules[sSelector];
        // }
        // try {
        // 	var aRules = UCF_CustomStyleProvider.oStyleSheet.cssRules || UCF_CustomStyleProvider.oStyleSheet.rules;

        // 	for (var i = UCF_CustomStyleProvider.iRuleIndex; i < aRules.length; i++) {
        // 		var oRule = aRules[i];
        // 		if (oRule.type == 1) {
        // 			UCF_CustomStyleProvider.mRules[oRule.selectorText] = oRule;
        // 		}
        // 		UCF_CustomStyleProvider.iRuleIndex++;
        // 		if (sSelector in UCF_CustomStyleProvider.mRules) {
        // 			return UCF_CustomStyleProvider.mRules[sSelector];
        // 		}
        // 	}
        // 	UCF_CustomStyleProvider.mRules[sSelector] = null;
        // 	_trace(WARNING, "Rule " + sSelector + " not found");
        // } catch (ex) {

        // }
        // return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getRule"] = 0;
    }
    ;

    /**
     * Returns the variable values for all variables that where explicitly defined
     * @public
     * @return {Object<_StyleVariableName,string>} A map of variables and their
     * values
     */
    UCF_CustomStyleProvider["prototype"]["getVariableValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getVariableValues"]++;
        }
        ;
        return UCF_JsUtil["reduce"](
            UCF_JsUtil["entries"](this["mVariables"]),
            /**
             * @param {Object<_StyleVariableName,string>} oResult the result
             * @param {{0: _StyleVariableName,1: _StyleVariable}} aEntry the entry
             * @return {Object<_StyleVariableName,string>}
             */
            function (oResult, aEntry) {
                /** @type {_StyleVariableName} */
                var sName = aEntry[0];
                /** @type {_StyleVariable} */
                var oVariable = aEntry[1];

                if (oVariable["value"] && !oVariable["calculated"]) {
                    oResult[sName] = oVariable["value"];
                }

                return oResult;
            }, {}
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getVariableValues"] = 0;
    }
    ;

    /**
     * Returns the variable values for all variables that where calculated via
     * expression
     * @public
     * @return {Object<_StyleVariableName,string>} A map of calculated variables
     * and their values
     */
    UCF_CustomStyleProvider["prototype"]["getCalculatedVariableValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCalculatedVariableValues"]++;
        }
        ;
        /** @type {Object<_StyleVariableName,string>} */
        var oResult = {};
        /** @type {Array<_StyleVariableName>} */
        var aVars = [];
        /** @type {Array<string>} */
        var aMatchingExpressions = [];
        /** @type {string} */
        var sName;
        /** @type {_StyleVariable} */
        var oVariable;
        /** @type {string} */
        var sMatchingExpression;
        /** @type {tring} */
        var sExpression;
        /** @type {Array<string>} */
        var aCssValues;
        /** @type {number} */
        var i;

        for (sName in this["mVariables"]) {
            oVariable = this["mVariables"][sName];

            if (!oVariable["value"] && oVariable["expression"]) {
                sMatchingExpression = this["evaluateExpression"](oVariable["expression"]);

                if (sMatchingExpression) {
                    sExpression = this["getExpressionLessValue"](sMatchingExpression);

                    if (sExpression) {
                        aMatchingExpressions["push"](sExpression);
                        aVars["push"](sName);
                        oResult[sName] = this["getCssValueForExpression"](sExpression);
                    }
                }
            }
        }

        aCssValues = this["getCssValueForExpressions"](aMatchingExpressions);
        for (i = 0; i < aCssValues["length"]; i++) {
            if (aCssValues[i]) {
                oResult[aVars[i]] = aCssValues[i];
            }
        }

        return oResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCalculatedVariableValues"] = 0;
    }
    ;

    /**
     * Returns the variable values for all variables that where explicitly defined
     * based on the given control instance
     * @public
     * @param {UCF_ClientControl} oControlInstance The client control
     * @return {Object<_StyleVariableName,string>} A map of variables and their
     * values
     */
    UCF_CustomStyleProvider["getVariableValues"] = function (oControlInstance) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getVariableValues"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var oStyleProvider = new (UCF_ClassLoader["oGetClass"]("UCF_CustomStyleProvider"))(oControlInstance);

        oStyleProvider["updateStyles"]();

        return oStyleProvider["getVariableValues"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getVariableValues"] = 0;
    }
    ;

    /**
     * Returns the variable values for all variables that where calculated via
     * expression based on the given control instance
     * @public
     * @param {UCF_ClientControl} oControlInstance The client control
     * @return {Object<_StyleVariableName,string>} A map of calculated variables
     * and their values
     */
    UCF_CustomStyleProvider["getCalculatedVariableValues"] = function (oControlInstance) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getCalculatedVariableValues"]++;
        }
        ;
        /** @type {UCF_CustomStyleProvider} */
        var oStyleProvider = new (UCF_ClassLoader["oGetClass"]("UCF_CustomStyleProvider"))(oControlInstance);

        oStyleProvider["updateStyles"]();

        return oStyleProvider["getCalculatedVariableValues"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getCalculatedVariableValues"] = 0;
    }
    ;

    /**
     * Returns the id of the registry style tag that includes the first occurance
     * of sName which starts with an optional prefix
     * @todo remove (unused in lightspeed sources, marked with default visibility)
     * @param {string} sName The name of the custom style as given with the control
     * @param {string} [sPrefix] prefix for the style block, i.e. P6S_
     * @return {string}
     */
    UCF_CustomStyleProvider["getRegistryIdForCustomStyleName"] = function (sName, sPrefix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["getRegistryIdForCustomStyleName"]++;
        }
        ;
        /** @type {_StyleRegistry} */
        var mRegistry = UCF_CustomStyleProvider["getStyleRegistry"]();
        /** @type {_ControlId} */
        var sControlId;
        /** @type {_StyleId} */
        var sValueId;

        for (sControlId in mRegistry) {
            for (sValueId in mRegistry[sControlId]) {
                if (sName === mRegistry[sControlId][sValueId]["customStyle"]) {
                    if (!sPrefix || UCF_StringUtil["bStartsWith"](sControlId, sPrefix)) {
                        return sControlId;
                    }
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["getRegistryIdForCustomStyleName"] = 0;
    }
    ;

    /**
     * @todo remove (unused in lightspeed sources, marked with default visibility)
     * @param {string} sPrefix the id prefix
     */
    UCF_CustomStyleProvider["unregisterIdPrefix"] = function (sPrefix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["unregisterIdPrefix"]++;
        }
        ;
        /** @type {_StyleRegistry} */
        var mRegistry = UCF_CustomStyleProvider["getStyleRegistry"]();
        /** @type {UCF_CustomStyleProvider} */
        var oProvider = new (UCF_ClassLoader["oGetClass"]("UCF_CustomStyleProvider"))();
        /** @type {_ControlId} */
        var sControlId;

        for (sControlId in mRegistry) {
            if (UCF_StringUtil["bStartsWith"](sControlId, sPrefix)) {
                oProvider["unregisterStyles"](sControlId);
                oProvider["updateStyles"](sControlId);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["unregisterIdPrefix"] = 0;
    }
    ;

    /**
     * @private
     * @param {_StyleVariableName} sVariable the variable to find
     * @return {Array<_StyleClass>}
     */
    UCF_CustomStyleProvider["prototype"]["aGetVariableOccurrence"] = function (sVariable) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_CustomStyleProvider["_"]["aGetVariableOccurrence"]++;
        }
        ;
        /** @type {string} */
        var sProperty = this["mVariables"][sVariable]["property"];

        return UCF_JsUtil["filter"](
            UCF_JsUtil["values"](this["mClasses"]),
            function (oClass) {
                return oClass["properties"][sProperty]
                    && UCF_StringUtil["bContains"](
                        oClass["properties"][sProperty]["expression"],
                        '@' + sVariable
                    );
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_CustomStyleProvider["_"]["aGetVariableOccurrence"] = 0;
    }
    ;

    UCF_CustomStyleProvider.prototype["aPublicMethods"] = ["getVariableValues", "getCalculatedVariableValues", "getVariableValues", "getCalculatedVariableValues"].concat(UCF_CustomStyleProvider.prototype.aPublicMethods || []);
    /* global UCF_KeyCodes */
/// <reference path="../../core/enums/KeyCodes.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="../../core/util/XSSEncoder.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_ControlFactory */
/// <reference path="./ControlFactory.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="./ResourceUtil.js"/>
    /* global UCF_System */

/// <reference path="./System.js"/>

    /**
     * This helpers are EXCLUDED from any support.
     *
     * Class to manage the handling of debug shortcuts (Ctrl-Alt-Shift-...).
     * Handler classes should only be loaded, when they are called, so only the classname
     * is used to identify the handler, instances are created on demand.
     *
     * @class
     *
     * @private
     * @param {object} oLS
     */
    function UCF_DebugHelper(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["UCF_DebugHelper"]++;
        }
        ;

        UCF_Object["apply"](this);

        /** @type {UCF_LS} */

        this["oLS"] = oLS;

        this["mDebugHandlers"] = {};

        // Registration for debug shortcut events
        var oBrowserWindow = oLS["oBrowserWindow"];
        oBrowserWindow["attachEvent"](oBrowserWindow["E_EVENTS"]["Debug"], this, "onDebug");

        this["addDebugHandlerClass"](UCF_KeyCodes["V"], "UCF_VersionInfo", "Shows/hides pane with version information");

        if (__UCF_DEBUG__) {
            //register helpers only if ClientDebug is true

            // Add known debug handlers from LS
            this["addDebugHandlerClass"](UCF_KeyCodes["A"], "UCF_AccessibilityInfo", "Shows/hides accessibility text display");
            //B: WDA Turn on/off debugger
            //C: WD ABAP Trace Tool
            this["addDebugHandlerClass"](UCF_KeyCodes["O"], "UCF_ContainerOutliner", "Shows nesting of HTML containers");
            this["addDebugHandlerClass"](UCF_KeyCodes["D"], "UCF_DOMAnalyzer", "Shows HTML DOM analysis");
            //M  No Debug Helper Command!!! Used for toggling Message Focus
            this["addDebugHandlerClass"](UCF_KeyCodes["N"], "UCF_NestingAnalyzer", "Shows nesting analysis");
            //F: WDA Runtime-Accessibility Trace
            //this.addDebugHandlerClass(UCF_KeyCodes.H, "UCF_DebugHelper", "Shows/hides the list of helper shortcuts");
            //L: LSX download
            //P: WDA Performance monitor
            this["addDebugHandlerClass"](UCF_KeyCodes["S"], "UCF_SizeInfo", "Shows/hides pane with size information.");
            //this.addDebugHandlerClas(UCF_KeyCodes.T, this, "Shows/hides trace window");

            this["addDebugHandlerClass"](UCF_KeyCodes["R"], "UCF_SeleniumRecorder", "Starts/stops the Selenium Test script recording.");

            UCF_DebugHelper["oWindow"] = window;
        }
        if (__UCF_DEBUG__ && !UCF_UserAgent["bIsDesktop"]()) {
            this["oElement"] = document["createElement"]("DIV");
            this["oElement"]["style"]["position"] = "fixed";
            this["oElement"]["style"]["overflow"] = "hidden";
            this["oElement"]["style"]["top"] = "-2px";
            this["oElement"]["style"]["right"] = "35px";
            this["oElement"]["style"]["width"] = "35px";
            this["oElement"]["style"]["height"] = "30px";
            this["oElement"]["style"]["backgroundColor"] = "rgba(200,200,200,0.8)";
            this["oElement"]["style"]["fontSize"] = "22px";
            this["oElement"]["style"]["padding"] = "0px 15px";
            this["oElement"]["style"]["boxSizing"] = "border-box";
            this["oElement"]["style"]["color"] = "#185779";
            this["oElement"]["style"]["lineHeight"] = "35px";
            this["oElement"]["style"]["border"] = "1px solid #185779";
            this["oElement"]["setAttribute"]("closed", "true");
            this["oElement"]["innerHTML"] = "<div style=\"text-align:right;\">+</div>";
            var that = this;
            UCF_DomUtil["attachEvent"](this["oElement"], "click", function (oEvent) {
                if (oEvent["target"] && oEvent["target"]["getAttribute"]("helper")) {
                    var oDebugHandler = that["mDebugHandlers"][oEvent["target"]["getAttribute"]("helper")];
                    if (!oDebugHandler) return;
                    if (!oDebugHandler["oObject"]) {
                        var sClassName = oDebugHandler["sClassName"],
                            oClass = UCF_ClassLoader["oGetClass"](sClassName);
                        oDebugHandler["oObject"] = new oClass(that["oLS"]);
                    }
                    oDebugHandler["oObject"]["trigger"]();
                } else {
                    if (that["oElement"]["getAttribute"]("closed") == "false") {
                        that["oElement"]["style"]["width"] = "35px";
                        that["oElement"]["style"]["height"] = "35px";
                        that["oElement"]["innerHTML"] = "<div style=\"text-align:right\">+</div>";
                        that["oElement"]["setAttribute"]("closed", "true");

                    } else {
                        that["oElement"]["innerHTML"] = "<div style=\"text-align:right\">-</div>";
                        that["oElement"]["setAttribute"]("closed", "false");
                        that["oElement"]["style"]["width"] = "300px";
                        that["oElement"]["style"]["height"] = "500px";
                        for (var i in that["mDebugHandlers"]) {
                            oDebugHandler = that["mDebugHandlers"][i];
                            var oDiv = document["createElement"]("div");
                            oDiv["setAttribute"]("helper", i);
                            oDiv["title"] = i;
                            oDiv["style"]["cursor"] = "pointer";
                            oDiv["style"]["width"] = "100%";
                            oDiv["style"]["overflow"] = "hidden";
                            oDiv["style"]["textOverflow"] = "ellipsis";
                            oDiv["style"]["whiteSpace"] = "nowrap";
                            // eslint-disable-next-line no-unsanitized/property
                            oDiv["innerHTML"] = oDebugHandler["sDescription"];
                            that["oElement"]["appendChild"](oDiv);
                        }
                    }
                }
            });
            document["body"]["appendChild"](this["oElement"]);

        }
    };window["UCF_DebugHelper"] = UCF_DebugHelper;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_DebugHelper");
        UCF_DebugHelper["_"] = {UCF_DebugHelper: 0};
    }
    ;
    ;
    UCF_DebugHelper["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_DebugHelper.prototype["sClassName"] = "UCF_DebugHelper";

    /**
     * Destroy all created handlers
     * @param {object} oEvent
     */
    UCF_DebugHelper["prototype"]["destroy"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["destroy"]++;
        }
        ;
        var sClassName, oObject;

        // Only destroy objects we have created
        for (var i in this["mDebugHandlers"]) {
            sClassName = this["mDebugHandlers"][i]["sClassName"];
            oObject = this["mDebugHandlers"][i]["oObject"];
            if (sClassName && oObject) {
                oObject["destroy"]();
            }
        }
        UCF_DebugHelper["oWindow"] = null;
        if (this["oElement"]) {
            UCF_DomUtil["detachEvent"](this["oElement"], "click");
            this["oElement"] = null;
        }
        this["oLS"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DebugHelper["_"]["destroy"] = 0;
    }
    ;

    /**
     * If an debug shortcut on the screen occurs, lookup for an instance of the info pane.
     *
     * @param {UCF_Event} oEvent The event object
     */
    UCF_DebugHelper["prototype"]["onDebug"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["onDebug"]++;
        }
        ;
        var iKey = oEvent["oGetParam"]("iKey"),
            oDebugHandler = this["mDebugHandlers"][iKey];

        // Special key "H" shows available debug handlers
        if (iKey == UCF_KeyCodes["H"]) {
            this["showAvailableHandlers"](oEvent);
            return;
        }

        // If there is no handler for this key return, nothing to do
        if (!oDebugHandler) return;

        // If there is no object yet for this key create it
        if (!oDebugHandler["oObject"]) {
            var sClassName = oDebugHandler["sClassName"],
                oClass = UCF_ClassLoader["oGetClass"](
                    sClassName,
                    sClassName === "UCF_SeleniumRecorder" ? (UCF_ResourceUtil["sGetQUnitRoot"]() + "/SeleniumRecorder.js") : undefined
                );
            oDebugHandler["oObject"] = new oClass(this["oLS"]);
        }

        var oBrowserEvent = oEvent["oGetParam"]("oBrowserEvent");
        oDebugHandler["oObject"]["trigger"]();

        oBrowserEvent["cancel"]();
        oBrowserEvent["cancelBubble"]();
        oBrowserEvent["bHandled"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DebugHelper["_"]["onDebug"] = 0;
    }
    ;

    /**
     * Add a handler for a given keyboard shortcut
     *
     * @param {int} iKeyCode the keycode the handler should be called on
     * @param {object} oObject
     * @param {string} sDescription Description
     */
    UCF_DebugHelper["prototype"]["addDebugHandler"] = function (iKeyCode, oObject, sDescription) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["addDebugHandler"]++;
        }
        ;
        this["mDebugHandlers"][iKeyCode] = {"oObject": oObject, "sDescription": sDescription};
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DebugHelper["_"]["addDebugHandler"] = 0;
    }
    ;

    /**
     * Add a handler for a given keyboard shortcut
     *
     * @param {int} iKeyCode the keycode the handler should be called on
     * @param {String} sClassName the class name of the handler
     * @param {String} sDescription the description of the handler
     */
    UCF_DebugHelper["prototype"]["addDebugHandlerClass"] = function (iKeyCode, sClassName, sDescription) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["addDebugHandlerClass"]++;
        }
        ;
        this["mDebugHandlers"][iKeyCode] = {"sClassName": sClassName, "sDescription": sDescription};
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DebugHelper["_"]["addDebugHandlerClass"] = 0;
    }
    ;

    /**
     * Show all registered handlers for debug shortcuts
     * @param {UCF_Event} oEvent
     */
    UCF_DebugHelper["prototype"]["showAvailableHandlers"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["showAvailableHandlers"]++;
        }
        ;
        if (
            !UCF_JsUtil["bIsEmpty"](this["mDebugHandlers"]) &&
            !(UCF_JsUtil["keys"](this["mDebugHandlers"])["length"] === 1 &&
                UCF_JsUtil["contains"](UCF_JsUtil["keys"](this["mDebugHandlers"]), '86'))
        ) {
            // don't display help if only the version key is included
            // ([CTRL][SHIFT][ALT][V] with keycode 86)
            var sDisplayText = "Available SAP UR Lightspeed Ctrl-Alt-Shift Shortcuts:\n\n These shortcuts work as implemented!\n\n",
                oDebugHandler;
            for (var i in this["mDebugHandlers"]) {
                oDebugHandler = this["mDebugHandlers"][i];
                sDisplayText += String["fromCharCode"](i) + " - " + oDebugHandler["sDescription"] + "\n";
            }
            alert(sDisplayText);

            var oBrowserEvent = oEvent["oGetParam"]("oBrowserEvent");
            oBrowserEvent["cancel"]();
            oBrowserEvent["cancelBubble"]();
            oBrowserEvent["bHandled"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_DebugHelper["_"]["showAvailableHandlers"] = 0;
    }
    ;

    if (__UCF_DEBUG__) {
        /**
         * @see {@link UCF_LS#oGetVisualViewport()}
         * @private
         * @param {_ObjectRect} oRect
         * @param {string} color
         * @param {string} text
         */
        UCF_DebugHelper["border"] = function (oRect, color, text) {
            ;
            if (__UCF_COVERAGE__) {
                UCF_DebugHelper["_"]["border"]++;
            }
            ;
            UCF_DebugHelper["hLine"](oRect["pageTop"], oRect["pageLeft"], oRect["width"], 'top', 'red');
            UCF_DebugHelper["hLine"](oRect["pageTop"] + oRect["height"] - 2, oRect["pageLeft"], oRect["width"], 'bottom', 'red');
            UCF_DebugHelper["vLine"](oRect["pageTop"], oRect["pageLeft"], oRect["height"], 'before', 'red', text);
            UCF_DebugHelper["vLine"](oRect["pageTop"], oRect["pageLeft"] + oRect["width"] - 2, oRect["height"], 'after', 'red');
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["border"] = 0;
        }
        ;

        UCF_DebugHelper["text"] = function (top, left, color, text) {
            ;
            if (__UCF_COVERAGE__) {
                UCF_DebugHelper["_"]["text"]++;
            }
            ;
            var id = 'text_' + color;
            var oParagraph = document["getElementById"](id);
            if (oParagraph) {
                UCF_DomUtil["removeFromDom"](oParagraph);
            }
            oParagraph = document["createElement"]('p');
            oParagraph["id"] = id;
            oParagraph["style"]["position"] = 'relative';
            oParagraph["style"]["top"] = '2px';
            oParagraph["innerHTML"] = UCF_XSSEncoder["encodeHTML"](text);
            oParagraph["style"]["fontSize"] = 'small';
            oParagraph["style"]["fontWeight"] = 'bold';
            oParagraph["style"]["backgroundColor"] = color;
            oParagraph["style"]["display"] = 'inline';

            return oParagraph;
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["text"] = 0;
        }
        ;

        UCF_DebugHelper["hLine"] = function (top, left, width, id, color, text) {
            ;
            if (__UCF_COVERAGE__) {
                UCF_DebugHelper["_"]["hLine"]++;
            }
            ;
            var myId = 'hline_' + id + '_' + color;
            var oDiv = document["getElementById"](myId);
            var oBody = document["body"];

            if (oDiv) {
                UCF_DomUtil["removeFromDom"](oDiv);
            }
            oDiv = document["createElement"]('div');
            oDiv["id"] = myId;
            oDiv["style"]["position"] = 'absolute';
            oDiv["style"]["top"] = top + 'px';
            oDiv["style"]["left"] = left + 'px';
            oDiv["style"]["height"] = '2px';
            oDiv["style"]["width"] = width + 'px';
            oDiv["style"]["backgroundColor"] = color;
            if (text) {
                oDiv["appendChild"](UCF_DebugHelper["text"](top, left, color, text));
            }
            oBody["insertBefore"](oDiv, oBody["firstChild"]);
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["hLine"] = 0;
        }
        ;

        UCF_DebugHelper["vLine"] = function (top, left, height, id, color, text) {
            ;
            if (__UCF_COVERAGE__) {
                UCF_DebugHelper["_"]["vLine"]++;
            }
            ;
            var myId = 'vline_' + id + '_' + color;
            var oDiv = document["getElementById"](myId);
            var oBody = document["body"];

            if (oDiv) {
                UCF_DomUtil["removeFromDom"](oDiv);
            }
            oDiv = document["createElement"]('div');
            oDiv["id"] = myId;
            oDiv["style"]["position"] = 'absolute';
            oDiv["style"]["top"] = top + 'px';
            oDiv["style"]["left"] = left + 'px';
            oDiv["style"]["height"] = height + 'px';
            oDiv["style"]["width"] = '2px';
            oDiv["style"]["backgroundColor"] = color;
            if (text) {
                oDiv["appendChild"](UCF_DebugHelper["text"](top, left, color, text));
            }
            oBody["insertBefore"](oDiv, oBody["firstChild"]);
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_DebugHelper["_"]["vLine"] = 0;
        }
        ;
    }

    /**
     *
     * Exception class
     *
     * This is the base exception class. In contrary to the Error an Exception
     * should be thrown in cases, where the exception can, and should, be handled
     * within the framework, instead of causing the application to exit.
     *
     * The try/catch statement in JavaScript can not catch specific exceptions, so
     * when catching internal exceptions you should make sure to rethrow other errors:
     *
     * try {
     *     ...
     * }
     * catch (oException) {
     *     if (oException instanceof sap.ui.base.Exception) {
     *         ... handle exception ...
     *     }
     *     else {
     *         throw oException;
     *     }
     * }
     * @class
     * @param {string} message
     */
    function UCF_Exception(message) {
        if (__UCF_COVERAGE__) {
            UCF_Exception["_"]["UCF_Exception"]++;
        }
        ;
        this["name"] = "Exception"; // eslint-disable-line ur/no-memory-leaks
        this["message"] = message; // eslint-disable-line ur/no-memory-leaks
    };window["UCF_Exception"] = UCF_Exception;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Exception");
        UCF_Exception["_"] = {UCF_Exception: 0};
    }
    ;
    ;


// eslint-disable-next-line ur/no-memory-leaks
    UCF_Exception["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Exception["_"]["destroy"]++;
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Exception["_"]["destroy"] = 0;
    }
    ;


    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global _trace, _assert, WARNING */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_Control */
/// <reference path="./Control.js"/>
    /* global UCF_LS */

/// <reference path="./LS.js"/>

    /**
     * A FocusInfo object contains all relevant information to restore
     * the focus state when there was a server roundtrip
     *
     *
     * @class
     * @version
     * @param {UCF_LS} oLS the LS instance
     */
    function UCF_FocusInfo(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["UCF_FocusInfo"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "FocusInfo.js(26): UCF_FocusInfo");
        }
        ;

        UCF_Object["apply"](this);

        /** @type {UCF_LS} */
        this["oLS"] = oLS;
        /** @type {string} */
        this["sFocussedId"] = '';
        /** @type {string} */
        this["sApplyControlId"] = '';
        /** @type {string} */
        this["sPopupWindowId"] = '';
        /** @type {Object} */
        this["mParameters"] = {};
        /** @type {HTMLElement} */
        this["oDomRefOrgFocussedElement"] = null;
        /** @type {string} */
        this["sSubControlHandle"] = '';

    };window["UCF_FocusInfo"] = UCF_FocusInfo;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_FocusInfo");
        UCF_FocusInfo["_"] = {UCF_FocusInfo: 0};
    }
    ;
    ;
    UCF_FocusInfo["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_FocusInfo.prototype["sClassName"] = "UCF_FocusInfo";

    /** @override */
    UCF_FocusInfo["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["destroy"]++;
        }
        ;
        this["cleanUp"]();

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["destroy"] = 0;
    }
    ;

    /**
     * @private
     * @const
     * @enum {string}
     */
    UCF_FocusInfo["PARAMS_TO_SERIALIZE"] = {
        "sFocussedId": 'sFocussedId',
        "sApplyControlId": 'sApplyControlId',
        "sPopupWindowId": 'sPopupWindowId',
        "sSubControlHandle": 'sSubControlHandle'

    };

    /**
     * @private
     * @const {string}
     */
    UCF_FocusInfo["ID_MARKER"] = '@';

    /**
     * CleanUp of the FocusInfo object
     */
    UCF_FocusInfo["prototype"]["cleanUp"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["cleanUp"]++;
        }
        ;
        this["oLS"] = null;
        this["sFocussedId"] = '';
        this["sApplyControlId"] = '';
        this["sPopupWindowId"] = '';
        this["mParameters"] = null;
        this["oDomRefOrgFocussedElement"] = null;
        this["sSubControlHandle"] = '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["cleanUp"] = 0;
    }
    ;

    /**
     * Initializes the FocusInfo
     *
     * @param {HTMLElement} [oDomRefOrgFocussedElement] the focussed element
     */
    UCF_FocusInfo["prototype"]["init"] = function (oDomRefOrgFocussedElement) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["init"]++;
        }
        ;
        /** @type {string} */
        var sFocussedElementId = '';
        /** @type {UCF_Control} */
        var oControl;
        /** @type {UCF_Control} */
        var oCurrControl;
        /** @type {UCF_PopupManager} */
        var oPopupManager = this["oLS"]["oGetPopupManagerInternal"]();
        /** @type {string} */
        var sPopupWindowId = oPopupManager && oPopupManager["sGetPopupIdByWindow"](window);

        if (oDomRefOrgFocussedElement && oDomRefOrgFocussedElement["getAttribute"]) {
            this["oDomRefOrgFocussedElement"] = oDomRefOrgFocussedElement;
            oControl = this["oLS"]["oGetControlByDomRef"](oDomRefOrgFocussedElement);
            sFocussedElementId = this["oDomRefOrgFocussedElement"]["getAttribute"]('id');
        }

        if (oControl && !sFocussedElementId) {
            if (oControl["oFocusDomRef"]) {
                sFocussedElementId = oControl["oFocusDomRef"]["getAttribute"]('id');
            } else if (oControl["oDomRef"]) {
                sFocussedElementId = oControl["oDomRef"]["getAttribute"]('id');
            }
        }

        if (sFocussedElementId) {
            this["setFocussedId"](sFocussedElementId);
            if (sFocussedElementId["indexOf"]('-') > -1 && sFocussedElementId["substring"](sFocussedElementId["indexOf"]('-') + 1) !== 'r') {
                this["setSubControlHandle"](sFocussedElementId["substring"](sFocussedElementId["indexOf"]('-') + 1));
            }
        }

        if (sPopupWindowId) {
            this["sPopupWindowId"] = sPopupWindowId;
        }

        // Collect focusInfo from focussed conrol and its containers
        if (oControl) {
            oCurrControl = oControl;

            while (oCurrControl != null && oCurrControl["bIsValid"]()) {
                oCurrControl["collectFocusInfo"](this);
                oCurrControl = oCurrControl["oGetParent"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["init"] = 0;
    }
    ;

    /**
     * Sets the ID of the DomElement which has to be focussed
     *
     * @param {string} sFocussedId
     */
    UCF_FocusInfo["prototype"]["setFocussedId"] = function (sFocussedId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["setFocussedId"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sFocussedId === 'string', "typeof sFocussedId === 'string'", "FocusInfo.js(146): setFocussedId");
        }
        ;

        this["sFocussedId"] = sFocussedId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["setFocussedId"] = 0;
    }
    ;

    /**
     * Returns the ID of the DomElement which has to be focussed
     *
     * @return {string} sFocussedId
     */
    UCF_FocusInfo["prototype"]["sGetFocussedId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["sGetFocussedId"]++;
        }
        ;
        return this["sFocussedId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["sGetFocussedId"] = 0;
    }
    ;

    /**
     * Sets the Subcontrol Suffix (if any) of the Control which has to be focussed
     *
     * @param {string} sSubControlHandle
     */
    UCF_FocusInfo["prototype"]["setSubControlHandle"] = function (sSubControlHandle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["setSubControlHandle"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sSubControlHandle === 'string', "typeof sSubControlHandle === 'string'", "FocusInfo.js(166): setSubControlHandle");
        }
        ;

        this["sSubControlHandle"] = sSubControlHandle;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["setSubControlHandle"] = 0;
    }
    ;

    /**
     * Returns the Suncontrol Suffix (if any) of the DomElement which has to be focussed
     *
     * @return { string } sSubControlHandle
     */
    UCF_FocusInfo["prototype"]["sGetSubControlHandle"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["sGetSubControlHandle"]++;
        }
        ;
        return this["sSubControlHandle"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["sGetSubControlHandle"] = 0;
    }
    ;

    /**
     * Sets the control which needs to be notified when the
     * the focus has to be applied again.
     *
     * @param {UFC_Control} oApplyControl the control to notify when the focus is
     * applied
     */
    UCF_FocusInfo["prototype"]["setApplyControl"] = function (oApplyControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["setApplyControl"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oApplyControl instanceof UCF_Control, "oApplyControl instanceof UCF_Control", "FocusInfo.js(188): setApplyControl");
        }
        ;

        this["sApplyControlId"] = oApplyControl["sId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["setApplyControl"] = 0;
    }
    ;

    /**
     * Returns the ID of PopupWindow the info was created for
     *
     * @return {string} sPopupWindowId
     */
    UCF_FocusInfo["prototype"]["sGetPopupWindowId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["sGetPopupWindowId"]++;
        }
        ;
        return this["sPopupWindowId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["sGetPopupWindowId"] = 0;
    }
    ;

    /**
     * Returns the DOM ref of the original focused element
     *
     * @return {HTMLElement} the DOM ref of the original focused element
     */
    UCF_FocusInfo["prototype"]["oGetOrgFocussedElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["oGetOrgFocussedElement"]++;
        }
        ;
        return this["oDomRefOrgFocussedElement"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["oGetOrgFocussedElement"] = 0;
    }
    ;

    /**
     * Adds a parameter value identified by the given key to the parameter map
     *
     * @param {string} sKey a key
     * @param {any} oValue a value associated with the key
     */
    UCF_FocusInfo["prototype"]["addParam"] = function (sKey, oValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["addParam"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sKey === 'string', "typeof sKey === 'string'", "FocusInfo.js(218): addParam");
        }
        ;

        this["mParameters"][sKey] = oValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["addParam"] = 0;
    }
    ;

    /**
     * Returns the value of a parameter identified by the given key
     *
     * @param {string} sKey the key to retrieve the value for
     * @return {any} the value
     */
    UCF_FocusInfo["prototype"]["oGetParam"] = function (sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["oGetParam"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sKey === 'string', "typeof sKey === 'string'", "FocusInfo.js(230): oGetParam");
        }
        ;

        return this["mParameters"][sKey];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["oGetParam"] = 0;
    }
    ;

    /**
     * Deletes a parameter identified by the given key from the parameter map
     *
     * @param {string} sKey the key to delete the value for
     */
    UCF_FocusInfo["prototype"]["deleteParam"] = function (sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["deleteParam"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sKey === 'string', "typeof sKey === 'string'", "FocusInfo.js(241): deleteParam");
        }
        ;

        delete this["mParameters"][sKey];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["deleteParam"] = 0;
    }
    ;

    /**
     * Applies the focus to a DomRef
     * @param {boolean} bForce `true` to force synchronous application
     * (`oControl.focus()`), `false` for asynchronous application
     * (`oControl.moveFocus()`)
     */
    UCF_FocusInfo["prototype"]["apply"] = function (bForce) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["apply"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oApplyControl;
        /** @type {HTMLElement} */
        var oDomRef;
        /** @type {UCF_Control} */
        var oControl;

        if (this["sSubControlHandle"] && this["sFocussedId"]["indexOf"]('-') < 0 && UCF_DomUtil["$"](this["sFocussedId"] + '-' + this["sSubControlHandle"])) {
            this["setFocussedId"](this["sFocussedId"] + '-' + this["sSubControlHandle"]);
        }

        if (this["sApplyControlId"]) {
            oApplyControl = this["oLS"]["oControlFactory"]["oGetControlById"](
                this["sApplyControlId"]
            );
            if (oApplyControl && oApplyControl["bIsVisible"]()) {
                oApplyControl["applyFocusInfo"](this);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Focus failed: Control "' + this["sApplyControlId"] + '" ' + (oApplyControl ? 'exists but is not visible.' : 'does not exist.'), "FocusInfo.js(271): apply");
                }
                ;
            }
        } else if (this["sFocussedId"]) {
            oDomRef = UCF_DomUtil["$"](this["sFocussedId"]);
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](this["sFocussedId"]);

            // handle focus for popup window (focus its title)
            if (oControl && UCF_JsUtil["bInstanceOf"](oControl, 'UCF_PopupWindow')) {
                oControl["focus"]();
            } else if (oControl && oControl["bIsVisible"]()) {
                if (bForce) {
                    oControl["focus"]();
                } else {
                    oControl["moveFocus"]();
                }
            } else if (oDomRef) {
                // delayed call because of
                // 1) AccessibilityHelper issue - tooltip was not updated with ACC
                // information CSN: 0000892740 2008.
                // 2) When this is called after a roundtrip the InputField is only
                // focussed properly by delayedCall
                if (UCF_DomUtil["bIsVisible"](oDomRef, true)) {
                    UCF_JsUtil["delayedCall"](0, UCF_DomUtil, 'focusDomElement', [oDomRef]);
                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(WARNING, 'Focus failed: DOM element "' + this["sFocussedId"] + '" exists but is not visible.', "FocusInfo.js(295): apply");
                    }
                    ;
                }
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Focus failed: DOM element "' + this["sFocussedId"] + '" does not exist.', "FocusInfo.js(298): apply");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["apply"] = 0;
    }
    ;

    /**
     * Serializes the FocusInfo
     *
     * @return {string}
     */
    UCF_FocusInfo["prototype"]["sSerialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["sSerialize"]++;
        }
        ;
        /** @type {string} */
        var i;

        for (i in UCF_FocusInfo["PARAMS_TO_SERIALIZE"]) {
            if (this[i]) {
                this["addParam"](UCF_FocusInfo["PARAMS_TO_SERIALIZE"][i], this[i]);
            }
        }

        return UCF_JsUtil["bIsEmpty"](this["mParameters"])
            ? ''
            : UCF_FocusInfo["ID_MARKER"] + UCF_JsUtil["sJsonStringify"](this["mParameters"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["sSerialize"] = 0;
    }
    ;

    /**
     * De-serializes an sInfo String to the FocusInfo object data
     *
     * @param {string} sInfo
     */
    UCF_FocusInfo["prototype"]["deserialize"] = function (sInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FocusInfo["_"]["deserialize"]++;
        }
        ;
        /** @type {any} */
        var oCurrValue;
        /** @type {Object} */
        var oResult;
        /** @type {string} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sInfo === 'string', "typeof sInfo === 'string'", "FocusInfo.js(336): deserialize");
        }
        ;

        if (sInfo) {
            if (UCF_StringUtil["bStartsWith"](sInfo, UCF_FocusInfo["ID_MARKER"])) {
                oResult = UCF_JsUtil["oJsonParse"](
                    sInfo["substring"](UCF_FocusInfo["ID_MARKER"]["length"], sInfo["length"])
                );
                this["mParameters"] = oResult;

                for (i in UCF_FocusInfo["PARAMS_TO_SERIALIZE"]) {
                    oCurrValue = this["oGetParam"](UCF_FocusInfo["PARAMS_TO_SERIALIZE"][i]);
                    if (oCurrValue) {
                        this[i] = oCurrValue; // eslint-disable-line ur/no-memory-leaks
                        this["deleteParam"](UCF_FocusInfo["PARAMS_TO_SERIALIZE"][i]);
                    }
                }
            } else {
                this["setFocussedId"](sInfo);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FocusInfo["_"]["deserialize"] = 0;
    }
    ;

    /* global UCF_Exception */

/// <reference path="./Exception.js"/>

    /**
     *
     * FormatException class
     *
     * This exception is thrown, when an error occurs while trying to convert a value of the model to
     * a specific property value in the UI.
     * @class
     * @param {string} message
     */
    function UCF_FormatException(message) {
        if (__UCF_COVERAGE__) {
            UCF_FormatException["_"]["UCF_FormatException"]++;
        }
        ;
        if (arguments["length"] === 0) return;

        this["name"] = 'FormatException'; // eslint-disable-line ur/no-memory-leaks
        this["message"] = message;	       // eslint-disable-line ur/no-memory-leaks
    };window["UCF_FormatException"] = UCF_FormatException;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_FormatException");
        UCF_FormatException["_"] = {UCF_FormatException: 0};
    }
    ;
    ;
    UCF_FormatException["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Exception"))();
    UCF_FormatException.prototype["sClassName"] = "UCF_FormatException";

    UCF_FormatException["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_FormatException["_"]["destroy"]++;
        }
        ;
        UCF_Exception.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_FormatException["_"]["destroy"] = 0;
    }
    ;


    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_ResourceUtil */

/// <reference path="./ResourceUtil.js"/>

    /**
     * Use the IconPool static class to add a font icon to a dom element
     * The styles are taken from the dom element itself or the parents. Color and size can be applied there.
     *
     *
     * @class
     */
    function UCF_IconPool() {
        if (__UCF_COVERAGE__) {
            UCF_IconPool["_"]["UCF_IconPool"]++;
        }
        ;
    };window["UCF_IconPool"] = UCF_IconPool;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_IconPool");
        UCF_IconPool["_"] = {UCF_IconPool: 0};
    }
    ;
    ;

    /**
     * Sets an icon with sIconName to the given dom element
     * Additional styles are taken from the Dom Element itself or its parents. Color and size can be applied there.
     * @param {string} sIconName The name of the icon as defined in the IconPool.enumeration
     * @param {Element} oDomRef The dom element where the icon should be displayed.
     * @public
     */
    UCF_IconPool["setIcon"] = function (sIconName, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IconPool["_"]["setIcon"]++;
        }
        ;
        UCF_IconPool["addIconFontCSS"](UCF_ResourceUtil["sGetFontsRoot"]() + "/");
        var o = this["getCharAndFont"](sIconName);
        if (!o) return;
        if (oDomRef) {
            oDomRef["className"] = "urFontIcon";
            oDomRef["setAttribute"]("data-sap-icon-content", o["char"]);
            oDomRef["style"]["fontFamily"] = o["fontFamily"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IconPool["_"]["setIcon"] = 0;
    }
    ;

    /**
     * Adds the SAP-icons font to the head of the document styles
     * from the given URL. If no URL is given the CSSUrl of the system interface is used.
     * @param {string} sUrl {optional} the url
     * @param {string} sFontName {optional} Font Name
     * @private
     */
    UCF_IconPool["addIconFontCSS"] = function (sUrl, sFontName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IconPool["_"]["addIconFontCSS"]++;
        }
        ;
        if (!sUrl) sUrl = UCF_ResourceUtil["sGetFontsRoot"]() + "/";
        if (!sFontName) sFontName = "SAP-icons";
        if (!UCF_IconPool["aIcons"]) {
            UCF_IconPool["aIcons"] = [];
            var sFontFace = "@font-face {" +
                "font-family: '" + sFontName + "';" +
                "src: url('" + sUrl + sFontName + ".eot');" +
                "src: url('" + sUrl + sFontName + ".eot?#iefix') format('embedded-opentype')," +
                "url('" + sUrl + sFontName + ".ttf') format('truetype');" +
                "font-weight: normal;" +
                "font-style: normal;" +
                "}";
            var oMap = Function("return " + UCF_RequestUtil["sendSyncRequest"](sUrl + sFontName + ".map.js", "GET")["sText"])();
            if (oMap) {
                var o = {};
                o[sFontName] = oMap;
                UCF_IconPool["aIcons"]["push"](o);
            }
            sFontFace += ".urFontIcon {}" +
                ".urFontIcon::before { content:attr(data-sap-icon-content); font-style:normal}";
            var oDiv = document["createElement"]("DIV");
            // eslint-disable-next-line no-unsanitized/property
            oDiv["innerHTML"] = "<style type=\"text/css\">" + sFontFace + "</style>";
            document["getElementsByTagName"]("HEAD")[0]["appendChild"](oDiv["firstChild"]);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IconPool["_"]["addIconFontCSS"] = 0;
    }
    ;

    UCF_IconPool["applyAllIcons"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IconPool["_"]["applyAllIcons"]++;
        }
        ;
        var oImgs = oDomRef["getElementsByTagName"]("IMG");
        for (var i = 0; i < oImgs["length"]; i++) {
            var sSrc = oImgs[i]["getAttribute"]("src");
            if (sSrc["indexOf"]("sap-icons://") > 0) {
                var oSpan = document["createElement"]("SPAN");
                this["setIcon"](sSrc, oSpan);
                oImgs[i]["parentNode"]["relaceChild"](oImgs[i], oSpan);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IconPool["_"]["applyAllIcons"] = 0;
    }
    ;

    /**
     * Returns the uni-code char for the given icon name.
     * @param {string} sIconName the icon name
     * @return {array} The unicode char for the icon.
     * @public
     */
    UCF_IconPool["getCharAndFont"] = function (sIconName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IconPool["_"]["getCharAndFont"]++;
        }
        ;
        if (!sIconName) return null;

        if (sIconName["indexOf"]("sap-icons://") === 0) {
            sIconName = sIconName["substring"](sIconName["lastIndexOf"]("/") + 1);
        }
        sIconName = sIconName["toLowerCase"]()["replace"]("_", "-");
        for (var i = UCF_IconPool["aIcons"]["length"] - 1; i >= 0; i--) {
            for (var n in UCF_IconPool["aIcons"][i]) {
                var sResult = UCF_IconPool["aIcons"][i][n][sIconName];
                if (sResult) {
                    return {"char": sResult, "fontFamily": n};
                }
            }
        }
        return {};
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IconPool["_"]["getCharAndFont"] = 0;
    }
    ;

    UCF_IconPool.prototype["aPublicMethods"] = ["setIcon", "getCharAndFont"].concat(UCF_IconPool.prototype.aPublicMethods || []);
    /* global _assert, _trace, DEBUG, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */

/// <reference path="../../core/util/DomUtil.js"/>

    /**
     * @class
     */
    function UCF_ImageUtil() {
        if (__UCF_COVERAGE__) {
            UCF_ImageUtil["_"]["UCF_ImageUtil"]++;
        }
        ;

    };window["UCF_ImageUtil"] = UCF_ImageUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ImageUtil");
        UCF_ImageUtil["_"] = {UCF_ImageUtil: 0};
    }
    ;
    ;

    /*
UCF_System is not available yet
*/

    if (document["getElementsByTagName"]('html')[0]["getAttribute"]('data-sap-ls-system-useragent') &&
        document["getElementsByTagName"]('html')[0]["getAttribute"]('data-sap-ls-system-useragent')["indexOf"]("MSIE") !== 0) {
        if (window["addEventListener"])
            window["addEventListener"]('DOMContentLoaded', function (e) {

                var aImgs = document["querySelectorAll"]('img[errorFallbackSrc]');
                for (var i = 0; i < aImgs["length"]; i++)
                    aImgs[i]["onerror"] = UCF_ImageUtil["onError"];
            });
    }
    ;

    UCF_ImageUtil["onError"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ImageUtil["_"]["onError"]++;
        }
        ;
        UCF_ImageUtil["loadErrorFallbackSrc"](this);
        this["setAttribute"]('berror', 'true');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ImageUtil["_"]["onError"] = 0;
    }
    ;

    UCF_ImageUtil["loadErrorFallbackSrc"] = function (oImageRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ImageUtil["_"]["loadErrorFallbackSrc"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oImageRef != null, "oImageRef != null", "ImageUtil.js(34): loadErrorFallbackSrc");
        }
        ;

        try {
            var sErrorFallbackSrc = oImageRef["getAttribute"]('errorFallbackSrc');
            oImageRef["onerror"] = null;

            if (sErrorFallbackSrc) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'Try to load fallback image from: ' + sErrorFallbackSrc, "ImageUtil.js(41): loadErrorFallbackSrc");
                }
                ;
                this["setImageSource"](sErrorFallbackSrc, oImageRef);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Unable to load fallback image. Missing source', "ImageUtil.js(44): loadErrorFallbackSrc");
                }
                ;
            }
        } catch (oException) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Unable to load fallback image', "ImageUtil.js(47): loadErrorFallbackSrc");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ImageUtil["_"]["loadErrorFallbackSrc"] = 0;
    }
    ;

    /**
     * Returns the image source of a control
     *
     * @param {HTMLElement} oImageRef
     * @return {string}
     * @private
     */
    UCF_ImageUtil["sGetImageSource"] = function (oImageRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ImageUtil["_"]["sGetImageSource"]++;
        }
        ;
        var sImageSrc;

        if (!oImageRef) return '';

        if (oImageRef["tagName"] === 'IMG') {
            sImageSrc = oImageRef["getAttribute"]('src');
        } else if (oImageRef["tagName"]["toUpperCase"]() === 'SVG') {
            //sImageSrc = oImageRef.getAttribute('xlink:href');
            sImageSrc = '';
        } else {
            if (oImageRef["hasAttribute"] && oImageRef["hasAttribute"]('data-src')) {
                sImageSrc = oImageRef["getAttribute"]('data-src');
            } else {
                sImageSrc = UCF_DomUtil["sGetCurrentStyle"](oImageRef, 'backgroundImage');
                sImageSrc = sImageSrc["substring"](4, sImageSrc["length"] - 1);
                //Firefox surrounds the url with "
                sImageSrc = sImageSrc["replace"]("\"", "");
            }
        }

        return sImageSrc;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ImageUtil["_"]["sGetImageSource"] = 0;
    }
    ;

    /**
     * Sets the image source
     *
     * @param {string} sImageSrc
     * @param {HTMLElement} oImageRef
     * @private
     */
    UCF_ImageUtil["setImageSource"] = function (sImageSrc, oImageRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ImageUtil["_"]["setImageSource"]++;
        }
        ;

        if (!oImageRef) return;

        if (oImageRef["tagName"] === "IMG") {
            sImageSrc = oImageRef["setAttribute"]("src", sImageSrc);
        } else if (oImageRef["tagName"] === "SVG") {
            sImageSrc = oImageRef["setAttribute"]("xlink:href", sImageSrc);
        } else {
            //TODO
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ImageUtil["_"]["setImageSource"] = 0;
    }
    ;

    /* global UCF_HotkeyValues */
/// <reference path="../../core/enums/HotkeyValues.js"/>
    /* global UCF_KeyCodes */
/// <reference path="../../core/enums/KeyCodes.js"/>
    /* global UCF_KeyNames */
/// <reference path="../../core/enums/KeyNames.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Page */
/// <reference path="../../ls/core/Page.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_System */

/// <reference path="./System.js"/>

    /**
     * Hotkey helper functions
     *
     * @class
     *
     */
    function UCF_KeyboardHelper() {
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["UCF_KeyboardHelper"]++;
        }
        ;

    };window["UCF_KeyboardHelper"] = UCF_KeyboardHelper;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_KeyboardHelper");
        UCF_KeyboardHelper["_"] = {UCF_KeyboardHelper: 0};
    }
    ;
    ;
    UCF_KeyboardHelper["bAccessKeyHighlight"] = false;
    UCF_KeyboardHelper["oRootRef"] = null;

    /**
     * Returns the hotkey text for tooltips or other string representation e.g. menu
     *
     * @param {UCF_LS} oLS the LightSpeed to use
     * @param {string} sHotkey the hotkey to get the text for
     * @return {string} the hotkey text in brackets
     */
    UCF_KeyboardHelper["sGetHotkeyText"] = function (oLS, sHotkey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["sGetHotkeyText"]++;
        }
        ;
        if (!sHotkey || sHotkey === '' || !this["bIsValidHotkeyByString"](sHotkey) || !this["bIsSupportedPlatform"]()) {
            //Decision 2020: Hotkeys should work on all platforms(like enter for ITS) but tooltip should not displayed on not supported platforms.
            return '';
        }

        var index = sHotkey["lastIndexOf"]('_'),
            compareText = '';

        if (index < 0) {
            compareText = sHotkey;
        } else if (index + 1 < sHotkey["length"]) {
            compareText = sHotkey["substr"](0, index);
            sHotkey = sHotkey["substr"](index + 1);
        }

        if (UCF_UserAgent["bIsMacOs"]()) {
            switch (compareText) {
                case 'NONE':
                    sHotkey = '';
                    break;
                case 'CTRL':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_CMD', sHotkey);
                    break;
                case 'CTRL_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_CMD_SHIFT', sHotkey);
                    break;
                case 'ALT':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT', sHotkey);
                    break;
                case 'ALT_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT_SHIFT', sHotkey);
                    break;
                case 'ALT_ARROW':
                    if (sHotkey === 'LEFT') sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_LEFT'));
                    else if (sHotkey === 'UP') sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_UP'));
                    else if (sHotkey === 'RIGHT') sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_RIGHT'));
                    else if (sHotkey === 'DOWN') sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_DOWN'));
                    break;
                case 'SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_MAC_CMD_SHIFT', sHotkey);
                    break;
                case 'CTRL_ALT_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'M_KEY_MAC_CMD_ALT_SHIFT', sHotkey);
                    break;
                case 'ESCAPE':
                    sHotkey = this["sGetText"](oLS, 'ESCAPE_KEY', sHotkey);
                    break;
                case 'DELETE':
                    sHotkey = this["sGetText"](oLS, 'DELETE_KEY', sHotkey);
                    break;
                case 'INSERT':
                    sHotkey = this["sGetText"](oLS, 'INSERT_KEY', sHotkey);
                    break;
            }
        } else {
            switch (compareText) {
                case 'NONE':
                    sHotkey = '';
                    break;
                case 'CTRL':
                    sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_CTRL', sHotkey);
                    break;
                case 'CTRL_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_CTRL_SHIFT', sHotkey);
                    break;
                case 'ALT':
                    sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT', sHotkey);
                    break;
                case 'ALT_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT_SHIFT', sHotkey);
                    break;
                case 'ALT_ARROW':
                    if (sHotkey === 'LEFT') sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_LEFT'));
                    else if (sHotkey === 'UP') sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_UP'));
                    else if (sHotkey === 'RIGHT') sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_RIGHT'));
                    else if (sHotkey === 'DOWN') sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_ALT', this["sGetText"](oLS, 'NAV_KEY_CURSOR_DOWN'));
                    break;
                case 'SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODIFIER_KEY_SHIFT', sHotkey);
                    break;
                case 'CTRL_ALT_SHIFT':
                    sHotkey = this["sGetText"](oLS, 'MODI_KEY_CTRL_ALT_SHIFT', sHotkey);
                    break;
                case 'ESCAPE':
                    sHotkey = this["sGetText"](oLS, 'ESCAPE_KEY', sHotkey);
                    break;
                case 'DELETE':
                    sHotkey = this["sGetText"](oLS, 'DELETE_KEY', sHotkey);
                    break;
                case 'INSERT':
                    sHotkey = this["sGetText"](oLS, 'INSERT_KEY', sHotkey);
                    break;
            }
        }

        return sHotkey === ''
            ? ''
            : '(' + sHotkey + ')';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["sGetHotkeyText"] = 0;
    }
    ;

    /**
     * Returns the text for a given sTextKey and replaces its placeholders with the given values
     * A placeholder is in {0}
     *
     * @private
     *
     * @param {UCF_LS} oLS the LightSpeed instance to use
     * @param {string} sTextKey The text key
     * @param {Array} aValues Array of values for the placeholders
     *
     * @return {string} the text for a given sTextKey
     */
    UCF_KeyboardHelper["sGetText"] = function (oLS, sTextKey, aValues) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["sGetText"]++;
        }
        ;
        var sText = oLS["sGetText"]('SAPUR_' + sTextKey);

        if (aValues && typeof aValues !== 'undefined') {
            if (typeof aValues === 'string') {
                aValues = [aValues];
            }
            for (var i = 0; i < aValues["length"]; i++) {
                sText = sText["replace"]('{' + i + '}', aValues[i]);
            }
        }

        if (!sText) sText = sTextKey;

        return sText;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["sGetText"] = 0;
    }
    ;

    /**
     * Concatenate modifiers keys and keycode and returns string representation
     *
     * @param {number} iKey the Keycode of the event
     * @param {boolean} bCtrl ctrl key is pressed
     * @param {boolean} bAlt alt key is pressed
     * @param {boolean} bShift shift key is pressed
     *
     * @return {string} the hotkey value for the given key combination
     */
    UCF_KeyboardHelper["sHotkeyValue"] = function (iKey, bCtrl, bAlt, bShift) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["sHotkeyValue"]++;
        }
        ;
        return UCF_JsUtil["filter"](['CTRL_', 'ALT_', 'SHIFT_'], function (sModifier, iIndex) {
            return [bCtrl, bAlt, bShift][iIndex];
        })["join"]('') + UCF_KeyNames[iKey];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["sHotkeyValue"] = 0;
    }
    ;

    /**
     * Checks whether a platform supports hotkeys
     *
     * @return {boolean} `true` if platform supportd hotkeys
     */
    UCF_KeyboardHelper["bIsSupportedPlatform"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsSupportedPlatform"]++;
        }
        ;
        //Decision 2020: Hotkeys should work on all platforms(like enter for ITS) but tooltip should not displayed on not supported platforms.
        //Render tooltip / menu entry only on MAC, WIN, CHROMEOS or Linux but not e.g.on mobile platforms like IOS and Android as hotkeys not supported.
        return (
            UCF_UserAgent["bIsWindows"]() ||
            UCF_UserAgent["bIsChromeOS"]() ||
            UCF_UserAgent["bIsMacOs"]() ||
            UCF_UserAgent["bIsLinux"]()
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsSupportedPlatform"] = 0;
    }
    ;

    /**
     * Checks whether a hotkey is supported in browser supports hotkeys
     * @param { string } sHotkey hotkey in string presentation
     * @param {boolean} bAlternativeKeyboardHandling `true` if UR runs in WebGui
     *
     * @return {boolean} `true` if browser supports hotkey.
     */
    UCF_KeyboardHelper["bIsSupportedHotkeyInBrowser"] = function (sHotkey, bAlternativeKeyboardHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsSupportedHotkeyInBrowser"]++;
        }
        ;

        if (sHotkey === "CTRL_F4") {
            //closes the browser without warning
            return false;
        }

        if (UCF_UserAgent["bIsFirefox"]() && sHotkey === "CTRL_SHIFT_Q") {
            //closes the firefox browser without warning
            return false;
        }

        if (!UCF_UserAgent["bIsIE"]() && !UCF_UserAgent["bIsMSEdge"]()) {
            if (sHotkey === "CTRL_W" ||
                sHotkey === "CTRL_SHIFT_W" ||
                sHotkey === "CTRL_N" ||
                sHotkey === "CTRL_SHIFT_N" ||
                sHotkey === "CTRL_T" ||
                sHotkey === "CTRL_SHIFT_T") {
                return false;
            }
        }

        if (sHotkey === "F6" && !bAlternativeKeyboardHandling) {
            //F6 can only be used as a Hotkey in ITS
            return false;
        }

        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsSupportedHotkeyInBrowser"] = 0;
    }
    ;

    /**
     * Checks whether the keystroke is a valid supported hotkey.
     * @param {int} iKey the Keycode of the event
     * @param {boolean} bCtrl ctrl key is pressed
     * @param {boolean} bAlt alt key is pressed
     * @param {boolean} bShift shift key is pressed
     * @param {boolean} bAlternativeKeyboardHandling `true` if UR runs in WebGui
     * @return {boolean} `true` if pressed combination is a valid hotkey, otherwise `false`
     */
    UCF_KeyboardHelper["bIsValidHotkey"] = function (iKey, bCtrl, bAlt, bShift, bAlternativeKeyboardHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsValidHotkey"]++;
        }
        ;
        return this["bIsValidHotkeyByString"](this["sHotkeyValue"](iKey, bCtrl, bAlt, bShift, bAlternativeKeyboardHandling));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsValidHotkey"] = 0;
    }
    ;

    /**
     * Checks whether the Hotkey is a valid supported hotkey.
     * @param {string} sHotkey hotkey in string presentation
     * @param {boolean} bAlternativeKeyboardHandling `true` if UR runs in WebGui
     *
     * @return {boolean} `true` if pressed combination is a valid hotkey, otherwise `false`
     */
    UCF_KeyboardHelper["bIsValidHotkeyByString"] = function (sHotkey, bAlternativeKeyboardHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsValidHotkeyByString"]++;
        }
        ;
        //Decision 2020: Hotkeys should work on all platforms(like enter for ITS) but tooltip should not displayed on not supported platforms.
        if (!this["bIsSupportedHotkeyInBrowser"](sHotkey, bAlternativeKeyboardHandling)) {
            return false;
        }

        return !!UCF_HotkeyValues[sHotkey];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsValidHotkeyByString"] = 0;
    }
    ;

    /**
     * Shows visualization for available access keys
     */
    UCF_KeyboardHelper["showAccessKeys"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["showAccessKeys"]++;
        }
        ;

        // 2014/09/05 D030999
        // Switching off the Access Key feature visualization for RTL due to a Microsoft bug [REG:114090111757998].
        // See Note 2059993. Remove that workaround when MS fixed the bug
        if (window["UCF_System"]["bIsRTL"] && UCF_UserAgent["bIsTrident"](6) && window["UCF_System"]["sDevice"] === 'ie6') { // eslint-disable-line no-magic-numbers
            return;
        }

        if (UCF_Page["bIsPageVisualizeAccesskeysEnabled"]) {
            // don't visualize accesskeys at the label and via overlay at the same time
            return;
        }

        if (window["UCF_System"]["sInteractionType"] == "TOUCH") {
            //We do not support access keys for any touch devices independend from browser type
            return;
        }

        if (!this["bAccessKeyHighlight"]) {
            UCF_DomUtil["addClass"](this["oRootRef"], 'urHighlightAccessKey');
            this["bAccessKeyHighlight"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["showAccessKeys"] = 0;
    }
    ;

    /**
     * Hides access key visualization
     */
    UCF_KeyboardHelper["hideAccessKeys"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["hideAccessKeys"]++;
        }
        ;
        if (this["bAccessKeyHighlight"]) {
            UCF_DomUtil["removeClass"](this["oRootRef"], 'urHighlightAccessKey');
            this["bAccessKeyHighlight"] = false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["hideAccessKeys"] = 0;
    }
    ;

    /**
     * Checks key code if it is a special key or an normal edit key which are used to enter a charcter into an field.
     * @param {number} iKey the Keycode of the event
     * @return {boolean} `true` in case of key code was an edit key and not a function key.
     */
    UCF_KeyboardHelper["bIsEditKey"] = function (iKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsEditKey"]++;
        }
        ;
        //list of function keys which are normally not used to enter characters into an edit field.
        return (iKey !== UCF_KeyCodes["TAB"] &&
            iKey !== UCF_KeyCodes["SHIFT"] &&
            iKey !== UCF_KeyCodes["CONTROL"] &&
            iKey !== UCF_KeyCodes["ALT"] &&
            iKey !== UCF_KeyCodes["BREAK"] &&
            iKey !== UCF_KeyCodes["CAPS_LOCK"] &&
            iKey !== UCF_KeyCodes["ESCAPE"] &&
            iKey !== UCF_KeyCodes["PAGE_UP"] &&
            iKey !== UCF_KeyCodes["PAGE_DOWN"] &&
            iKey !== UCF_KeyCodes["END"] &&
            iKey !== UCF_KeyCodes["HOME"] &&
            iKey !== UCF_KeyCodes["ARROW_LEFT"] &&
            iKey !== UCF_KeyCodes["ARROW_UP"] &&
            iKey !== UCF_KeyCodes["ARROW_RIGHT"] &&
            iKey !== UCF_KeyCodes["ARROW_DOWN"] &&
            iKey !== UCF_KeyCodes["PRINT"] &&
            iKey !== UCF_KeyCodes["INSERT"] &&
            iKey !== UCF_KeyCodes["WINDOWS"] &&
            iKey !== UCF_KeyCodes["CONTEXT_MENU"] &&
            iKey !== UCF_KeyCodes["TURN_OFF"] &&
            iKey !== UCF_KeyCodes["TURN_OFF"] &&
            iKey !== UCF_KeyCodes["SLEEP"] &&
            iKey !== UCF_KeyCodes["F1"] &&
            iKey !== UCF_KeyCodes["F2"] &&
            iKey !== UCF_KeyCodes["F3"] &&
            iKey !== UCF_KeyCodes["F4"] &&
            iKey !== UCF_KeyCodes["F5"] &&
            iKey !== UCF_KeyCodes["F6"] &&
            iKey !== UCF_KeyCodes["F7"] &&
            iKey !== UCF_KeyCodes["F8"] &&
            iKey !== UCF_KeyCodes["F9"] &&
            iKey !== UCF_KeyCodes["F10"] &&
            iKey !== UCF_KeyCodes["F11"] &&
            iKey !== UCF_KeyCodes["F12"] &&
            iKey !== UCF_KeyCodes["NUM_LOCK"] &&
            iKey !== UCF_KeyCodes["SCROLL_LOCK"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsEditKey"] = 0;
    }
    ;

    /**
     * @example
     * UCF_KeyboardHelper.bIsEventForKey(oBrowserEvent, UCF_KeyCodes.F4) // matches [F4] exactly
     * UCF_KeyboardHelper.bIsEventForKey(oBrowserEvent, UCF_KeyCodes.DOWN, 'A') // matches [ALT]+[DOWN] exactly
     * UCF_KeyboardHelper.bIsEventForKey(oBrowserEvent, UCF_KeyCodes.DELETE, 'CA') // matches [CTRL]+[ALT]+[DELETE] exactly
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the key event
     * @param {number} iKeyCode the keycode that should be checked (see UCF_KeyCodes)
     * @param {string} [sModifiers=] modifiers that should be pressed ('A' for alt, 'C' for ctrl, 'S' for shift)
     * @return {boolean} `true` if the key event represents a keypress with the given modifiers of the key specified
     */
    UCF_KeyboardHelper["bIsEventForKey"] = function (oBrowserEvent, iKeyCode, sModifiers) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsEventForKey"]++;
        }
        ;
        var bAlt = oBrowserEvent["bAlt"](),
            bCtrl = oBrowserEvent["bCtrl"](),
            bShift = oBrowserEvent["bShift"](),
            sUppercaseModifiers = (sModifiers || '')["toUpperCase"]();

        return (oBrowserEvent["iKeyCode"]() === iKeyCode)
            && (UCF_StringUtil["bContains"](sUppercaseModifiers, 'A') ? bAlt : !bAlt)
            && (UCF_StringUtil["bContains"](sUppercaseModifiers, 'C') ? bCtrl : !bCtrl)
            && (UCF_StringUtil["bContains"](sUppercaseModifiers, 'S') ? bShift : !bShift);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsEventForKey"] = 0;
    }
    ;

    /**
     * @param {UCF_BrowserEvent} oBrowserEvent the key event
     * @param {number} iKeyCode the keycode that should be checked
     * @return {boolean} `true` if the key code should be handled as accesskey
     */
    UCF_KeyboardHelper["bShouldHandleAccessKey"] = function (oBrowserEvent, iKeyCode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bShouldHandleAccessKey"]++;
        }
        ;
        //See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/accesskey
        //Chromium Edge & Chrome: [ALT] + [Accesskey]
        //Firefox: [ALT] + [SHIFT] + [Accesskey]
        //IE: [ALT] + [Accesskey] or [ALT] + [SHIFT] + [Accesskey] -> let IE handle the accesskeys itself as it works fine
        //Opera: [ALT] + [Accesskey] -> not included
        return this["bIsEditKey"](iKeyCode) && this["bIsValidAccessKeyShortcut"](oBrowserEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bShouldHandleAccessKey"] = 0;
    }
    ;

    /**
     * @param {UCF_BrowserEvent} oBrowserEvent the key event
     * @return {boolean} `true` if the key combination should trigger the accesskey
     */
    UCF_KeyboardHelper["bIsValidAccessKeyShortcut"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsValidAccessKeyShortcut"]++;
        }
        ;
        return ((UCF_UserAgent["bIsLinux"]() ||
                    UCF_UserAgent["bIsWindows"]() ||
                    UCF_UserAgent["bIsChromeOS"]()
                ) &&
                (UCF_UserAgent["bIsWebKit"]() && oBrowserEvent["bAlt"]() && !oBrowserEvent["bShift"]() ||
                    UCF_UserAgent["bIsGecko"]() && oBrowserEvent["bAlt"]() && oBrowserEvent["bShift"]()
                )) ||
            (UCF_UserAgent["bIsMacOs"]() &&
                (UCF_UserAgent["bIsWebKit"]() && oBrowserEvent["bAlt"]() && !oBrowserEvent["bShift"]() ||
                    UCF_UserAgent["bIsGecko"]() && oBrowserEvent["bAlt"]() && oBrowserEvent["bCtrl"]()
                ));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsValidAccessKeyShortcut"] = 0;
    }
    ;

    /**
     * @param {number} iKeyCode the key code to check
     * @return {boolean} `true` if the key code denotes a key that produces a '+'
     */
    UCF_KeyboardHelper["bIsPlusKey"] = function (iKeyCode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsPlusKey"]++;
        }
        ;
        return iKeyCode === UCF_KeyCodes["PLUS"]
            || iKeyCode === UCF_KeyCodes["NUMPAD_PLUS"]
            || (UCF_UserAgent["bIsFirefox"]() && iKeyCode === 171);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsPlusKey"] = 0;
    }
    ;

    /**
     * @param {number} iKeyCode the key code to check
     * @return {boolean} `true` if the key code denotes a key that produces a '-'
     */
    UCF_KeyboardHelper["bIsMinusKey"] = function (iKeyCode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsMinusKey"]++;
        }
        ;
        return iKeyCode === UCF_KeyCodes["DASH"]
            || iKeyCode === UCF_KeyCodes["NUMPAD_MINUS"]
            || (UCF_UserAgent["bIsFirefox"]() && iKeyCode === 173);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsMinusKey"] = 0;
    }
    ;

    /**
     * @param {UCF_BrowserEvent} oBrowserEvent the key event
     * @param { boolean } bAlternativeKeyboardHandling `true` if UR runs in WebGui
     * @return {boolean} `true` if the key combination should trigger skipforward or skipback
     */
    UCF_KeyboardHelper["bIsSkippingShortcut"] = function (oBrowserEvent, bAlternativeKeyboardHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_KeyboardHelper["_"]["bIsSkippingShortcut"]++;
        }
        ;
        /** @type {number} */
        var iKey = oBrowserEvent["iKeyCode"]();

        return (
            // oBrowserEvent.oDomEvent.ctrlKey instead of oBrowserEvent.bCtrl()
            // since on MacOS the specified key is also [CTRL][ALT/OPTION][UP] or [DOWN]
            // this results in all OS: [CTRL][ALT][DOWN] or [UP]
            (oBrowserEvent["oDomEvent"]["ctrlKey"] && oBrowserEvent["bAlt"]() &&
                (iKey === UCF_KeyCodes["ARROW_DOWN"] || iKey === UCF_KeyCodes["ARROW_UP"]))
            ||
            // [F6]
            (!bAlternativeKeyboardHandling && iKey === UCF_KeyCodes["F6"] &&
                !oBrowserEvent["oDomEvent"]["ctrlKey"] && !oBrowserEvent["bAlt"]()
            )
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_KeyboardHelper["_"]["bIsSkippingShortcut"] = 0;
    }
    ;

    /* global UCF_Event */
/// <reference path="../../core/Event.js"/>
    /* global UCF_EventHandler */
/// <reference path="../ucf/EventHandler.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global _assert, _trace, _measure, START, STOP, DEBUG, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_ErrorMessage */
/// <reference path="../../core/util/ErrorMessage.js"/>
    /* global UCF_FesrUtil */
/// <reference path="../../core/util/FesrUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="./ResourceUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_SystemPopup */
/// <reference path="../../core/util/SystemPopup.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Promise */
/// <reference path="../../core/util/Promise.js"/>
    /* global UCF_ClipboardUtil */
/// <reference path="../../core/util/ClipboardUtil.js"/>
    /* global UCF_ClientElement */
/// <reference path="./ClientElement.js"/>
    /* global UCF_Control */
/// <reference path="./Control.js"/>
    /* global UCF_ControlFactory */
/// <reference path="./ControlFactory.js"/>
    /* global UCF_DebugHelper */
/// <reference path="./DebugHelper.js"/>
    /* global UCF_FocusInfo */
/// <reference path="./FocusInfo.js"/>
    /* global UCF_Page */
/// <reference path="./Page.js"/>
    /* global UCF_Performance */
/// <reference path="./Performance.js"/>
    /* global UCF_RenderManager */
/// <reference path="./RenderManager.js"/>
    /* global UCF_SemanticEvent */
/// <reference path="./SemanticEvent.js"/>
    /* global UCF_System */
/// <reference path="./System.js"/>
    /* global UCF_Animation */
/// <reference path="../anim/Animation.js"/>
    /* global UCF_BrowserWindow */
/// <reference path="../browser/BrowserWindow.js"/>
    /* global UCF_AccessibilityHelper */
/// <reference path="../helper/AccessibilityHelper.js"/>
    /* global UCF_MessageBundle */
/// <reference path="../helper/MessageBundle.js"/>
    /* global UCF_PopupManager */
/// <reference path="../helper/PopupManager.js"/>
    /* global UCF_DebugWindow */
/// <reference path="../debug/DebugWindow.js"/>
    /* global UCF_PageUpdater */
/// <reference path="../ucf/PageUpdater.js"/>
    /* global UCF_BeaconRequest */
/// <reference path="../ucf/BeaconRequest.js"/>
    /* global UCF_SeleniumRecorder */
/// <reference path="../../../../_testframework/pack/testframework/js/qunit/SeleniumRecorder.js"/>
    /* global UCF_SeleniumRuntime */

/// <reference path="../../../../_testframework/pack/testframework/js/qunit/SeleniumRuntime.js"/>

    /**
     * Lightspeed instance that creates and manages instances of framework objects
     * (BrowserWindow, PopupManager, DragAndDropManager, PageUpdater, etc.) and
     * provides the main entry point for the LS API, e.g. oGetControlById().
     *
     * @class
     * @param {HTMLElement} oRootRef The root container for lightspeed
     * @param {UCF_System} [oSystem] UCF_System object
     */
    function UCF_LS(oRootRef, oSystem) {
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["UCF_LS"]++;
        }
        ;
        /** @type {UCF_LS} */
        var self = this;
        /** @type {string} */
        var sPopupId;
        /** @type {UCF_SystemPopup} */
        var oSystemPopup;
        /** @type {string[]} */
        var aContent;
        /** @type {string} */
        var sTitle;
        /** @type {string} */
        var sDetail;
        /** @type {string} */
        var sButtonText;
        /** @type {UCF_Object} */
        var oHandler;
        /** @type {UCF_Promise[]} */
        var aPromises = [];

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(START, 'UCF_LS');
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Starting up Lightspeed', "LS.js(106): onButtonPress");
        }
        ;

        UCF_EventProvider["apply"](this);

        this["defineEvents"]([
            'SemanticEvent',
            'Lock',
            'Unlock',
            'PendingRequest',
            'FocusEnd',
            'ControlCreate',
            'ControlDestroy',
            'BeforeDestroy',
            'BeforeRequest',
            'AfterRequest',
            'AfterResponse',
            // control, delta or full-update per LS instance
            'UpdateComplete',
            'ControlsInitialized',
            'CustomUpdateComplete',
            'BeforeHotkey',
            'ControlVisibilityChange',
            'InvisibilityChanged',
            // fired only once on "main" LS instance after all control-, delta- or
            // full-updates in one response document are complete
            'UpdateDocumentComplete',
            'BeforeSemanticEvent',
            'RenderClientControl',
            'BeforeControlsInitialized',
            'BeforeUpdateDocument',
            'DirtyFlagChanged',
            'SystemParameterChange'
        ]);

        // Register the library on the classloader
        this["registerLibrary"]();

        // Sanity check, multiple instances of Lightspeed are not supported
        if (window["UCF_bLSCreated"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Trying to create multiple instances of LightSpeed in the same browser window', "LS.js(145): onButtonPress");
            }
            ;
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, 'UCF_LS', 'Stopped LS');
            }
            ;
        } else {
            window["UCF_bLSCreated"] = true;

            // Set root container for the LS app
            this["setRootRef"](oRootRef);

            /**
             * @private
             * @type {UCF_LS} a dummy reference to main LS instance
             */
            this["oMainLS"] = null;

            /**
             * Initial style block must be moved
             * @private
             * @type {boolean}
             */
            this["bStylesMoved"] = false;

            /**
             * @private
             * @type {string} Default Button for the Lightspeed Application
             */
            this["sActiveDefaultButtonId"] = '';

            /**
             * ???????
             * @private
             * @type {string}
             */
            this["sDragData"] = null;

            /**
             * @private
             * @type {string} Main window id, not handled by PopupManager
             */
            this["sMainWindowId"] = '';

            /**
             * @private
             * @type {boolean} Flag to keep locked state
             */
            this["bIsLocked"] = false;

            /**
             * @private
             * @type {boolean} Flag to keep dom changed
             */
            this["bDomChanged"] = false;

            /**
             * @private
             * @type {boolean} Flag to keep whether there are pending changes or not.
             **/
            this["bPendingChange"] = false;

            /**
             * @private
             * @type {boolean} Flag to keep dirty state
             */
            this["bDirty"] = false;

            /**
             * @private
             * @type {boolean} Flag for an alternative keyboard handling (used by ITS)
             */
            this["bAlternativeKeyboardHandling"] = false;

            /**
             * @private
             * @type {Object} Map to store captured events
             */
            this["mCapturedEvents"] = {};

            /**
             * @private
             * @type {Window} The current window
             */
            this["oWindow"] = window;

            this["activateSemanticEventBootingBuffer"](true);

            /**
             * @private
             * @type {Array.<string>} Id array of controls to initiaize
             */
            this["aInitializeIds"] = [];

            /**
             * Set to true in processInitializeIDs(). Only needed by PageUpdater for LS inside IFrame-popup
             * and only relevant for the initial update (WDA).
             * @private
             * @type {boolean}
             */
            this["bControlsInitialized"] = false;

            /**
             * @private
             * @type {Object} Semantic Event Handler
             */
            this["oSemanticEventHandlerObject"] = null;

            /**
             * @private
             * @type {string}
             */
            this["sSemanticEventHandlerFunction"] = '';

            /**
             * @private
             * @type {Array}
             */
            this["aSemanticEventHandlers"] = [];

            /**
             * @private
             * @type {Object} Update Complete Handler
             */
            this["oUpdateCompleteObject"] = null;

            /**
             * @private
             * @type {string}
             */
            this["sUpdateCompleteFunction"] = '';

            /**
             * @private
             * @type {Array}
             */
            this["aUpdateCompleteHandlers"] = [];

            /**
             * @private
             * @type {Object} Application Exit Handler
             */
            this["oApplicationExitHandlerObject"] = null;

            /**
             * @private
             * @type {string}
             */
            this["sApplicationExitHandlerFunction"] = '';

            /**
             * @private
             * @type {Object} Pending Request handler
             */
            this["oPendingRequestHandlerObject"] = null;

            /**
             * @private
             * @type {string}
             */
            this["sPendingRequestHandlerFunction"] = '';

            /**
             * @private
             * @type {UCF_PopupManager}
             */
            this["oPopupManager"] = null;

            // Create associated objects

            /**
             * @private
             * @type {UCF_System}
             */
            this["oSystem"] = oSystem
                || new (UCF_ClassLoader["oGetClass"]("UCF_System"))(document["getElementById"]('UCF_System'), this);

            if (__UCF_DEBUG__) {
                try {
                    if ( // eslint-disable-line max-depth
                        !UCF_DomUtil["oGetTopWindow"]() ||
                        UCF_DomUtil["oGetTopWindow"]()["location"]["search"]["indexOf"]('Coverage=true') === -1
                    ) {
                        // new UCF_DebugWindow() is expanded to
                        // new UCF_ClassLoader.oGetClass('UCF_DebugWindow') which requires
                        // the UCF_ library to be registered (i.e. executed after
                        // #registerLibrary()) and UCF_System.sNonce set to eval the string
                        // (i.e. executed after this.oSystem = new UCF_System())
                        //
                        // window.UCF_debugWindow is a singleton used in UCF_DebugWindow
                        window["UCF_debugWindow"] = new (UCF_ClassLoader["oGetClass"]("UCF_DebugWindow"))();
                    }
                } catch (ignored) {
                }
            }

            if (!UCF_UserAgent["bSkipIPadOsOverrule"]()) {
                //check and correct platform. In case of IOS switches browser to desktop mode
                //the platform is Macintosh and should be IOS.
                if (this["oSystem"]["sPlatform"] !== UCF_UserAgent["sGetPlatform"]()) {
                    this["setSystemParameters"]({"Platform": UCF_UserAgent["sGetPlatform"]()});
                }
            }

            if (!this["bHasDuplicateControlIds"]()) {
                /**
                 * @private
                 * @type {UCF_BrowserWindow}
                 */
                this["oBrowserWindow"] = new (UCF_ClassLoader["oGetClass"]("UCF_BrowserWindow"))(this["oRootRef"]);

                /**
                 * @private
                 * @type {UCF_BeaconRequest} BeaconRequest Object used by FESR
                 */
                this["oFESRBeacon"] = new (UCF_ClassLoader["oGetClass"]("UCF_BeaconRequest"))(this);

                //initialize FESR with a BeaconRequest Object at earliest moment
                UCF_FesrUtil["setBeacon"](this["oFESRBeacon"]);

                if (UCF_FesrUtil["bIsFESREnabled"]() == null &&
                    this["oSystem"]["bIsDebugLevelActive"](this["oSystem"]["E_LOG_LEVELS"]["Fesr"])) {
                    //enable FESR at earliest moment if bFESREnabled is still initial (null) and Log Level is at least FESR.
                    //set FESR to debugOnly once Log Level is debug (clientDebug=true). Might be overwritten by a framework call
                    UCF_FesrUtil["initFESR"](null, this["oSystem"]["bIsDebugLevelActive"](this["oSystem"]["E_LOG_LEVELS"]["Debug"]));
                }

                /**
                 * @private
                 * @type {UCF_Performance}
                 */
                this["oPerformance"] = (this["bIsMainLS"]() &&
                    this["oSystem"]["bIsDebugLevelActive"](this["oSystem"]["E_LOG_LEVELS"]["Fesr"]))
                    ? new (UCF_ClassLoader["oGetClass"]("UCF_Performance"))(this)
                    : null;

                /**
                 * @private
                 * @type {Object}
                 */
                this["oHighlightObject"] = {};

                /**
                 * @private
                 * @type {UCF_ControlFactory}
                 */
                this["oControlFactory"] = new (UCF_ClassLoader["oGetClass"]("UCF_ControlFactory"))(this);

                /**
                 * @private
                 * @type {UCF_DebugHelper}
                 */
                this["oDebugHelper"] = new (UCF_ClassLoader["oGetClass"]("UCF_DebugHelper"))(this);

                // This is a test version for embedding concept POC. API on System
                // control has been introduced as deprecated. -> D030999
                if (!this["bIsDestroyed"] &&
                    this["oSystem"] &&
                    this["oSystem"]["sEmbedding"] === this["oSystem"]["EMBEDDING"]["ISOLATED"]
                ) {
                    this["oMainLS"] = this;

                    /**
                     * @private
                     * @type {boolean}
                     */
                    this["bIsolatedEmbedding"] = true;
                } else {
                    /**
                     * @private
                     * @type{boolean}
                     */
                    this["bIsolatedEmbedding"] = false;
                }

                // Disable ActiveX on the RequestUtil
                if (!this["oSystem"]["bUseActiveX"]) {
                    UCF_RequestUtil["disableActiveX"]();
                }

                if (!this["oSystem"]["bUseXHR"]) {
                    UCF_RequestUtil["disableXHR"]();
                }

                // Several helper classes are created lazy
                /**
                 * @private
                 * @type {UCF_MessageBundle}
                 */
                this["oMessageBundle"] = new (UCF_ClassLoader["oGetClass"]("UCF_MessageBundle"))();

                // Register for browserwindow events
                this["oBrowserWindow"]["attachEvent"](
                    this["oBrowserWindow"]["E_EVENTS"]["ControlEvent"],
                    this,
                    'onControlEvent'
                );
                this["oBrowserWindow"]["attachEvent"](
                    this["oBrowserWindow"]["E_EVENTS"]["DDManagerCreate"],
                    this,
                    'onDDManagerCreate'
                );

                // UCF Event Handler, ensure events are get queued during startup and
                // refired later !
                if (!(this["bIsDestroyed"] && this["oSystem"] == null) &&
                    this["oSystem"]["bIsUCF"]
                ) {
                    /**
                     * @private
                     * @type {UCF_EventHandler}
                     */
                    this["oEventHandler"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventHandler"))(this);

                    this["oEventHandler"]["activateStartupQueueing"]();

                    /**
                     * @private
                     * @type {UCF_PageUpdater}
                     */
                    this["oPageUpdater"] = new (UCF_ClassLoader["oGetClass"]("UCF_PageUpdater"))(this);
                }

                // If UCF is used, attach to main window events
                if (this["oSystem"]["bIsUCF"]) {
                    this["attachMainLSEvents"]();
                }

                // If this is not the main LS send a notification to the main LS
                if (!this["bIsMainLS"]()) {
                    if (!this["oPopupManager"]) {
                        /**
                         * @private
                         * @type {UCF_PopupManager}
                         */
                        this["oPopupManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_PopupManager"))(this);
                    }

                    sPopupId = this["oPopupManager"]["sGetPopupIdByWindow"](window);
                    // notify PopupManager that LS in Popup is loaded
                    this["oGetMainLS"]()["oPopupManager"]["handleLSloaded"](this, sPopupId);

                    if (!this["bSeleniumTestMode"] && this["oGetMainLS"]()["bSeleniumTestMode"]) {
                        UCF_ClassLoader["oGetClass"]('UCF_SeleniumRuntime', UCF_ResourceUtil["sGetQUnitRoot"]() + '/SeleniumRuntime.js');
                        this["oSeleniumRuntime"] = window["UCF_SeleniumRuntime"];
                        this["oSeleniumRuntime"]["init"](this);
                    }
                }

                this["prepareLsClassCache"]();

                // If DebugWindow is loaded, attach to it
                this["attachToDebugWindow"]();

                // If running in the testsuite, attach to it
                this["attachToTestsuite"]();

                // Provide test access to controls for QTP
                this["attachToQTP"]();

                UCF_ErrorMessage["attachDestroyHandler"](this, 'destroy');

                /**
                 * @private
                 * @type {boolean} Do not fire ControlCreate and ControlDestroy events
                 */
                this["bFireLifecycleEvents"] = false;

                // now it is safe to refire collected events
                if (this["oEventHandler"]) {
                    this["oEventHandler"]["deactivateStartupQueueing"]();
                }

                // sanity check: don't use a wrong rendering mode
                // We do not support QME or Standards mode less than IE9
                if (
                    UCF_UserAgent["bIsIE"]() &&
                    (
                        UCF_UserAgent["bIsQME"]() ||
                        (
                            UCF_UserAgent["bIsStandardsMode"]() &&
                            // eslint-disable-next-line no-magic-numbers
                            parseInt(document["documentMode"]) <= 8
                        )
                    )
                ) {
                    oSystemPopup = new (UCF_ClassLoader["oGetClass"]("UCF_SystemPopup"))();
                    aContent = [];
                    sTitle = this["sGetText"]('SAPUR_BROWSER_QUIRKS_TITLE');
                    sButtonText = this["sGetText"]('SAPUR_BROWSER_QUIRKS_CONTINUE');
                    oHandler = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
                    sDetail = this["sGetText"](
                        UCF_UserAgent["bIsQME"]()
                            ? 'SAPUR_BROWSER_COMPAT_WARN'
                            : 'SAPUR_BROWSER_STD_IE8_WARN', ['<a target="_blank" href="https://service.sap.com/sap/support/notes/1970689">Note 1970689</a>']
                    );
                    oSystemPopup["setTitle"](sTitle);
                    oSystemPopup["setButton"]('IgnoreButton', sButtonText);

                    oHandler["oLS"] = this;
                    oHandler["oSystemPopup"] = oSystemPopup;
                    oHandler["onButtonPress"] = function () {
                        oHandler["oSystemPopup"]["hide"]();
                        // oHandler.oLS.unlock();
                    };

                    oSystemPopup["onClick"](oHandler["onButtonPress"]);

                    aContent["push"]('<div style="margin:10px">');
                    aContent["push"](sDetail);
                    aContent["push"]('</div>');

                    oSystemPopup["setContent"](aContent["join"](''));

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'LightSpeed error - ' + sTitle + sDetail, "LS.js(554): UCF_LS");
                    }
                    ;

                    // lock disables the link in the error
                    // this.lock();
                    oSystemPopup["show"]();
                }

                // don't show offline popup if LS is initialized in offline mode to
                // enable development on localhost
                this["attachOfflineListener"]();

                //Trace most important User Agent information
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Browser Engine : "' + UCF_UserAgent["sGetUserAgentName"]() + '" Version: "' + UCF_UserAgent["fUAVersion"] + '"', "LS.js(566): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Browser : "' + UCF_UserAgent["sGetBrowserName"]() + '" Version: "' + UCF_UserAgent["iGetBrowserVersion"]() + '"', "LS.js(567): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Tablet: ' + UCF_UserAgent["bIsTablet"](), "LS.js(568): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Phone: ' + UCF_UserAgent["bIsPhone"](), "LS.js(569): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Desktop: ' + UCF_UserAgent["bIsDesktop"](), "LS.js(570): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Combi (Touch+Desktop): ' + UCF_UserAgent["bIsCombi"](), "LS.js(571): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Touch Screen: ' + UCF_UserAgent["bSupportTouch"](), "LS.js(572): UCF_LS");
                }
                ;
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Detected Platform (OS)  : "' + UCF_UserAgent["sGetPlatform"]() + '" Version: "' + UCF_UserAgent["sGetPlatformVersion"]() + '"', "LS.js(573): UCF_LS");
                }
                ;
                if (UCF_UserAgent["bIsIE"]()) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Detected IE Compatibility Mode : "' + UCF_UserAgent["bIsIECompatibilityMode"]() + '" IsStandardsMode: "' + UCF_UserAgent["bIsStandardsMode"]() + '" IsQME: "' + UCF_UserAgent["bIsQME"]() + '"', "LS.js(575): UCF_LS");
                    }
                    ;
                }

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'LightSpeed started', "LS.js(578): UCF_LS");
                }
                ;
                window["document"]["qtp_readystate"] = true;
                if (this["oSeleniumRuntime"]) {
                    this["oSeleniumRuntime"]["bReady"] = true;
                }

                // create a namespace for sap.ls and pass the instance
                if (UCF_LS["aRegisteredClasses"]["length"] > 0) {
                    UCF_JsUtil["forEach"](
                        UCF_JsUtil["filter"](
                            UCF_LS["aRegisteredClasses"],
                            function (oClass) {
                                return oClass["onLSInit"];
                            }
                        ),
                        function (oClass) {
                            oClass["onLSInit"](self);
                        }
                    );
                }

                //Create promise array including all async actions to be finished
                //before initialization of controls

                //promises to check session storage for unload URLs
                aPromises = UCF_RequestUtil["aSessionStorageUnloadRequest"]();
                //promise to process the themes (theme fallback)
                aPromises["push"](UCF_ResourceUtil["initTheme"]());

                // Initial processing of controls after resolving all promises.
                // Ensure to continue even a Promise was rejected.
                UCF_Promise["allSettled"](aPromises)["then"](function (results) {
                    // Start initialization only when CSS is loaded to ensure correct
                    // metric calculations in the controls
                    self["processInitializeIDs"]();
                    // CSN 1980172555: the semanticEventBootingBuffer has to be disabled
                    // after (!) processInitializeIDs. Otherwise the thing is meaningless.
                    self["activateSemanticEventBootingBuffer"](false);

                    if (__UCF_MEASURE__) {
                        UCF_Tracer.measure(STOP, 'UCF_LS', 'LS loaded in ');
                    }
                    ;

                    UCF_JsUtil["requestIdleCallback"](function () {
                        self["runIdleTasks"]();
                    });
                });

                return this["oGetInterface"]();
            }
        }
    };window["UCF_LS"] = UCF_LS;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_LS");
        UCF_LS["_"] = {UCF_LS: 0};
    }
    ;
    ;
    UCF_LS["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_LS.prototype["sClassName"] = "UCF_LS";

    /**
     * @private
     * @type {Object.<string,number>} Lock Types
     */

    /* Lock Types are evaluated with bit wise operations
	the next entry should be 2, then 4...
	*/

    UCF_LS["E_LOCKTYPES"] = {
        "NORMAL": 0,
        "FORCE": 1
    };

    /**
     * @private
     * @type {Object.<string,any>} Internal constants
     */
    UCF_LS["prototype"]["M_CONSTANTS"] = {
        "LSPOPUP": 'LSPOPUP'
    };

    /**
     * @private
     * @type {Object.<string,number>} Internal Z-Indexes of Layers
     */
    UCF_LS["E_LAYERS"] = {
        "CONTROLS": 1000,
        "DT_DECORATORS": 1400,
        "DT_ELEMENTS": 1500,
        "BLINDLAYER": 4000,
        "POPUPWINDOWS": 10000,
        "POPUPMENUS": 20000,
        "GHOSTS": 21000,
        "DECORATORS": 22000
    };

    /**
     * Destructor
     *
     * @public
     * @param {string} sErrorHTML HTML error page to be displayed on the page
     * @param {number} iStatusCode the status
     */
    UCF_LS["prototype"]["destroy"] = function (sErrorHTML, iStatusCode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["destroy"]++;
        }
        ;
        /** @type {UCF_LS} */
        var self = this;
        /** @type {string} */
        var n;

        // Destroy should not be called twice...
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(!this["bIsDestroyed"], "!this.bIsDestroyed", "LS.js(675): destroy");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Lightspeed will be destroyed now', "LS.js(677): destroy");
        }
        ;

        if (!this["bIsDestroyed"]) {
            this["bIsDestroyed"] = true; // TODO remove and rely on _super()

            if (this["oHighlightObject"] &&
                this["oHighlightObject"]["dom"] &&
                this["oHighlightObject"]["parentNode"]
            ) {
                this["oHighlightObject"]["dom"]["parentNode"]["removeChild"](
                    this["oHighlightObject"]["dom"]
                );
            }

            this["fireEvent"](this["E_EVENTS"]["BeforeDestroy"], {});

            if (this["oFESRBeacon"]) {
                this["oFESRBeacon"]["destroy"]();
                this["oFESRBeacon"] = null;
            }

            this["oBrowserWindow"]["detachEvent"](
                this["oBrowserWindow"]["E_EVENTS"]["ControlEvent"],
                this,
                'onControlEvent'
            );
            this["oBrowserWindow"]["detachEvent"](
                this["oBrowserWindow"]["E_EVENTS"]["DDManagerCreate"],
                this,
                'onDDManagerCreate'
            );

            this["removeUpdateCompleteHandler"]();

            // If there is an application exit handler for the framework call it first
            if (this["oApplicationExitHandlerObject"]) {
                this["oApplicationExitHandlerObject"][
                    this["sApplicationExitHandlerFunction"]
                    ]();
            }

            if (this["oSeleniumRuntime"]) {
                this["oSeleniumRuntime"]["destroy"]();
                this["oSeleniumRuntime"] = null;
            }

            if (this["oSystem"]["bIsUCF"]) {
                this["detachMainLSEvents"]();
                this["oEventHandler"]["destroy"]();
                this["oEventHandler"] = null;
                this["oPageUpdater"]["destroy"]();
                this["oPageUpdater"] = null;
            }

            if (this["oPopupManager"]) {
                // close all dependant popups if this is main ls (needed for portal etc.)
                if (this["bIsMainLS"]()) {
                    this["oPopupManager"]["closeAllPopups"]();
                }

                this["oPopupManager"]["destroy"]();
                this["oPopupManager"] = null;
            }

            if (this["oMessageBundle"]) {
                this["oMessageBundle"]["destroy"]();
                this["oMessageBundle"] = null;
            }

            if (this["oDebugHelper"]) {
                this["oDebugHelper"]["destroy"]();
                this["oDebugHelper"] = null;
            }

            if (this["oRenderManager"]) {
                this["oRenderManager"]["destroy"]();
                this["oRenderManager"] = null;
            }

            if ('oPage' in this) {
                delete this["oPage"];
            }

            this["oSystem"]["destroy"]();
            this["oSystem"] = null;

            this["oControlFactory"]["destroy"]();
            this["oControlFactory"] = null;

            this["detachOfflineListener"]();
            this["oBrowserWindow"]["destroy"]();
            this["oBrowserWindow"] = null;

            this["mCapturedEvents"] = null;
            this["oWindow"] = null;
            this["oMainLS"] = null;
            this["oRootRef"] = null;

            this["oPerformance"] = null;

            if (sErrorHTML || sErrorHTML === '') {
                // eslint-disable-next-line no-magic-numbers
                if (typeof iStatusCode === 'number' && iStatusCode >= 400) {
                    // Error page: inject HTML so that reload-button and F5 will work
                    document["body"]["className"] = '';
                    // eslint-disable-next-line no-unsanitized/property
                    document["body"]["innerHTML"] = '<input type="hidden">' + sErrorHTML;

                    // remove "unsupported theme" image on body see note 1892457
                    UCF_LS["applySupportedThemes"](document["body"]);
                } else {
                    // Int. CSN 3068535 2010:
                    // If content is an HMTL page where JS and CSS must work (if URLs are
                    // absolute or the baseURL is the same)
                    setTimeout(function () {
                        document["open"]();
                        //eslint-disable-next-line no-unsanitized/method
                        document["write"](sErrorHTML); //must assume the sErrorHTML is valid HTML as it comes from the server
                        document["close"]();
                    }, 0);
                }
            }
            if (UCF_LS["aRegisteredClasses"]["length"] > 0) {
                UCF_JsUtil["forEach"](
                    UCF_JsUtil["filter"](
                        UCF_LS["aRegisteredClasses"],
                        function (oClass) {
                            return oClass["onLSDestroy"];
                        }
                    ),
                    function (oClass) {
                        oClass["onLSDestroy"](self);
                    }
                );
            }

            this["cleanUpStoredFocus"]();
            this["cleanUpSemanticEventBootingBuffer"]();
            this["oScrollIntoViewInfo"] = null;
            UCF_JsUtil["clearDelayedCallsOfObject"](this);

            UCF_ErrorMessage["detachDestroyHandler"](this, 'destroy');
        }

        this["_bIsReady_bAllImagesLoaded"] = null;
        this["unregisterInputAssistant"]();
        this["oLoadingAnim"] = null;
        this["bKeepLocked"] = null;
        this["oPage"] = null;
        this["fUpdateDocumentCompleteCallback"] = null;
        this["sPendingRequestHandlerFunction"] = null;
        this["oPendingRequestHandlerObject"] = null;
        this["sApplicationExitHandlerFunction"] = null;
        this["oApplicationExitHandlerObject"] = null;
        this["aUpdateCompleteHandlers"] = null;
        this["aSemanticEventHandlers"] = null;
        this["sSemanticEventHandlerFunction"] = null;
        this["oSemanticEventHandlerObject"] = null;
        this["aInitializeIds"] = null;
        this["bAlternativeKeyboardHandling"] = null;
        this["bDirty"] = null;
        this["bPendingChange"] = null;
        this["bDomChanged"] = null;
        this["sMainWindowId"] = null;
        this["sActiveDefaultButtonId"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);

        for (n in window) {
            // iterate all window members and call .destroyStatic() on all UCF_*
            // members that have it defined
            try {
                if (
                    n["indexOf"]('UCF_') === 0 &&
                    window[n] &&
                    UCF_JsUtil["bIsFunction"](window[n]["destroyStatic"])
                ) {
                    // named .destroyStatic(), because that's more easy to find when
                    // scanning for .destroy
                    window[n]["destroyStatic"]();
                }
            } catch (e) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Error in ' + n + '.destroyStatic(): ' + e["message"], "LS.js(855): destroy");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["destroy"] = 0;
    }
    ;

    /**
     * Registers the LightSpeed library with the ClassLoader
     */
    UCF_LS["prototype"]["registerLibrary"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerLibrary"]++;
        }
        ;
        /** @type {HTMLCollection} */
        var aScriptTags = document["getElementsByTagName"]('script');
        /** @type {string} */
        var sScriptUrl;
        /** @type {number} */
        var iFilePos;
        /** @type {number} */
        var iQueryPos;
        /** @type {string} */
        var sUrlTemplate;
        /** @type {boolean} */
        var bDebugMode;
        /** @type {string} */
        var sBaseUrl;
        /** @type {string} */
        var sQueryString;
        /** @type {number} */
        var i;

        for (i = 0; i < aScriptTags["length"]; i++) {
            sScriptUrl = aScriptTags[i]["getAttribute"]('src');
            if (sScriptUrl) {
                iFilePos = sScriptUrl["indexOf"]('/lightspeed.js');
                iQueryPos = sScriptUrl["lastIndexOf"]('?');
                if (iFilePos >= 0) {
                    break;
                }
            }
        }

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iFilePos >= 0, "iFilePos >= 0", "LS.js(894): registerLibrary");
        }
        ;

        sBaseUrl = sScriptUrl["substr"](0, iFilePos);
        sQueryString = '';
        sUrlTemplate = __UCF_IE6__
            ? sBaseUrl["replace"]('/ie6', '') + '/classes/ie6/$$.js'
            : sBaseUrl + '/classes/$$.js';
        bDebugMode = sUrlTemplate["indexOf"]('/js/dbg') > 0;

        if (bDebugMode) {
            sQueryString = '?' +
                sScriptUrl["substr"](iQueryPos + 1) +
                '__' +
                UCF_JsUtil["iGetTimeStamp"]();
        } else if (iQueryPos > 0) {
            sQueryString = '?' + sScriptUrl["substr"](iQueryPos + 1);
        }
        sUrlTemplate += sQueryString;
        UCF_ClassLoader["registerBaseUrl"](sBaseUrl, sQueryString);
        UCF_ClassLoader["registerLibrary"]('UCF_', sUrlTemplate, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerLibrary"] = 0;
    }
    ;

    /**
     * Prepares Lightspeed for usage of class cache.
     * @public
     */
    UCF_LS["prototype"]["prepareLsClassCache"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["prepareLsClassCache"]++;
        }
        ;
        // Use class file cache of main LS
        if (this["oGetMainLS"]() !== this) {
            UCF_ClassLoader["connectToParentClassLoader"](
                this["oGetMainLS"]()["oGetWindow"]()["UCF_ClassLoader"]
            );
        }
        // Worker usage currently disabled because of issues in Web GUI
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["prepareLsClassCache"] = 0;
    }
    ;

    /**
     * Prepares Lightspeed for a Clientside Rendering use.
     * This call triggers preloading classes with a WebWorker if possible.
     * @public
     */
    UCF_LS["prototype"]["prepareClientSideRendering"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["prepareClientSideRendering"]++;
        }
        ;
        // Worker usage currently disabled because of issues in Web GUI
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["prepareClientSideRendering"] = 0;
    }
    ;

    /**
     * Allows frameworks to add custom debug handler which are triggered by
     * Ctrl-Alt-Shift shortcuts. The object which is passed to this function needs
     * to have a method called "trigger", which is called whenever the keyboard
     * shortcut is used.
     *
     * @public
     * @param {number} iKeyCode for Ctrl-Alt-Shift Shortcut
     * @param {Object} oObject the handler class which is notified, if the keyboard
     * shortcut is used
     * @param {string} sDescription a textual description of the debug handler for
     * display in the help window
     */
    UCF_LS["prototype"]["addDebugHandler"] = function (iKeyCode, oObject, sDescription) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["addDebugHandler"]++;
        }
        ;
        this["oDebugHelper"]["addDebugHandler"](iKeyCode, oObject, sDescription);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["addDebugHandler"] = 0;
    }
    ;

    /**
     * If an event of a control on the screen occurs, get a control instance, look
     * whether the control wants to handle it, and if so call the appropriate
     * handler. Bubble up the control tree, until cancelBubble is called on the
     * event
     *
     * @param {UCF_Event} oEvent The event object
     * @private
     */
    UCF_LS["prototype"]["onControlEvent"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onControlEvent"]++;
        }
        ;
        /** @type {UCF_BrowserEvent} */
        var oBrowserEvent = oEvent["oGetParam"]('oBrowserEvent');
        /** @type {HTMLElement} */
        var oSourceRef = oBrowserEvent["oGetSource"]();
        /** @type {HTMLElement} */
        var oControlDomRef = oBrowserEvent["oGetSourceRoot"]();
        /** @type {UCF_Control} */
        var oControl = null;
        /** @type {boolean} */
        var bIsAccessibilityEvent = (this["oSystem"]["bIs508"] || this["oSystem"]["bIsAria"]) &&
            oBrowserEvent["sGetName"]() === this["oBrowserWindow"]["E_LS_EVENTS"]["accessibility"];
        /** @type {boolean} */
        var bNeedsAriaGeneric;
        /** @type {string} */
        var s;
        /** @type {RegExp} */
        var regex;
        /** @type {Array.<string>} */
        var aRowCol;
        /** @type {HTMLElement} */
        var oAriaGeneric;

        if (this["oOfflinePopup"] && this["oOfflinePopup"]["bIsOpen"]) {
            // enforce that no sync request is fired and therefore the Network lost
            // popup occurs
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Network is offline - ignore event so that no request is triggered: ' + '"' + oBrowserEvent["sGetName"]() + '" occurred' + (oSourceRef ? ' at ' + oSourceRef["tagName"] + ' "' + oSourceRef["id"] + '"' : ''), "LS.js(991): onControlEvent");
            }
            ;
        } else {
            oControl = this["oControlFactory"]["bIsControlDomRef"](oControlDomRef)
                ? this["oControlFactory"]["oGetControlByDomRef"](
                    oControlDomRef,
                    true
                )
                : this["oGetPageInternal"]();
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, '"' + oBrowserEvent["sGetName"]() + '" occurred' + (oSourceRef ? ' at ' + oSourceRef["tagName"] + ' "' + oSourceRef["id"] + '"' : '') + (oControl ? (' in control ' + oControl["sClassName"] + ' "' + oControl["sId"] + '"') : ''), "LS.js(999): onControlEvent");
            }
            ;

            oBrowserEvent["oSourceControl"] = oControl;

            bNeedsAriaGeneric = false;
            if (bIsAccessibilityEvent) {
                if (this["oSystem"]["sAccessibility"] === 'ARIA' || this["oSystem"]["sAccessibility"] === 'ARIA1.1') {
                    oBrowserEvent["oAccessibilityHelper"] = new (UCF_ClassLoader["oGetClass"]("UCF_AccessibilityHelper"))(this);
                    if (oControl && oControl["bPrepareAria"]) {
                        bNeedsAriaGeneric = oControl["bPrepareAria"](oBrowserEvent);
                    }
                } else {
                    oBrowserEvent["oAccessibilityHelper"] = new (UCF_ClassLoader["oGetClass"]("UCF_AccessibilityHelper"))(this);
                }
            }

            // Ignore stored focus and clear it when an user explicitly clicks on a
            // control of a unfocussed window. If don't doing that a user could click
            // on a control and the stored focus mechanism directly moves the focus to
            // the stored element ID which is somewhere else on the screen. This feels
            // odd.
            if (oBrowserEvent["sGetName"]() === 'mousedown' &&
                this["sGetStoredFocus"]() &&
                !this["bUseStoredFocus"]()
            ) {
                this["cleanUpStoredFocus"]();
            }

            if (oControl) {
                this["dispatchCapturedEvent"](oControl, oBrowserEvent);
            }

            while (oControl && !oBrowserEvent["bCancelBubble"]) {
                this["dispatchBrowserEvent"](oControl, oBrowserEvent);
                if (!oBrowserEvent["bCancelBubble"]) {
                    oControl = oControl["oGetParent"]();
                }
            }

            if (bIsAccessibilityEvent) {
                if (this["oSystem"]["bIsAria"]) {
                    if (bNeedsAriaGeneric) {
                        s = oBrowserEvent["oAccessibilityHelper"]["sGetExtendedTextForARIA"]();
                        regex = / *(\w* *\w*) *(\w* .*).*/g;
                        aRowCol = regex["exec"](s);

                        if (aRowCol) { // eslint-disable-line max-depth
                            oAriaGeneric = document["getElementById"]('ARIA_GENERIC');
                            s = '';
                            if (oAriaGeneric) {
                                // eslint-disable-next-line no-magic-numbers, max-depth
                                if (aRowCol["length"] === 3 && aRowCol[2] === '') {
                                    oAriaGeneric["setAttribute"]('oldAriaInfoRow', '');
                                    oAriaGeneric["setAttribute"]('oldAriaInfoCol', aRowCol[1]);
                                    // eslint-disable-next-line no-unsanitized/property
                                    oAriaGeneric["innerHTML"] = aRowCol[0];
                                } else {
                                    // eslint-disable-next-line no-magic-numbers
                                    s = aRowCol[1] + ' ' + aRowCol[2];

                                    // eslint-disable-next-line no-unsanitized/property
                                    oAriaGeneric["innerHTML"] = s;
                                }
                            }
                        }
                    }
                } else {
                    oBrowserEvent["oAccessibilityHelper"]["apply"](oBrowserEvent["oGetSource"]());
                }
            }

            if (oBrowserEvent["bCancelBubble"]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, '"' + oBrowserEvent["sGetName"]() + '" has been canceled', "LS.js(1071): onControlEvent");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onControlEvent"] = 0;
    }
    ;

    /**
     * Set the page in DDManager
     *
     * @param {UCF_Event} oEvent The event object
     * @private
     */
    UCF_LS["prototype"]["onDDManagerCreate"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onDDManagerCreate"]++;
        }
        ;
        /** @type {UCF_DragAndDropManager} */
        var oDragAndDropManager = oEvent["oGetParam"]('oDragAndDropManager');

        if (oDragAndDropManager) {
            oDragAndDropManager["setPage"](this["oGetPageInternal"]());
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onDDManagerCreate"] = 0;
    }
    ;

    /**
     * Attaches Offline Mode
     * @private
     */
    UCF_LS["prototype"]["attachOfflineListener"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachOfflineListener"]++;
        }
        ;
        /** @type {string} */
        var sContent = this["sGetText"]('SAPUR_OFFLINE');
        /** @type {string} */
        var sTitle = this["sGetText"]('SAPUR_OFFLINE_TITLE');

        // enforce that the offline text and UCF_System is loaded while going offline
        this["oOfflinePopup"] = new (UCF_ClassLoader["oGetClass"]("UCF_SystemPopup"))();

        this["oOfflinePopup"]["setTitle"](sTitle || 'Network Connection Lost');
        this["oOfflinePopup"]["setContent"](
            sContent ||
            'Your network connection is offline. Reconnecting your network will ' +
            'close this popup.'
        );

        // register the offline helper
        // see https://developer.mozilla.org/en/DOM/window.navigator.onLine
        this["oBrowserWindow"]["attachEvent"](
            this["oBrowserWindow"]["E_EVENTS"]["Offline"],
            this,
            'onOffline'
        );
        this["oBrowserWindow"]["attachEvent"](
            this["oBrowserWindow"]["E_EVENTS"]["Online"],
            this,
            'onOnline'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachOfflineListener"] = 0;
    }
    ;

    /**
     * Detaches Offline Mode
     * @private
     */
    UCF_LS["prototype"]["detachOfflineListener"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachOfflineListener"]++;
        }
        ;
        this["oBrowserWindow"]["detachEvent"](this["oBrowserWindow"]["E_EVENTS"]["Offline"], this);
        this["oBrowserWindow"]["detachEvent"](this["oBrowserWindow"]["E_EVENTS"]["Online"], this);

        if (this["oOfflinePopup"]) {
            this["oOfflinePopup"]["destroy"]();
            this["oOfflinePopup"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachOfflineListener"] = 0;
    }
    ;

    /**
     * Executed if network goes offline
     * @private
     */
    UCF_LS["prototype"]["onOffline"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onOffline"]++;
        }
        ;
        /** @type {UCF_LoadingAnimation} */
        var oLoadingAnim;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(ERROR, 'Network is lost', "LS.js(1147): onOffline");
        }
        ;
        this["lock"]();
        oLoadingAnim = this["oGetLoadingAnim"]();

        if (oLoadingAnim) {
            oLoadingAnim["setText"](this["sGetText"]('SAPUR_OFFLINE_TITLE'));
        } else {
            this["oOfflinePopup"]["show"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onOffline"] = 0;
    }
    ;

    /**
     * Executed if network goes online again after offline
     * @private
     */
    UCF_LS["prototype"]["onOnline"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onOnline"]++;
        }
        ;
        this["unlock"]();
        if (this["oOfflinePopup"] != null && this["oOfflinePopup"]["bIsOpen"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Network is online', "LS.js(1165): onOnline");
            }
            ;
        }
        this["oOfflinePopup"]["hide"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onOnline"] = 0;
    }
    ;

    /**
     * Dispatch a browser event on the given handler. If it is a UCF_Control, check
     * if there is a delegate handler and also fire event on the delegate.
     *
     * @param {UCF_Object} oHandler the handler where the event is fired
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event
     */
    UCF_LS["prototype"]["dispatchBrowserEvent"] = function (oHandler, oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["dispatchBrowserEvent"]++;
        }
        ;
        /** @type {Array.<UCF_Object>} */
        var aDelegates = null;
        /** @type {string} */
        var sName = oBrowserEvent["sGetName"]();
        /** @type {string} */
        var sHandlerName = 'on' + sName;
        /** @type {boolean} */
        var bCancelByBrowserWindow = oBrowserEvent["bCancel"];
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oHandler, "oHandler", "LS.js(1189): dispatchBrowserEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oHandler instanceof UCF_Object, "oHandler instanceof UCF_Object", "LS.js(1190): dispatchBrowserEvent");
        }
        ;

        if (oHandler instanceof UCF_Control) {
            aDelegates = oHandler["aGetDelegates"](true); // get the before delegates
        }
        if (aDelegates) {
            for (i = 0; i < aDelegates["length"]; i++) {
                this["dispatchBrowserEvent"](aDelegates[i], oBrowserEvent);
            }
        }

        // If canceled by before-delegate but was not already canceled by
        // BrowserWindow. E.g. selectstart must be dispatched to the controls
        // although already canceled in BrowserWindow
        if (!aDelegates || bCancelByBrowserWindow || !oBrowserEvent["bCancel"]) {
            if (oHandler[sHandlerName]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, '"' + oBrowserEvent["sGetName"]() + '" handled by ' + oHandler["sClassName"] + ' "' + oHandler["sId"] + '"', "LS.js(1206): dispatchBrowserEvent");
                }
                ;
                oHandler[sHandlerName](oBrowserEvent);
            }

            if (oHandler instanceof UCF_Control) {
                aDelegates = oHandler["aGetDelegates"]();
            }
            if (aDelegates) {
                for (i = 0; i < aDelegates["length"]; i++) {
                    this["dispatchBrowserEvent"](aDelegates[i], oBrowserEvent);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["dispatchBrowserEvent"] = 0;
    }
    ;

    /**
     * Dispatch a captured event.
     * @param {UCF_Control} oControl the control where the event occurred
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event
     * @private
     */
    UCF_LS["prototype"]["dispatchCapturedEvent"] = function (oControl, oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["dispatchCapturedEvent"]++;
        }
        ;
        /** @type {string} */
        var sName = oBrowserEvent["sGetName"]();
        /** @type {Array.<Object>} */
        var aHandlers = this["mCapturedEvents"][sName];
        /** @type {Array.<Object>} */
        var aCallHandlers;
        /** @type {Object} */
        var oHandler;
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl, "oControl", "LS.js(1239): dispatchCapturedEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Object, "oControl instanceof UCF_Object", "LS.js(1240): dispatchCapturedEvent");
        }
        ;

        if (aHandlers) {
            aCallHandlers = [];

            for (i = 0; i < aHandlers["length"]; i++) {
                oHandler = aHandlers[i];
                if (oControl === oHandler["oControl"] ||
                    oControl["bIsChildOf"](oHandler["oControl"])
                ) {
                    aCallHandlers["push"](oHandler);
                }
            }

            for (i = 0; i < aCallHandlers["length"]; i++) {
                oHandler = aCallHandlers[i];
                oHandler["oControl"][oHandler["sFunction"]](oBrowserEvent);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["dispatchCapturedEvent"] = 0;
    }
    ;

    /**
     * Attach a captured event.
     *
     * @param {string} sName the name of the event to capture
     * @param {UCF_Control} oControl the control
     * @param {string} sFunction the name of the handler function
     */
    UCF_LS["prototype"]["attachCaptureEvent"] = function (sName, oControl, sFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachCaptureEvent"]++;
        }
        ;
        /** @type {Array.<Object>} */
        var aHandlers = this["mCapturedEvents"][sName];

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "LS.js(1272): attachCaptureEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "LS.js(1273): attachCaptureEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sFunction === 'string', "typeof sFunction === 'string'", "LS.js(1274): attachCaptureEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl[sFunction], "oControl[sFunction]", "LS.js(1275): attachCaptureEvent");
        }
        ;

        if (!aHandlers) {
            this["mCapturedEvents"][sName] = [];
            aHandlers = this["mCapturedEvents"][sName];
        }
        aHandlers["push"]({"oControl": oControl, "sFunction": sFunction});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachCaptureEvent"] = 0;
    }
    ;

    /**
     * Detach a captured event.
     *
     * @param {string} sName the name of the event to capture
     * @param {UCF_Control} oControl the control
     */
    UCF_LS["prototype"]["detachCaptureEvent"] = function (sName, oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachCaptureEvent"]++;
        }
        ;
        /** @type {Array.<Object>} */
        var aHandlers = this["mCapturedEvents"][sName];
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "LS.js(1296): detachCaptureEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "LS.js(1297): detachCaptureEvent");
        }
        ;

        if (aHandlers) {
            for (i = 0; i < aHandlers["length"]; i++) {
                if (aHandlers[i]["oControl"] === oControl) {
                    aHandlers["splice"](i, 1);
                    i--;
                }
            }
            if (aHandlers["length"] === 0) {
                delete this["mCapturedEvents"][sName];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachCaptureEvent"] = 0;
    }
    ;

    /**
     * Create a custom semantic event objects
     *
     * @public
     * @param {string} sEventName the name of the event to create
     * @param {Object} mParameters the parameters to pass
     * @param {Object} mCustomParameters additional parameters to pass
     * @return {UCF_SemanticEvent} the custom semantic event
     */
    UCF_LS["prototype"]["oCreateSemanticEvent"] = function (sEventName, mParameters, mCustomParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oCreateSemanticEvent"]++;
        }
        ;
        // no interface is used here so that full access to all APIs in the semantic
        // event can be used - warning - setForm expects the obejct and not the
        // interface, so bypass this at the consumtion because the semanticEvent and
        // the framework has no reference to the internal LS object.
        return new (UCF_ClassLoader["oGetClass"]("UCF_SemanticEvent"))(
            'Custom',
            sEventName,
            mParameters,
            mCustomParameters
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oCreateSemanticEvent"] = 0;
    }
    ;

    /**
     * Fire a custom semantic event
     * @public
     * @param {UCF_SemanticEvent} oSemanticEvent The semantic event object
     */
    UCF_LS["prototype"]["fireSemanticEvent"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireSemanticEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oSemanticEvent instanceof UCF_SemanticEvent, "oSemanticEvent instanceof UCF_SemanticEvent", "LS.js(1340): fireSemanticEvent");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Custom semantic event ' + oSemanticEvent["sGetControl"]() + ':' + oSemanticEvent["sGetName"]() + ' fired.', "LS.js(1342): fireSemanticEvent");
        }
        ;

        this["processSemanticEvent"](oSemanticEvent);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireSemanticEvent"] = 0;
    }
    ;

    /**
     * Fires an event if a control is created
     *
     * @public
     * @param {Object} mParameters parameters
     */
    UCF_LS["prototype"]["fireControlCreate"] = function (mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireControlCreate"]++;
        }
        ;
        if (this["bFireLifecycleEvents"]) {
            this["fireSemanticEvent"](
                this["oCreateSemanticEvent"]('CreateControl', mParameters, {})
            );
        }
        this["fireEvent"](this["E_EVENTS"]["ControlCreate"], mParameters);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireControlCreate"] = 0;
    }
    ;

    /**
     * Fires an event if a control is destroyed
     *
     * @public
     * @param {Object} mParameters an array with parameters
     */
    UCF_LS["prototype"]["fireControlDestroy"] = function (mParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireControlDestroy"]++;
        }
        ;
        if (this["bFireLifecycleEvents"]) {
            this["fireSemanticEvent"](
                this["oCreateSemanticEvent"]('DestroyControl', mParameters, {})
            );
        }
        this["fireEvent"](this["E_EVENTS"]["ControlDestroy"], mParameters);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireControlDestroy"] = 0;
    }
    ;

    /**
     * Fires the BeforeHotkey event. Attach to this event to get informed whenever
     * a hotkey event is sent to the framework.
     * @private
     */
    UCF_LS["prototype"]["fireBeforeHotkey"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireBeforeHotkey"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["BeforeHotkey"], {});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireBeforeHotkey"] = 0;
    }
    ;

    /**
     * Gets the semantic event passed from the control, and calls the registered
     * handlers of the framework
     * @param {UCF_SemanticEvent} oSemanticEvent The semantic event object
     */
    UCF_LS["prototype"]["processSemanticEvent"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["processSemanticEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oSemanticEvent != null, "oSemanticEvent != null", "LS.js(1392): processSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oSemanticEvent === 'object', "typeof oSemanticEvent === 'object'", "LS.js(1393): processSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oSemanticEvent instanceof UCF_SemanticEvent, "oSemanticEvent instanceof UCF_SemanticEvent", "LS.js(1394): processSemanticEvent");
        }
        ;

        this["fireEvent"](
            this["E_EVENTS"]["BeforeSemanticEvent"], {"oSemanticEvent": oSemanticEvent}
        );

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Semantic event "' + oSemanticEvent["sGetControl"]() + ':' + oSemanticEvent["sGetName"]() + '" occurred, ' + UCF_JsUtil["sJsonStringify"](oSemanticEvent["mGetParameters"]()) + ' ' + UCF_JsUtil["sJsonStringify"](oSemanticEvent["mGetCustomParameters"]()), "LS.js(1400): processSemanticEvent");
        }
        ;

        if (this["oSeleniumRuntime"]) {
            this["oSeleniumRuntime"]["processSemanticEvent"](oSemanticEvent["oGetInterface"]());
        }

        oSemanticEvent["setSourceLS"](this);

        this["processSemanticEventByExternalHandlers"](oSemanticEvent);

        this["fireEvent"](
            this["E_EVENTS"]["SemanticEvent"], {"oSemanticEvent": oSemanticEvent}
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["processSemanticEvent"] = 0;
    }
    ;

    /**
     * Processes the semantic event handlers provided by external registration
     * @param {UCF_SemanticEvent} oSemanticEvent The semantic event object
     */
    UCF_LS["prototype"]["processSemanticEventByExternalHandlers"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["processSemanticEventByExternalHandlers"]++;
        }
        ;
        /** @type {boolean} */
        var bHasBootingBufferEvents = this["aSemanticEventBootingBuffer"];
        // Main event handler existence determine if delegation is done
        /** @type {UCF_LS} */
        var oTargetLS = !this["oSemanticEventHandlerObject"] && !this["bIsMainLS"]()
            ? this["oGetMainLS"]()
            : this;
        /** @type {UCF_LS} */
        var self = this;

        // Process main event handler first
        if (oTargetLS["oSemanticEventHandlerObject"] &&
            oTargetLS["sSemanticEventHandlerFunction"]
        ) {
            if (bHasBootingBufferEvents) {
                this["flushSemanticEventBootingBuffer"]();
            }
            oTargetLS["oSemanticEventHandlerObject"][
                oTargetLS["sSemanticEventHandlerFunction"]
                ](oSemanticEvent["oGetInterface"]());
        }

        // Secondary event handlers are only processed on local LS and are not
        // delegated
        UCF_JsUtil["forEach"](this["aSemanticEventHandlers"], function (oHandler) {
            if (oHandler["o"] && oHandler["f"] && oHandler["o"][oHandler["f"]]) {
                if (bHasBootingBufferEvents) {
                    self["flushSemanticEventBootingBuffer"]();
                }
                oHandler["o"][oHandler["f"]](oSemanticEvent["oGetInterface"]());
            }
        });

        // Info BootingBuffer: It could happen that events are triggred before the
        // external frameworks have a chance to attach an external handler,  e.g.
        // ClientInspector. Sometimes they need those events. In the constructor of
        // LS the processInitializeIDs is called which could generate those events.
        // Therefore we buffer the events while booting the LS object. The framework
        // can flush them explicitly by
        if (this["bSemanticEventBootingBufferActive"]) {
            if (!this["aSemanticEventBootingBuffer"]) {
                this["aSemanticEventBootingBuffer"] = [];
            }

            // Collect semantic events in booting buffer while LS is booting
            this["aSemanticEventBootingBuffer"]["push"](oSemanticEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["processSemanticEventByExternalHandlers"] = 0;
    }
    ;

    /**
     * Flushes booting buffer and provides the buufered events to the attahced
     * external semantinc event handlers
     *
     * @public
     */
    UCF_LS["prototype"]["flushSemanticEventBootingBuffer"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["flushSemanticEventBootingBuffer"]++;
        }
        ;
        /** @type {Array} */
        var aSemanticEventBootingBuffer;
        /** @type {number} */
        var i;

        this["bSemanticEventBootingBufferActive"] = false;

        if (this["aSemanticEventBootingBuffer"]) {
            // Flush booting buffer
            aSemanticEventBootingBuffer = this["aSemanticEventBootingBuffer"];
            this["cleanUpSemanticEventBootingBuffer"]();

            for (i = 0; i < aSemanticEventBootingBuffer["length"]; i++) {
                this["processSemanticEventByExternalHandlers"](
                    aSemanticEventBootingBuffer[i]
                );
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["flushSemanticEventBootingBuffer"] = 0;
    }
    ;

    /**
     * Sets the current active state of the booting buffer phase
     * @param {boolean} bActive `true` to set active
     */
    UCF_LS["prototype"]["activateSemanticEventBootingBuffer"] = function (bActive) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["activateSemanticEventBootingBuffer"]++;
        }
        ;
        this["bSemanticEventBootingBufferActive"] = bActive;

        if (!bActive) {
            UCF_JsUtil["delayedCall"](0, this, 'cleanUpSemanticEventBootingBuffer');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["activateSemanticEventBootingBuffer"] = 0;
    }
    ;

    /**
     * Clean up of booting buffer
     */
    UCF_LS["prototype"]["cleanUpSemanticEventBootingBuffer"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["cleanUpSemanticEventBootingBuffer"]++;
        }
        ;
        this["aSemanticEventBootingBuffer"] = null;
        this["bSemanticEventBootingBufferActive"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["cleanUpSemanticEventBootingBuffer"] = 0;
    }
    ;

    /**
     * Processing of a pending request, notifies the framework and fire internal
     * events for controls that want to do something for request is sent
     *
     * @param {UCF_PendingRequest} oPendingRequest the pending request
     */
    UCF_LS["prototype"]["processPendingRequest"] = function (oPendingRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["processPendingRequest"]++;
        }
        ;
        // oPendingRequest cannot be asserted as it might come from other windows
        if (this["oPendingRequestHandlerObject"]) {
            this["oPendingRequestHandlerObject"][this["sPendingRequestHandlerFunction"]](
                oPendingRequest["oGetInterface"]()
            );
        }
        this["fireEvent"](
            this["E_EVENTS"]["PendingRequest"], {"oPendingRequest": oPendingRequest}
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["processPendingRequest"] = 0;
    }
    ;

    /**
     * Fires the internal before request event
     */
    UCF_LS["prototype"]["fireBeforeRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireBeforeRequest"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["BeforeRequest"], {"oLS": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireBeforeRequest"] = 0;
    }
    ;

    /**
     * Fires the internal after request event
     */
    UCF_LS["prototype"]["fireAfterRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireAfterRequest"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["AfterRequest"], {"oLS": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireAfterRequest"] = 0;
    }
    ;

    /**
     * Fires the internal after response event
     */
    UCF_LS["prototype"]["fireAfterResponse"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireAfterResponse"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["AfterResponse"], {"oLS": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireAfterResponse"] = 0;
    }
    ;

    /**
     * Fires the internal update complete event
     */
    UCF_LS["prototype"]["fireUpdateComplete"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireUpdateComplete"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["UpdateComplete"], {"oLS": this});
        // eslint-disable-next-line no-magic-numbers
        UCF_JsUtil["delayedCall"](10, this, 'fireCustomUpdateComplete');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireUpdateComplete"] = 0;
    }
    ;

    /**
     * Fires internal UpdateDocumentComplete event.
     */
    UCF_LS["prototype"]["fireUpdateDocumentComplete"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireUpdateDocumentComplete"]++;
        }
        ;
        if (!this["bHasDuplicateControlIds"]()) {
            this["fireEvent"](this["E_EVENTS"]["UpdateDocumentComplete"], {"oLS": this});
            if (typeof (this["fUpdateDocumentCompleteCallback"]) === 'function') {
                this["fUpdateDocumentCompleteCallback"]();
            }
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireUpdateDocumentComplete"] = 0;
    }
    ;

    /**
     * Register/overwrite a single callback function for the 'UpdateDocumentComplete' event.
     * This event is fired only once on "main" LS instance after all control-, delta- or
     * full-updates in one response document are complete.
     * @param {function} fCallback
     * @public
     */
    UCF_LS["prototype"]["registerUpdateDocumentCompleteCallback"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerUpdateDocumentCompleteCallback"]++;
        }
        ;
        this["fUpdateDocumentCompleteCallback"] = fCallback;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerUpdateDocumentCompleteCallback"] = 0;
    }
    ;

    /**
     * Fires internal BeforeUpdateDocument event.
     * @param {UCF_Event} oEvent the BeforeUpdateDocument event
     */
    UCF_LS["prototype"]["fireBeforeUpdateDocument"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireBeforeUpdateDocument"]++;
        }
        ;
        this["fireEvent"](
            this["E_EVENTS"]["BeforeUpdateDocument"],
            UCF_JsUtil["extend"]({"oLS": this}, oEvent)
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireBeforeUpdateDocument"] = 0;
    }
    ;

    /**
     * Checks whether there are duplicate ids on the page for controls.
     * @return {boolean}
     */
    UCF_LS["prototype"]["bHasDuplicateControlIds"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bHasDuplicateControlIds"]++;
        }
        ;
        /** @type {NodeList} */
        var aDomElements;
        /** @type {Object.<string,HTMLElement>} */
        var mElements;
        /** @type {Array.<string>} */
        var aMessage;
        /** @type {boolean} */
        var bError;
        /** @type {number} */
        var i;
        /** @type {HTMLElement} */
        var oExisting;

        if (__UCF_DEBUG__ && document["querySelectorAll"]) {
            aDomElements = document["querySelectorAll"]('[ct="PAGE"] * [ct][id]');
            mElements = {};
            aMessage = [];
            bError = false;

            for (i = 0; i < aDomElements["length"]; i++) {
                if (aDomElements[i]["id"] in mElements) {
                    bError = true;
                    oExisting = mElements[aDomElements[i]["id"]];
                    if (aDomElements[i]["id"] === '') { // eslint-disable-line max-depth
                        aDomElements[i]["setAttribute"]('id', 'ls-empty-' + i);
                    }
                    aMessage["push"](
                        oExisting["id"] +
                        '->' +
                        UCF_ControlFactory["prototype"]["M_TYPES"][oExisting["getAttribute"]('ct')]
                    );
                    aMessage["push"](
                        aDomElements[i]["id"] +
                        '->' +
                        UCF_ControlFactory["prototype"]["M_TYPES"][
                            aDomElements[i]["getAttribute"]('ct')
                            ]
                    );
                    mElements[aDomElements[i]["id"]] = aDomElements[i];
                } else {
                    if (aDomElements[i]["id"] === '') { // eslint-disable-line max-depth
                        aDomElements[i]["setAttribute"]('id', 'ls-empty-' + i);
                    }
                    mElements[aDomElements[i]["id"]] = aDomElements[i];
                }
            }
            if (bError) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Framework needs to correct duplicate ids for the following controls:\n' + aMessage["join"]('\n'), "LS.js(1650): bHasDuplicateControlIds");
                }
                ;

                return false;
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bHasDuplicateControlIds"] = 0;
    }
    ;

    /**
     * Fires the external update complete event
     */
    UCF_LS["prototype"]["fireCustomUpdateComplete"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireCustomUpdateComplete"]++;
        }
        ;
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oHandler;

        if (this["oUpdateCompleteObject"] &&
            this["sUpdateCompleteFunction"] &&
            this["oUpdateCompleteObject"][this["sUpdateCompleteFunction"]]
        ) {
            this["oUpdateCompleteObject"][this["sUpdateCompleteFunction"]](
                this["oGetInterface"]()
            );
        }
        for (i = 0; i < this["aUpdateCompleteHandlers"]["length"]; i++) {
            oHandler = this["aUpdateCompleteHandlers"][i];
            if (oHandler["o"] && oHandler["f"] && oHandler["o"][oHandler["f"]]) {
                oHandler["o"][oHandler["f"]](this["oGetInterface"]());
            }
        }
        this["fireEvent"](this["E_EVENTS"]["CustomUpdateComplete"], {"oLS": this});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireCustomUpdateComplete"] = 0;
    }
    ;

    /**
     * Enables the ControlCreate and ControlDestroy events
     * for lifecycle management from a hosting framework
     *
     * @public
     */
    UCF_LS["prototype"]["enableLifecycleEvents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["enableLifecycleEvents"]++;
        }
        ;
        this["bFireLifecycleEvents"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["enableLifecycleEvents"] = 0;
    }
    ;

    /**
     * Sets the semantic event handler of the framework
     *
     * @public
     *
     * @param {Object} oSemanticEventHandlerObject the object
     * @param {string} sSemanticEventHandlerFunction the name of the handler function
     */
    UCF_LS["prototype"]["setSemanticEventHandler"] = function (oSemanticEventHandlerObject, sSemanticEventHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setSemanticEventHandler"]++;
        }
        ;
        this["oSemanticEventHandlerObject"] = oSemanticEventHandlerObject;
        this["sSemanticEventHandlerFunction"] = sSemanticEventHandlerFunction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setSemanticEventHandler"] = 0;
    }
    ;

    /**
     * Attaches to the SemanticEvent event
     * @param {Object} oSemanticEventHandlerObject the object
     * @param {string} sSemanticEventHandlerFunction the name of the handler function
     * @public
     */
    UCF_LS["prototype"]["attachSemanticEvent"] = function (oSemanticEventHandlerObject, sSemanticEventHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachSemanticEvent"]++;
        }
        ;
        this["aSemanticEventHandlers"]["push"]({
            "o": oSemanticEventHandlerObject,
            "f": sSemanticEventHandlerFunction
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachSemanticEvent"] = 0;
    }
    ;

    /**
     * Detaches from the SemanticEvent event
     * @public
     * @param {Object} oSemanticEventHandlerObject the handler
     * @param {string} sSemanticEventHandlerFunction the function name
     */
    UCF_LS["prototype"]["detachSemanticEvent"] = function (oSemanticEventHandlerObject, sSemanticEventHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachSemanticEvent"]++;
        }
        ;
        /** @type {Array.<{o:Object,f:function}>} */
        var a = [];
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oHandler;

        for (i = 0; i < this["aSemanticEventHandlers"]["length"]; i++) {
            oHandler = this["aSemanticEventHandlers"][i];
            if (oHandler["o"] !== oSemanticEventHandlerObject ||
                oHandler["f"] !== sSemanticEventHandlerFunction
            ) {
                a["push"]({"o": oHandler["o"], "f": oHandler["f"]});
            }
        }
        this["aSemanticEventHandlers"] = a;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachSemanticEvent"] = 0;
    }
    ;

    /**
     * Sets the update complete event handler of the framework
     *
     * @public
     *
     * @param {Object} oUpdateCompleteObject the object
     * @param {string} sUpdateCompleteFunction the name of the handler function
     */
    UCF_LS["prototype"]["setUpdateCompleteHandler"] = function (oUpdateCompleteObject, sUpdateCompleteFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setUpdateCompleteHandler"]++;
        }
        ;
        this["oUpdateCompleteObject"] = oUpdateCompleteObject;
        this["sUpdateCompleteFunction"] = sUpdateCompleteFunction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setUpdateCompleteHandler"] = 0;
    }
    ;

    /**
     * Attaches to the UpdateComplete event
     * @public
     * @param {Object} oUpdateCompleteObject the object
     * @param {string} sUpdateCompleteFunction the name of the handler function
     */
    UCF_LS["prototype"]["attachUpdateComplete"] = function (oUpdateCompleteObject, sUpdateCompleteFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachUpdateComplete"]++;
        }
        ;
        this["aUpdateCompleteHandlers"]["push"]({
            "o": oUpdateCompleteObject,
            "f": sUpdateCompleteFunction
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachUpdateComplete"] = 0;
    }
    ;

    /**
     * Detaches from the UpdateComplete event
     * @public
     * @param {Object} oUpdateCompleteObject the object
     * @param {string} sUpdateCompleteFunction the name of the handler function
     */
    UCF_LS["prototype"]["detachUpdateComplete"] = function (oUpdateCompleteObject, sUpdateCompleteFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachUpdateComplete"]++;
        }
        ;
        /** @type {Array.<{o: Object, f: function}>} */
        var a = [];
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oHandler;

        for (i = 0; i < this["aUpdateCompleteHandlers"]["length"]; i++) {
            oHandler = this["aUpdateCompleteHandlers"][i];
            if (oHandler["o"] !== oUpdateCompleteObject ||
                oHandler["f"] !== sUpdateCompleteFunction
            ) {
                a["push"]({"o": oHandler["o"], "f": oHandler["f"]});
            }
        }
        this["aUpdateCompleteHandlers"] = a;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachUpdateComplete"] = 0;
    }
    ;

    /**
     * Removes the update complete handler
     * @public
     */
    UCF_LS["prototype"]["removeUpdateCompleteHandler"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["removeUpdateCompleteHandler"]++;
        }
        ;
        this["oUpdateCompleteObject"] = null;
        this["sUpdateCompleteFunction"] = '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["removeUpdateCompleteHandler"] = 0;
    }
    ;

    /**
     * Sets the application exit handler of the framework
     *
     * @public
     * @param {Object} oApplicationExitHandlerObject the object
     * @param {string} sApplicationExitHandlerFunction the name of the handler
     */
    UCF_LS["prototype"]["setApplicationExitHandler"] = function (oApplicationExitHandlerObject, sApplicationExitHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setApplicationExitHandler"]++;
        }
        ;
        this["oApplicationExitHandlerObject"] = oApplicationExitHandlerObject;
        this["sApplicationExitHandlerFunction"] = sApplicationExitHandlerFunction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setApplicationExitHandler"] = 0;
    }
    ;

    /**
     * Sets the pending request handler of the framework
     *
     * @public
     * @param {Object} oPendingRequestHandlerObject the object
     * @param {string} sPendingRequestHandlerFunction the name of the handler
     */
    UCF_LS["prototype"]["setPendingRequestHandler"] = function (oPendingRequestHandlerObject, sPendingRequestHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setPendingRequestHandler"]++;
        }
        ;
        this["oPendingRequestHandlerObject"] = oPendingRequestHandlerObject;
        this["sPendingRequestHandlerFunction"] = sPendingRequestHandlerFunction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setPendingRequestHandler"] = 0;
    }
    ;

    /**
     * Set the main window id
     * @public
     * @param {string} sMainWindowId
     */
    UCF_LS["prototype"]["setMainWindowId"] = function (sMainWindowId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setMainWindowId"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sMainWindowId === 'string', "typeof sMainWindowId === 'string'", "LS.js(1836): setMainWindowId");
        }
        ;

        this["sMainWindowId"] = sMainWindowId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setMainWindowId"] = 0;
    }
    ;

    /**
     * Get the main window id
     * @return {string}
     */
    UCF_LS["prototype"]["sGetMainWindowId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetMainWindowId"]++;
        }
        ;
        return this["sMainWindowId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetMainWindowId"] = 0;
    }
    ;

    /**
     * Enables toggling of Message Area focus with Ctrl+Alt+M
     *
     * @public
     * @param {string} sMessageAreaId the id of the message area
     * @param {string} sFocusedMessageId the id of the focussed message
     * @param {string} sTargetFocusInfo focus info
     * @param {Object} oCallbackObject the object to call
     * @param {string} sCallbackMethod the method name of the oCallbackObject
     */
    UCF_LS["prototype"]["setMessageFocusToggleInfo"] = function (sMessageAreaId, sFocusedMessageId, sTargetFocusInfo, oCallbackObject, sCallbackMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setMessageFocusToggleInfo"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        if (oPage) {
            oPage["setMessageFocusToggleInfoInternal"](
                sMessageAreaId,
                sFocusedMessageId,
                sTargetFocusInfo,
                oCallbackObject,
                sCallbackMethod
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setMessageFocusToggleInfo"] = 0;
    }
    ;

    /**
     * Check whether current LS is LS of the main window
     * @return {boolean}
     */
    UCF_LS["prototype"]["bIsMainLS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsMainLS"]++;
        }
        ;
        // does not run in a popup iframe -> return true
        return this["bIsolatedEmbedding"]
            || this["oGetPopupIFrame"]() == null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsMainLS"] = 0;
    }
    ;

    /**
     * Returns the LS object of the main window
     * TODO: Not just return the opener, but find the main window
     * @return {UCF_LS}
     */
    UCF_LS["prototype"]["oGetMainLS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetMainLS"]++;
        }
        ;
        if (!this["oMainLS"]) {
            this["oMainLS"] = this["oFindMainLS"]();
        }

        return this["oMainLS"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetMainLS"] = 0;
    }
    ;

    /**
     * Returns the LS object of the main window
     * TODO: Not just return the opener, but find the main window
     * @return {UCF_LS}
     */
    UCF_LS["prototype"]["oFindMainLS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oFindMainLS"]++;
        }
        ;
        /** @type {string} */
        var sPopupId;
        /** @type {UCF_LS} */
        var oOpenerLS;

        if (!this["oPopupManager"]) {
            this["oPopupManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_PopupManager"))(this);
        }

        if (this["bIsolatedEmbedding"]) {
            return this;
        }

        sPopupId = this["oPopupManager"]["sGetPopupIdByWindow"](window);

        // PopupManager doesn't know the main window id, so if this is null,
        // we already are in the main window
        if (!sPopupId) {
            return this;
        }

        oOpenerLS = this["oPopupManager"]["oGetOpenerLSByPopupIdInternal"](sPopupId);

        if (oOpenerLS["bIsMainLS"]()) {
            return oOpenerLS;
        }

        return oOpenerLS["oGetMainLS"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oFindMainLS"] = 0;
    }
    ;

    /**
     * @param {string} [sPwControlId] the ID of the PopupWindow control for which
     * the IFrame must be found. In this case, the result will always be null for
     * DIV-Popups.
     * @return {HTMLIFrameElement} the iframe where this LS runs in if it is in a
     * PopupWindow, null else
     */
    UCF_LS["prototype"]["oGetPopupIFrame"] = function (sPwControlId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPopupIFrame"]++;
        }
        ;
        /** @type {HTMLCollection} */
        var aIFrames;
        /** @type {number} */
        var x;
        /** @type {HTMLIFrameElement} */
        var oIFrame;

        // Find parent iframe
        try {
            // eslint-disable-next-line no-unused-expressions
            window["parent"]["document"]["domain"];
        } catch (ex) {
            // parent document is NOT reachable -> ignore

            return null;
        }

        aIFrames = window["parent"]["document"]["getElementsByTagName"]('iframe');

        for (x = 0; x < aIFrames["length"]; x++) {
            oIFrame = aIFrames[x];

            try {
                if (oIFrame["contentWindow"] == window && // eslint-disable-line eqeqeq
                    oIFrame["getAttribute"](this["M_CONSTANTS"]["LSPOPUP"]) === 'true'
                ) {
                    return sPwControlId
                        // see UCF_PopupManager.createPopupWindow
                        ? (oIFrame["getAttribute"]('PWID') === sPwControlId ? oIFrame : null)
                        : oIFrame;
                }
            } catch (ignored) {
                // just continue searching
            }
        }

        // no iframe found -> LS does not run in a popupwindow
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPopupIFrame"] = 0;
    }
    ;

    /**
     * Attach to main LS events, if this is not the main LS instance
     */
    UCF_LS["prototype"]["attachMainLSEvents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachMainLSEvents"]++;
        }
        ;
        /** @type {UCF_LS} */
        var oMainLS;

        if (!this["bIsMainLS"]()) {
            oMainLS = this["oGetMainLS"]();
            oMainLS["attachEvent"](oMainLS["E_EVENTS"]["Lock"], this, 'onMainLock');
            oMainLS["attachEvent"](oMainLS["E_EVENTS"]["Unlock"], this, 'onMainUnlock');
            oMainLS["attachEvent"](
                oMainLS["E_EVENTS"]["PendingRequest"],
                this,
                'onMainPendingRequest'
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachMainLSEvents"] = 0;
    }
    ;

    /**
     * Detach from main LS events, if this is not the main LS instance
     */
    UCF_LS["prototype"]["detachMainLSEvents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachMainLSEvents"]++;
        }
        ;
        /** @type {UCF_LS} */
        var oMainLS;

        if (!this["bIsMainLS"]()) {
            oMainLS = this["oGetMainLS"]();
            try {
                oMainLS["detachEvent"](oMainLS["E_EVENTS"]["Lock"], this);
                oMainLS["detachEvent"](oMainLS["E_EVENTS"]["Unlock"], this);
                oMainLS["detachEvent"](oMainLS["E_EVENTS"]["PendingRequest"], this);
            } catch (ignored /* freed script */) {
                // fail silently
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachMainLSEvents"] = 0;
    }
    ;

    /**
     * Main lock handler
     * @param {UCF_Event} oEvent the lock
     */
    UCF_LS["prototype"]["onMainLock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onMainLock"]++;
        }
        ;
        this["lock"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onMainLock"] = 0;
    }
    ;

    /**
     * Main unlock handler
     * @param {UCF_Event} oEvent the unlock
     */
    UCF_LS["prototype"]["onMainUnlock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onMainUnlock"]++;
        }
        ;
        this["unlock"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onMainUnlock"] = 0;
    }
    ;

    /**
     * Main pending request handler
     * @param {UCF_Event} oEvent the pending request event
     */
    UCF_LS["prototype"]["onMainPendingRequest"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onMainPendingRequest"]++;
        }
        ;
        this["processPendingRequest"](oEvent["oGetParam"]('oPendingRequest'));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onMainPendingRequest"] = 0;
    }
    ;

    /**
     * Find DebugWindow and attach it
     */
    UCF_LS["prototype"]["attachToDebugWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachToDebugWindow"]++;
        }
        ;
        /** @type {Window} */
        var oWinRef;
        /** @type {UCF_DebugWindow} */
        var debugWindow;

        if (this["bIsMainLS"]()) {
            oWinRef = window;
        } else {
            if (!this["oPopupManager"]) {
                this["oPopupManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_PopupManager"))(this);
            }
            oWinRef = this["oPopupManager"]["oGetOpenerWindow"](window);
        }

        debugWindow = window["UCF_debugWindow"];
        if (debugWindow) {
            debugWindow["attachToLS"](this, oWinRef);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachToDebugWindow"] = 0;
    }
    ;

    /**
     * Find Testsuite and attach it
     */
    UCF_LS["prototype"]["attachToTestsuite"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachToTestsuite"]++;
        }
        ;
        if (this["bIsMainLS"]()) {
            try {
                if (top["testFramework"] && top["testFramework"]["setLS"]) {
                    top["testFramework"]["setLS"](this["oGetInterface"]());
                    UCF_ResourceUtil["enableSVG"]();
                }
            } catch (ignored) {
                // top.testFramework not reachable, ignore
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachToTestsuite"] = 0;
    }
    ;

    /**
     * Proved access to getQTPControl method for QTP tests
     */
    UCF_LS["prototype"]["attachToQTP"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachToQTP"]++;
        }
        ;
        window["oQTP"] = this["oGetInterface"](['oGetQTPControl']);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachToQTP"] = 0;
    }
    ;

    /**
     * Returns the Page control interface , if there is any
     *
     * @public
     * @return {UCF_Page}
     */
    UCF_LS["prototype"]["oGetPage"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPage"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        return oPage && oPage["oGetInterface"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPage"] = 0;
    }
    ;

    /**
     * Returns the internal Page control for private uage inside of the LS
     * framework, if there is any
     *
     * @private
     * @return {UCF_Page}
     */
    UCF_LS["prototype"]["oGetPageInternal"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPageInternal"]++;
        }
        ;
        /** @type {HTMLCollection} */
        var aDivs;
        /** @type {HTMLDivElement} */
        var oFirstDiv;
        /** @type {HTMLDivElement} */
        var oSecondDiv;
        /** @type {number} */
        var i;

        // oPage == undefined -> not searched before
        // oPage == null -> searched before but not found
        // oPage == any reference -> searched before and found

        if (!('oPage' in this)) {
            // If there is a Page control used, search for its DIV
            //
            // Addons or plugins may add additional unexpected DIV elements
            // to the page (like Firebug or Babylon), so always check the second
            // DIV in the DOM as well.
            aDivs = document["getElementsByTagName"]('DIV');
            oFirstDiv = aDivs[0];
            oSecondDiv = aDivs[1];

            if (this["oRootRef"] && this["oRootRef"]["getAttribute"]('ct') === 'PAGE') {
                this["oPage"] = this["oControlFactory"]["oGetControlByDomRef"](
                    this["oRootRef"],
                    true
                );
            } else if (oFirstDiv && oFirstDiv["getAttribute"]('ct') === 'PAGE') {
                this["oPage"] = this["oControlFactory"]["oGetControlByDomRef"](oFirstDiv, true);
            } else if (oSecondDiv && oSecondDiv["getAttribute"]('ct') === 'PAGE') {
                this["oPage"] = this["oControlFactory"]["oGetControlByDomRef"](oSecondDiv, true);
            } else {
                this["oPage"] = null;
            }
            if (this["oPage"]) {
                if (UCF_LS["aRegisteredClasses"]["length"] > 0) {
                    for (i = 0; i < UCF_LS["aRegisteredClasses"]["length"]; i++) {
                        if (UCF_LS["aRegisteredClasses"][i]["onLSPageInit"]) {
                            UCF_LS["aRegisteredClasses"][i]["onLSPageInit"](this["oPage"]);
                        }
                    }
                }
            }
        }

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(this["oPage"] == null || this["oPage"] instanceof UCF_Page, "this.oPage == null || this.oPage instanceof UCF_Page", "LS.js(2157): oGetPageInternal");
        }
        ;

        return this["oPage"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPageInternal"] = 0;
    }
    ;

    /**
     * Get the popup manager
     *
     * @public
     * @return {UCF_PopupManager}
     */
    UCF_LS["prototype"]["oGetPopupManager"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPopupManager"]++;
        }
        ;
        /** @type {UCF_PopupManager} */
        var oPopupManager = this["oGetPopupManagerInternal"]();

        return oPopupManager && oPopupManager["oGetInterface"]();

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPopupManager"] = 0;
    }
    ;

    /**
     * Get the popup managers internal object for usage inside of the LS framework
     *
     * @private
     * @return {UCF_PopupManager}
     */
    UCF_LS["prototype"]["oGetPopupManagerInternal"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPopupManagerInternal"]++;
        }
        ;
        if (!this["oPopupManager"]) {
            this["oPopupManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_PopupManager"))(this);
        }

        return this["oPopupManager"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPopupManagerInternal"] = 0;
    }
    ;

    /**
     * Reads the initializer IDs from the HTML (if any), create the controls and
     * call the initialize method. For client side rendering an array is given to
     * this method that is added to the current stack of initialize ids stored in
     * this.aInitializeIds
     * @public
     * @param {Array.<string>} [aIds] array of ids to initialize
     */
    UCF_LS["prototype"]["processInitializeIDs"] = function (aIds) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["processInitializeIDs"]++;
        }
        ;
        // read the initialize ids from dom, erase dom and call self
        /** @type {HTMLSpanElement} */
        var oIdRef = UCF_DomUtil["$"]('UCF_InitializeIDs');
        /** @type {Array.<string>} */
        var aDomIds;
        /** @type {string} */
        var sId;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {UCF_Page} */
        var oPage;

        if (oIdRef) {
            aDomIds = UCF_JsUtil["oJsonParse"](oIdRef["innerHTML"]);
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(UCF_JsUtil["bIsArray"](aDomIds), "UCF_JsUtil.bIsArray(aDomIds)", "LS.js(2213): processInitializeIDs");
            }
            ;

            UCF_DomUtil["removeFromDom"](oIdRef);

            // first process initialize ids of html, then others
            aIds = aDomIds["concat"](aIds || []);
        }

        if (aIds) {
            // just concat the ids to the existing stack
            if (this["aInitializeIds"]["length"] > 0) {
                this["aInitializeIds"] = this["aInitializeIds"]["concat"](aIds);

                return;
            } else {
                this["aInitializeIds"] = aIds;
            }
        }

        this["fireEvent"](this["E_EVENTS"]["BeforeControlsInitialized"], {
            "iControls": this["aInitializeIds"]["length"]
        });

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(START, 'initall', 'Initialize ' + this["aInitializeIds"]["length"] + ' controls...');
        }
        ;

        while (this["aInitializeIds"]["length"] > 0) {
            sId = this["aInitializeIds"]["shift"]();
            oControl = this["oControlFactory"]["oGetControlById"](sId);
            if (sId["indexOf"]('-') > -1) {
                if (!oControl ||
                    oControl["sClassName"] !== 'UCF_Scrollbar' ||
                    sId["indexOf"]('scrollV') === -1
                ) {
                    // unfortunately, SapTable and AbapList renderers use such an id for
                    // the scrollbar, changes  would be incompatible
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Framework Error. Id (' + sId + ') should not contain - (minus)', "LS.js(2248): processInitializeIDs");
                    }
                    ;
                }
            }
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(oControl != null && oControl["initialize"] != null, "oControl != null && oControl.initialize != null", "LS.js(2251): processInitializeIDs");
            }
            ;

            if (oControl && oControl["initialize"]) {
                if (__UCF_MEASURE__) {
                    UCF_Tracer.measure(START, 'initialize');
                }
                ;
                oControl["initialize"]();
                if (__UCF_MEASURE__) {
                    UCF_Tracer.measure(STOP, 'initialize', 'Initialized ' + oControl["sClassName"] + ' "' + sId + '" within');
                }
                ;
            }
        }

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(STOP, 'initall', 'Initialized all controls within');
        }
        ;

        oPage = this["oGetPageInternal"]();
        if (oPage && oPage["loadingScripts"]()) {
            // additionally wait for pending script loads of the page
            oPage["attachEvent"](
                oPage["E_EVENTS"]["FinishedScriptLoading"],
                this,
                'fireControlsInitialized'
            );
        } else {
            this["fireControlsInitialized"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["processInitializeIDs"] = 0;
    }
    ;

    /**
     * Fires the controls initialized event after all controls where initialized
     */
    UCF_LS["prototype"]["fireControlsInitialized"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireControlsInitialized"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        if (oPage) {
            oPage["detachEvent"](
                oPage["E_EVENTS"]["FinishedScriptLoading"],
                this,
                'fireControlsInitialized'
            );
        }
        this["bControlsInitialized"] = true;
        this["fireEvent"](this["E_EVENTS"]["ControlsInitialized"], {
            "sPopupId": this["oPopupManager"]["sGetPopupIdByWindow"](this["oWindow"])
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireControlsInitialized"] = 0;
    }
    ;

    /** @private */
    UCF_LS["prototype"]["runIdleTasks"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["runIdleTasks"]++;
        }
        ;
        UCF_ClassLoader["requestPreloadExpansion"]();
        this["requestFontLoading"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["runIdleTasks"] = 0;
    }
    ;

    /** @private */
    UCF_LS["prototype"]["requestFontLoading"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["requestFontLoading"]++;
        }
        ;
        // TODO might need to cancel the idle callback if LS destroyed before
        UCF_JsUtil["requestIdleCallback"](function () {
            /** @type {CSSStyleDeclaration[]} */
            var aThemeDefinedFonts = UCF_JsUtil["aGetThemeDefinedFonts"]();
            /** @type {HTMLSpanElement} */
            var oRef;

            if (aThemeDefinedFonts["length"] > 0) {
                oRef = document["createElement"]('span');

                oRef["style"]["position"] = 'absolute';
                oRef["style"]["top"] = '-5000px';

                UCF_DomUtil["prepend"](document["body"], oRef);

                UCF_Promise["all"](UCF_JsUtil["map"](aThemeDefinedFonts, function (oFont) {
                    return new (UCF_ClassLoader["oGetClass"]("UCF_Promise"))(function (resolve) {
                        /** @param {{didTimeout: boolean, timeRemaining: function(): number}} oDeadline */
                        function loadFont(oDeadline) {
                            // eslint-disable-next-line no-magic-numbers
                            if (!oDeadline["didTimeout"] && oDeadline["timeRemaining"]() > 10) {
                                UCF_DomUtil["setStyle"](oRef, oFont);

                                resolve();
                            } else {
                                UCF_JsUtil["requestIdleCallback"](loadFont);
                            }
                        }

                        UCF_JsUtil["requestIdleCallback"](loadFont);
                    });
                }))["then"](function () {
                    UCF_JsUtil["requestIdleCallback"](function () {
                        UCF_DomUtil["removeFromDom"](oRef);
                    });
                });
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["requestFontLoading"] = 0;
    }
    ;

    /**
     * Grants private access to the LS instance
     * @param {Object} oObject An object instance to be used for granting access
     * @return {UCF_LS}
     * @public
     */
    UCF_LS["prototype"]["oGetInternal"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetInternal"]++;
        }
        ;
        if (oObject instanceof UCF_Object) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Access granted to internal lightspeed instance for UCF_Object instance', "LS.js(2351): oGetInternal");
            }
            ;

            return this;
        }
        if (
            (
                oObject["getMetadata"] &&
                oObject["getMetadata"]()["_sClassName"] &&
                UCF_StringUtil["bStartsWith"](oObject["getMetadata"]()["_sClassName"], 'sap.')
            ) ||
            (
                window["sap"] &&
                window["sap"]["ui"] &&
                window["sap"]["ui"]["base"] &&
                oObject instanceof window["sap"]["ui"]["base"]["Object"]
            )
        ) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Access granted to internal lightspeed instance for ' + oObject["toString"](), "LS.js(2368): oGetInternal");
            }
            ;

            return this;
        }
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(ERROR, 'No access granted to internal lightspeed instance', "LS.js(2372): oGetInternal");
        }
        ;

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetInternal"] = 0;
    }
    ;

    /**
     * @param {UCF_ClientControl} oClientControl the client control to fire
     * @return {boolea}
     */
    UCF_LS["prototype"]["fireRenderClientControl"] = function (oClientControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireRenderClientControl"]++;
        }
        ;
        this["fireEvent"](
            this["E_EVENTS"]["RenderClientControl"], {"bCancelRendering": false, "oClientControl": oClientControl}
        );

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireRenderClientControl"] = 0;
    }
    ;

    /**
     * Attach to the ClientControlRender event that is called before the control is
     * actually rendered
     *
     * @public
     * @param {Object} oObject the handler
     * @param {string} sMethod the method name
     */
    UCF_LS["prototype"]["attachRenderClientControl"] = function (oObject, sMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["attachRenderClientControl"]++;
        }
        ;
        this["attachEvent"](this["E_EVENTS"]["RenderClientControl"], oObject, sMethod);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["attachRenderClientControl"] = 0;
    }
    ;

    /**
     * Detach from the ClientControlRender event that is called before the control
     * is actually rendered
     *
     * @public
     * @param {Object} oObject the handler
     * @param {string} sMethod the method name
     */
    UCF_LS["prototype"]["detachRenderClientControl"] = function (oObject, sMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["detachRenderClientControl"]++;
        }
        ;
        this["detachEvent"](this["E_EVENTS"]["RenderClientControl"], oObject, sMethod);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["detachRenderClientControl"] = 0;
    }
    ;

    /**
     * Create a Control dynamically
     *
     * @public
     * @param {string} sControlName the control name to create
     * @param {string} sId the id of the control to create
     * @return {UCF_Control}
     */
    UCF_LS["prototype"]["oCreateControl"] = function (sControlName, sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oCreateControl"]++;
        }
        ;
        return this["oControlFactory"]["oCreateControl"](
            sControlName,
            sId
        )["oGetInterface"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oCreateControl"] = 0;
    }
    ;

    /**
     * Returns the client control instance for the given id
     *
     * @public
     * @param {string} sId the id of the client control
     * @return {UCF_ClientElement} The Client control with the given id
     */
    UCF_LS["prototype"]["oGetClientControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetClientControlById"]++;
        }
        ;
        return this["oControlFactory"]["oGetClientControlById"](sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetClientControlById"] = 0;
    }
    ;

    /**
     * Create a ClientControl dynamically
     *
     * @public
     * @param {string|Object} sControlName the name of the client control to create
     * or a JSON control tree representation
     * @param {string} [sId] the id of the client control to create
     * @param {Object} [oJson] JSON with content and settings for the control
     * @return {UCF_ClientControl}
     */
    UCF_LS["prototype"]["oCreateClientControl"] = function (sControlName, sId, oJson) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oCreateClientControl"]++;
        }
        ;
        if (typeof sId === 'object' && !oJson) {
            oJson = sId;
            sId = UCF_ClientElement["createId"]();
        }

        return this["oControlFactory"]["oCreateClientControl"](sControlName, sId, oJson);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oCreateClientControl"] = 0;
    }
    ;

    /**
     * Returns the currently managed controltree that contains the given control or
     * the control with the given id
     *
     * @public
     * @param {string|UCF_ClientControl} oControlOrId the client control or id of
     * the client control to get the client control tree for
     * @return {UCF_ClientControlTree} The currently managed controltree that
     * contains the given control or the control with the given id
     */
    UCF_LS["prototype"]["oGetClientControlTree"] = function (oControlOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetClientControlTree"]++;
        }
        ;
        return this["oControlFactory"]["oGetClientControlTree"](oControlOrId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetClientControlTree"] = 0;
    }
    ;

    /**
     * Returns the currently managed control-trees.
     * @public
     * @return {Object} The currently managed control-trees.
     */
    UCF_LS["prototype"]["mGetClientControlTrees"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["mGetClientControlTrees"]++;
        }
        ;
        return this["oControlFactory"]["mGetClientControlTrees"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["mGetClientControlTrees"] = 0;
    }
    ;

    /**
     * Get LightSpeed control instance by ID
     *
     * @public
     * @param {string} sId the id of the control to get
     * @return {UCF_Interface}
     */
    UCF_LS["prototype"]["oGetControlById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetControlById"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "LS.js(2492): oGetControlById");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId !== '', "sId !== ''", "LS.js(2493): oGetControlById");
        }
        ;

        oControl = this["oControlFactory"]["oGetControlById"](sId);

        return oControl && oControl["oGetInterface"]();

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetControlById"] = 0;
    }
    ;

    /**
     * Get LightSpeed control instance by a screen point
     *
     * @public
     * @param {number} iX x-coordinate relative to the current viewport
     * @param {number} iY y-coordinate relative to the current viewport
     * @return {UCF_Interface}
     */
    UCF_LS["prototype"]["oGetControlFromPoint"] = function (iX, iY) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetControlFromPoint"]++;
        }
        ;
        /** @type {string} */
        var sOldDisplay;
        /** @type {HTMLElement} */
        var oDomRef;

        if (this["oHighlightObject"]["dom"]) {
            sOldDisplay = this["oHighlightObject"]["dom"]["style"]["display"];
            this["oHighlightObject"]["dom"]["style"]["display"] = 'none';
        }
        oDomRef = UCF_DomUtil["oGetElementFromPoint"](iX, iY);
        if (this["oHighlightObject"]["dom"]) {
            this["oHighlightObject"]["dom"]["style"]["display"] = sOldDisplay;
        }

        return this["oGetControlByDomRef"](oDomRef, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetControlFromPoint"] = 0;
    }
    ;

    /**
     * Get LightSpeed control instance by ID
     *
     * @public
     * @param {string} sId the id of the control
     * @return {UCF_Interface}
     */
    UCF_LS["prototype"]["oGetQTPControl"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetQTPControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {Array.<string>} */
        var aQTPInterface;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "LS.js(2540): oGetQTPControl");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId !== '', "sId !== ''", "LS.js(2541): oGetQTPControl");
        }
        ;

        oControl = this["oControlFactory"]["oGetControlById"](sId);

        if (!oControl) {
            return null;
        }

        aQTPInterface = oControl["aMethodNames"]["slice"](0);
        aQTPInterface["push"]('oGetQTPProperty');

        return oControl["oGetInterface"](aQTPInterface);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetQTPControl"] = 0;
    }
    ;

    /**
     * Register a new {UCF_Control} type. It delegates to the {UCF_ControlFactory}.
     *
     * @see UCF_ControlFactory#registerControlType
     * @public
     * @param {string} sPrefix the library prefix
     * @param {string} sCT the ct
     * @param {string} sType the classname in the library
     */
    UCF_LS["prototype"]["registerControlType"] = function (sPrefix, sCT, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerControlType"]++;
        }
        ;
        // asserts are done inside
        this["oControlFactory"]["registerControlType"](sPrefix, sCT, sType);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerControlType"] = 0;
    }
    ;

    /**
     * Get LightSpeed control instance by DomRef
     *
     * @param {HTMLElement} oDomRef
     * @return {UCF_Control}
     */
    UCF_LS["prototype"]["oGetControlByDomRef"] = function (oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetControlByDomRef"]++;
        }
        ;
        /** @type {string} */
        var sId;
        /** @type {number} */
        var iRootPos;

        while (oDomRef && oDomRef !== window && oDomRef !== document) {
            sId = oDomRef["id"];
            if (oDomRef["getAttribute"]('ct')) {
                return this["oControlFactory"]["oGetControlByDomRef"](oDomRef, true);
            }
            if (sId) {
                iRootPos = sId["indexOf"]('-r');
                // eslint-disable-next-line no-magic-numbers
                if (iRootPos > 0 && iRootPos + 2 === sId["length"]) {
                    oDomRef = UCF_DomUtil["$"](sId["substr"](0, iRootPos));

                    return this["oControlFactory"]["oGetControlByDomRef"](oDomRef, true);
                }
            }
            oDomRef = oDomRef["parentNode"];
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetControlByDomRef"] = 0;
    }
    ;

    /**
     * Purge all currently stored control instances. This is needed for frameworks
     * that are using innerHTML update to not keep the DOM references of removed
     * objects
     *
     * @public
     */
    UCF_LS["prototype"]["purgeControls"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["purgeControls"]++;
        }
        ;
        this["oControlFactory"]["purgeControls"]();
        UCF_DomUtil["purgeActiveElement"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["purgeControls"] = 0;
    }
    ;

    /**
     * Sets the root ref.
     * @param {HTMLElement} oRootRef
     */
    UCF_LS["prototype"]["setRootRef"] = function (oRootRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setRootRef"]++;
        }
        ;
        this["oRootRef"] = oRootRef || document["body"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setRootRef"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the root container
     * @return {HTMLElement}
     */
    UCF_LS["prototype"]["oGetRootRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetRootRef"]++;
        }
        ;
        return this["oRootRef"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetRootRef"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the associated area of the page
     *
     * @private
     * @return {HTMLElement}
     */
    UCF_LS["prototype"]["oGetAssociatedAreaRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetAssociatedAreaRef"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        return oPage
            ? oPage["oGetAssociatedAreaRef"]()
            : this["oRootRef"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetAssociatedAreaRef"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the static area of the page
     *
     * @private
     * @return {HTMLElement}
     */
    UCF_LS["prototype"]["oGetStaticAreaRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetStaticAreaRef"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        return oPage
            ? oPage["oGetStaticAreaRef"]()
            : document["body"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetStaticAreaRef"] = 0;
    }
    ;

    /**
     * Returns the translated text for the passed key
     *
     * @private
     * @param {string} sKey the translation key
     * @param {Array} aVars Array of variables to be replaced in the text
     * @return {string} Returns a translated text for a given key
     */
    UCF_LS["prototype"]["sGetText"] = function (sKey, aVars) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetText"]++;
        }
        ;
        /** @type {UCF_LS} */
        var oMainLS = this["oGetMainLS"]();

        // Get the text from main ls do avoid roundtrip for message bundle.
        if (oMainLS && !this["bIsMainLS"]()) {
            return oMainLS["sGetText"](sKey, aVars);
        }
        // Lazy creation of message bundle
        if (!this["oMessageBundle"]) {
            this["oMessageBundle"] = new (UCF_ClassLoader["oGetClass"]("UCF_MessageBundle"))();
        }

        return this["oMessageBundle"]["sGetText"](sKey, aVars);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetText"] = 0;
    }
    ;

    /**
     * Returns a translated text for a given key or empty string if key doesn't
     * exist
     *
     * @private
     * @param {string} sKey the translation key
     * @return {string}
     */
    UCF_LS["prototype"]["sGetRawText"] = function (sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetRawText"]++;
        }
        ;
        /** @type {UCF_LS} */
        var oMainLS = this["oGetMainLS"]();

        // Get the text from main ls do avoid roundtrip for message bundle.
        if (oMainLS && !this["bIsMainLS"]()) {
            return oMainLS["sGetRawText"](sKey);
        }
        // Lazy creation of message bundle
        if (!this["oMessageBundle"]) {
            this["oMessageBundle"] = new (UCF_ClassLoader["oGetClass"]("UCF_MessageBundle"))();
        }

        return this["oMessageBundle"]["sGetRawText"](sKey);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetRawText"] = 0;
    }
    ;

    /**
     * Updates a controls outer HTML
     *
     * @public
     * @param {string} sControlId the ID of the control to update
     * @param {string} sHTML the new HTML for the control
     */
    UCF_LS["prototype"]["updateControl"] = function (sControlId, sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["updateControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl = this["oControlFactory"]["oGetControlById"](sControlId);
        /** @type {HTMLElement} */
        var oRootRef = oControl["oRootRef"];
        /** @type {HTMLElement} */
        var oParentRef = oRootRef["parentNode"];
        /** @type {HTMLElement} */
        var oPreviousRef = oRootRef["previousSibling"];
        /** @type {CSSStyleDeclaration} */
        var oStyle = this["oRootRef"]["getElementsByTagName"]('STYLE')[0];
        /** @type {Element|Element[]} */
        var oRef;

        // Move initial styles to head, they contain body styles
        if (oStyle && !this["bStylesMoved"]) {
            this["bStylesMoved"] = true;
            document["getElementsByTagName"]('HEAD')[0]["appendChild"](oStyle);
        }

        // Remove style tags from previous delta updates
        oPreviousRef = oRootRef["previousSibling"];
        while (oPreviousRef && oPreviousRef["nodeType"] !== 1) {
            oPreviousRef = oPreviousRef["previousSibling"];
        }

        if (oPreviousRef &&
            oPreviousRef["tagName"] &&
            oPreviousRef["tagName"]["toLowerCase"]() === 'style'
        ) {
            oParentRef["removeChild"](oPreviousRef);
        }

        // Use outerHTML for IE and DOM operations for Firefox
        if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
            // eslint-disable-next-line no-unsanitized/property
            oRootRef["outerHTML"] = sHTML;
        } else {
            oRef = UCF_DomUtil["oHtmlToElement"](sHTML);
            if (UCF_JsUtil["bIsArray"](oRef)) {
                oParentRef["replaceChild"](oRef[0], oRootRef);
                if (oRef["length"] > 1) {
                    UCF_JsUtil["forEach"](oRef["slice"](1), function (oRef) {
                        oParentRef["appendChild"](oRef);
                    });
                }
            } else {
                oParentRef["replaceChild"](oRef, oRootRef);
            }
        }
        this["purgeControls"]();
        this["processInitializeIDs"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["updateControl"] = 0;
    }
    ;

    /**
     * Updates the HTML of a given dom ref by replacing its inner HTML
     *
     * @param {HTMLElement} oDomRef the DOM reference that should be udpated
     * @param {string} sHTML the new HTML content
     */
    UCF_LS["prototype"]["updateDomRef"] = function (oDomRef, sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["updateDomRef"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oRoot = oDomRef;
        /** @type {HTMLStyleElement} */
        var oStyle = oDomRef["getElementsByTagName"]('STYLE')[0];

        if (oStyle && !this["bStylesMoved"]) {
            this["bStylesMoved"] = true;
            document["getElementsByTagName"]('HEAD')[0]["appendChild"](oStyle);
        }
        // eslint-disable-next-line no-unsanitized/property
        oRoot["innerHTML"] = sHTML;
        this["purgeControls"]();
        this["processInitializeIDs"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["updateDomRef"] = 0;
    }
    ;

    /**
     * Updates the HTML of the complete page by replacing its inner HTML
     *
     * This is e.g. used by the LightSpeed TestSuite when applying "Body Delta"
     * updates via the LightSpeedParameterServlet
     *
     * @public
     * @param {string} sHTML the new HTML content
     */
    UCF_LS["prototype"]["updatePage"] = function (sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["updatePage"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();
        /** @type {HTMLElement} */
        var oAsso;

        if (oPage) {
            oAsso = oPage["oGetAssociatedAreaRef"]();
            if (oAsso) {
                sHTML += oAsso["outerHTML"];
            }
            if (oPage["oDomRef"]) {
                oPage["oDomRef"]["style"]["opacity"] = '0.2';
                // eslint-disable-next-line no-magic-numbers
                UCF_JsUtil["delayedCall"](100, this, 'applyUpdate', [oPage, sHTML]);
            }
        } else {
            this["updateDomRef"](this["oRootRef"], sHTML);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["updatePage"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Page} oPage the page
     * @param {string} sHTML the html
     */
    UCF_LS["prototype"]["applyUpdate"] = function (oPage, sHTML) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["applyUpdate"]++;
        }
        ;
        this["updateDomRef"](oPage["oDomRef"], sHTML);
        oPage["oDomRef"]["style"]["opacity"] = '1.0';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["applyUpdate"] = 0;
    }
    ;

    /**
     * Returns the id of the element that currently has the focus
     *
     * @public
     * @return {string}
     */
    UCF_LS["prototype"]["sGetFocusedElementId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetFocusedElementId"]++;
        }
        ;
        /** @type {UCF_PopupManager} */
        var oPopupManager = this["oGetPopupManagerInternal"]();
        /** @type {string} */
        var sFocussedPopupWindowId = oPopupManager["sGetFocusedPopupId"]();
        /** @type {string} */
        var sResult = '';
        /** @type {UCF_LS} */
        var oPWLsToDelegate = null;
        /** @type {UCF_FocusInfo} */
        var oFocusInfo;

        // Find the right PopupWindow to get the FocusInfo
        if (sFocussedPopupWindowId &&
            sFocussedPopupWindowId !== oPopupManager["sGetPopupIdByWindow"](window)
        ) {
            oPWLsToDelegate = oPopupManager["oGetLSByPopupId"](sFocussedPopupWindowId);
            // skip further processing because no delegate found
            if (!oPWLsToDelegate) {
                return sResult;
            }

            // Reset delegate when delegate is already the current LS object (avoid
            // endless loop) This can happen when PopupWindow is rendered as DIV and
            // shares the same LS object.
            if (oPWLsToDelegate === this) {
                oPWLsToDelegate = null;
            }
        }

        if (oPWLsToDelegate) {
            sResult = oPWLsToDelegate["sGetFocusedElementId"]();
        } else if (this["bUseStoredFocus"]() && this["sGetStoredFocus"]()) {
            // The browser window lock could remove or invalidate the current set focus
            // (e.g. because of removeCaret). Get sGetFocusedElementId could return
            // wrong data while being locked. Therefore store focus before lock and
            // return stored focus if set in method sGetFocusedElementId.
            sResult = this["sGetStoredFocus"]();
        } else {
            oFocusInfo = new (UCF_ClassLoader["oGetClass"]("UCF_FocusInfo"))(this);

            oFocusInfo["init"](UCF_DomUtil["oGetActiveElement"]());
            sResult = oFocusInfo["sSerialize"]();
            oFocusInfo["cleanUp"]();
        }

        return sResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetFocusedElementId"] = 0;
    }
    ;

    /**
     * Focuses the window of this LS application.
     * @public
     */
    UCF_LS["prototype"]["focusWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["focusWindow"]++;
        }
        ;
        /** @type {UCF_FocusInfo} */
        var oFocusInfo;

        if (!this["bIsDestroyed"]) {
            if (this["oBrowserWindow"]["bIsLockedByType"](
                UCF_BrowserWindow["LOCKTYPES"]["PENDINGNAVIGATION"]
            )) {
                // just save the focus for further processing after unlock. do not focus
                // the window directly to prevent the new window opens in background
                this["focusElement"](this["sGetStoredFocus"]());
            } else {
                oFocusInfo = new (UCF_ClassLoader["oGetClass"]("UCF_FocusInfo"))(this);
                oFocusInfo["deserialize"](this["sGetStoredFocus"]());
                oFocusInfo["apply"]();
                oFocusInfo["cleanUp"]();
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["focusWindow"] = 0;
    }
    ;

    /**
     * Focuses the element with the given sId
     *
     * @public
     * @param {string} sId Id of the element that wil get the focus
     */
    UCF_LS["prototype"]["focusElement"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["focusElement"]++;
        }
        ;
        /** @type {UCF_PopupManager} */
        var oPopupManager;
        /** @type {string} */
        var sPopupWindowToDelegateId;
        /** @type {string} */
        var sThisPopupWindowId;
        /** @type {UCF_PopupWindow} */
        var oFocusInfo;
        /** @type {UCF_LS} */
        var oPWLsToDelegate;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "LS.js(2927): focusElement");
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Trying to apply focus with data "' + sId + '"', "LS.js(2928): focusElement");
        }
        ;

        if (!this["bIsDestroyed"] && sId !== '') {
            oPopupManager = this["oGetPopupManagerInternal"]();
            sPopupWindowToDelegateId = null;
            sThisPopupWindowId = oPopupManager["sGetPopupIdByWindow"](window);
            oFocusInfo = new (UCF_ClassLoader["oGetClass"]("UCF_FocusInfo"))(this);

            oFocusInfo["deserialize"](sId);

            // Delegate to right PopupWindow
            if (oFocusInfo["sGetPopupWindowId"]()) {
                // There is PopupWindow information
                if (oFocusInfo["sGetPopupWindowId"]() !== sThisPopupWindowId) {
                    sPopupWindowToDelegateId = oFocusInfo["sGetPopupWindowId"]();
                }
                // else -> continue process because already in the right LS
            } else {
                // There is NO PopupWindow information so delegate to top modal
                sPopupWindowToDelegateId = oPopupManager["sGetFocusedPopupId"]();
            }

            if (sPopupWindowToDelegateId &&
                sPopupWindowToDelegateId !== sThisPopupWindowId
            ) {
                oPWLsToDelegate = oPopupManager["oGetLSByPopupId"](
                    sPopupWindowToDelegateId
                );

                // Only delegate when delegate is not the current LS object (avoid
                // endless loop). This can happen when PopupWindow is rendered as DIV and
                // shares the same LS object.
                if (oPWLsToDelegate !== this) {
                    if (oPWLsToDelegate) {
                        oPWLsToDelegate["focusElement"](sId);
                    }
                    oFocusInfo["cleanUp"]();

                    return;
                }
            }

            if (this["bUseStoredFocus"]()) {
                this["setStoredFocus"](sId);
            } else {
                this["cleanUpStoredFocus"]();
            }

            if (!this["oBrowserWindow"]["bFocussed"]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'BrowserWindow is not focussed - waiting for focus', "LS.js(2977): focusElement");
                }
                ;
                this["oBrowserWindow"]["attachEvent"](
                    this["oBrowserWindow"]["E_EVENTS"]["Focus"],
                    this,
                    'onWindowFocus'
                );

                // CSN 1870291842 (2018): FLP back navigation removes focus from
                // UR iframe, LS won't perform a focusElement() because the BrowserWindow
                // is not focussed. Need to apply the focusInfo directly *and* wait for
                // the BrowserWindow being focused.
                //
                // In IE, the focus stays in the iframe, so it is not necessary to apply
                // the focusInfo directly. It is even wrong, because applying the focus
                // in a non-focused window in IE brings the OS focus to this window
                // (which may hide other windows). So: don't do it in IE.
                if (!UCF_UserAgent["bIsIE"]()) {
                    oFocusInfo["apply"](true);
                    oFocusInfo["cleanUp"]();
                }

                return;
            }

            if (this["oBrowserWindow"]["bIsLocked"]()) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'BrowserWindow is currently locked - waiting for unlock', "LS.js(3002): focusElement");
                }
                ;
                this["oBrowserWindow"]["attachEvent"](
                    this["oBrowserWindow"]["E_EVENTS"]["Unlock"],
                    this,
                    'onWindowUnlock'
                );
                oFocusInfo["cleanUp"]();

                return;
            }

            // force focussing without delay
            oFocusInfo["apply"](true);
            oFocusInfo["cleanUp"]();

            if (this["oScrollIntoViewInfo"]) {
                this["scrollIntoView"](
                    this["oScrollIntoViewInfo"]["sId"],
                    this["oScrollIntoViewInfo"]["bAlignToTop"]
                );
            }
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'Applied focus', "LS.js(3023): focusElement");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["focusElement"] = 0;
    }
    ;

    /**
     * Sets the stored focus info
     *
     * @private
     * @param {string} sStoredFocusId the stored focus
     */
    UCF_LS["prototype"]["setStoredFocus"] = function (sStoredFocusId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setStoredFocus"]++;
        }
        ;
        this["sStoredFocusId"] = sStoredFocusId;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setStoredFocus"] = 0;
    }
    ;

    /**
     * Gets the stored focus info
     *
     * @private
     * @return {string} the stored focus
     */
    UCF_LS["prototype"]["sGetStoredFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetStoredFocus"]++;
        }
        ;
        return this["sStoredFocusId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetStoredFocus"] = 0;
    }
    ;

    /**
     * Determines when the stored focus concept has to be used for writing and
     * reading.
     *
     * @private
     * @return {boolean}
     */
    UCF_LS["prototype"]["bUseStoredFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bUseStoredFocus"]++;
        }
        ;
        return !this["oBrowserWindow"]["bFocussed"] || this["oBrowserWindow"]["bIsLocked"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bUseStoredFocus"] = 0;
    }
    ;

    /**
     * Apply the stored focus info
     *
     * @private
     */
    UCF_LS["prototype"]["applyStoredFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["applyStoredFocus"]++;
        }
        ;
        if (this["sStoredFocusId"]) {
            // Delayed call is needed to find out, whether window is still focussed
            // Additionally it is needed for reliable cleanUpStoredFocus call in method
            // onControlEvent
            this["sStoredFocusApplyCall"] = UCF_JsUtil["delayedCall"](
                0,
                this,
                'focusElement', [this["sStoredFocusId"]]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["applyStoredFocus"] = 0;
    }
    ;

    /**
     * cleans the stored focus
     *
     * @private
     */
    UCF_LS["prototype"]["cleanUpStoredFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["cleanUpStoredFocus"]++;
        }
        ;
        if (this["sStoredFocusApplyCall"]) {
            UCF_JsUtil["clearDelayedCall"](this["sStoredFocusApplyCall"]);
            this["sStoredFocusApplyCall"] = null;
        }
        this["sStoredFocusId"] = '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["cleanUpStoredFocus"] = 0;
    }
    ;

    /**
     * Handles the Unlock Event of the BrowserWindow
     *
     * @private
     *
     * @param {UCF_Event} oEvent the internal event object
     */
    UCF_LS["prototype"]["onWindowUnlock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onWindowUnlock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "LS.js(3097): onWindowUnlock");
        }
        ;

        this["oBrowserWindow"]["detachEvent"](this["oBrowserWindow"]["E_EVENTS"]["Unlock"], this);
        this["applyStoredFocus"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onWindowUnlock"] = 0;
    }
    ;

    /**
     * Handles the Focus Event of the BrowserWindow
     *
     * @private
     *
     * @param {UCF_Event} oEvent the internal event object
     */
    UCF_LS["prototype"]["onWindowFocus"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["onWindowFocus"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "LS.js(3111): onWindowFocus");
        }
        ;

        this["oBrowserWindow"]["detachEvent"](this["oBrowserWindow"]["E_EVENTS"]["Focus"], this);
        this["applyStoredFocus"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["onWindowFocus"] = 0;
    }
    ;

    /**
     * Delegates the focus out of the Lightspeed instance
     */
    UCF_LS["prototype"]["focusEnd"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["focusEnd"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oEnd = UCF_DomUtil["$"]('ls-endofpage');
        /** @type {HTMLElement} */
        var oContainer = this["oGetStaticAreaRef"]();
        /** @type {Object} */
        var oScrollOffset;
        /** @type {number} */
        var iMarginTop;

        if (oContainer) {
            if (!oEnd) {
                oEnd = document["createElement"]('SPAN');
                oEnd["setAttribute"]('id', 'ls-endofpage');
                if (this["oSystem"]["bIs508"]) {
                    oEnd["setAttribute"]('title', this["sGetText"]('SAPUR_PAGE_END'));
                }
                oEnd["tabIndex"] = '0';
                oEnd = oContainer["appendChild"](oEnd);
            } else if (UCF_DomUtil["oGetNextSibling"](oEnd)) {
                // If in the meantime elements which can be tabbed are added behind the
                // END element (e.g. placeholder) move it to the end
                oEnd = oContainer["appendChild"](oEnd);
            }

            // avoid that the page scrolls
            oEnd["style"]["position"] = 'absolute';
            oScrollOffset = UCF_DomUtil["oGetScrollOffset"]();
            iMarginTop = UCF_DomUtil["sGetCurrentStyle"](document["body"], 'marginTop');

            if (iMarginTop) {
                oScrollOffset["y"] += parseInt(iMarginTop);
            }
            if (typeof oScrollOffset["y"] === 'number') {
                oEnd["style"]["top"] = oScrollOffset["y"] + 'px';
            }
            if (typeof oScrollOffset["x"] === 'number') {
                oEnd["style"]["left"] = oScrollOffset["x"] + 'px';
            }

            UCF_DomUtil["focusDomElement"](oEnd);
        }

        this["fireEvent"](this["E_EVENTS"]["FocusEnd"], {});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["focusEnd"] = 0;
    }
    ;

    /**
     * Scrolls the element with the given sId into the visible area
     *
     * @public
     *
     * @param {string} sId Id of the element that will scrolled into view
     * @param {boolean} bAlignToTop whether the top of object should be scrolled to
     * the top of the window
     */
    UCF_LS["prototype"]["scrollIntoView"] = function (sId, bAlignToTop) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["scrollIntoView"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oDomRef;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "LS.js(3179): scrollIntoView");
        }
        ;

        if (this["sGetStoredFocus"]() === '') {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'scrollIntoView called with id "' + sId + '"', "LS.js(3182): scrollIntoView");
            }
            ;

            oDomRef = document["getElementById"](sId);
            if (oDomRef) {
                oDomRef["scrollIntoView"](bAlignToTop);
            }
            this["oScrollIntoViewInfo"] = null;
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'scrollIntoView currently not possible, wait until focus is applied', "LS.js(3190): scrollIntoView");
            }
            ;
            this["oScrollIntoViewInfo"] = {"sId": sId, "bAlignToTop": bAlignToTop};
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["scrollIntoView"] = 0;
    }
    ;

    /**
     * Lock the Browser Window as the framework starts a navigation.
     *
     * @private
     */
    UCF_LS["prototype"]["lockByNavigation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["lockByNavigation"]++;
        }
        ;
        // TODO: lock the upper most popup (if a popup exists). Currently only the
        // main ls is locked and not an open Popup.
        this["oBrowserWindow"]["lock"](UCF_BrowserWindow["LOCKTYPES"]["PENDINGNAVIGATION"]);
        // TODO: show the loadingAnimation in the upper most popup (if a popup
        // exists). The LA is currently only shown in the main ls.
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["lockByNavigation"] = 0;
    }
    ;

    /**
     * Lock the Browser Window as the framework starts a navigation.
     *
     * @private
     */
    UCF_LS["prototype"]["unlockByNavigation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["unlockByNavigation"]++;
        }
        ;
        // TODO: unlock the upper most popup (if a popup exists). Currently only the
        // main ls is unlocked and not an open Popup.
        this["oBrowserWindow"]["unlock"](UCF_BrowserWindow["LOCKTYPES"]["PENDINGNAVIGATION"]);
        // TODO: cancel the loadingAnimation in the upper most popup (if a popup
        // exists). The LA is currently only canceled in the main ls.
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["unlockByNavigation"] = 0;
    }
    ;

    /**
     * @private
     * @param {boolean} bKeepLocked `true` to keep locked
     */
    UCF_LS["prototype"]["keepLocked"] = function (bKeepLocked) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["keepLocked"]++;
        }
        ;
        this["bKeepLocked"] = bKeepLocked;
        if (bKeepLocked === false && this["bUnlockRequested"]) {
            this["unlock"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["keepLocked"] = 0;
    }
    ;

    /**
     * Lock the LightSpeed Framework, do not allow any user interaction
     *
     * @public
     * @param {UCF_LS.LOCKTYPES} eLockType
     *
     */
    UCF_LS["prototype"]["lock"] = function (eLockType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["lock"]++;
        }
        ;
        /** @type {UCF_LoadingAnimation} */
        var oLoadingAnim;

        if (eLockType && eLockType & UCF_LS["E_LOCKTYPES"]["FORCE"])
            this["keepLocked"](true);

        if (this["bKeepLocked"]) {
            this["bUnlockRequested"] = false;
        }
        if (!this["bIsLocked"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Locking LightSpeed...', "LS.js(3250): lock");
            }
            ;

            // The browser window lock could remove or invalidate the current set focus
            // (e.g. because of removeCaret). Get sGetFocusedElementId could return
            // wrong data while being locked. Therfore store focus before lock and
            // return stored focus if set in method sGetFocusedElementId.
            this["setStoredFocus"](this["sGetFocusedElementId"]());

            this["oBrowserWindow"]["lock"](UCF_BrowserWindow["LOCKTYPES"]["ROUNDTRIP"]);
            this["fireEvent"](this["E_EVENTS"]["Lock"]);
            // Only show LoadingAnimation in the active window
            if (this["bIsActiveWindow"]()) {
                oLoadingAnim = this["oGetLoadingAnim"]();
                if (oLoadingAnim) {
                    oLoadingAnim["trigger"]();
                }
            }
            this["bIsLocked"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["lock"] = 0;
    }
    ;

    /**
     * Unlock LightSpeed
     *
     * @public
     * @param {UCF_LS.LOCKTYPES} eLockType
     *
     */
    UCF_LS["prototype"]["unlock"] = function (eLockType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["unlock"]++;
        }
        ;
        /** @type {UCF_LoadingAnimation} */
        var oLoadingAnim;

        if (eLockType && eLockType & UCF_LS["E_LOCKTYPES"]["FORCE"])
            this["keepLocked"](false);

        if (this["bKeepLocked"]) {
            this["bUnlockRequested"] = true;
        } else if (this["bIsLocked"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Unlocking LightSpeed...', "LS.js(3288): unlock");
            }
            ;
            this["oBrowserWindow"]["unlock"](UCF_BrowserWindow["LOCKTYPES"]["ROUNDTRIP"]);
            this["fireEvent"](this["E_EVENTS"]["Unlock"]);
            // Always cancel LoadingAnimation, as the active window may
            // be different after the roudntrip
            oLoadingAnim = this["oGetLoadingAnim"]();

            // Note: If loading animation in lockByNavigation() is activated we may
            // have to change the next if to:
            // if (oLoadingAnim &&
            //     !this.oBrowserWindow.bIsLockedByType(
            //       UCF_BrowserWindow.LOCKTYPES.PENDINGNAVIGATION
            //     )
            // ) {
            //   oLoadingAnim.cancel();
            // }
            if (oLoadingAnim) {
                oLoadingAnim["cancel"]();
            }
            this["bIsLocked"] = false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["unlock"] = 0;
    }
    ;

    /**
     * Returns whether lightspeeed is locked.
     * @public
     * @return {boolean}
     */
    UCF_LS["prototype"]["bLocked"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bLocked"]++;
        }
        ;
        return this["bIsLocked"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bLocked"] = 0;
    }
    ;

    /**
     * Get the loading animation control
     * @public
     * @return {UCF_LoadingAnimation} the loading animation
     */
    UCF_LS["prototype"]["oGetLoadingAnim"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetLoadingAnim"]++;
        }
        ;
        if (!this["oLoadingAnim"]) {
            this["oLoadingAnim"] = this["oControlFactory"]["oGetControlById"]('ur-loading');
        }

        return this["oLoadingAnim"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetLoadingAnim"] = 0;
    }
    ;

    /**
     * Checks whether LS is running in the currently active window
     * @return {boolean} true if ls is running in the currently active window
     */
    UCF_LS["prototype"]["bIsActiveWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsActiveWindow"]++;
        }
        ;
        if (!this["oPopupManager"]) {
            return true;
        }

        return this["oPopupManager"]["bIsActiveWindow"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsActiveWindow"] = 0;
    }
    ;

    /**
     * Sets the current default button for the lightspeed application
     *
     * @public
     * @param {string} sActiveDefaultButtonId the id of the default button object
     */
    UCF_LS["prototype"]["highlightDefaultButton"] = function (sActiveDefaultButtonId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["highlightDefaultButton"]++;
        }
        ;
        /** @type {UCF_Button} */
        var oDefaultButton = null;

        if (this["sActiveDefaultButtonId"]) {
            oDefaultButton = this["oControlFactory"]["oGetControlById"](
                this["sActiveDefaultButtonId"]
            );
            if (oDefaultButton) {
                oDefaultButton["setIsDefaultButton"](false);
            }
        }

        this["sActiveDefaultButtonId"] = sActiveDefaultButtonId;

        if (this["sActiveDefaultButtonId"]) {
            oDefaultButton = this["oControlFactory"]["oGetControlById"](
                this["sActiveDefaultButtonId"]
            );
            if (oDefaultButton) {
                oDefaultButton["setIsDefaultButton"](true);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["highlightDefaultButton"] = 0;
    }
    ;

    /**
     * Returns the current default button for the lightspeed application
     *
     * @public
     * @return {UCF_Button}
     */
    UCF_LS["prototype"]["oGetDefaultButton"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetDefaultButton"]++;
        }
        ;
        /** @type {UCF_Button} */
        var oDefaultButton;

        if (this["sActiveDefaultButtonId"]) {
            oDefaultButton = this["oControlFactory"]["oGetControlById"](
                this["sActiveDefaultButtonId"]
            );
            if (oDefaultButton) {
                return oDefaultButton;
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetDefaultButton"] = 0;
    }
    ;

    /**
     * Creates a blind layer
     * @param {string} sId the id of the blind layer to create
     * @return {{oDomRef: HTMLIFrameElement, bUsed: boolean}}
     */
    UCF_LS["prototype"]["oCreateBlindLayer"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oCreateBlindLayer"]++;
        }
        ;
        var oDomRef = document["createElement"]('IFRAME');

        if (UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsSafari"]()) {
            // BlindLayer not used on mobile - Safari.
            oDomRef["style"]["display"] = 'none';
        } else {
            oDomRef["frameBorder"] = '0';
            oDomRef["scrolling"] = 'no';
            oDomRef["setAttribute"]('id', sId);
            oDomRef["style"]["position"] = 'absolute';
            oDomRef["style"]["top"] = '-10000px';
            oDomRef["style"]["height"] = '1px';
            oDomRef["style"]["width"] = '1px';
            oDomRef["style"]["zIndex"] = UCF_LS["E_LAYERS"]["BLINDLAYER"];
            //	oDomRef.src = 'javascript:""';    Needed for IE? - violates CSP
            oDomRef["tabIndex"] = '-1';
            oDomRef["className"] = 'lsnoprint';
            // oDomRef.allowTransparency = "true";

            UCF_DomUtil["setOpacityStyle"](oDomRef, 1);
        }

        return {
            "oDomRef": oDomRef,
            "bUsed": true
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oCreateBlindLayer"] = 0;
    }
    ;

    /**
     * Get the blind layer object, create if it does not exist yet
     *
     * @private
     * @return {HTMLIFrameElement}
     */
    UCF_LS["prototype"]["oGetBlindLayer"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetBlindLayer"]++;
        }
        ;
        /** @type {{oDomRef: HTMLIFrameElement, bUsed: boolea}} */
        var oBlindLayer = null;
        /** @type {number} */
        var i;

        if (!this["oBlindLayers"]) {
            this["oBlindLayers"] = [];
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Blindlayer Layer Pool has ' + this["oBlindLayers"]["length"] + ' items.', "LS.js(3448): oGetBlindLayer");
        }
        ;

        for (i = 0; i < this["oBlindLayers"]["length"]; i++) {
            oBlindLayer = this["oBlindLayers"][i];
            if (oBlindLayer["bUsed"]) {
                oBlindLayer = null;
            } else {
                break;
            }
        }

        if (!oBlindLayer) {
            // No unused blind layer found -> create a new one and add it
            oBlindLayer = this["oCreateBlindLayer"](
                'ls-blindlayer-' + this["oBlindLayers"]["length"]
            );
            this["oBlindLayers"]["push"](oBlindLayer);
        }

        // Make sure blind layer ist last element in the DOM to avoid z-order
        // problems in Firefox.
        if (!oBlindLayer["oDomRef"]["parentNode"] ||
            oBlindLayer["oDomRef"]["parentNode"]["lastChild"] !== oBlindLayer["oDomRef"]) {
            if (!(UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsSafari"]())) {
                this["oGetStaticAreaRef"]()["appendChild"](oBlindLayer["oDomRef"]);
            }
            // else: BlindLayer not used on mobile-Safari. Do not connect to DOM...
        }

        oBlindLayer["bUsed"] = true;

        return oBlindLayer;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetBlindLayer"] = 0;
    }
    ;

    /**
     * Releases the blind layer, if it is not used at the moment
     *
     * @private
     * @param {{oDomRef: HTMLIFrameElement, bUsed: boolean}} oBlindLayer
     */
    UCF_LS["prototype"]["releaseBlindLayer"] = function (oBlindLayer) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["releaseBlindLayer"]++;
        }
        ;
        oBlindLayer["oDomRef"]["style"]["top"] = '-10000px';
        oBlindLayer["oDomRef"]["style"]["left"] = '1px';
        oBlindLayer["oDomRef"]["style"]["height"] = '1px';
        oBlindLayer["oDomRef"]["style"]["width"] = '1px';
        oBlindLayer["bUsed"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["releaseBlindLayer"] = 0;
    }
    ;

    /**
     * sets data and mime type for drag data
     *
     * @public
     * @param {string} sData the data
     * @param {string} sMimeType the mime type of the data
     * @param {string} sDragSessionId the drag session id
     */
    UCF_LS["prototype"]["setDragData"] = function (sData, sMimeType, sDragSessionId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setDragData"]++;
        }
        ;
        this["oBrowserWindow"]["oDragAndDropManager"]["setDragData"](
            sData,
            sMimeType,
            sDragSessionId
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setDragData"] = 0;
    }
    ;

    /**
     * starts a drag session
     * @public
     * @param {string} sDragSessionData serialized drag object
     * @return {string} id of the dragsession
     */
    UCF_LS["prototype"]["sCreateDragSession"] = function (sDragSessionData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sCreateDragSession"]++;
        }
        ;
        return this["oBrowserWindow"]["oGetDragAndDropManager"]()["sCreateDragSession"](
            sDragSessionData
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sCreateDragSession"] = 0;
    }
    ;

    /**
     * retrieves the dragsession
     * @public
     * @return {Object} the dragsession
     */
    UCF_LS["prototype"]["oGetDragSession"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetDragSession"]++;
        }
        ;
        return UCF_DomUtil["oGetTopWindow"]()["oDragSession"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetDragSession"] = 0;
    }
    ;

    /**
     * retrieves the dragsession
     * @public
     * @return {string} serialized dragsession
     */
    UCF_LS["prototype"]["sGetDragSession"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["sGetDragSession"]++;
        }
        ;
        return this["oBrowserWindow"]["oGetDragAndDropManager"]()["sGetDragSession"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["sGetDragSession"] = 0;
    }
    ;

    /**
     * destroys the dragsession
     * @public
     * @param {string} sDragSessionId the id of the drag session to destroy
     */
    UCF_LS["prototype"]["destroyDragSession"] = function (sDragSessionId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["destroyDragSession"]++;
        }
        ;
        this["oBrowserWindow"]["oGetDragAndDropManager"]()["destroyDragSession"](
            sDragSessionId
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["destroyDragSession"] = 0;
    }
    ;

    /**
     * Marks the Lightspeed instance as dirty for the work protect mode
     * @public
     * @param {boolean} [bFromEvent] defines whether the the dirty flag is marked
     * by a control event.
     */
    UCF_LS["prototype"]["markDirty"] = function (bFromEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["markDirty"]++;
        }
        ;
        if (this["bIsMainLS"]()) {
            if (!this["bDirty"]) {
                if (bFromEvent &&
                    this["sDirtyMode"] === 'CLIENTSERVER'
                ) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Application is now set dirty by an event.', "LS.js(3565): markDirty");
                    }
                    ;
                    this["setDirty"](true);
                } else if (!bFromEvent && this["sDirtyMode"] !== 'NONE') {
                    this["setDirty"](true);
                }
            }
        } else {
            this["oGetMainLS"]()["markDirty"](bFromEvent);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["markDirty"] = 0;
    }
    ;

    /**
     * Marks the Lightspeed instance as dirty for the work protect mode
     * @private
     * @param {boolean} bDirty `true` to set dirty, `false` to unset dirty
     */
    UCF_LS["prototype"]["setDirty"] = function (bDirty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setDirty"]++;
        }
        ;
        if (this["bIsMainLS"]()) {
            if (this["sDirtyMode"] !== 'NONE') {
                this["bDirty"] = bDirty;
                this["fireEvent"](this["E_EVENTS"]["DirtyFlagChanged"], {"bDirty": bDirty});
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Application is now set dirty by the server.', "LS.js(3586): setDirty");
                }
                ;
            }
        } else {
            this["oGetMainLS"]()["setDirty"](bDirty);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setDirty"] = 0;
    }
    ;

    /**
     * Returns whether the Lighspeed instance is dirty
     * @public
     * @return {boolean} true if the instance is dirty
     */
    UCF_LS["prototype"]["bIsDirty"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsDirty"]++;
        }
        ;
        return this["bIsMainLS"]() ? this["bDirty"] : this["oGetMainLS"]()["bIsDirty"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsDirty"] = 0;
    }
    ;

    /**
     * Sets whether there are pending changes that would need to be submitted
     * with the next event queue. This flag should be set if the user started to
     * enter text. If the next change event occured the flag should be reset.
     * @param {boolean} bPending the pending change flag to set.
     * @private
     */
    UCF_LS["prototype"]["setPendingChange"] = function (bPending) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setPendingChange"]++;
        }
        ;
        if (this["bIsMainLS"]()) {
            this["bPendingChange"] = bPending;
        } else {
            this["oGetMainLS"]()["setPendingChange"](bPending);
        }
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Pending Changes set to ' + bPending, "LS.js(3615): setPendingChange");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setPendingChange"] = 0;
    }
    ;

    /**
     * Returns whether there are pending changes in this lightspeed instance or the
     * main lightspeed instance.
     * @private
     * @return {boolean} Whether there are pending changes in this lightspeed
     * instance or the main lightspeed instance.
     */
    UCF_LS["prototype"]["hasPendingChange"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["hasPendingChange"]++;
        }
        ;
        return this["bIsMainLS"]()
            ? this["bPendingChange"]
            : this["oGetMainLS"]()["hasPendingChange"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["hasPendingChange"] = 0;
    }
    ;

    /**
     * Returns the window where LS runs
     * @public
     * @return {Window} the window
     */
    UCF_LS["prototype"]["oGetWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetWindow"]++;
        }
        ;
        return window;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetWindow"] = 0;
    }
    ;

    /**
     * Returns true if the Dom has changed beween two roundtrips
     * @public
     * @return {boolean} true if the dom has changed
     */
    UCF_LS["prototype"]["bHasDomChanged"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bHasDomChanged"]++;
        }
        ;
        return this["bDomChanged"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bHasDomChanged"] = 0;
    }
    ;

    /**
     * Sets whether the dom was changed
     * @public
     * @param {boolean} bChanged Sets whether the dom was changed.
     */
    UCF_LS["prototype"]["setDomChanged"] = function (bChanged) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setDomChanged"]++;
        }
        ;
        this["bDomChanged"] = bChanged;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setDomChanged"] = 0;
    }
    ;

    /**
     * Returns a RenderManager
     * @public
     * @return {UCF_RenderManager} RenderManager object
     */
    UCF_LS["prototype"]["oGetRenderManager"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetRenderManager"]++;
        }
        ;
        /** @type {boolean} */
        var bTestMode;

        if (!this["oRenderManager"]) {
            this["oRenderManager"] = new (UCF_ClassLoader["oGetClass"]("UCF_RenderManager"))(this);
            bTestMode = false;
            try {
                bTestMode = UCF_StringUtil["bContains"](
                    top["document"]["location"]["search"],
                    'clientrenderingtestmode=true'
                );
            } catch (ignored) {
            }

            if (!bTestMode) {
                bTestMode = UCF_StringUtil["bContains"](
                    document["location"]["search"],
                    'clientrenderingtestmode=true'
                );
            }
            if (bTestMode) {
                this["oRenderManager"]["setMode"](UCF_RenderManager["Mode"]["RENDERALL"]);
                UCF_ControlFactory["bTestMode"] = true;
            }
        }

        return this["oRenderManager"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetRenderManager"] = 0;
    }
    ;

    /**
     * @private
     * @return {UCF_RenderManager}
     */
    UCF_LS["prototype"]["oGetLsNamespaceRenderManager"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetLsNamespaceRenderManager"]++;
        }
        ;
        if (!this["oRenderManager"]) {
            window["sap"]["ls"]["require"]('sap.ls.core.RenderManager');
            this["oRenderManager"] = new window["sap"]["ls"]["core"]["RenderManager"](this);
        }

        return this["oRenderManager"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetLsNamespaceRenderManager"] = 0;
    }
    ;

    /**
     * When set to 'true' it enables an alternative keyboard handling for special
     * legacy frameworks like ITS. Mainly skipping is mapped to a different key
     * combination (ctrl+shift+b and ctrl+shift+f)
     *
     * @public
     * @deprecated
     * @param {boolean} bSet
     */
    UCF_LS["prototype"]["setAlternativeKeyboardHandling"] = function (bSet) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setAlternativeKeyboardHandling"]++;
        }
        ;
        this["bAlternativeKeyboardHandling"] = bSet;
        this["oBrowserWindow"]["bAlternativeKeyboardHandling"] = bSet;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setAlternativeKeyboardHandling"] = 0;
    }
    ;

    /**
     * Internal API to get the state of the alternative keyboard handling
     *
     * @private
     * @deprecated
     * @return {boolean} true if alternative keyboardhandling is activated
     */
    UCF_LS["prototype"]["bIsAlternativeKeyboardHandling"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsAlternativeKeyboardHandling"]++;
        }
        ;
        return this["bAlternativeKeyboardHandling"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsAlternativeKeyboardHandling"] = 0;
    }
    ;

    /**
     * This is a test version for embedding concept POC. API on System control has
     * been introduced as deprecated.
     * -> D030999
     *
     * @private
     * @deprecated
     * @return {boolean} true if framework runs isolated
     */
    UCF_LS["prototype"]["bIsIsolatedEmbedding"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsIsolatedEmbedding"]++;
        }
        ;
        return this["bIsolatedEmbedding"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsIsolatedEmbedding"] = 0;
    }
    ;

    /**
     * applySupportedThemes: add attributes to the body for supporting sap_themes
     * @param {HTMLBodyElement} oBody the body
     */
    UCF_LS["applySupportedThemes"] = function (oBody) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["applySupportedThemes"]++;
        }
        ;
        if (oBody) {
            oBody["setAttribute"]('supportedthemes', 'sap_corbu');
            if (UCF_UserAgent["bIsIE"]() && !UCF_UserAgent["bIsStandardsMode"]()) {
                UCF_DomUtil["addClass"](oBody, 'urBdyNoBlocker');
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["applySupportedThemes"] = 0;
    }
    ;

    /**
     * Registers a call back function for a specific input type which is called
     * when a user entry helper is requested.
     *
     * @public
     * @param {function} fCallback the callback function pointer.
     * @see UCF_LS.unregisterInputAssistant
     */
    UCF_LS["prototype"]["registerInputAssistant"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerInputAssistant"]++;
        }
        ;
        this["fInputAssistantCallBack"] = fCallback;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerInputAssistant"] = 0;
    }
    ;

    /**
     * Removes the registration of a InputAssistant.
     * @public
     * @param {function} fCallback the callback function pointer.
     * @see UCF_LS.registerInputAssistant
     */
    UCF_LS["prototype"]["unregisterInputAssistant"] = function (fCallback) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["unregisterInputAssistant"]++;
        }
        ;
        this["fInputAssistantCallBack"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["unregisterInputAssistant"] = 0;
    }
    ;

    /**
     * Returns a Model Instance
     * @public
     * @param {string} sName the name of the model
     * @return {UCF_Model}
     */
    UCF_LS["prototype"]["getModel"] = function (sName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getModel"]++;
        }
        ;
        var oPage = this["oGetPageInternal"]();

        return oPage
            ? this["oGetPageInternal"]()["getModel"](sName)
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getModel"] = 0;
    }
    ;

    /**
     * Returns the array of controls that are bound to the given path
     * @public
     * @param {string} sPath The binding path
     * @param {string} sClassName optional The class name
     * @return {Array.<UCF_Interface>}
     */
    UCF_LS["prototype"]["getBoundControls"] = function (sPath, sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getBoundControls"]++;
        }
        ;
        /** @type {UCF_Model} */
        var oModel = null;
        /** @type {string} */
        var sModelName;

        if (sPath["indexOf"]('>') > -1) {
            sModelName = sPath["substring"](0, sPath["indexOf"]('>'));
            sPath = sPath["replace"](sModelName + '>', '');
            oModel = this["getModel"](sModelName);
        } else {
            oModel = this["getModel"]();
        }

        return oModel
            ? UCF_JsUtil["map"](
                oModel["getBoundControls"](sPath, true, sClassName),
                function (oControl) {
                    return oControl["oGetInterface"]();
                }
            )
            : [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getBoundControls"] = 0;
    }
    ;

    /**
     * Creates a DataTip for a given binding path.
     *
     * @public
     * @param {string} sPath The binding path
     * @param {string} sText The text to display
     * @param {string} sType The the type, ERROR or WARNING
     */
    UCF_LS["prototype"]["createBoundDataTip"] = function (sPath, sText, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["createBoundDataTip"]++;
        }
        ;
        /** @type {Array.<UCF_Interface>} */
        var aControls = this["getBoundControls"](sPath);
        /** @type {number} */
        var i;
        /** @type {string} */
        var sId;
        /** @type {UCF_DataTip} */
        var oDataTip;

        for (i = 0; i < aControls["length"]; i++) {
            sId = aControls[i]["getId"]();
            oDataTip = this["oCreateClientControl"]('DataTip', sId + '__dtip', {});

            oDataTip["setConnectedControlId"](sId);
            oDataTip["placeAt"](this["oGetAssociatedAreaRef"]());
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["createBoundDataTip"] = 0;
    }
    ;

    /**
     * Returns the control that matches first the given binding
     * @param {string|Object} oBindingContextObject The binding context
     * @return {UCF_Control} The control that matches best the given
     * oBindingContextObject
     */
    UCF_LS["prototype"]["getControlByBindingContext"] = function (oBindingContextObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getControlByBindingContext"]++;
        }
        ;
        /** @type {Array.<UCF_Interface>} */
        var aControls;
        /** @type {Array.<UCF_Interface>} */
        var aParents;
        /** @type {UCF_Interface} */
        var oParent;
        /** @type {number} */
        var j;
        /** @type {number} */
        var i;

        if (typeof oBindingContextObject === 'string') {
            oBindingContextObject = UCF_JsUtil["oJsonParse"](oBindingContextObject);
        }

        aControls = this["getBoundControls"](
            oBindingContextObject["sBindingContext"],
            oBindingContextObject["sClassName"]
        );

        aParents = [];
        if (oBindingContextObject["__parent"]) {
            oParent = oBindingContextObject["__parent"];
            aParents = this["getBoundControls"](
                oParent["sBindingContext"],
                oParent["sClassName"]
            );
        }

        if (aControls["length"] === 1) {
            return aControls[0];
        }

        for (j = 0; j < aControls["length"]; j++) {
            for (i = 0; i < aParents["length"]; i++) {
                if (aControls[j]["oGetParent"]() === aParents[i]) {
                    return aControls[j];
                }
            }
        }

        return null;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getControlByBindingContext"] = 0;
    }
    ;

    /**
     * Updates the model
     * @public
     * @param {string} sName the name of the model
     * @param {Object} oData the data to update the model with
     * @param {boolean} bMerge merge or replace
     */
    UCF_LS["prototype"]["updateModel"] = function (sName, oData, bMerge) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["updateModel"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();

        if (oPage) {
            oPage["updateModel"](sName, oData, bMerge);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["updateModel"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object} oValidationSuccess the event payload
     */
    UCF_LS["prototype"]["fireValidationSuccess"] = function (oValidationSuccess) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireValidationSuccess"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireValidationSuccess"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object} oParseError the event payload
     */
    UCF_LS["prototype"]["fireParseError"] = function (oParseError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireParseError"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireParseError"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object} oValidationError the event payload
     */
    UCF_LS["prototype"]["fireValidationError"] = function (oValidationError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireValidationError"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireValidationError"] = 0;
    }
    ;

    /**
     * @private
     * @param {Object} oError the event payload
     */
    UCF_LS["prototype"]["fireFormatError"] = function (oError) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["fireFormatError"]++;
        }
        ;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["fireFormatError"] = 0;
    }
    ;

    /**
     * Returns the first ClientControl instance that has the sKey with sValue set
     * in their JSON custom data.
     *
     * @public
     * @param {string} sKey the key to search
     * @param {string} sValue the value for the key
     * @return {UCF_ClientElement} The client element for the custom data
     */
    UCF_LS["prototype"]["getClientControlByCustomData"] = function (sKey, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getClientControlByCustomData"]++;
        }
        ;
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement} */
        var oClientControl;

        for (n in this["oControlFactory"]["mClientControls"]) {
            oClientControl = this["oControlFactory"]["mClientControls"][n];
            if (oClientControl["getCustomDataKey"](sKey) &&
                oClientControl["getCustomDataKey"](sKey) === sValue
            ) {
                return oClientControl;
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getClientControlByCustomData"] = 0;
    }
    ;

    /**
     * Returns the all ClientControl instances that have the sKey with sValue set
     * in their JSON of CustomData property.
     *
     * @public
     * @param {string} sKey the key to search
     * @param {string} sValue the value for the key
     * @return {Array.<UCF_ClientElement>} The client elements for the custom data
     */
    UCF_LS["prototype"]["getClientControlsByCustomData"] = function (sKey, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getClientControlsByCustomData"]++;
        }
        ;
        /** @type {Array.<UCF_ClientElement>} */
        var aResult = [];
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement} */
        var oClientControl;

        for (n in this["oControlFactory"]["mClientControls"]) {
            oClientControl = this["oControlFactory"]["mClientControls"][n];
            if ((oClientControl["getCustomDataKey"](sKey) &&
                    oClientControl["getCustomDataKey"](sKey) === sValue) ||
                (oClientControl["getCustomDataKey"](sKey) &&
                    typeof sValue === 'undefined')
            ) {
                aResult["push"](oClientControl);
            }
        }

        return aResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getClientControlsByCustomData"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sClassName the class name
     * @param {boolean} bFirst `true` to break after the first found client control
     * @return {Array.<UCF_ClientElement>} The client elements with the given
     * class name
     */
    UCF_LS["prototype"]["getClientControlsByClassName"] = function (sClassName, bFirst) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getClientControlsByClassName"]++;
        }
        ;
        /** @type {Array.<UCF_ClientElement>} */
        var aControls = [];
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement} */
        var oClientControl;

        for (n in this["oControlFactory"]["mClientControls"]) {
            oClientControl = this["oControlFactory"]["mClientControls"][n];
            if (oClientControl["getMetadata"]()["name"] === sClassName) {
                aControls["push"](oClientControl);
                if (bFirst) {
                    return aControls;
                }
            }
        }

        return aControls;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getClientControlsByClassName"] = 0;
    }
    ;

    /**
     * Returns the first Control instance that has the sKey with sValue set in
     * their JSON custom data.
     *
     * @public
     * @param {string} sKey the key to search
     * @param {string} sValue the value for the key
     * @return {UCF_Interface} The public interface of the control
     */
    UCF_LS["prototype"]["oGetControlByCustomData"] = function (sKey, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetControlByCustomData"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();
        /** @type {Array.<UCF_Interface>} */
        var aControls;
        /** @type {number} */
        var i;

        if (oPage) {
            aControls = oPage["aGetContainedControls"]();
            if (typeof sValue === 'undefined') {
                sValue = null;
            }
            for (i = 0; i < aControls["length"]; i++) {
                if (sValue === null) {
                    if (aControls[i]["getCustomData"](sKey) !== null) {
                        return aControls[i]["oGetInterface"]();
                    }
                } else if (aControls[i]["getCustomData"](sKey) === sValue) {
                    return aControls[i]["oGetInterface"]();
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetControlByCustomData"] = 0;
    }
    ;

    /**
     * Returns the all Control instances that have the sKey with sValue set in
     * their JSON of CustomData property.
     *
     * @public
     * @param {string} sKey the key to search
     * @param {string} sValue the value for the key
     * @return {Array.<UCF_Interface>} An array of public interfaces of the
     * matching controls
     */
    UCF_LS["prototype"]["aGetControlsByCustomData"] = function (sKey, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["aGetControlsByCustomData"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage = this["oGetPageInternal"]();
        /** @type {Array.<UCF_Interface>} */
        var aControls;
        /** @type {Array.<UCF_Interface>} */
        var aResult;
        /** @type {number} */
        var i;

        if (oPage) {
            aControls = oPage["aGetContainedControls"]();
            aResult = [];
            if (typeof sValue === 'undefined') {
                sValue = null;
            }
            for (i = 0; i < aControls["length"]; i++) {
                if (sValue === null) {
                    if (aControls[i]["getCustomData"](sKey) !== null) {
                        aResult["push"](aControls[i]["oGetInterface"]());
                    }
                } else if (aControls[i]["getCustomData"](sKey) === sValue) {
                    aResult["push"](aControls[i]["oGetInterface"]());
                }
            }

            return aResult;
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["aGetControlsByCustomData"] = 0;
    }
    ;

    /**
     * Registers a new type that can be used in data binding. Registering a new
     * type imply that all bindings need to be recreated which might have
     * performance impact.
     *
     * @private
     * @param {string} sTypeName the name of the type
     * @param {string} sBaseClass the name of the base class where the new type
     * should derive from id no implementation but only a new configuration is
     * given
     * @param {Object} oDefaultConfiguratation object with the default
     * configuration for the new type if derived from a base class.
     * @param {string} sImplementationUrl url to the js file that implements the
     * type.
     */
    UCF_LS["prototype"]["registerDataType"] = function (sTypeName, sBaseClass, oDefaultConfiguratation, sImplementationUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerDataType"]++;
        }
        ;
        /** @type {UCF_JSONModel} */
        var oClass = UCF_ClassLoader["oGetClass"]('UCF_JSONModel');

        if (oClass && oClass["registerDataType"]) {
            oClass["registerDataType"](
                sTypeName,
                sBaseClass,
                oDefaultConfiguratation,
                sImplementationUrl
            );
            if (oClass["getDataType"](sTypeName)) {
                // we need to recreate the bindings if a type is added after
                // initialization
                this["oControlFactory"]["updateControlTreeBindings"](null, true);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerDataType"] = 0;
    }
    ;

    /**
     * Registers a new map type that can be used in data binding for enumerations
     * Registering a new type imply that all bindings need to be recreated which
     * might have performance impact.
     *
     * @public
     * @param {string} sTypeName the name of the type
     * @param {Object} oJsonMap the map definition as a JSON object {1:"EMPHASIZED",2:"STANDARD"}
     */
    UCF_LS["prototype"]["registerMapDataType"] = function (sTypeName, oJsonMap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerMapDataType"]++;
        }
        ;
        if (typeof oJsonMap === 'string') {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Transform string to map not supported any more', "LS.js(4157): registerMapDataType");
            }
            ;
            oJsonMap = UCF_JsUtil["oJsonParse"](oJsonMap);
            /*
			_trace(INFO, 'Transform string to map');
				try {
					oJsonMap = new Function('return ' + oJsonMap)();
				} catch (ex) {
					_trace(WARNING, 'Failed to create map from string');
				}
		*/
        }
        this["registerDataType"](sTypeName, 'Map', oJsonMap);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerMapDataType"] = 0;
    }
    ;

    /**
     * Registers an array of new map types that can be used in data binding for enumerations
     * Registering new types imply that all bindings need to be recreated which
     * might have performance impact.
     *
     * @public
     * @param {string} sMapDataTypes JSON array of mapDataTypes to be registered
     */
    UCF_LS["prototype"]["registerMapDataTypes"] = function (sMapDataTypes) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerMapDataTypes"]++;
        }
        ;
        /** @type {boolean} */
        var bClassRegistered = false;
        /** @type {typeof UCF_JSONModel} */
        var oClass = UCF_ClassLoader["oGetClass"]('UCF_JSONModel');
        /** @type {Array<Object>} */
        var aMapDataTypes = UCF_JsUtil["oJsonParse"](sMapDataTypes);
        /** @type {number} */
        var i;
        /** @type {Object} */
        var oMapDataType;
        /** @type {string} */
        var sTypeName;
        /** @type {Object} */
        var oJsonMap;

        for (i = 0; i < aMapDataTypes["length"]; i++) {
            oMapDataType = aMapDataTypes[i];
            sTypeName = oMapDataType["sTypeName"];
            oJsonMap = oMapDataType["oJsonMap"];

            if (typeof oJsonMap === 'string') {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Transform string to map not supported any more', "LS.js(4201): registerMapDataTypes");
                }
                ;
                return;
                /*			_trace(INFO, 'Transform string to map');
						try {
							oJsonMap = new Function('return ' + oJsonMap)();
						} catch (ex) {
							_trace(WARNING, 'Failed to create map from string');
						}
						*/
            }

            if (oClass && oClass["registerDataType"]) {
                oClass["registerDataType"](
                    sTypeName,
                    'Map',
                    oJsonMap,
                    null
                );
            }

            if (oClass["getDataType"](sTypeName)) {
                bClassRegistered = true;
            }
        }
        if (bClassRegistered) {
            // we need to recreate the bindings if a type is added after
            // initialization
            this["oControlFactory"]["updateControlTreeBindings"](null, true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerMapDataTypes"] = 0;
    }
    ;

    /**
     * Registers a new map type that can be used in data binding for enumerations
     * Registering a new type imply that all bindings need to be recreated which
     * might have performance impact.
     *
     * @public
     * @param {string} sTypeName the name of the type
     * @param {Object} sImplementationUrl the URL of the js file that implements
     * the type. The type must derive from UCF_SimpleType and implement parseValue,
     * formatValue, validateValue methods. The type implementation class name must
     * match the given sTypeName
     */
    UCF_LS["prototype"]["registerCustomDataType"] = function (sTypeName, sImplementationUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerCustomDataType"]++;
        }
        ;
        this["registerDataType"](sTypeName, null, null, sImplementationUrl);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerCustomDataType"] = 0;
    }
    ;

    /**
     * Returns the new instance of the SeleniumRecorder
     * @public
     * @return {UCF_SeleniumRecorder}
     */
    UCF_LS["prototype"]["getSeleniumRecorder"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["getSeleniumRecorder"]++;
        }
        ;
        UCF_ClassLoader["oGetClass"]('UCF_SeleniumRecorder', UCF_ResourceUtil["sGetQUnitRoot"]() + '/SeleniumRecorder.js');

        return window["UCF_SeleniumRecorder"]["getInstance"](this, 'ABAP');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["getSeleniumRecorder"] = 0;
    }
    ;

    /**
     * Register a custom js instance to Lightspeed that gets notified if Lightspeed
     * is created, destroyed or the page is created
     * @public
     * @static
     * @param {Object} oInstance a class that implements the following methods
     *    - onLSInit
     *    - onLSDestroy
     *    - onLSPageInit
     */
    UCF_LS["registerCustomInstance"] = function (oInstance) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["registerCustomInstance"]++;
        }
        ;
        UCF_LS["aRegisteredClasses"]["push"](oInstance);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["registerCustomInstance"] = 0;
    }
    ;

    /**
     * Adds a tab sequence with a given id
     * @param {string} sTabSequenceId The id of the sequence
     * @param {Object} mTabSequenceMap The map of control ids with their next
     * focusable id
     * @public
     */
    UCF_LS["prototype"]["addTabSequence"] = function (sTabSequenceId, mTabSequenceMap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["addTabSequence"]++;
        }
        ;
        if (typeof sTabSequenceId === 'object') {
            mTabSequenceMap = sTabSequenceId;
            sTabSequenceId = '_global';
        }
        this["oBrowserWindow"]["addTabSequence"](sTabSequenceId, mTabSequenceMap);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["addTabSequence"] = 0;
    }
    ;

    /**
     * Removes a tab sequence with a given id
     * @public
     * @param {string} sTabSequenceId The id of the sequence
     */
    UCF_LS["prototype"]["removeTabSequence"] = function (sTabSequenceId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["removeTabSequence"]++;
        }
        ;
        if (!sTabSequenceId) {
            sTabSequenceId = '_global';
        }
        this["oBrowserWindow"]["removeTabSequence"](sTabSequenceId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["removeTabSequence"] = 0;
    }
    ;

    /**
     * Add the given dom reference to be handled as an isolated area where events
     * are not handled by Lightspeed.
     * @public
     * @param {HTMLElement|string} oDomRefOrId The dom ref or an id of an element
     */
    UCF_LS["prototype"]["addIsolatedArea"] = function (oDomRefOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["addIsolatedArea"]++;
        }
        ;
        if (oDomRefOrId) {
            this["oBrowserWindow"]["addIsolatedArea"](oDomRefOrId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["addIsolatedArea"] = 0;
    }
    ;

    /**
     * Remove the given dom reference to be handled as an isolated area.
     * @see addIsolatedArea
     * @public
     * @param {HTMLElement|string} oDomRefOrId The dom ref or an id of an element
     */
    UCF_LS["prototype"]["removeIsolatedArea"] = function (oDomRefOrId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["removeIsolatedArea"]++;
        }
        ;
        if (oDomRefOrId) {
            this["oBrowserWindow"]["removeIsolatedArea"](oDomRefOrId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["removeIsolatedArea"] = 0;
    }
    ;

    /**
     * Processes an update XML Document that is normally done via the event handler
     * @public
     * @param {string|XMLDocument} oXMLDocument The xml document to update.
     */
    UCF_LS["prototype"]["processUpdate"] = function (oXMLDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["processUpdate"]++;
        }
        ;
        if (typeof oXMLDocument === 'string') {
            oXMLDocument = UCF_JsUtil["oParseXMLDocument"](oXMLDocument);
        }

        if (this["oPageUpdater"]) {
            this["lock"]();
            this["oPageUpdater"]["processUpdateDocument"](oXMLDocument);
            this["unlock"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["processUpdate"] = 0;
    }
    ;

    /**
     * Highlights a DOM Element with the given styles
     * @param {HTMLElement} oDomRef
     * @param {Object} mStyle map of CSS attributes for the highlight
     * @param {string} sClassName a CSS class used for highlighting
     * @param {number} iOffset the boundary offset
     * @public
     */
    UCF_LS["prototype"]["highlightBoundaries"] = function (oDomRef, mStyle, sClassName, iOffset) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["highlightBoundaries"]++;
        }
        ;
        /** @type {string} */
        var n;
        /** @type {HTMLDivElement} */
        var oDiv;
        /** @type {UCF_Rectangle} */
        var oRect;
        /** @type {HTMLElement} */
        var oStyle;
        /** @type {number} */
        var iTop;
        /** @type {number} */
        var iLeft;
        /** @type {number} */
        var iWidth;
        /** @type {number} */
        var iHeight;

        if (oDomRef == null && this["oHighlightObject"] && this["oHighlightObject"]["dom"]) {
            this["oHighlightObject"]["dom"]["style"]["display"] = 'none';
        }

        if (oDomRef !== this["oHighlightObject"]["ref"] &&
            oDomRef !== this["oHighlightObject"]["dom"]
        ) {
            if (this["oHighlightObject"]["ref"] && this["oHighlightObject"]["dom"]) {
                if (this["oHighlightObject"]["style"]) {
                    for (n in this["oHighlightObject"]["style"]) {
                        this["oHighlightObject"]["dom"]["style"][n] = '';
                    }
                }
                if (this["oHighlightObject"]["className"]) {
                    UCF_DomUtil["removeClass"](
                        this["oHighlightObject"]["dom"],
                        this["oHighlightObject"]["className"]
                    );
                }
            }
            if (!this["oHighlightObject"]["dom"]) {
                oDiv = document["createElement"]('DIV');
                oDiv["setAttribute"]('id', 'ls-highlight-domref');
                oDiv["style"]["position"] = 'absolute';
                oDiv["style"]["zIndex"] = UCF_LS["E_LAYERS"]["GHOSTS"];
                document["body"]["appendChild"](oDiv);
                this["oHighlightObject"]["dom"] = oDiv;
            }
            if (oDomRef) {
                this["oHighlightObject"]["ref"] = oDomRef;

                if (!iOffset) {
                    iOffset = 0;
                }
                oRect = UCF_DomUtil["oGetViewPort"](this["oHighlightObject"]["ref"]);
                oStyle = this["oHighlightObject"]["dom"]["style"];
                iTop = Math["max"](oRect["top"] - iOffset);
                iLeft = Math["max"](oRect["left"] - iOffset);
                iWidth = Math["min"](
                    // eslint-disable-next-line no-magic-numbers
                    oRect["width"] + (2 * iOffset),
                    document["body"]["clientWidth"]
                );
                iHeight = Math["min"](
                    // eslint-disable-next-line no-magic-numbers
                    oRect["height"] + (2 * iOffset),
                    document["body"]["clientHeight"]
                );

                oStyle["top"] = iTop + 'px';
                oStyle["left"] = iLeft + 'px';
                oStyle["width"] = iWidth + 'px';
                oStyle["height"] = iHeight + 'px';

                if (!mStyle && !sClassName) {
                    mStyle = {
                        'backgroundColor': 'rgba(162,209,234,0.8)',
                        'borderRadius': '1px'
                    };
                }
                this["oHighlightObject"]["style"] = mStyle;
                if (sClassName) {
                    this["oHighlightObject"]["className"] = sClassName;
                }

                for (n in this["oHighlightObject"]["style"]) {
                    this["oHighlightObject"]["dom"]["style"][n] = this["oHighlightObject"]["style"][n];
                }
                if (this["oHighlightObject"]["className"]) {
                    UCF_DomUtil["addClass"](
                        this["oHighlightObject"]["dom"],
                        this["oHighlightObject"]["className"]
                    );
                }
                this["oHighlightObject"]["dom"]["style"]["display"] = 'block';
            } else {
                this["oHighlightObject"]["ref"] = null;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["highlightBoundaries"] = 0;
    }
    ;

    /**
     * Returns true if this LS instance is already destroyed.
     * @public
     * @return {boolean}
     */
    UCF_LS["prototype"]["bDestroyed"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bDestroyed"]++;
        }
        ;
        return this["bIsDestroyed"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bDestroyed"] = 0;
    }
    ;

    UCF_LS["aRegisteredClasses"] = [];

    /**
     * @typedef {Object} UCF_LS_EditableSystemParameters
     * @property {boolean} [IsRTL]
     * @property {string} [Accessibility]
     */
    /**
     * @typedef {Object} UCF_LS_SystemParameterChange
     * @property {string} sParameter
     * @property {Object} oValue
     */
    /**
     * @example
     * oLS.setSystemParameters({
     *     IsRTL: true, // => set
     *   Accessibility: 'ARIA', // => set
     *   Hugo: 'WILLI' // => dropped, Hugo is no UCF_LS_EditableSystemParameters
     * }) // => sets IsRTL=true and Accessibility=ARIA on the system
     * @public
     * @param {UCF_LS_EditableSystemParameters} oValues
     * @return {void}
     */
    UCF_LS["prototype"]["setSystemParameters"] = function (oValues) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["setSystemParameters"]++;
        }
        ;
        /** @type {UCF_LS} */
        var self = this;
        /** @type {Array<UCF_LS_SystemParameterChange>} */
        var aUpdates;
        /** @type {boolean} */
        var bThemeUrlChanged;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oValues === 'object', "typeof oValues === 'object'", "LS.js(4488): setSystemParameters");
        }
        ;

        aUpdates = UCF_JsUtil["reduce"](UCF_JsUtil["filter"](UCF_JsUtil["entries"](oValues), function (aEntry) {
            return 'set' + aEntry[0] in self["oSystem"];
        }), function (aAll, aEntry) {
            /** @type {string} */
            var k = aEntry[0];
            /** @type {any} */
            var v = aEntry[1];

            try {
                self["oSystem"]['set' + k](v);
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Set "' + k + '" = ' + (typeof v === 'object' ? UCF_JsUtil["sJsonStringify"](v) : typeof v === 'string' ? '"' + v + '"' : v) + ' successfully.', "LS.js(4500): setSystemParameters");
                }
                ;
                aAll["push"]({"sParameter": k, "oValue": v});
            } catch (e) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, e["message"], "LS.js(4503): setSystemParameters");
                }
                ;
            }

            return aAll;
        }, []);

        bThemeUrlChanged = UCF_JsUtil["some"](aUpdates, function (oUpdate) {
            return oUpdate["sParameter"]["indexOf"]('Theme') === 0;
        });

        if (bThemeUrlChanged) {
            UCF_ResourceUtil["applyThemeChange"](function () {
                UCF_JsUtil["forEach"](UCF_DomUtil["querySelectorAll"]('[ct="CI"]'), function (oClientInspectorRef) {
                    self["oControlFactory"]["oGetControlByDomRef"](oClientInspectorRef, true)["initialize"]();
                });
            });
        }

        if (aUpdates["length"] > 0) {
            this["fireEvent"](this["E_EVENTS"]["SystemParameterChange"], {"Changes": aUpdates});
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["setSystemParameters"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sFeatureFlag
     */
    UCF_LS["prototype"]["addFeatureFlag"] = function (sFeatureFlag) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["addFeatureFlag"]++;
        }
        ;
        /** @type {string} */
        var sFeatureFlags = this["oSystem"]["sFeatureFlags"];

        if (!UCF_StringUtil["bContains"](sFeatureFlags, sFeatureFlag)) {
            this["setSystemParameters"]({
                "FeatureFlags": [sFeatureFlags, sFeatureFlag]["join"](',')
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["addFeatureFlag"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sFeatureFlag
     */
    UCF_LS["prototype"]["removeFeatureFlag"] = function (sFeatureFlag) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["removeFeatureFlag"]++;
        }
        ;
        /** @type {string} */
        var sFeatureFlags = this["oSystem"]["sFeatureFlags"];

        if (UCF_StringUtil["bContains"](sFeatureFlags, sFeatureFlag)) {
            this["setSystemParameters"]({
                "FeatureFlags": sFeatureFlags["replace"](new RegExp('(^|,\s*)' + sFeatureFlag), '')
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["removeFeatureFlag"] = 0;
    }
    ;

    /**
     * Returns the amount of pixels the page has been scrolled. If the optional oDomRef is specified,
     * the offset is returned only if relevant for positioning of the given element:
     * The iPad-FLP-IFrame-workaround of the Page is taken into account. If that is used,
     * the scroll-position is NOT relevant for stuff that is inside another
     * position-absolute container (e.g. PopupWindow, QuickView/PopOver) - in which case the retured offset is 0,0.
     *
     * -- param {HTMLElement} [oDomRef] Optional element to check
     * @return {{x: number, y: number}} x and y
     */
    UCF_LS["prototype"]["oGetPageScrollOffset"] = function ( /*oDomRef*/) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetPageScrollOffset"]++;
        }
        ;
        var o;
        var oResult;

        if (this["oPage"] && this["oPage"]["bInsideShellIFrameOnIOS"]()) {
            o = this["oPage"]["oGetInternalBlockLayerLocation"]();
            oResult = {"x": o["scrollLeft"], "y": o["scrollTop"]};
            // if (oDomRef) {
            // 	if (!this.oPage.bHasParentPopupWindow(oDomRef) &&
            // 		!UCF_DomUtil.oGetParentByAttribute(oDomRef, 'ls-layeredcontrol')) {
            // 		return oResult;
            // 	}
            // 	else {
            // 		return { x: 0, y: 0 };
            // 	}
            // }
            // else {

            return oResult;
            //}
        } else {
            return UCF_DomUtil["oGetScrollOffset"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetPageScrollOffset"] = 0;
    }
    ;

    /**
     * @typedef {Object} UCF_LS_VisualViewport Result of oGetVisualViewport()
     * @property {number} width
     * @property {number} height
     * @property {number} offsetLeft
     * @property {number} offsetTop
     * @property {number} margin
     * @property {number} scale
     */
    /**
     * Returns the visual viewport of the window
     * @param {number} iMargin the margin around the visual viewport
     * @return {UCF_LS_VisualViewport}
     */
    UCF_LS["prototype"]["oGetVisualViewport"] = function (iMargin) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetVisualViewport"]++;
        }
        ;
        /** @type {UCF_LS_VisualViewport} */
        var oVisualViewport;
        /** @type {{x:number, y:number}} */
        var oScrollOffset = this["oGetPageScrollOffset"]();
        // /** @type {HTMLElement} */
        // var oActiveElement;

        if (UCF_UserAgent["bIsAndroid"]()) {
            oVisualViewport = UCF_JsUtil["extend"]({}, window["visualViewport"], {
                "onresize": undefined,
                "onscroll": undefined
            });
        } else {
            oVisualViewport = {
                "height": document["documentElement"]["clientHeight"] || document["body"]["clientHeight"] || window["innerHeight"],
                "pageLeft": oScrollOffset["x"],
                "pageTop": oScrollOffset["y"],
                "offsetLeft": 0,
                "offsetTop": 0,
                "scale": 1,
                "width": document["documentElement"]["clientWidth"] || document["body"]["clientWidth"] || window["innerWidth"]
            };
        }

        // if (UCF_UserAgent.bIsIOS()) {
        // 	oActiveElement = UCF_DomUtil.oGetActiveElement();
        // 	if (oActiveElement && (oActiveElement.tagName === 'INPUT' || oActiveElement.tagName === 'TEXTAREA')) {
        // 		oVisualViewport.height -= UCF_DomUtil.iGetVirtualKeyboardHeight();
        // 	}
        // }

        oVisualViewport["margin"] = iMargin || 0;
        // eslint-disable-next-line no-magic-numbers
        oVisualViewport["height"] -= (2 * oVisualViewport["margin"]);
        // eslint-disable-next-line no-magic-numbers
        oVisualViewport["width"] -= (2 * oVisualViewport["margin"]);
        oVisualViewport["pageLeft"] += oVisualViewport["margin"];
        oVisualViewport["pageTop"] += oVisualViewport["margin"];
        oVisualViewport["offsetLeft"] = 0;
        oVisualViewport["offsetTop"] = 0;

        // UCF_DebugHelper.border(oVisualViewport, 'red', UCF_JsUtil.sJsonStringify(oVisualViewport));

        return oVisualViewport;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetVisualViewport"] = 0;
    }
    ;

    /**
     * Returns the position(top, bottom, left, right), width and height of the
     * given HTMLElement in the (for the user!) visible viewport
     * @param {HTMLElement} oDomRef reference to element in DOM
     * @param {UCF_LS_VisualViewport} [oVisualViewport] viewport data
     * @return {_ObjectRect}
     */
    UCF_LS["prototype"]["oGetViewportObjectRect"] = function (oDomRef, oVisualViewport) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["oGetViewportObjectRect"]++;
        }
        ;
        var oViewportRect;

        if (!oVisualViewport) {
            oVisualViewport = this["oGetVisualViewport"]();
        }
        if (window["UCF_System"]["sDevice"] === 'standards') {
            oViewportRect = UCF_JsUtil["extend"]({}, oDomRef["getBoundingClientRect"](), {
                "x": undefined,
                "y": undefined,
                "toJSON": undefined
            });
            if (UCF_UserAgent["bIsAndroid"]()) {
                // Note: The margin is already contained in pageTop/pageLeft!
                oViewportRect["top"] -= oVisualViewport["pageTop"];
                oViewportRect["left"] -= oVisualViewport["pageLeft"];
            } else {
                oViewportRect["top"] -= oVisualViewport["margin"];
                oViewportRect["left"] -= oVisualViewport["margin"];
            }
        } else {
            oViewportRect = UCF_DomUtil["oGetObjectRect"](oDomRef);
            // oGetObjectRect() returns the rect relative to the container, so we have
            // to convert them relative to the viewport.
            // Note: The margin is already contained in pageTop/pageLeft!
            oViewportRect["top"] -= (oVisualViewport["pageTop"] - oVisualViewport["offsetTop"]);
            oViewportRect["left"] -= (oVisualViewport["pageLeft"] - oVisualViewport["offsetLeft"]);
        }

        oViewportRect["bottom"] = Math["max"](0, oVisualViewport["height"] - (oViewportRect["top"] + oViewportRect["height"]));

        oViewportRect["width"] += Math["min"](0, oViewportRect["left"]); // object is left outside the visual viewport
        oViewportRect["left"] = Math["max"](0, oViewportRect["left"]);
        oViewportRect["width"] += Math["min"](0, oVisualViewport["width"] - (oViewportRect["left"] + oViewportRect["width"]));
        oViewportRect["left"] = Math["min"](oViewportRect["left"], oVisualViewport["width"]);
        oViewportRect["right"] = Math["max"](0, oVisualViewport["width"] - (oViewportRect["left"] + oViewportRect["width"]));

        oViewportRect["left"] = Math["round"](oViewportRect["left"]);
        oViewportRect["right"] = Math["round"](oViewportRect["right"]);
        oViewportRect["top"] = Math["round"](oViewportRect["top"]);
        oViewportRect["bottom"] = Math["round"](oViewportRect["bottom"]);
        oViewportRect["width"] = Math["round"](oViewportRect["width"]);
        oViewportRect["height"] = Math["round"](oViewportRect["height"]);

        // UCF_DebugHelper.vLine(
        // 	oVisualViewport.pageTop,
        // 	oVisualViewport.pageLeft + oViewportRect.left,
        // 	oViewportRect.top,
        // 	'top',
        // 	'lightblue'
        // );

        // UCF_DebugHelper.hLine(
        // 	oVisualViewport.pageTop + oViewportRect.top,
        // 	oVisualViewport.pageLeft,
        // 	oViewportRect.left,
        // 	'left',
        // 	'lightgreen'
        // 	// ,UCF_JsUtil.sJsonStringify(oViewportRect)
        // );

        // UCF_DebugHelper.vLine(
        // 	oVisualViewport.pageTop + oViewportRect.top + oViewportRect.height,
        // 	oVisualViewport.pageLeft + oViewportRect.left + oViewportRect.width,
        // 	oViewportRect.bottom,
        // 	'bottom',
        // 	'yellow'
        // );

        // UCF_DebugHelper.hLine(
        // 	oVisualViewport.pageTop + oViewportRect.top + oViewportRect.height,
        // 	oVisualViewport.pageLeft + oViewportRect.left + oViewportRect.width,
        // 	oViewportRect.right,
        // 	'right',
        // 	'aqua'
        // );

        return oViewportRect;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["oGetViewportObjectRect"] = 0;
    }
    ;

    /**
     * Returns true if Lightspeed framework and rendered controls on the page are ready for the next interaction: E.g. Header-scripts are finished loading,
     * has received a response from the server, PopupWindow IFrames are loaded, Page-updates are finished,
     * active and pending client-side rendering is finished, LS is unlocked, animations are finished, SVG images are loaded.
     * The function also checks for all known async. operations in certain controls, e.g. Designtime, RichtextEdit, etc.
     * @return {boolean} Ready or not
     * @param {boolean} [bNoImageLoadingCheck=false] Optional flag: When set the check will not consider that all images are loaded
     * @public
     */
    UCF_LS["prototype"]["bIsReady"] = function (bNoImageLoadingCheck) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bIsReady"]++;
        }
        ;

        /**
         * @param {HTMLImageElement} oImgRef
         * @return {function(): void}
         */
        function onError(oImgRef) {
            return function f() {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'image "' + oImgRef["id"] + '" loaded with error', "LS.js(4748): bIsReady");
                }
                ;
                oImgRef["qunitHelperLoadingErrorOccurred"] = true;
                UCF_DomUtil["detachEvent"](oImgRef, 'error', f);
            };
        }

        var bDesigntimeDelayedActivities = UCF_JsUtil["bDelayedCallExists"]('updatePositions')
            || UCF_JsUtil["bDelayedCallExists"]('updatePosition')
            || UCF_JsUtil["bDelayedCallExists"]('handleInvisibilityChanged')
            || UCF_JsUtil["bDelayedCallExists"]('updateHitZones')
            || UCF_JsUtil["bDelayedCallExists"]('hideDraggedElements');
        var bDiverseDelayedCalls = UCF_JsUtil["bDelayedCallExists"]('_applyCustomStyles')
            || UCF_JsUtil["bDelayedCallExists"]('loadLessCallback')
            || UCF_JsUtil["bDelayedCallExists"]('notifyLayoutChange')
            || UCF_JsUtil["bDelayedCallExists"]('timedMassNotificationFilter')
            || UCF_JsUtil["bDelayedCallExists"]('moveFocusDomElement')
            || UCF_JsUtil["bDelayedCallExists"]('doAfterRendering')
            || UCF_JsUtil["bDelayedCallExists"]('onAfterResize');
        var bPopupMenuDelay = UCF_JsUtil["bDelayedCallExists"]('open2')
            || UCF_JsUtil["bDelayedCallExists"]('removeMenu');
        var bPageInitialized = !UCF_JsUtil["bDelayedCallExists"]('fireInitialized');
        var bPendingDataTip = UCF_JsUtil["bDelayedCallExists"]('open');
        var bRichTextEditIsBusy = UCF_JsUtil["bDelayedCallExists"]('handleFireScroll')
            || UCF_JsUtil["bDelayedCallExists"]('onEditorBlur')
            || UCF_JsUtil["bDelayedCallExists"]('updateButtons')
            || UCF_JsUtil["bDelayedCallExists"]('adjustSizeInternal');

        var bAllImagesLoaded;

        if (bNoImageLoadingCheck === true) {
            bAllImagesLoaded = true;
        } else {
            bAllImagesLoaded = UCF_JsUtil["every"](
                UCF_JsUtil["arrayFrom"](document["getElementsByTagName"]('IMG')),
                function (oImgRef) {
                    return oImgRef["bLoaded"]
                        || !oImgRef["src"]
                        || oImgRef["complete"]
                        || (
                            oImgRef["getAttribute"]('ct') === 'I' &&
                            this["oControlFactory"]["oGetControlByDomRef"](oImgRef, true)["bIgnoreLoad"]
                        )
                        || oImgRef["qunitHelperLoadingErrorOccurred"]
                        || (
                            UCF_UserAgent["bIsIE"]() || (UCF_DomUtil["attachEvent"](oImgRef, 'error', onError(oImgRef)) && false)
                        );
                }
            );
        }

        // Temp. hack: QUnitHelper shoud be able to access info about these internal results for debugging:
        // this._bIsReady_xxx = xxx;
        this["_bIsReady_bAllImagesLoaded"] = (bNoImageLoadingCheck === true) ? undefined : bAllImagesLoaded;

        var r = !this["oGetPageInternal"]()["loadingScripts"]() &&
            !(typeof (UCF_Animation) !== 'undefined' && UCF_Animation["bRunning"]) &&
            !UCF_RequestUtil["bWaitingForServerResponse"] &&
            !this["oGetPopupManagerInternal"]()["bIFrameIsLoading"]() &&
            !this["oGetPopupManagerInternal"]()["bHasPendingPopups"]() &&
            !this["bLocked"]() &&
            this["bCSRDone"]() &&
            !UCF_RenderManager["bPending"] &&
            !bDesigntimeDelayedActivities &&
            !bPopupMenuDelay &&
            bPageInitialized &&
            !bDiverseDelayedCalls &&
            !bPendingDataTip &&
            !bRichTextEditIsBusy &&
            bAllImagesLoaded;

        // console.log(">>>>>> r=" + r);
        // if (r === false) {
        // 	//_trace(DEBUG, "");
        // 	console.log(">>> !this.oGetPageInternal().loadingScripts()=" + !this.oGetPageInternal().loadingScripts());
        // 	console.log(">>> !(typeof (UCF_Animation) !== 'undefined' && UCF_Animation.bRunning)=" + !(typeof (UCF_Animation) !== 'undefined' && UCF_Animation.bRunning));
        // 	console.log(">>> !UCF_RequestUtil.bWaitingForServerResponse=" + !UCF_RequestUtil.bWaitingForServerResponse);
        // 	console.log(">>> !this.bLocked()=" + !this.bLocked());
        // 	console.log(">>> this.bCSRDone()=" + this.bCSRDone());
        // 	console.log(">>> !UCF_RenderManager.bPending=" + !UCF_RenderManager.bPending);
        // 	console.log(">>> !bPopupMenuDelay=" + !bPopupMenuDelay);
        // 	console.log(">>> bPageInitialized=" + bPageInitialized);
        // 	console.log(">>> !bDiverseDelayedCalls=" + !bDiverseDelayedCalls);
        // 	console.log(">>> bAllImagesLoaded=" + bAllImagesLoaded);
        // }

        return r;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bIsReady"] = 0;
    }
    ;

    /**
     * Returns true if all currently active and pending client-side rendering tasks are finished.
     * @return {boolean}
     */
    UCF_LS["prototype"]["bCSRDone"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_LS["_"]["bCSRDone"]++;
        }
        ;
        // No more pending stuff in all control trees?
        var mCCTs = this["mGetClientControlTrees"]();
        for (var n in mCCTs) {
            if (mCCTs[n]["hasPendingChanges"]()) {
                return false;
            }
        }
        // Now check for queued delayed-calls from ClientControl class
        return !(UCF_JsUtil["bDelayedCallExists"]('render') || UCF_JsUtil["bDelayedCallExists"]('replace'));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_LS["_"]["bCSRDone"] = 0;
    }
    ;

    UCF_LS.prototype["aPublicMethods"] = ["destroy", "prepareLsClassCache", "prepareClientSideRendering", "addDebugHandler", "oCreateSemanticEvent", "fireSemanticEvent", "fireControlCreate", "fireControlDestroy", "flushSemanticEventBootingBuffer", "registerUpdateDocumentCompleteCallback", "enableLifecycleEvents", "setSemanticEventHandler", "attachSemanticEvent", "detachSemanticEvent", "setUpdateCompleteHandler", "attachUpdateComplete", "detachUpdateComplete", "removeUpdateCompleteHandler", "setApplicationExitHandler", "setPendingRequestHandler", "setMainWindowId", "setMessageFocusToggleInfo", "oGetPage", "oGetPopupManager", "processInitializeIDs", "oGetInternal", "attachRenderClientControl", "detachRenderClientControl", "oCreateControl", "oGetClientControlById", "oCreateClientControl", "oGetClientControlTree", "mGetClientControlTrees", "oGetControlById", "oGetControlFromPoint", "oGetQTPControl", "registerControlType", "purgeControls", "updateControl", "updatePage", "sGetFocusedElementId", "focusWindow", "focusElement", "scrollIntoView", "lock", "unlock", "bLocked", "oGetLoadingAnim", "highlightDefaultButton", "oGetDefaultButton", "setDragData", "sCreateDragSession", "oGetDragSession", "sGetDragSession", "destroyDragSession", "markDirty", "bIsDirty", "oGetWindow", "bHasDomChanged", "setDomChanged", "oGetRenderManager", "setAlternativeKeyboardHandling", "registerInputAssistant", "unregisterInputAssistant", "getModel", "getBoundControls", "createBoundDataTip", "updateModel", "getClientControlByCustomData", "getClientControlsByCustomData", "getClientControlsByClassName", "oGetControlByCustomData", "aGetControlsByCustomData", "registerMapDataType", "registerMapDataTypes", "registerCustomDataType", "getSeleniumRecorder", "registerCustomInstance", "addTabSequence", "removeTabSequence", "addIsolatedArea", "removeIsolatedArea", "processUpdate", "highlightBoundaries", "bDestroyed", "setSystemParameters", "addFeatureFlag", "removeFeatureFlag", "bIsReady"].concat(UCF_LS.prototype.aPublicMethods || []);
    /* global _assert, _trace, DEBUG, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_KeyCodes */
/// <reference path="../../core/enums/KeyCodes.js"/>
    /* global UCF_AriaStateHelper */
/// <reference path="../../core/util/AriaStateHelper.js"/>
    /* global UCF_BrowserHistory */
/// <reference path="../../core/util/BrowserHistory.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_Promise */
/// <reference path="../../core/util/Promise.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Cache */
/// <reference path="../../core/util/Cache.js"/>
    /* global UCF_IHubPostMessage */
/// <reference path="../ihub/IHubPostMessage.js"/>
    /* global UCF_Animation */
/// <reference path="../anim/Animation.js"/>
    /* global UCF_BrowserEvent */
/// <reference path="../browser/BrowserEvent.js"/>
    /* global UCF_ScrollArea */
/// <reference path="../controls/base/ScrollArea.js"/>
    /* global UCF_Hotkeys */
/// <reference path="../controls/Hotkeys.js"/>
    /* global UCF_ModelControl */
/// <reference path="../controls/ModelControl.js"/>
    /* global UCF_PostMessageServices */
/// <reference path="../controls/PostMessageServices.js"/>
    /* global UCF_SessionMonitor */
/// <reference path="../helper/SessionMonitor.js"/>
    /* global UCF_KeyboardHelper */
/// <reference path="../core/KeyboardHelper.js"/>
    /* global UCF_JSONModel */
/// <reference path="../model/json/JSONModel.js"/>
    /* global UCF_ClientControlTree */
/// <reference path="./ClientControlTree.js"/>
    /* global UCF_Control */
/// <reference path="./Control.js"/>
    /* global UCF_CustomStyleProvider */
/// <reference path="./CustomStyleProvider.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="./ResourceUtil.js"/>
    /* global UCF_System */

/// <reference path="./System.js"/>

    /**
     * The Page control
     *
     *
     * @class
     * @param {HTMLElement} oDomRef DOM reference
     * @param {UCF_LS} oLS LS instance
     */
    function UCF_Page(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["UCF_Page"]++;
        }
        ;
        var bAccessFE, s;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === "object", "typeof oDomRef === \"object\"", "Page.js(67): UCF_Page");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef, "oDomRef", "Page.js(68): UCF_Page");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oLS, 'UCF_LS'), "UCF_JsUtil.bInstanceOf(oLS, 'UCF_LS')", "Page.js(69): UCF_Page");
        }
        ;

        UCF_Control["apply"](this, [oDomRef, oLS]);

        this["defineEvents"]([
            'FinishedScriptLoading',
            'BeforeResize',
            'ModelAvailable',
            'CustomStylesApplied',
            'WindowResize',
            'ContextMenuLongTouchEnd'
        ]);

        //check and correct platform. In case of IOS switches browser to desktop mode
        //the platform is Macintosh and should be IOS.
        if (UCF_UserAgent["bIsIOS"]() && !UCF_DomUtil["bHasClass"](document["body"], "urNoUserSelect")) {
            UCF_DomUtil["addClass"](document["body"], "urNoUserSelect");
        }

        if (UCF_UserAgent["bIsPhone"]() || UCF_UserAgent["bIsTablet"]()) {
            UCF_DomUtil["addClass"](document["body"], "lsScrollbar--touch");
        }

        // e.g. <attribute name="data-sap-ls-system-platform" value="$System.Platform" />
        if (document["documentElement"]["getAttribute"]("data-sap-ls-system-platform") !== UCF_UserAgent["sGetPlatform"]()) {
            document["documentElement"]["setAttribute"]("data-sap-ls-system-platform", UCF_UserAgent["sGetPlatform"]());
        }

        this["oBrowserHistory"] = null;

        this["aExternalWindows"] = [];
        this["setDirtyMode"](this["sDirtyMode"]);

        // Note: Do NOT reset the dirty-flag on the Main LS if a PopupWindow opens!
        if (this["bDirty"] || this["oLS"]["bIsMainLS"]()) {
            this["setDirty"](this["bDirty"]);
        }

        this["bResizeNotification"] = this["mEvents"]["Resize"] ? true : false; // eslint-disable-line ur/no-memory-leaks

        if (this["mEvents"]["Scroll"]) {
            // eslint-disable-next-line ur/no-memory-leaks
            this["oScrollArea"] = new (UCF_ClassLoader["oGetClass"]("UCF_ScrollArea"))(document["body"]);
            this["oScrollArea"]["attachEvent"](this["oScrollArea"]["E_EVENTS"]["Scroll"], this, "onAreaScroll");
            this["addDelegate"](this["oScrollArea"]);
        }
        if (this["bResizeNotification"]) {
            this["iWidth"] = document["body"]["offsetWidth"]; // eslint-disable-line ur/no-memory-leaks
            this["iHeight"] = document["body"]["offsetHeight"]; // eslint-disable-line ur/no-memory-leaks
        }

        //initialize the default button for this control
        this["setDefaultButtonId"](this["sDefaultButtonId"]);

        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["Lock"], this, "onLsLock");
        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, "onLsUnlock");

        this["bSubscribedToDragOver"] = false;
        this["bDragEnterRaised"] = false;
        this["bDragLeaveRaised"] = false;
        //attach browser dragover event to be able to raise semantic page dragenter event
        this["oLS"]["oBrowserWindow"]["attachBrowserEvent"]("dragover", document);

        this["bCancelCtrlF4KeyPress"] = false;

        this["mAnimations"] = {};
        this["mAnimationTriggers"] = {};

        //Timer objects
        this["oResizeInfo"] = {};
        this["oWindowResizeInfo"] = {};

        //DataModels
        this["mModels"] = {};
        this["sDefaultModelId"] = null; // eslint-disable-line ur/no-memory-leaks

        //Script Loading Queue
        this["aScriptQueue"] = [];

        this["bAppliedWorkaround"] = false;

        this["mConditionalRules"] = null;
        this["mConditionalControlMap"] = null;
        this["bProcessContextMenuEvent"] = true;
        this["bTextSelectionDisabled"] = false;

        //Preunload handling
        this["mSessionState"] = {};
        this["mPreunloadUrl"] = {};
        this["bPreunloadHandled"] = false;

        if (!__UCF_IE6__) {
            this["bFLPSessionHandlingRegistered"] = false;
        }

        //Toggle Message Area Focus
        this["oMessageFocusToggleInfo"] = null;

        /** @type {UCF_TouchContextMenu} */
        this["oTouchCM"] = null;
        /** @type {Object} */
        this["oContextMenuEventData"] = null;

        /** @type {UCF_Cache} */
        this["oCache"] = new (UCF_ClassLoader["oGetClass"]("UCF_Cache"))();

        this["attachLSEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], 'onPendingRequest');

        if (this["bIsPageVisualizeAccesskeysEnabled"]()) {
            /** @type {bool} */
            this["bAccessKeyIsHighlighted"] = false;
        }

        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["SystemParameterChange"], this, 'onSystemParameterChange');

        if (this["bInsideShellIFrameOnIOS"]()) {
            // Set marker-class for Page.less:
            // UR is inside FLP/NWBC IFrame(s): We use the decoupling-trick on the Page control,
            // where the TD has position:relative and overflow:auto and the main DIV of the Page has position:absolute
            // Note: The blocklayer DIV has to be a child of the TD element for the zindex layering to work -
            // see UCF_BlockLayer.doResizeBlocklayer()
            UCF_DomUtil["addClass"](document["body"], 'lsPage--ios-shell');
            // Needed for proper position calculation (UCF_Control.oGetParentScrollAreaDomRef)
            this["oDomRef"]["setAttribute"]('lsscrl', 'true');
        }

        // Support for loading unit testing frameworks and test scripts via URL parameter, e.g. QUnit
        if (window["UCF_System"]["bEnableClientSideTesting"] === true) {
            try {
                this["oTestWindow"] = window;
                bAccessFE = true;
                try {
                    window["frameElement"]; // eslint-disable-line no-unused-expressions
                } catch (e) {
                    bAccessFE = false;
                }
                if (bAccessFE && window["frameElement"] && UCF_StringUtil["bStartsWith"](window["frameElement"]["id"], "ITSFRAME")) {
                    // ITS embeds LS in an IFrame
                    this["oTestWindow"] = window["parent"];
                }
                if (this["oTestWindow"]) {
                    s = this["oTestWindow"]["document"]["location"]["search"]["replace"]("?", "&");
                    this["bQUnitTest"] = UCF_JsUtil["contains"](s, "&qunit="); // eslint-disable-line ur/no-memory-leaks
                    this["bQUnitSuite"] = UCF_JsUtil["contains"](s, "&qunit-suite="); // eslint-disable-line ur/no-memory-leaks
                    this["bQUnitTestMode"] = this["bQUnitTest"] || this["bQUnitSuite"]; // eslint-disable-line ur/no-memory-leaks
                }
            } catch (e) {
                // catch cross-domain access violation!
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "Caught error during check for unit-tests in page: " + e["message"], "Page.js(217): UCF_Page");
                }
                ;
            }
            if (this["bQUnitTestMode"]) {
                UCF_JsUtil["delayedCall"](10, this, "initTestEnvironment", ["qunit"]);
            }
        }
    };window["UCF_Page"] = UCF_Page;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Page");
        UCF_Page["_"] = {UCF_Page: 0};
    }
    ;
    ;
    UCF_Page["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Control"))();
    UCF_Page.prototype["sClassName"] = "UCF_Page";

    UCF_Page["prototype"]["EPCM_BROWSER_NAMESPACE"] = "urn:com.sapportals.portal:browser";
    UCF_Page["prototype"]["EPCM_BEFOREUSRLOGOFF_EVENT"] = "beforeusrlogoff";
    UCF_Page["prototype"]["EPCM_PREUNLOAD_EVENT"] = "preunload";
    UCF_Page["prototype"]["EPCM_USER_NAMESPACE"] = "urn:com.sapportals.portal:user";
    UCF_Page["prototype"]["EPCM_LOGOFF_EVENT"] = "logoff";
    UCF_Page["prototype"]["EPCM_HANDLER_NAME"] = "onEPCMevent";

    /**
     * Returns true if UR is embeded inside an (FLP/NWBC) IFrame on iOS/Safari
     * @return {boolean}
     */
    UCF_Page["prototype"]["bInsideShellIFrameOnIOS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bInsideShellIFrameOnIOS"]++;
        }
        ;
        if (UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsSafari"]()) {
            try {
                return (window["frameElement"] != null || window !== window["top"]);
            } catch (e) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "TOUCH: caught error accessing window.frameElement or window.top: " + e["message"], "Page.js(242): bInsideShellIFrameOnIOS");
                }
                ;
                return true;
            }
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bInsideShellIFrameOnIOS"] = 0;
    }
    ;

//UCF_Page.INTERNAL_BLOCKLAYER_LOCATION_ID = 'ls-page-td';

    /**
     * Returns the suitable parent DOM element if the IFrame-workaround on iOS/Safari in FLP is used.
     * See also UCF_Page() and UCF_BlockLayer.doResizeBlocklayer()
     * This element must also be used to determine the scroll-offset of the Page (instead o f the window): oGetScrollOffset()
     * @return {HTMLElement}
     */
    UCF_Page["prototype"]["oGetInternalBlockLayerLocation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oGetInternalBlockLayerLocation"]++;
        }
        ;
        this["oBLL"] = this["oBLL"] || document["querySelector"]('body>table>tbody>tr>td'); //UCF_DomUtil.$(UCF_Page.INTERNAL_BLOCKLAYER_LOCATION_ID);
        return this["oBLL"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oGetInternalBlockLayerLocation"] = 0;
    }
    ;

    /**
     * Initialize the page
     * @private
     */
    UCF_Page["prototype"]["initialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["initialize"]++;
        }
        ;
        var oMainLS, mMainCustomStyles, n;

        if (this["oScrollArea"]) {
            this["oScrollArea"]["setScrollPosition"](this["iScrollTop"], this["iScrollLeft"]);
        }

        if (this["iSessionTimeout"]) {
            // eslint-disable-next-line ur/no-memory-leaks
            this["oSessionMonitor"] = new (UCF_ClassLoader["oGetClass"]("UCF_SessionMonitor"))(this["oLS"], this["iSessionTimeout"], this["sSessionKeepAliveUrl"],
                this["sSessionTimeoutActionUrl"], this["sSessionTimeoutActionTarget"], this["sSessionTimeoutActionText"],
                this["sSessionTimeoutBehavior"], this["sUnloadUrl"], this["sSessionLogoutServiceName"], this["sSessionExtendServiceName"]);
        }

        this["initBrowserHistory"](true);
        this["initAnimations"]();
        this["initSapui5Scripts"]();

        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, "createClientControlTrees");

        oMainLS = this["oLS"]["oGetMainLS"]();
        if (this["oLS"] !== oMainLS) {
            mMainCustomStyles = oMainLS["oGetWindow"]()["UCF_CustomStyleProvider"]["getStyleRegistry"]();
            for (n in mMainCustomStyles) {
                this["applyCustomStyles"](n, mMainCustomStyles[n]);
            }
        }

        if (!__UCF_IE6__) {
            //register for session handling of FLP if unloadUrl is provided
            this["registerFLPSessionHandling"]();
        }

        UCF_JsUtil["delayedCall"](0, this, "fireInitialized", [this["sId"]]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["initialize"] = 0;
    }
    ;

    /**
     * Destructor
     * @private
     */
    UCF_Page["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["destroy"]++;
        }
        ;
        var n, oAnimationConfig, oIHubEventingIds, oIHubEventing;

        UCF_JsUtil["resetMassNotificationFilter"](this);

        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["Lock"], this, "onLsLock");
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, "onLsUnlock");
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["SystemParameterChange"], this, 'onSystemParameterChange');
        this["oLS"]["oBrowserWindow"]["detachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["BeforeUnload"], this, 'showDataLossPopup');

        //detach browser dragover event
        this["oLS"]["oBrowserWindow"]["detachBrowserEvent"]("dragover", document);

        if (this["oScrollArea"]) {
            UCF_ScrollArea["disconnectAndDestroyScrollArea"](this, this["oScrollArea"]);
            this["oScrollArea"] = null;
        }

        if (this["sUnloadUrl"]) {
            UCF_RequestUtil["sendUnloadRequest"](this["sUnloadUrl"], null, this["sSessionHandling"]);
        }

        if (this["oSessionMonitor"]) {
            this["oSessionMonitor"]["destroy"]();
            this["oSessionMonitor"] = null;
        }

        if (this["mAnimations"]) {
            for (n in this["mAnimations"]) {
                oAnimationConfig = this["mAnimations"][n];
                if (oAnimationConfig["animation"]) {
                    oAnimationConfig["animation"]["destroy"]();
                }
                //detach from events
                this["oLS"]["oBrowserWindow"]["detachEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["ControlEvent"], this, "triggerAnimation");
                this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["SemanticEvent"], this, "triggerAnimation");
                //delete the animation
                delete this["mAnimations"][n];
            }
        }
        UCF_CustomStyleProvider["removeAllStyles"]();

        this["cleanUpBrowserHistory"]();
        UCF_JsUtil["clearDelayedCallsOfObject"](this);

        //Preunload handling
        if (!this["bPreunloadHandled"]) {
            this["handlePreunload"]();
        }
        oIHubEventingIds = {};
        for (n in this["mPreunloadUrl"]) {
            oIHubEventingIds[this["mPreunloadUrl"][n]["serviceProviderId"]] = this["mPreunloadUrl"][n]["serviceProviderId"];
        }
        for (n in oIHubEventingIds) {
            oIHubEventing = this["oGetControlById"](oIHubEventingIds[n]);
            if (oIHubEventing) {
                oIHubEventing["unsubscribeEvent"](this["EPCM_BROWSER_NAMESPACE"], this["EPCM_BEFOREUSRLOGOFF_EVENT"]);
                oIHubEventing["unsubscribeEvent"](this["EPCM_BROWSER_NAMESPACE"], this["EPCM_PREUNLOAD_EVENT"]);
                oIHubEventing["unsubscribeEvent"](this["EPCM_USER_NAMESPACE"], this["EPCM_LOGOFF_EVENT"]);
                oIHubEventing["detachEvent"](oIHubEventing["E_EVENTS"]["InternalEvent"], this);
            }
        }
        oIHubEventingIds = null;
        this["mSessionState"] = null;
        this["mPreunloadUrl"] = null;

        this["mAnimations"] = null;
        this["mAnimationTriggers"] = null;
        this["mModels"] = null;
        this["aScriptQueue"] = null;

        UCF_JsUtil["resetMassNotificationFilter"](this["oResizeInfo"]);
        this["oResizeInfo"] = null;
        UCF_JsUtil["resetMassNotificationFilter"](this["oWindowResizeInfo"]);
        this["oWindowResizeInfo"] = null;

        this["oMessageFocusToggleInfo"] = null;
        this["mConditionalControlMap"] = null;
        this["mConditionalRules"] = null;
        this["oTestWindow"] = null;
        this["oBLL"] = null;
        this["oFocusedControl"] = null;
        this["oStaticAreaRef"] = null;
        this["oCurrentAnimation"] = null;
        this["handleScriptChangeEvent"] = null;

        this["oCache"]["destroy"]();
        this["oCache"] = null;

        this["detachLSEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], 'onPendingRequest');

        if (this["bIsPageVisualizeAccesskeysEnabled"]()) {
            this["bAccessKeyIsHighlighted"] = null;
        }

        if (this["fForwardMouseMoveEvent"]) {
            UCF_DomUtil["detachEvent"](document["body"], "mousemove", this["fForwardMouseMoveEvent"]);
            delete this["fForwardMouseMoveEvent"];
        }
        this["bIgnoreFirstMouseMove"] = true;
        this["oUploadControl"] = null;

        UCF_Control.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["destroy"] = 0;
    }
    ;

    /**
     * Sets a Url for a specific session state to be sent via xmlHttpRequest before Unload
     * @param {string} sSessionState The sessionState
     * @param {string} sUrl The Url to be triggered
     * @param {string} sServiceProviderId The Id of the oIHubEventing control attached
     * @public
     */
    UCF_Page["prototype"]["setPreunloadUrl"] = function (sSessionState, sUrl, sServiceProviderId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setPreunloadUrl"]++;
        }
        ;
        var bAlreadySubscribed = false;
        for (var n in this["mPreunloadUrl"]) {
            if (sServiceProviderId === this["mPreunloadUrl"][n]["serviceProviderId"]) {
                bAlreadySubscribed = true;
            }
        }
        if (!bAlreadySubscribed) {
            var oIHubEventing = this["oGetControlById"](sServiceProviderId);
            if (oIHubEventing) {
                oIHubEventing["subscribeEvent"](this["EPCM_BROWSER_NAMESPACE"], this["EPCM_BEFOREUSRLOGOFF_EVENT"]);
                oIHubEventing["subscribeEvent"](this["EPCM_BROWSER_NAMESPACE"], this["EPCM_PREUNLOAD_EVENT"]);
                oIHubEventing["subscribeEvent"](this["EPCM_USER_NAMESPACE"], this["EPCM_LOGOFF_EVENT"]);
                oIHubEventing["attachEvent"](oIHubEventing["E_EVENTS"]["InternalEvent"], this, this["EPCM_HANDLER_NAME"]);
            }
        }
        this["mPreunloadUrl"][sSessionState] = {
            "url": sUrl,
            "serviceProviderId": sServiceProviderId
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setPreunloadUrl"] = 0;
    }
    ;

    /**
     * Sets the current session state. The validity parameter defines the validity of the sessionState [permanent, roundtrip, ...].
     * @param {string} sSessionState The sessionState
     * @param {string} sValidity The validity of the session state to be set [permanent, roundtrip, ...]
     * @public
     */
    UCF_Page["prototype"]["setSessionState"] = function (sSessionState, sValidity) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setSessionState"]++;
        }
        ;
        this["mSessionState"] = {
            "sessionState": sSessionState,
            "validity": sValidity
        };
        if (!this["bAfterResponseEventAttached4Animation"] && !this["bAfterResponseEventAttached4SessionState"]) {
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["AfterResponse"], this, "handleAfterResponse");
        }
        this["bAfterResponseEventAttached4SessionState"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setSessionState"] = 0;
    }
    ;

    /**
     * Handle the preunload by checking session state and opening an external window triggering a xmlHttpRequest
     * @private
     */
    UCF_Page["prototype"]["handlePreunload"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["handlePreunload"]++;
        }
        ;
        if (this["mSessionState"] &&
            this["mSessionState"]["sessionState"] &&
            this["mPreunloadUrl"] &&
            this["mPreunloadUrl"][this["mSessionState"]["sessionState"]] &&
            this["mPreunloadUrl"][this["mSessionState"]["sessionState"]]["url"] &&
            this["bPreunloadHandled"] === false) {
            this["bPreunloadHandled"] = true;
            //sync session handling should not be needed if mPreunloadUrl conatins cancel (kill the session).
            UCF_RequestUtil["sendUnloadRequest"](this["mPreunloadUrl"][this["mSessionState"]["sessionState"]]["url"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["handlePreunload"] = 0;
    }
    ;

    UCF_Page["prototype"]["sendPreunloadRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["sendPreunloadRequest"]++;
        }
        ;
        this["handlePreunload"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["sendPreunloadRequest"] = 0;
    }
    ;

    /**
     * EPCMevent handler
     * @private
     * @param {Object} oEvent
     */
    UCF_Page["prototype"]["onEPCMevent"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onEPCMevent"]++;
        }
        ;
        this["handlePreunload"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onEPCMevent"] = 0;
    }
    ;

    /**
     * The lscontainerfocus handler of the page that fires the FocusChange event
     * of the page. The lsfocus event may be canceled and can not be used here.
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event
     * @private
     */
    UCF_Page["prototype"]["onlscontainerfocus"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlscontainerfocus"]++;
        }
        ;
        var oSource, oControl, sControlId, sLastFocusId, oFocusedControl, sFocusInfo;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oBrowserEvent, 'UCF_BrowserEvent'), "UCF_JsUtil.bInstanceOf(oBrowserEvent, 'UCF_BrowserEvent')", "Page.js(496): onlscontainerfocus");
        }
        ;

        UCF_Control.prototype["onlscontainerfocus"]["call"](this, oBrowserEvent);

        oSource = oBrowserEvent["oGetSource"]();
        oControl = oBrowserEvent["oGetSourceControl"]();
        sControlId = oControl["sGetId"](oSource);
        sLastFocusId = "";
        oFocusedControl = this["oFocusedControl"];

        if (oFocusedControl && oFocusedControl["bIsValid"]()) {
            sLastFocusId = oFocusedControl["sGetId"](oSource);
        } else {
            this["oFocusedControl"] = null;
        }
        if (this["oFocusedControl"] !== oControl) {
            // For ITS: Fire event also in case the LastFocusId is not available, e.g. because the last focus control is already invalid
            if (sLastFocusId !== "" || this["oLS"]["bAlternativeKeyboardHandling"]) {
                sFocusInfo = this["oLS"]["sGetFocusedElementId"]();
                this["fireFocusChange"](this["sId"], sControlId, sLastFocusId, sFocusInfo);
            }
        }

        this["updateMessageFocusToggleInfo"](oControl, this["oLS"]["sGetFocusedElementId"]());

        this["oFocusedControl"] = oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlscontainerfocus"] = 0;
    }
    ;

    /**
     * Disables processing of the ContextMenu semantic event
     * @public
     */
    UCF_Page["prototype"]["disableContextMenuEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["disableContextMenuEvent"]++;
        }
        ;
        this["bProcessContextMenuEvent"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["disableContextMenuEvent"] = 0;
    }
    ;

    /**
     * Enables processing of the ContextMenu semantic event
     * @public
     */
    UCF_Page["prototype"]["enableContextMenuEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["enableContextMenuEvent"]++;
        }
        ;
        this["bProcessContextMenuEvent"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["enableContextMenuEvent"] = 0;
    }
    ;

    /**
     * Handle lslongtap event for contextmenu on touch device
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_Page["prototype"]["onlslongtap"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlslongtap"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: onlslongtap...', "Page.js(546): onlslongtap");
        }
        ;
        if (this["bProcessContextMenuEvent"] !== false && oBrowserEvent["bIsTouchInteraction"]()) {
            this["oContextMenuEventData"] = {
                "bOpenedByLongTabEnd": false,
                "bOpenedByExtraLongTab": false
            };
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlslongtap"] = 0;
    }
    ;

    /**
     * Handle lslongtapend event for contextmenu on touch device
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_Page["prototype"]["onlslongtapend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlslongtapend"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: onlslongtapend...', "Page.js(561): onlslongtapend");
        }
        ;
        if (this["bProcessContextMenuEvent"] !== false && oBrowserEvent["bIsTouchInteraction"]()) {
            // Ignore longtapend if a text-selection exists on the opener
            // created by Safari if the long-tap last ~ 500ms
            if (UCF_DomUtil["bHasSelection"](oBrowserEvent["oGetSourceControl"]()["oRootRef"])) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'TOUCH: ignore lslongtapend because of text-selection', "Page.js(566): onlslongtapend");
                }
                ;
                oBrowserEvent["cancel"]();
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'TOUCH: onlslongtapend: Open TCM', "Page.js(569): onlslongtapend");
                }
                ;
                this["handleTouchContextMenu"](oBrowserEvent, false);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlslongtapend"] = 0;
    }
    ;

    /**
     * Handle lsextralongtap event for contextmenu on touch device
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_Page["prototype"]["onlsextralongtap"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlsextralongtap"]++;
        }
        ;
        // Only process this event if TCM was not already opened during onlslongtapend
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: onlsextralongtap', "Page.js(582): onlsextralongtap");
        }
        ;
        if (this["oContextMenuEventData"] && this["oContextMenuEventData"]["bOpenedByLongTabEnd"] === false &&
            this["bProcessContextMenuEvent"] !== false && oBrowserEvent["bIsTouchInteraction"]()) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'TOUCH: onlsextralongtap: Open TCM', "Page.js(585): onlsextralongtap");
            }
            ;
            this["handleTouchContextMenu"](oBrowserEvent, true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlsextralongtap"] = 0;
    }
    ;

    /**
     * Handle lsextralongtapend event for contextmenu on touch device
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @private
     */
    UCF_Page["prototype"]["onlsextralongtapend"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlsextralongtapend"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'TOUCH: onlsextralongtapend', "Page.js(596): onlsextralongtapend");
        }
        ;
        // Only process this event if TCM was not already opened during onlslongtapend
        //var bSourceHasSelection = UCF_DomUtil.bHasSelection(oBrowserEvent.oGetSourceControl().oRootRef);
        if (this["oContextMenuEventData"] && this["oContextMenuEventData"]["bOpenedByExtraLongTab"] &&
            this["bProcessContextMenuEvent"] !== false && oBrowserEvent["bIsTouchInteraction"]() &&
            !UCF_UserAgent["bIsAndroid"]()) {
            oBrowserEvent["cancel"]();
            UCF_JsUtil["delayedCall"](
                200,
                UCF_DomUtil,
                'removeSelectionFrom',
                [oBrowserEvent["oGetSourceControl"]()["oRootRef"]]
            );
            this["fireEvent"](this["E_EVENTS"]["ContextMenuLongTouchEnd"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlsextralongtapend"] = 0;
    }
    ;

    /**
     * Decide if the touch-contextmenu should be opened (all browsers)
     * -> fire ContextMenu event, fill this.oContextMenuEventData
     * @param {UCF_BrowserEvent} oBrowserEvent
     * @param {boolean} bExtraLongTap
     */
    UCF_Page["prototype"]["handleTouchContextMenu"] = function (oBrowserEvent, bExtraLongTap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["handleTouchContextMenu"]++;
        }
        ;
        var oSourceControl = oBrowserEvent["oGetSourceControl"]();

        if (!this["oLS"]["oBrowserWindow"]["bTouchStartOnActiveTextInput"]) {
            this["sContextMenuOpenerId"] = oSourceControl["sGetId"](oBrowserEvent["oGetSource"]()); // eslint-disable-line ur/no-memory-leaks
            // Provide position properties from browser event that may be needed later when controls
            // need to trigger the DoubleClick on sub-controls/items (e.g. AbapList/Item)
            this["oContextMenuEventData"] = {};
            var _this = this;
            UCF_JsUtil["forEach"](['ClientX', 'ClientY', 'OffsetX', 'OffsetY', 'PageX', 'PageY', 'ScreenX', 'ScreenY'], function (n) {
                _this["oContextMenuEventData"]['i' + n] = oBrowserEvent['i' + n]();
            });
            this["oContextMenuEventData"]["sSourceId"] = oBrowserEvent["oGetSource"]() ? oBrowserEvent["oGetSource"]()["id"] : undefined;
            this["oContextMenuEventData"]["bOpenedByLongTabEnd"] = !bExtraLongTap;
            this["oContextMenuEventData"]["bOpenedByExtraLongTab"] = bExtraLongTap;
            this["fireContextMenu"](
                this["sId"],
                this["sContextMenuOpenerId"],
                oBrowserEvent["iPageX"](),
                oBrowserEvent["iPageY"](),
                oBrowserEvent["bShift"](),
                oBrowserEvent["bCtrl"](),
                oBrowserEvent["bAlt"]()
            );
        }
        oBrowserEvent["cancel"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["handleTouchContextMenu"] = 0;
    }
    ;

    /**
     * The context menu handler of the page
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event
     * @private
     */
    UCF_Page["prototype"]["oncontextmenu"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oncontextmenu"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Page.js(653): oncontextmenu");
        }
        ;
        /** @type {HTMLElement} */
        //	var oAE = UCF_DomUtil.oGetActiveElement();

        if (oBrowserEvent["bIsTouchInteraction"]()
            /*		UCF_System.sInteractionType === 'TOUCH' || (
					oAE.nodeName === 'INPUT' &&
					UCF_DomUtil.iGetSelectionStart(oAE) === 0 &&
					UCF_DomUtil.iGetSelectionEnd(oAE) === oAE.value.length &&
					oBrowserEvent.bIsTouchInteraction() ) */
        ) {
            // Ignore on mobile Chrome, which emulates the contextmenu event during long-tap
            return;
        }

        var oSource, oControl, iPosX, iPosY, sControlId, bShowBrowserMenu, oRectangle, oPopupWindow;
        oSource = oBrowserEvent["oGetSource"]();
        oControl = oBrowserEvent["oGetSourceControl"]();
        iPosX = oBrowserEvent["iPageX"]();
        iPosY = oBrowserEvent["iPageY"]();
        sControlId = oControl["sGetId"](oSource);
        bShowBrowserMenu = oBrowserEvent["bCtrl"]() && oBrowserEvent["bAlt"]() && oBrowserEvent["bShift"]();

        if (oSource && oBrowserEvent["bIsKeyboardTriggered"]()) {
            oRectangle = UCF_DomUtil["oGetObjectRect"](oSource);
            iPosX = oRectangle["left"] + Math["floor"](oRectangle["width"] / 2);
            iPosY = oRectangle["top"] + Math["floor"](oRectangle["height"] / 2);
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, "menu position on Shift-F10 adjusted to X=" + iPosX + " Y=" + iPosY, "Page.js(680): oncontextmenu");
            }
            ;
        }
        if (oControl) {
            oPopupWindow = oControl["oGetParentPopupWindow"]();
            if (oPopupWindow && oPopupWindow["bIsEnhanced"]()) {
                iPosX -= oPopupWindow["iEnhancedValue"];
                iPosY -= oPopupWindow["iEnhancedValue"];
            }
        }

        if (!bShowBrowserMenu) {
            if (this["bProcessContextMenuEvent"] !== false) {
                this["sContextMenuOpenerId"] = sControlId;
                this["bContextMenuEventByKeyBoard"] = oBrowserEvent["bIsKeyboardTriggered"](); // eslint-disable-line ur/no-memory-leaks
                this["fireContextMenu"](
                    this["sId"],
                    sControlId,
                    iPosX,
                    iPosY,
                    oBrowserEvent["bShift"](),
                    oBrowserEvent["bCtrl"](),
                    oBrowserEvent["bAlt"]()
                );
            }
            // uncomment the following comment if you want to have browser menus - it cancels the context menu only if context menu was attached
            oBrowserEvent["cancel"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oncontextmenu"] = 0;
    }
    ;

    /**
     * Returns the Control ID of the control on which the last ContextMenu event was triggered.
     * @return {string|undefined}
     */
    UCF_Page["prototype"]["sGetContextMenuOpenerId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["sGetContextMenuOpenerId"]++;
        }
        ;
        return this["sContextMenuOpenerId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["sGetContextMenuOpenerId"] = 0;
    }
    ;

    /**
     * Returns whether the last ContextMenu event was triggered ny keyboard interaction.
     * @return {boolean|undefined}
     */
    UCF_Page["prototype"]["bGetContextMenuEventByKeyBoard"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bGetContextMenuEventByKeyBoard"]++;
        }
        ;
        return this["bContextMenuEventByKeyBoard"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bGetContextMenuEventByKeyBoard"] = 0;
    }
    ;

    /**
     * Returns BrowserEvent position properties for the last ContextMenu event was triggered.
     * @return {Object<string,number>|null} iPageX/Y, iClientX/Y, iOffsetX/Y, iScreenX/Y
     */
    UCF_Page["prototype"]["oGetContextMenuEventData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oGetContextMenuEventData"]++;
        }
        ;
        return this["oContextMenuEventData"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oGetContextMenuEventData"] = 0;
    }
    ;

    /**
     * Handle hotkey events
     * @param {UCF_Event} oBrowserEvent
     * @private
     */
    UCF_Page["prototype"]["onlshotkey"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onlshotkey"]++;
        }
        ;
        var bHelp = false,
            oSource = oBrowserEvent["oGetSource"](),
            oControl = oBrowserEvent["oGetSourceControl"](),
            sControlId = oControl["sGetId"](oSource),
            kc = oBrowserEvent["iKeyCode"](),
            bIsHelpKey = false,
            bIsHelpEventInIE11 = false,
            oHotkeys = null,
            oHotkey = null;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oBrowserEvent instanceof UCF_BrowserEvent, "oBrowserEvent instanceof UCF_BrowserEvent", "Page.js(749): onlshotkey");
        }
        ;

        //IE11 the help event hasn't a keycode and no modifiers even modifiers are pressed
        bIsHelpEventInIE11 = (kc === 0 || kc === undefined) && oBrowserEvent["oDomEvent"]["type"] === "help";
        bIsHelpKey = (kc === UCF_KeyCodes["F1"] || bIsHelpEventInIE11);

        if (bIsHelpKey && !oBrowserEvent["bAlt"]() && !oBrowserEvent["bShift"]() && !oBrowserEvent["bCtrl"]()) {
            bHelp = true; //F1 was pressed without modifiers but the IE11 help event doesn't include modifiers information.
        }
        if (this["sHotkeysId"] === '') {
            if (bHelp && this["mEvents"]["Help"]) {
                this["oLS"]["fireBeforeHotkey"]();
                this["fireHelp"](this["sId"], sControlId);
                oBrowserEvent["cancel"]();
            } else {
                return;
            }
        }

        oHotkeys = this["oGetControlById"](this["sHotkeysId"]);
        if (!oHotkeys) {
            return;
        }

        oHotkey = oHotkeys["oGetHotkeyFromEvent"](oBrowserEvent);
        if (oHotkey) {
            // Cancel and prevent default behaviour in browser
            if (UCF_Hotkeys["bMustCancelLSHotKey"](oBrowserEvent)) {
                oBrowserEvent["cancel"]();
            }

            if (bHelp && this["mEvents"]["Help"]) {
                this["oLS"]["fireBeforeHotkey"]();
                this["fireHelp"](this["sId"], sControlId);
            }
            if (!oHotkeys["bHandleHotkeyOnClient"](oHotkey)) {

                //IE fires for F1 with and without modifier in addition the onhelp event. Do not send hotkey twice for IE11
                if (!bIsHelpEventInIE11) {
                    this["oLS"]["fireBeforeHotkey"]();
                    this["fireHotkey"](this["sId"], oHotkey["sHotkey"], oHotkey["sProviderId"], sControlId);
                }
            }

        } else if (bHelp && this["mEvents"]["Help"]) {
            oBrowserEvent["cancel"]();
            this["oLS"]["fireBeforeHotkey"]();
            this["fireHelp"](this["sId"], sControlId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onlshotkey"] = 0;
    }
    ;

    UCF_Page["prototype"]["onkeypress"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onkeypress"]++;
        }
        ;
        if (UCF_ClassLoader["oGetClass"]("UCF_Hotkeys")["bMustCancelKeyPress"](oBrowserEvent)) {
            oBrowserEvent["cancel"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onkeypress"] = 0;
    }
    ;

    UCF_Page["prototype"]["disableTextSelection"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["disableTextSelection"]++;
        }
        ;
        if (document["body"]["className"]["indexOf"](" urNoUserSelect") > 0 || document["body"]["className"]["indexOf"]("urNoUserSelect") === 0) {
            return;
        }
        this["bTextSelectionDisabled"] = true;
        UCF_DomUtil["addClass"](document["body"], "urNoUserSelect");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["disableTextSelection"] = 0;
    }
    ;

    UCF_Page["prototype"]["enableTextSelection"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["enableTextSelection"]++;
        }
        ;
        if (this["bTextSelectionDisabled"]) {
            this["bTextSelectionDisabled"] = false;
            UCF_DomUtil["removeClass"](document["body"], "urNoUserSelect");
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["enableTextSelection"] = 0;
    }
    ;

    /**
     * Handles the onresize event of the browser.
     * In this method the further processing is filtered by a delay to reduce the mass resize event notifications.
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event object that occurred
     * @private
     */
    UCF_Page["prototype"]["onresize"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onresize"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oBrowserEvent, 'UCF_BrowserEvent'), "UCF_JsUtil.bInstanceOf(oBrowserEvent, 'UCF_BrowserEvent')", "Page.js(829): onresize");
        }
        ;

        if (this["bResizeNotification"]) {
            UCF_JsUtil["feedMassNotificationFilter"](400, this["oResizeInfo"], this, "checkResize");
        }

        UCF_JsUtil["feedMassNotificationFilter"](100, this["oWindowResizeInfo"], this, "checkResize");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onresize"] = 0;
    }
    ;

    /**
     * @private
     */
    UCF_Page["prototype"]["fireWindowResize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireWindowResize"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["WindowResize"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireWindowResize"] = 0;
    }
    ;

    /**
     * Handles the ondragover event of the browser.
     *
     * @param {UCF_BrowserEvent} oBrowserEvent the browser event object that occurred
     * @private
     */
    UCF_Page["prototype"]["ondragover"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["ondragover"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oBrowserEvent, 'UCF_BrowserEvent'), "UCF_JsUtil.bInstanceOf(oBrowserEvent, 'UCF_BrowserEvent')", "Page.js(852): ondragover");
        }
        ;

        this["bSubscribedToDragOver"] = true;
        this["raiseDragEnter"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["ondragover"] = 0;
    }
    ;

    UCF_Page["prototype"]["raiseDragEnter"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["raiseDragEnter"]++;
        }
        ;
        //fire dragenter once
        if (!this["bDragEnterRaised"]) {
            this["bDragEnterRaised"] = true;
            this["fireDragEnter"](this["sId"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["raiseDragEnter"] = 0;
    }
    ;

    UCF_Page["prototype"]["raiseDragLeave"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["raiseDragLeave"]++;
        }
        ;
        this["fireDragLeave"](this["sId"]);
        this["bDragLeaveRaised"] = true;
        this["bDragEnterRaised"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["raiseDragLeave"] = 0;
    }
    ;

    UCF_Page["prototype"]["bGetSubscribedToDragOver"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bGetSubscribedToDragOver"]++;
        }
        ;
        return this["bSubscribedToDragOver"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bGetSubscribedToDragOver"] = 0;
    }
    ;

    /**
     * Checks the page dimensions and fires a semantic Resize event OR internal WindowResize if necessary.
     * @private
     */
    UCF_Page["prototype"]["checkResize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["checkResize"]++;
        }
        ;
        var iWidth = document["body"]["offsetWidth"];
        var iHeight = document["body"]["offsetHeight"];

        if (iWidth !== this["iWidth"] || iHeight !== this["iHeight"]) {
            this["iWidth"] = iWidth;
            this["iHeight"] = iHeight;

            if (this["bResizeNotification"]) {
                // Internal notification for other controls, e.g. input controls that need to put a Change event into the queue
                // in case a framework (e.g. ITS) has registered for Resize with action=submit
                this["fireEvent"](this["E_EVENTS"]["BeforeResize"]);
                this["fireResize"](this["sId"], this["iWidth"], this["iHeight"]);
            }
            this["fireWindowResize"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["checkResize"] = 0;
    }
    ;

    /**
     * Fires the scroll event - called by the {UCF_ScrollArea}
     * @param {UCF_Event} oEvent
     * @private
     */
    UCF_Page["prototype"]["onAreaScroll"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onAreaScroll"]++;
        }
        ;
        var iScrollTop = oEvent["oGetParam"]("iScrollTop"),
            iScrollLeft = oEvent["oGetParam"]("iScrollLeft");

        //this.fireEvent(this.E_EVENTS.PageScroll);
        this["fireScroll"](this["sId"], iScrollTop, iScrollLeft);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onAreaScroll"] = 0;
    }
    ;

    /**
     * Sets the body scroll position.
     *
     * @param {number} iScrollTop The scrollTop value that will be set
     * @param {number} iScrollLeft The scrollLeft value that will be set
     * @public
     */
    UCF_Page["prototype"]["setScrollPosition"] = function (iScrollTop, iScrollLeft) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setScrollPosition"]++;
        }
        ;
        this["oScrollArea"]["setScrollPosition"](iScrollTop, iScrollLeft);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setScrollPosition"] = 0;
    }
    ;

    /**
     * Set the title of the browser window
     * @param {string} sTitle the title of the window
     * @public
     */
    UCF_Page["prototype"]["setTitle"] = function (sTitle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setTitle"]++;
        }
        ;
        var oPopupManager, sPopupId;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sTitle === "string", "typeof sTitle === \"string\"", "Page.js(930): setTitle");
        }
        ;

        //set title for main window
        if (this["oLS"]["bIsMainLS"]()) {
            document["title"] = sTitle["replace"](/ /g, "\xa0");
        } else {
            //set title for popup window
            oPopupManager = this["oLS"]["oGetPopupManager"]();
            sPopupId = oPopupManager["sGetPopupIdByWindow"](window);

            if (sPopupId) {
                oPopupManager["notifyTitleUpdate"](sPopupId, sTitle);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setTitle"] = 0;
    }
    ;

    /**
     * Applies the default margin to the page. Calling this function will lead to a rerendering of the screen
     * which could cause perfomance issues.
     * @param {boolean} bHasMargin determines whether the default margin should be applied or not.
     * @public
     * @see HasMargin parameter of the page interface
     */
    UCF_Page["prototype"]["setHasMargin"] = function (bHasMargin) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setHasMargin"]++;
        }
        ;
        if (bHasMargin) {
            UCF_DomUtil["removeClass"](document["body"], "urBdyStdNoMrg");
            UCF_DomUtil["addClass"](document["body"], "lsPage--hasmargin");
        } else {
            UCF_DomUtil["removeClass"](document["body"], "lsPage--hasmargin");
            UCF_DomUtil["addClass"](document["body"], "urBdyStdNoMrg");
        }

        // Notify framework, that layout has changed after setting/removing the margin
        this["notifyLayoutChange"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setHasMargin"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the associated area of the page
     * @private
     * @return {HTMLElement}
     */
    UCF_Page["prototype"]["oGetAssociatedAreaRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oGetAssociatedAreaRef"]++;
        }
        ;
        return UCF_DomUtil["$"](this["sId"] + "-asso");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oGetAssociatedAreaRef"] = 0;
    }
    ;

    /**
     * Returns the DOM reference of the static area of the page
     * @private
     * @return {HTMLElement}
     */
    UCF_Page["prototype"]["oGetStaticAreaRef"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oGetStaticAreaRef"]++;
        }
        ;
        var oStatic;

        if (!this["oStaticAreaRef"]) {
            this["oStaticAreaRef"] = UCF_DomUtil["$"](this["sId"] + "-static");
            if (!this["oStaticAreaRef"]) {
                oStatic = document["createElement"]("DIV");
                oStatic["setAttribute"]("id", this["sId"] + "-static");
                this["oStaticAreaRef"] = this["oDomRef"]["appendChild"](oStatic);
            }
        }
        return this["oStaticAreaRef"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oGetStaticAreaRef"] = 0;
    }
    ;

    /**
     * open a popup modal window with a iven id and url
     * @param {string} sId the id of the popup window
     * @param {string} sURL the url of the popup window
     * @public
     */
    UCF_Page["prototype"]["openModalPopup"] = function (sId, sURL) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["openModalPopup"]++;
        }
        ;
        var oOpenerWindow = window,
            oOnloadCallbackMethod = null,
            oPopupManager = this["oLS"]["oGetPopupManagerInternal"]();

        oPopupManager["createPopupWindow"](oOpenerWindow, sURL, sId, oOnloadCallbackMethod, oPopupManager["DISPLAY_MODE"]["MODAL"]);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["openModalPopup"] = 0;
    }
    ;

    /**
     * close a popup window
     * @public
     * @param {string} sId the id to close
     */
    UCF_Page["prototype"]["closePopup"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["closePopup"]++;
        }
        ;
        this["oLS"]["oGetPopupManager"]()["closePopup"](sId);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["closePopup"] = 0;
    }
    ;

    /**
     * closes all internal popup windows
     * @public
     */
    UCF_Page["prototype"]["closeAllModalPopups"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["closeAllModalPopups"]++;
        }
        ;
        this["oLS"]["oGetPopupManager"]()["closeAllPopups"]();

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["closeAllModalPopups"] = 0;
    }
    ;

    /**
     * Opens and external window with a given id and url
     * @param {string} sId the id of the window to open
     * @param {string} sURL the URL for the new window
     * @param {number} iTop the top position of the new window on the screen. Has to be > 0
     * @param {number} iLeft the left position of the new window on the screen. Has to be > 0
     * @param {number} iWidth the width of the new window on the screen. Has to be > 0
     * @param {number} iHeight the height of the new window on the screen. Has to be > 0
     * @param {boolean} bHasMenubar determines whether the window has a menubar
     * @param {boolean} bHasStatusbar determines whether the window has a statusbar
     * @param {boolean} bHasToolbar determines whether the window has a toolbar
     * @param {boolean} bHasAddressbar determines whether the window has a address bar
     * @param {boolean} bDisableOpener This is disables the opener reference on the new window
     * @public
     */
    UCF_Page["prototype"]["openExternalWindow"] = function (sId, sURL, iTop, iLeft, iWidth, iHeight, bHasMenubar, bHasStatusbar, bHasToolbar, bHasAddressbar, bDisableOpener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["openExternalWindow"]++;
        }
        ;
        var features = "scrollbars=yes,resizable=yes";

        //sizes
        features += ",top=" + iTop;
        features += ",left=" + iLeft;
        if (iWidth) {
            features += ",width=" + iWidth;
        }
        if (iHeight) {
            features += ",height=" + iHeight;
        }

        //other features
        features += ",menubar=" + (bHasMenubar ? "yes" : "no");
        features += ",status=" + (bHasStatusbar ? "yes" : "no");
        features += ",toolbar=" + (bHasToolbar ? "yes" : "no");
        features += ",location=" + (bHasAddressbar ? "yes" : "no");

        // Locking and unlocking after timeout is a workaround for new window opening behing opener because of timing issue with "restored focus".
        this["oLS"]["lockByNavigation"]();

        if (bDisableOpener === true) {
            features += ",noopener=yes";
            features += ",noreferrer=yes";
        }

        var oExternalWindow;
        try {
            if (UCF_UserAgent["bIsIE"]() && bDisableOpener === true) {
                oExternalWindow = window["open"]("about:blank", sId, features);
                oExternalWindow["opener"] = null;
                oExternalWindow["location"] = sURL;
            } else {
                oExternalWindow = window["open"](sURL, sId, features);
            }
        } catch (e) {
            // ignored
        }
        ;

        if (oExternalWindow) {
            this["aExternalWindows"][sId] = oExternalWindow;

            try {
                oExternalWindow["focus"]();
            } catch (e) {
                // ignored
            }
            ;
        }

        UCF_JsUtil["delayedCall"](1500, this["oLS"], "unlockByNavigation", []);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["openExternalWindow"] = 0;
    }
    ;

    /**
     * Opens and external window with a given id and posts the given parameters by submiting a form
     * @param {string} sId the id of the window to open
     * @param {string} sURL the URL for the new window
     * @param {string} sPostParameters the parameters to post in an URL encoded string
     * @param {number} iTop the top position of the new window on the screen. Has to be > 0
     * @param {number} iLeft the left position of the new window on the screen. Has to be > 0
     * @param {number} iWidth the width of the new window on the screen. Has to be > 0
     * @param {number} iHeight the height of the new window on the screen. Has to be > 0
     * @param {boolean} bHasMenubar determines whether the window has a menubar
     * @param {boolean} bHasStatusbar determines whether the window has a statusbar
     * @param {boolean} bHasToolbar determines whether the window has a toolbar
     * @param {boolean} bHasAddressbar determines whether the window has a address bar
     * @param {boolean} bDisableOpener This is disables the opener reference on the new window
     * @public
     */
    UCF_Page["prototype"]["openExternalWindowByPost"] = function (sId, sURL, sPostParameters, iTop, iLeft, iWidth, iHeight, bHasMenubar, bHasStatusbar, bHasToolbar, bHasAddressbar, bDisableOpener) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["openExternalWindowByPost"]++;
        }
        ;
        this["openExternalWindow"](sId, "about:blank", iTop, iLeft, iWidth, iHeight, bHasMenubar, bHasStatusbar, bHasToolbar, bHasAddressbar, bDisableOpener);
        UCF_RequestUtil["sendFormRequest"]("POST", sURL, UCF_JsUtil["mDecodeURIParameters"](sPostParameters), sId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["openExternalWindowByPost"] = 0;
    }
    ;

    /**
     * Closes an external window with a given id
     * @param {string} sId the id of the window to close
     * @public
     */
    UCF_Page["prototype"]["closeExternalWindow"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["closeExternalWindow"]++;
        }
        ;
        //debugger;
        var bExternalWindow = this["aExternalWindows"][sId];
        if (bExternalWindow) {
            try {
                //using the reference would not work
                window["open"](UCF_ResourceUtil["sGetSpacerImageUrl"](), sId, "left=10000")["close"]();
            } catch (e) {
                // ignored
            }
            ;

        }
        delete this["aExternalWindows"][sId];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["closeExternalWindow"] = 0;
    }
    ;

    /**
     * Closes this browser window
     * @public
     */
    UCF_Page["prototype"]["closeWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["closeWindow"]++;
        }
        ;
        //Hack for IE and SF to close window.
        //currently no workaround for FF
        window["open"]('', '_self');
        window["close"]();

        this["oLS"]["destroy"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["closeWindow"] = 0;
    }
    ;

    /**
     * Sets the focus on the page to a given control or (pass the sFocusInfo)
     * or recovers the focus information sFocusInfo that was passed with the FocusChange event
     * @param {string} sFocusInfo FocusInfo that was passed with the FocusChange event or the control id
     * @public
     */
    UCF_Page["prototype"]["setFocus"] = function (sFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setFocus"]++;
        }
        ;
        if (!sFocusInfo) {
            return;
        }
        this["oLS"]["focusElement"](sFocusInfo);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setFocus"] = 0;
    }
    ;

    /**
     * Sets the keepalive state for a given control
     * @param {string} sId The id of the control
     * @param {boolean} bKeepAlive The new keepalive state
     * @public
     */
    UCF_Page["prototype"]["setKeepAlive"] = function (sId, bKeepAlive) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setKeepAlive"]++;
        }
        ;
        var oControl;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === "string", "typeof sId === \"string\"", "Page.js(1172): setKeepAlive");
        }
        ;

        oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
        if (oControl && oControl["setKeepAlive"]) {
            oControl["setKeepAlive"](bKeepAlive);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setKeepAlive"] = 0;
    }
    ;

    /**
     * Adds a link/style tag to the head of the page
     *
     * @param {string} sUrl The url to a css file to be loaded
     * @param {string} sContent The content for a style to be added
     * @public
     */
    UCF_Page["prototype"]["addStyle"] = function (sUrl, sContent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["addStyle"]++;
        }
        ;
        /** @type {HTMLHeadElement} */
        var oHead;
        /** @type {HTMLLinkElement} */
        var oLink;
        /** @type {HTMLStyleElement} */
        var oStyle;

        if (sUrl || sContent) {
            oHead = document["head"] || document["getElementsByTagName"]('HEAD')[0];

            if (oHead) {
                if (sUrl && UCF_JsUtil["every"](
                    UCF_JsUtil["arrayFrom"](document["getElementsByTagName"]('LINK')),
                    function (o) {
                        return o["getAttribute"]('href') !== sUrl;
                    }
                )) {
                    oLink = document["createElement"]('LINK');
                    oLink["setAttribute"]('rel', 'stylesheet');
                    oLink["setAttribute"]('type', 'text/css');
                    oLink["setAttribute"]('href', sUrl);
                    oHead["appendChild"](oLink);
                }

                if (sContent) {
                    if (__UCF_IE6__) {
                        // the only way to add a style to the document in IE Quirks seems to
                        // to be to append it to the innerHTML of the body.
                        // eslint-disable-next-line no-unsanitized/property
                        document["body"]["innerHTML"] += '<style>' + sContent + '</style>';
                    } else {
                        oStyle = document["createElement"]('style');
                        oStyle["textContent"] = sContent;
                        UCF_DomUtil["append"](document["head"], oStyle);
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["addStyle"] = 0;
    }
    ;

    /**
     * Adds a script tag to the head of the page
     *
     * @param {string} [sUrl=''] The URL to load
     * @param {string} [sContent=''] The content script to be executed
     * @param {Object} [mCustomAttributes={}] the custom attributes to be applied to the script tag
     * @param {Object} [oObject] the object where the given sMethod should be called after the script was loaded or executed
     * @param {string} [sMethod] the name of the method to call on the given oObject after the script was loaded or executed
     * @param {any[]} [aParameters] the array of parameters to pass to the given sMethod.
     * @param {function(): boolean} [fCondition] Anonymous function that returns true or false, which can be used to check if global objects added by the script already exists. The function will be executed at the time before the actual script tag would be created and inserted in the DOM. It will be created if the function returns true.
     *
     * @public
     */
    UCF_Page["prototype"]["addScript"] = function (sUrl, sContent, mCustomAttributes, oObject, sMethod, aParameters, fCondition) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["addScript"]++;
        }
        ;
        if (!sUrl && !sContent) {
            return;
        }

        if (sUrl && sContent) {
            this["addScript"](sUrl, null, mCustomAttributes);
            sUrl = null;
        }

        this["aScriptQueue"]["push"]({
            "src": sUrl,
            "content": sContent,
            "attributes": mCustomAttributes,
            "object": oObject,
            "method": sMethod,
            "parameters": aParameters || [],
            "requested": false,
            "fCondition": fCondition
        });

        if (this["aScriptQueue"]["length"] === 1) {
            this["loadAndExecScript"]();
        } else {
            // TODO: This seems to be incorrect (?)
            this["fireEvent"](this["E_EVENTS"]["FinishedScriptLoading"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["addScript"] = 0;
    }
    ;

    /**
     * Returns whether the page is currently waiting for downloads
     * or execution of scripts added by addScript
     * @return {boolean}
     */
    UCF_Page["prototype"]["loadingScripts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["loadingScripts"]++;
        }
        ;
        return this["aScriptQueue"]["length"] > 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["loadingScripts"] = 0;
    }
    ;
    /**
     * Triggers Loading and executes scripts stored in this.aScriptQueue
     * @private
     */
    UCF_Page["prototype"]["loadAndExecScript"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["loadAndExecScript"]++;
        }
        ;
        var oHead, oScriptProperties, bFound, aScripts, i, bCreateIt, attribute, self = this;

        if (this["aScriptQueue"]["length"] === 0) {
            UCF_DomUtil["detachEvent"](window["oScript"], "load", this["handleScriptChangeEvent"]);
            UCF_DomUtil["detachEvent"](window["oScript"], "readystatechange", this["handleScriptChangeEvent"]);
            this["fireEvent"](this["E_EVENTS"]["FinishedScriptLoading"]);
            return;
        }

        oHead = document["getElementsByTagName"]("HEAD")[0];
        oScriptProperties = this["aScriptQueue"][0];

        if (oScriptProperties["requested"]) {
            return;
        }

        if (oScriptProperties["src"]) {
            //check the script url (if already exists do not load)
            bFound = false;
            aScripts = document["getElementsByTagName"]("SCRIPT");

            //check the script url
            for (i = 0; i < aScripts["length"]; i++) {
                if (aScripts[i]["getAttribute"]("src") === oScriptProperties["src"]) {
                    bFound = true;
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Script "' + oScriptProperties["src"] + '" is already added. Not adding it again.', "Page.js(1306): handleScriptChangeEvent");
                    }
                    ;
                    break;
                }
            }

            if (bFound) {
                this["handleSapui5RuntimeConfigurationIfNecessary"](oScriptProperties["attributes"]);
                this["shiftScriptQueue"]();
                if (this["aScriptQueue"]["length"] > 0) {
                    this["loadAndExecScript"]();
                } else {
                    this["fireEvent"](this["E_EVENTS"]["FinishedScriptLoading"]);
                }
                return;
            }

            // Call condition check function if present
            bCreateIt = true;
            if (oScriptProperties["fCondition"]) {
                try {
                    bCreateIt = oScriptProperties["fCondition"]();
                } catch (e) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, "Condition for script " + oScriptProperties["src"] + " has thrown error (script will be added): " + e["message"], "Page.js(1328): handleScriptChangeEvent");
                    }
                    ;
                }
            }

            if (bCreateIt === true) {
                // oScript is global!?! (see #onScriptReadyStateChange)
                window["oScript"] = document["createElement"]("SCRIPT");
                window["oScript"]["language"] = "text/javascript";
                window["oScript"]["type"] = "text/javascript";
                oScriptProperties["requested"] = true;
                if (oScriptProperties["attributes"]) {
                    for (attribute in oScriptProperties["attributes"]) {
                        window["oScript"]["setAttribute"](attribute, oScriptProperties["attributes"][attribute]);
                    }
                }
                this["handleScriptChangeEvent"] = function (oDomEvent) {
                    self["onScriptReadyStateChange"](oDomEvent);
                };
                UCF_DomUtil["attachEvent"](window["oScript"], "load", this["handleScriptChangeEvent"]);
                UCF_DomUtil["attachEvent"](window["oScript"], "readystatechange", this["handleScriptChangeEvent"]);
                oHead["appendChild"](window["oScript"]);
                window["oScript"]["src"] = oScriptProperties["src"];
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "Script not loaded because condition was not true: " + oScriptProperties["src"], "Page.js(1351): loadAndExecScript");
                }
                ;
                this["shiftScriptQueue"]();
                this["loadAndExecScript"]();
            }
        } else if (oScriptProperties["content"]) {
            UCF_JsUtil["rawEval"](oScriptProperties["content"]);
            this["shiftScriptQueue"]();
            if (this["aScriptQueue"]["length"] > 0) {
                this["loadAndExecScript"]();
            } else {
                this["fireEvent"](this["E_EVENTS"]["FinishedScriptLoading"]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["loadAndExecScript"] = 0;
    }
    ;

    /**
     * configures sapui5 at runtime if sapui5-related attributes are found in
     * oCustomAttributes
     *
     * @private
     * @param {{string: string}} oCustomAttributes a map of attribute->value mappings
     */
    UCF_Page["prototype"]["handleSapui5RuntimeConfigurationIfNecessary"] = function (oCustomAttributes) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["handleSapui5RuntimeConfigurationIfNecessary"]++;
        }
        ;
        var sapui5Configuration = this["oFilterSapui5Attributes"](oCustomAttributes);
        if (!UCF_JsUtil["bIsEmpty"](sapui5Configuration)) {
            this["runtimeConfigureSapui5IfNecessary"](sapui5Configuration);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["handleSapui5RuntimeConfigurationIfNecessary"] = 0;
    }
    ;

    /**
     * creates a subset of oAttributes which only contains attributes that start
     * with 'data-sap-ui-'.
     *
     * @private
     * @param {{string: string}} oAttributes a map of attribute->value mappings
     * @return {{'data-sap-ui-*': string}} a subset of oAttributes
     */
    UCF_Page["prototype"]["oFilterSapui5Attributes"] = function (oAttributes) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oFilterSapui5Attributes"]++;
        }
        ;
        var result = {},
            a;

        for (a in oAttributes) {
            if (UCF_StringUtil["bStartsWith"](a, 'data-sap-ui-')) {
                result[a] = oAttributes[a];
            }
        }

        return result;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oFilterSapui5Attributes"] = 0;
    }
    ;

    /**
     * configures sapui5 at runtime if runtime-configurable parameters are found in
     * oSapui5Attributes
     *
     * @private
     * @param {{'data-sap-ui-*': string}} oSapui5Attributes the parameters to configure
     */
    UCF_Page["prototype"]["runtimeConfigureSapui5IfNecessary"] = function (oSapui5Attributes) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["runtimeConfigureSapui5IfNecessary"]++;
        }
        ;
        /* global sap */
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sap, "sap", "Page.js(1410): runtimeConfigureSapui5IfNecessary");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sap["ui"], "sap.ui", "Page.js(1411): runtimeConfigureSapui5IfNecessary");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sap["ui"]["getCore"] === 'function', "typeof sap.ui.getCore === 'function'", "Page.js(1412): runtimeConfigureSapui5IfNecessary");
        }
        ;
        /* global jQuery */
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(window["jQuery"], "window.jQuery", "Page.js(1414): runtimeConfigureSapui5IfNecessary");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(window["jQuery"]["sap"], "window.jQuery.sap", "Page.js(1415): runtimeConfigureSapui5IfNecessary");
        }
        ;

        var sapui5 = sap["ui"]["getCore"](),
            aConfigurableAttributes = UCF_JsUtil["map"](['areas', 'language', 'libs', 'logLevel', 'theme', 'themeRoots'], function (s) {
                return 'data-sap-ui-' + s;
            }),
            oLoadedLibraries;

        if ('data-sap-ui-areas' in oSapui5Attributes) {
            UCF_JsUtil["forEach"](oSapui5Attributes['data-sap-ui-areas']["split"](','), function (sArea) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'creating area "' + sArea + '"', "Page.js(1423): runtimeConfigureSapui5IfNecessary");
                }
                ;
                sapui5["createUIArea"](sArea);
            });
        }

        if ('data-sap-ui-language' in oSapui5Attributes) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'setting language to "' + oSapui5Attributes['data-sap-ui-language'] + '"', "Page.js(1429): runtimeConfigureSapui5IfNecessary");
            }
            ;
            sapui5["getConfiguration"]()["setLanguage"](oSapui5Attributes['data-sap-ui-language']);
        }

        if ('data-sap-ui-libs' in oSapui5Attributes) {
            oLoadedLibraries = sapui5["getLoadedLibraries"]();
            UCF_JsUtil["forEach"](UCF_JsUtil["map"](oSapui5Attributes['data-sap-ui-libs']["split"](','), UCF_StringUtil["sTrim"]), function (sLib) {
                if (UCF_JsUtil["contains"](UCF_JsUtil["keys"](oLoadedLibraries), sLib)) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'skipping library "' + sLib + '" as it is already loaded', "Page.js(1437): runtimeConfigureSapui5IfNecessary");
                    }
                    ;
                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'loading library "' + sLib + '"', "Page.js(1439): runtimeConfigureSapui5IfNecessary");
                    }
                    ;
                    sapui5["loadLibrary"](sLib);
                }
            });
        }

        if ('data-sap-ui-logLevel' in oSapui5Attributes) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'setting logLevel to "' + oSapui5Attributes['data-sap-ui-logLevel'] + '"', "Page.js(1446): runtimeConfigureSapui5IfNecessary");
            }
            ;
            window["jQuery"]["sap"]["log"]["setLevel"](oSapui5Attributes['data-sap-ui-logLevel']);
        }

        if ('data-sap-ui-theme' in oSapui5Attributes) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'setting theme to "' + oSapui5Attributes['data-sap-ui-theme'] + '"', "Page.js(1451): runtimeConfigureSapui5IfNecessary");
            }
            ;
            sapui5["applyTheme"](oSapui5Attributes['data-sap-ui-theme']);
        }

        if ('data-sap-ui-themeRoots' in oSapui5Attributes) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'setting themeRoots to "' + oSapui5Attributes['data-sap-ui-themeRoots'] + '"', "Page.js(1456): runtimeConfigureSapui5IfNecessary");
            }
            ;
            sapui5["setThemeRoot"](oSapui5Attributes['data-sap-ui-themeRoots']);
        }

        UCF_JsUtil["each"](oSapui5Attributes, function (sAttribute, sValue) { // using each (not forEach) as it can walk objects
            if (!UCF_JsUtil["contains"](aConfigurableAttributes, sAttribute)) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, sAttribute + '="' + sValue + '" can not be configured at runtime and is ignored.', "Page.js(1462): runtimeConfigureSapui5IfNecessary");
                }
                ;
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["runtimeConfigureSapui5IfNecessary"] = 0;
    }
    ;

    /**
     * Multiple SAPUI5 scripts may be loaded using <script type="SAPUI5"/>
     * controls. As non but the first is executed, we collect them during
     * initialization and call #runtimeConfigureSapui5IfNecessary() on the
     * dataset.
     */
    UCF_Page["prototype"]["initSapui5Scripts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["initSapui5Scripts"]++;
        }
        ;
        var self = this;

        UCF_JsUtil["forEach"](Array["prototype"]["slice"]["call"](UCF_DomUtil["querySelectorAll"]('script[src]')), function (element) {
            var dataset = UCF_DomUtil["dataset"](element),
                sapui5Configuration = {},
                key;

            for (key in dataset) {
                if (dataset["hasOwnProperty"](key) && UCF_StringUtil["bStartsWith"](key, 'sapUi')) {
                    sapui5Configuration['data-' + UCF_StringUtil["sDasherize"](key)] = dataset[key];
                }
            }

            if (!UCF_JsUtil["bIsEmpty"](sapui5Configuration)) {
                self["runtimeConfigureSapui5IfNecessary"](sapui5Configuration);
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["initSapui5Scripts"] = 0;
    }
    ;

    /**
     * Shifts the queue of scripts
     * @private
     *
     */
    UCF_Page["prototype"]["shiftScriptQueue"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["shiftScriptQueue"]++;
        }
        ;
        var oFirstScript = this["aScriptQueue"]["shift"](); //remove the currently loaded script

        if (oFirstScript && oFirstScript["object"] && oFirstScript["method"]) {
            //call the callback method on the object with the given parameters
            oFirstScript["object"][oFirstScript["method"]]["apply"](oFirstScript["object"], oFirstScript["parameters"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["shiftScriptQueue"] = 0;
    }
    ;

    /**
     * Handles the onreadystatechange event of a script element that was added using addScript
     * @param {Object} oDomEvent
     * @private
     */
    UCF_Page["prototype"]["onScriptReadyStateChange"] = function (oDomEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onScriptReadyStateChange"]++;
        }
        ;
        var oSource = oDomEvent["target"] || oDomEvent["srcElement"];
        if (oSource["tagName"] === "SCRIPT" && (!window["oScript"]["readyState"] || window["oScript"]["readyState"] === "loaded" || window["oScript"]["readyState"] === "complete")) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, "Script added " + oSource["src"] + " successful", "Page.js(1515): onScriptReadyStateChange");
            }
            ;
            this["shiftScriptQueue"](); //remove the currently loaded script
            this["loadAndExecScript"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onScriptReadyStateChange"] = 0;
    }
    ;

    /**
     * Sets the drag data for the current drag operation
     * @param {string} sData The drag data
     * @param {string} sMimeType The mime type
     * @param {string} sDragSessionId The id of the drag session
     * @public
     */
    UCF_Page["prototype"]["setDragData"] = function (sData, sMimeType, sDragSessionId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setDragData"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sData === "string", "typeof sData === \"string\"", "Page.js(1529): setDragData");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sMimeType === "string", "typeof sMimeType === \"string\"", "Page.js(1530): setDragData");
        }
        ;

        this["oLS"]["setDragData"](sData, sMimeType, sDragSessionId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setDragData"] = 0;
    }
    ;

    /**
     * Download the file with the given URL
     * @param {string} sUrl The URL to download
     * @public
     */
    UCF_Page["prototype"]["downloadFile"] = function (sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["downloadFile"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sUrl === "string", "typeof sUrl === \"string\"", "Page.js(1541): downloadFile");
        }
        ;

        UCF_JsUtil["downloadFile"](sUrl);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["downloadFile"] = 0;
    }
    ;

    /**
     * Upload file(s)
     * @param {Object} oOptions
     * @return {UCF_Promise}
     * @public
     */
    UCF_Page["prototype"]["fileSelect"] = function (oOptions) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fileSelect"]++;
        }
        ;
        var that = this;
        var sFileUploadId = 'ls-fileupload';
        var oOpts;
        var bMultiple = true;
        var sAccept = '';
        if (oOptions) {
            if (typeof oOptions === "string")
                oOpts = UCF_JsUtil["oJsonParse"](oOptions);
            else
                oOpts = oOptions;
            if (oOpts && oOpts["multiple"] === false)
                bMultiple = false;
            if (oOpts && oOpts["accept"])
                sAccept = oOpts["accept"];
        }
        return new (UCF_ClassLoader["oGetClass"]("UCF_Promise"))(function (resolve) {
            if (!UCF_Page["oUploadControl"]) {
                UCF_Page["oUploadControl"] = that["oLS"]["oCreateClientControl"]({
                    "FileUpload": {
                        "Multiple": bMultiple,
                        "Id": sFileUploadId,
                        "Name": sFileUploadId,
                        "Hidden": true,
                        "Accept": sAccept
                    }
                });
                UCF_Page["oUploadControl"]["placeAt"](that["oGetAssociatedAreaRef"]());
            }
            var oDomElement = document["getElementById"](sFileUploadId);
            if (bMultiple)
                oDomElement["setAttribute"]('multiple', '');
            else
                oDomElement["removeAttribute"]('multiple');
            if (sAccept !== '')
                oDomElement["setAttribute"]('accept', sAccept);
            else
                oDomElement["removeAttribute"]('accept');
            oDomElement["value"] = "";

            /**
             * fChange the event handler needs to be named for detaching
             * @param {UCF_Event}  arg
             */
            function fChange(arg) {
                resolve(that["oLS"]["oGetControlById"](sFileUploadId)["aGetSelectedFiles"]());
                UCF_Page["oUploadControl"]["detachChange"](fChange);
            };
            UCF_Page["oUploadControl"]["attachChange"](fChange);
            that["oLS"]["oGetControlById"](sFileUploadId)["openFileSelection"]();
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fileSelect"] = 0;
    }
    ;

    /**
     * Scroll a control into view
     * @param {string} sId Id of the element that will scrolled into view
     * @param {boolean} bAlignToTop whether the top of object should be scrolled to the top of the window
     * @public
     */
    UCF_Page["prototype"]["scrollIntoView"] = function (sId, bAlignToTop) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["scrollIntoView"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === "string", "typeof sId === \"string\"", "Page.js(1611): scrollIntoView");
        }
        ;

        this["oLS"]["scrollIntoView"](sId, bAlignToTop);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["scrollIntoView"] = 0;
    }
    ;
    /**
     * Sets the dirty flag of the page
     * @param {boolean} bDirty new dirty Flag of the page
     * @public
     */
    UCF_Page["prototype"]["setDirty"] = function (bDirty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setDirty"]++;
        }
        ;
        this["oLS"]["setDirty"](bDirty);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setDirty"] = 0;
    }
    ;

    /**
     * Returns the dirty flag of the page
     * @private
     * @return {boolean}
     */
    UCF_Page["prototype"]["bIsDirty"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bIsDirty"]++;
        }
        ;
        return this["oLS"]["bDirty"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bIsDirty"] = 0;
    }
    ;

    /**
     * Prints the page or a control
     * @public
     */
    UCF_Page["prototype"]["print"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["print"]++;
        }
        ;
        window["print"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["print"] = 0;
    }
    ;

    if (!__UCF_IE6__) {
        // SessionHandling
        /** @private */
        UCF_Page["prototype"]["registerFLPSessionHandling"] = function () {
            ;
            if (__UCF_COVERAGE__) {
                UCF_Page["_"]["registerFLPSessionHandling"]++;
            }
            ;
            /** @type {UCF_Page} */
            var self = this;

            try {
                if (this["sUnloadUrl"] && (
                    this["sSessionHandling"] === "SYNC" ||
                    this["sSessionHandling"] === "SYNCNAVIGATION" ||
                    this["sSessionTimeoutBehavior"] === 'POSTMESSAGE'
                )) {
                    // the special FLP SessionHandling is used only in case of SYNC
                    // SessionHandling otherwise the normal unload event is used
                    if (!this["bFLPSessionHandlingRegistered"]) {
                        UCF_PostMessageServices["addPostMessageService"](
                            "sap.ushell.services.CrossApplicationNavigation.beforeAppCloseEvent",
                            function (sService, oEvent) {
                                return self["bHandleUnloadPostMessage"](sService, oEvent);
                            }
                        );
                        UCF_IHubPostMessage["postObjectMessage"]({
                            "type": "request",
                            "service": "sap.ushell.services.CrossApplicationNavigation.registerBeforeAppCloseEvent",
                            "body": {}
                        }, window["parent"]);
                        this["bFLPSessionHandlingRegistered"] = true;
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(INFO, "FLP LogoffHandling: register via PM sap.ushell.services.CrossApplicationNavigation.registerBeforeAppCloseEvent and listen to sap.ushell.services.CrossApplicationNavigation.beforeAppCloseEvent", "Page.js(1667): registerFLPSessionHandling");
                        }
                        ;
                    }
                }
            } catch (ex) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "FLP LogoffHandling: could NOT register via PM PostMessage sap.ushell.services.CrossApplicationNavigation.registerBeforeAppCloseEvent: " + ex, "Page.js(1671): registerFLPSessionHandling");
                }
                ;
            }
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["registerFLPSessionHandling"] = 0;
        }
        ;
    }

    UCF_Page["prototype"]["bHandleUnloadPostMessage"] = function (sService, oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bHandleUnloadPostMessage"]++;
        }
        ;

        var oEventData = UCF_JsUtil["oJsonParse"](oEvent["data"]);

        if (this["sUnloadUrl"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, "FLP LogoffHandling: send logoff request due to received PM sap.ushell.services.CrossApplicationNavigation.beforeAppCloseEvent", "Page.js(1681): bHandleUnloadPostMessage");
            }
            ;
            UCF_RequestUtil["sendUnloadRequest"](this["sUnloadUrl"], null, "DEFAULT");
            this["setUnloadUrl"](""); //unload done - do not repeat it during unload event
        }
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, "FLP LogoffHandling: done answer with PM sap.ushell.services.CrossApplicationNavigation.beforeAppCloseEvent", "Page.js(1685): bHandleUnloadPostMessage");
        }
        ;

        return ({
            "type": "response",
            "request_id": oEventData["request_id"],
            "status": "success",
            "service": "sap.ushell.services.CrossApplicationNavigation.beforeAppCloseEvent",
            "body": oEventData["body"]
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bHandleUnloadPostMessage"] = 0;
    }
    ;

    /**
     * Sets the unload URL of the page that is called before the page is unloaded
     * @param {string} sUrl the url to be called
     * @param {string} sSessionHandling used session handling
     * @public
     */
    UCF_Page["prototype"]["setUnloadUrl"] = function (sUrl, sSessionHandling) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setUnloadUrl"]++;
        }
        ;

        if (typeof sSessionHandling === 'string' && sSessionHandling !== '') {
            this["sSessionHandling"] = sSessionHandling; // eslint-disable-line ur/no-memory-leaks
            this["setClientProperty"]("SessionHandling", this["sSessionHandling"], true);
        }

        this["sUnloadUrl"] = sUrl; // eslint-disable-line ur/no-memory-leaks
        this["setClientProperty"]("UnloadUrl", this["sUnloadUrl"], true);
        if (!__UCF_IE6__ && !this["bFLPSessionHandlingRegistered"]) {
            this["registerFLPSessionHandling"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setUnloadUrl"] = 0;
    }
    ;

    /**
     * Show browser data loss popup in case of LS is dirty
     * @param {boolean} bShowPopup whether UR shoul
     */
    UCF_Page["prototype"]["enableDataLossPopup"] = function (bShowPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["enableDataLossPopup"]++;
        }
        ;

        if (bShowPopup) {
            this["oLS"]["oBrowserWindow"]["attachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["BeforeUnload"], this, 'showDataLossPopup');
        } else {
            this["oLS"]["oBrowserWindow"]["detachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["BeforeUnload"], this, 'showDataLossPopup');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["enableDataLossPopup"] = 0;
    }
    ;

    /**
     * Called by onbeforeunload event in case of LS should display data loss popup
     * @param {UCF_Event} oEvent the event
     * @privat
     */
    UCF_Page["prototype"]["showDataLossPopup"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["showDataLossPopup"]++;
        }
        ;
        if (this["bIsDirty"]() && this["oLS"]["sDirtyMode"] !== "NONE") {
            //UR is dirty and should display dirty popup in beforeunload
            //to force a confirmation popup use preventDefault and for Chrome use a
            //returnValue != undefined or null

            oEvent["mGetParameters"]()["cancel"]();
            //oEvent.mGetParameters().oDomEvent.returnValue = "";
            //oEvent.mGetParameters().oDomEvent.preventDefault();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["showDataLossPopup"] = 0;
    }
    ;

    /**
     * Redirects to a given URL
     * @param {string} sMethod GET or POST
     * @param {string} sUrl the url to be called
     * @param {string} sPostParameters The Url Encoded Parameters that are sent with a POST redirects. Ignored for GET
     * @public
     */
    UCF_Page["prototype"]["redirect"] = function (sMethod, sUrl, sPostParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["redirect"]++;
        }
        ;
        var mParameters;
        if (sPostParameters) {
            mParameters = UCF_JsUtil["mDecodeURIParameters"](sPostParameters);
        }
        UCF_RequestUtil["sendFormRequest"](sMethod, sUrl, mParameters, "");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["redirect"] = 0;
    }
    ;

    /**
     * Sets dirty Mode of the page
     * @param {string} sDirtyMode of the page
     * @public
     */
    UCF_Page["prototype"]["setDirtyMode"] = function (sDirtyMode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setDirtyMode"]++;
        }
        ;
        this["oLS"]["sDirtyMode"] = sDirtyMode;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setDirtyMode"] = 0;
    }
    ;

    /**
     * Handler for the unlock event of lightspeed
     * @param {UCF_Event} oEvent The reference to internal event
     * @private
     */
    UCF_Page["prototype"]["onLsUnlock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onLsUnlock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oEvent, 'UCF_Event'), "UCF_JsUtil.bInstanceOf(oEvent, 'UCF_Event')", "Page.js(1776): onLsUnlock");
        }
        ;

        if (this["mHashInfoLockMap"]) { //Unlock relevant for Hash handling
            this["fireHashChanged"](this["sId"], this["mHashInfoLockMap"]["sNewHashAfterLock"], this["mHashInfoLockMap"]["sOldHashBeforeLock"]);
            this["mHashInfoLockMap"] = null;
        }

        this["bResizeNotification"] = this["mEvents"]["Resize"] ? true : false;

        if (this["bResizeNotification"]) {
            this["checkResize"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onLsUnlock"] = 0;
    }
    ;
    /**
     * Handler for the lock event of lightspeed
     * @param {UCF_Event} oEvent The reference to internal event
     * @private
     */
    UCF_Page["prototype"]["onLsLock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onLsLock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oEvent, 'UCF_Event'), "UCF_JsUtil.bInstanceOf(oEvent, 'UCF_Event')", "Page.js(1795): onLsLock");
        }
        ;

        if (this["bResizeNotification"]) {
            this["bResizeNotification"] = false;
            //CleanUp pending delayed resize requests when UI is locked
            UCF_JsUtil["resetMassNotificationFilter"](this);

        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onLsLock"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event<{Changes: UCF_LS_SystemParameterChange[]}>} oEvent
     */
    UCF_Page["prototype"]["onSystemParameterChange"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onSystemParameterChange"]++;
        }
        ;
        /** @type {UCF_LS_SystemParameterChange} */
        var oFeatureFlagsChange = UCF_JsUtil["find"](
            oEvent["oGetParam"]('Changes'),
            function (oUpdate) {
                return oUpdate["sParameter"] === 'FeatureFlags';
            }
        );

        if (oFeatureFlagsChange) {
            document["body"]["parentElement"]["setAttribute"](
                'data-sap-ls-system-featureflags',
                oFeatureFlagsChange["oValue"]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onSystemParameterChange"] = 0;
    }
    ;

    /**
     * BROWSER HISTORY
     * @see {BrowserHistory}
     *
     */

    /**
     * Sets the browser history mode
     * @param {string} sBrowserHistory Enumeration of ENABLED,DISABLED,NOTIFY
     * @public
     */
    UCF_Page["prototype"]["setBrowserHistory"] = function (sBrowserHistory) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setBrowserHistory"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sBrowserHistory === "string", "typeof sBrowserHistory === \"string\"", "Page.js(1836): setBrowserHistory");
        }
        ;

        this["cleanUpBrowserHistory"]();
        this["sBrowserHistory"] = sBrowserHistory; // eslint-disable-line ur/no-memory-leaks
        this["setClientProperty"]("BrowserHistory", this["sBrowserHistory"], true);
        this["initBrowserHistory"](false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setBrowserHistory"] = 0;
    }
    ;

    /**
     * Cleanup of all browser history relevant states and references
     * @private
     */
    UCF_Page["prototype"]["cleanUpBrowserHistory"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["cleanUpBrowserHistory"]++;
        }
        ;
        if (this["oBrowserHistory"]) {
            this["oBrowserHistory"]["detachEvent"](this["oBrowserHistory"]["E_EVENTS"]["HashChanged"], this, "onHashChanged");
            this["oBrowserHistory"]["destroy"]();
            this["oBrowserHistory"] = null;
        }

        this["bSkipNextHashChangeNotification"] = false;
        this["mHashInfoLockMap"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["cleanUpBrowserHistory"] = 0;
    }
    ;

    /**
     * Creates the browser history object and activates it
     * @param {boolean} bPageInitial true is initialization is done on application startup
     * @private
     */
    UCF_Page["prototype"]["initBrowserHistory"] = function (bPageInitial) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["initBrowserHistory"]++;
        }
        ;
        var bBackprevention, bHistorySupport;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bPageInitial === "boolean", "typeof bPageInitial === \"boolean\"", "Page.js(1867): initBrowserHistory");
        }
        ;

        bBackprevention = this["sBrowserHistory"] !== "ENABLED";
        bHistorySupport = this["bIsHistorySupport"]();

        this["mHashInfoLockMap"] = null;
        this["oBrowserHistory"] = new (UCF_ClassLoader["oGetClass"]("UCF_BrowserHistory"))();

        if (bHistorySupport) {
            //Before starting the browser history check initial hash by URL and hash set by application.
            //Create a consistant state or even fire a change event
            if (this["oBrowserHistory"]["sGetHash"]() !== this["sHash"]) {
                if (this["oBrowserHistory"]["sGetHash"]()) {
                    //The user overwrote the hash of the application by directly setting a hash in the URL
                    this["fireHashChangedEvent"](this["oBrowserHistory"]["sGetHash"](), this["sHash"]);
                } else {
                    //Update the location bar with the hash code set by the application
                    this["oBrowserHistory"]["setHashDirect"](this["sHash"], true);
                }
            }

            //Disable Iframe caching for hash support because reuse of IFrame causes navigation which creates an entry
            //in native history of browser
            this["oLS"]["oGetPopupManagerInternal"]()["setIframeCaching"](false);

            this["oBrowserHistory"]["attachEvent"](this["oBrowserHistory"]["E_EVENTS"]["HashChanged"], this, "onHashChanged");
        }

        this["oBrowserHistory"]["init"](bBackprevention, bHistorySupport, bPageInitial);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["initBrowserHistory"] = 0;
    }
    ;

    /**
     * Returns true if the hash or history support is enabled
     * @private
     * @return {boolean}
     */
    UCF_Page["prototype"]["bIsHistorySupport"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bIsHistorySupport"]++;
        }
        ;
        return window === window["top"] //Allow hash support only for the most top window (do not use window === window.top because of a bug in IE11 quirks)
            && (this["sBrowserHistory"] === "NOTIFY"
                || (this["mEvents"]["HashChanged"] && this["bHashChangedNotification"]));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bIsHistorySupport"] = 0;
    }
    ;

    /**
     * Called by internal eventing of browserHistory object when hash changed
     * @param {UCF_Event} oEvent The reference to internal event
     * @private
     */
    UCF_Page["prototype"]["onHashChanged"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onHashChanged"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oEvent, 'UCF_Event'), "UCF_JsUtil.bInstanceOf(oEvent, 'UCF_Event')", "Page.js(1915): onHashChanged");
        }
        ;

        if (!this["bSkipNextHashChangeNotification"]) {
            this["fireHashChangedEvent"](oEvent["oGetParam"]("sNewHash"), oEvent["oGetParam"]("sOldHash"));
        }

        this["bSkipNextHashChangeNotification"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onHashChanged"] = 0;
    }
    ;

    /**
     * Fire notification by semantic event "HashChanged"
     * @param {string} sNewHash
     * @param {string} sOldHash
     * @private
     */
    UCF_Page["prototype"]["fireHashChangedEvent"] = function (sNewHash, sOldHash) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireHashChangedEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sNewHash === "string", "typeof sNewHash === \"string\"", "Page.js(1931): fireHashChangedEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sOldHash === "string", "typeof sOldHash === \"string\"", "Page.js(1932): fireHashChangedEvent");
        }
        ;

        if (this["bIsHistorySupport"]()) {
            if (this["oLS"]["bIsLocked"]) {
                if (this["mHashInfoLockMap"]) {
                    this["mHashInfoLockMap"]["sNewHashAfterLock"] = sNewHash;
                } else {
                    this["mHashInfoLockMap"] = {
                        "sOldHashBeforeLock": sOldHash,
                        "sNewHashAfterLock": sNewHash
                    };
                }
            } else {
                this["fireHashChanged"](this["sId"], sNewHash, sOldHash);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireHashChangedEvent"] = 0;
    }
    ;

    /**
     * Sets the hash of the page
     * @param {string} sHash the new hash key
     * @param {string} [bSuppressHashChanged=false] deprecated This parmeter has been deprecated and has no effect. The method does not fire any events when used.
     * @public
     */
    UCF_Page["prototype"]["setHash"] = function (sHash, /*deprecated*/ bSuppressHashChanged) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setHash"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === "string", "typeof sHash === \"string\"", "Page.js(1957): setHash");
        }
        ;

        sHash = this["oBrowserHistory"]["sNormalizeHash"](sHash);

        if (this["mHashInfoLockMap"]) { //hash has changed while LS was locked. This hash change has priority. Hash set by application is ignored
            this["mHashInfoLockMap"]["sOldHashBeforeLock"] = sHash;
        } else {
            if (sHash !== this["oBrowserHistory"]["sGetHash"]()) {
                this["bSkipNextHashChangeNotification"] = true;
            }

            this["oBrowserHistory"]["setHash"](sHash);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setHash"] = 0;
    }
    ;

    /**
     * Returns the currently set hash of the URL
     * @public
     * @return {string}
     */
    UCF_Page["prototype"]["getHash"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["getHash"]++;
        }
        ;
        return this["oBrowserHistory"]
            ? this["oBrowserHistory"]["sGetHash"]()
            : '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["getHash"] = 0;
    }
    ;

    /**
     * Switches the hash change notification on/off if a HashChanged event is bound.
     *
     * @param {bool} bHashChangedNotification true is 'on', false is 'off'
     * @public
     */
    UCF_Page["prototype"]["setHashChangedNotification"] = function (bHashChangedNotification) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setHashChangedNotification"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bHashChangedNotification === "string", "typeof bHashChangedNotification === \"string\"", "Page.js(1990): setHashChangedNotification");
        }
        ;

        if (bHashChangedNotification !== this["bHashChangedNotification"]) {
            this["bHashChangedNotification"] = bHashChangedNotification; // eslint-disable-line ur/no-memory-leaks
            this["setClientProperty"]("HashChangedNotification", this["bHashChangedNotification"], true);
            this["cleanUpBrowserHistory"]();
            this["initBrowserHistory"](false);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setHashChangedNotification"] = 0;
    }
    ;

    /**
     * Sets the scroll mode for the Page control. For the parameter values see enumeration 'ScrollingMode'. Default is 'NONE' - in this mode no scrollbar viualization is set and the browser default (overflow:inherit) is used.
     *
     * @param {string} sScrollingMode the ScrollingMode enum constant
     * @public
     */
    UCF_Page["prototype"]["setScrollingMode"] = function (sScrollingMode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setScrollingMode"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sScrollingMode === "string", "typeof sScrollingMode === \"string\"", "Page.js(2007): setScrollingMode");
        }
        ;

        if (this["sScrollingMode"] !== sScrollingMode) {
            switch (sScrollingMode) {
                case "BOTH":
                    document["body"]["style"]["overflow"] = "scroll";
                    break;
                case "HIDE":
                    document["body"]["style"]["overflow"] = "hidden";
                    break;
                case "AUTO":
                    document["body"]["style"]["overflow"] = "auto";
                    break;
                case "NONE":
                    document["body"]["style"]["overflow"] = ""; //remove
                    break;
                default:
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, "ScrollingMode '" + sScrollingMode + "' is unknown.", "Page.js(2024): setScrollingMode");
                    }
                    ;
                    return;
            }

            this["sScrollingMode"] = sScrollingMode; // eslint-disable-line ur/no-memory-leaks
            this["setClientProperty"]("ScrollingMode", this["sScrollingMode"], true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setScrollingMode"] = 0;
    }
    ;

    /**
     * Gets the scrolling mode of the page control
     *
     * @public
     * @return {string}
     */
    UCF_Page["prototype"]["sGetScrollingMode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["sGetScrollingMode"]++;
        }
        ;
        return this["sScrollingMode"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["sGetScrollingMode"] = 0;
    }
    ;

    UCF_Page["prototype"]["sGetThemeUrl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["sGetThemeUrl"]++;
        }
        ;
        return UCF_ResourceUtil["sGetLightspeedCssLinkUrl"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["sGetThemeUrl"] = 0;
    }
    ;

    /**
     * Sets the Theme URL to the given URL.
     * If you change the theme URL to a different CSS you also need to adjust all controls HTML as the
     * control might refer the image folders of the currently applied theme.
     * @param {string} sThemeUrl The url to the theme or the id of a standard theme
     * @public
     */
    UCF_Page["prototype"]["changeThemeUrl"] = function (sThemeUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["changeThemeUrl"]++;
        }
        ;
        if (!UCF_JsUtil["contains"](sThemeUrl, ".css")) {
            sThemeUrl = UCF_ResourceUtil["sGetCssUrl"](sThemeUrl);
        }

        UCF_ResourceUtil["setLightspeedCssLinkUrl"](sThemeUrl);
        window["UCF_System"]["sCSSURL"] = sThemeUrl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["changeThemeUrl"] = 0;
    }
    ;

    /**
     * Adds the given class name to the body
     * @param {string} sClassName The css class to add
     * @public
     */
    UCF_Page["prototype"]["addCustomStyleClass"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["addCustomStyleClass"]++;
        }
        ;
        UCF_DomUtil["addClass"](document["body"], sClassName);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["addCustomStyleClass"] = 0;
    }
    ;

    /**
     * Removes the given class name from the body
     * @param {string} sClassName The css class to remove
     * @public
     */
    UCF_Page["prototype"]["removeCustomStyleClass"] = function (sClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["removeCustomStyleClass"]++;
        }
        ;
        UCF_DomUtil["removeClass"](document["body"], sClassName);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["removeCustomStyleClass"] = 0;
    }
    ;

    /**
     * Applies a list of custom styles for the current page.
     * @param {string} sId The id of the customstyle block to add
     * @param {Array} aStyles Array of custom styles that should be included in this style block
     *                If empty the style block is deleted
     *                Format of the array objects is defined in the CustomStyleProvider.prototype.serialize() method class on the client
     * @param {boolean} bDeleteLocal
     * @public
     */
    UCF_Page["prototype"]["applyCustomStyles"] = function (sId, aStyles, bDeleteLocal) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["applyCustomStyles"]++;
        }
        ;
        var self = this;

        if (!window["less"]) {
            this["loadLess"](function () {
                self["_applyCustomStyles"](sId, aStyles, bDeleteLocal);
            });
        } else {
            this["_applyCustomStyles"](sId, aStyles, bDeleteLocal);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["applyCustomStyles"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sId The id of the customstyle block to add
     * @param {Array} aStyles Array of custom styles that should be included in this style block
     *                If empty the style block is deleted
     *                Format of the array objects is defined in the CustomStyleProvider.prototype.serialize() method class on the client
     * @param {boolean} bDeleteLocal
     */
    UCF_Page["prototype"]["_applyCustomStyles"] = function (sId, aStyles, bDeleteLocal) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["_applyCustomStyles"]++;
        }
        ;
        var oProvider, aPopups;

        if (!sId || !aStyles) {
            return;
        }

        oProvider = new (UCF_ClassLoader["oGetClass"]("UCF_CustomStyleProvider"))();
        oProvider["unregisterStyles"](sId);
        oProvider["registerStyles"](sId, aStyles);
        if (bDeleteLocal) {
            oProvider["deleteStorage"](sId);
        }
        oProvider["updateStyles"](sId, true);

        // Apply for the Page control of IFrame-PopupWindows
        if (this["oLS"]["bIsMainLS"]()) {
            aPopups = this["oLS"]["oGetPopupManagerInternal"]()["aGetPopups"]();
            if (aPopups) {
                UCF_JsUtil["forEach"](aPopups, function (popup) {
                    if (popup["ucfPopupWindow"]
                        && popup["ucfPopupWindow"]["oLS"]
                        && !popup["ucfPopupWindow"]["bIsDivPopup"]
                        && popup["ucfPopupWindow"]["oLS"]["oGetPageInternal"]()) {
                        popup["ucfPopupWindow"]["oLS"]["oGetPageInternal"]()["applyCustomStyles"](sId, aStyles, bDeleteLocal);
                    }
                });
            }
        }

        // Because applyCustomStyles() is delayed (because of less loading)
        // Some controls that calculate dimensions during initialize(), with delay or not, must also attach to this event - example: Toolbar
        this["fireEvent"](this["E_EVENTS"]["CustomStylesApplied"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["_applyCustomStyles"] = 0;
    }
    ;

    /**
     * Load 'less' compiler if not already loaded. It is needed for custom styles. Call this function before creating an instance of the CustomStyleProvider.
     * @param {function} [fOnLoad] Optional callback function when script was loaded
     * @public
     */
    UCF_Page["prototype"]["loadLess"] = function (fOnLoad) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["loadLess"]++;
        }
        ;
        if (!Object["bind"]) {
            //less uses bind and cannot be loaded in old environments
            if (__UCF_TRACE__) {
                UCF_Tracer.trace("ERROR", "Failed to load less because bind() is not available.", "Page.js(2151): loadLess");
            }
            ;
            return;
        }

        if (!window["less"]) {
            this["addScript"](UCF_ResourceUtil["sGetJsRoot"]() + "/common/lib/less.js", null, null, this, "loadLessCallback", [fOnLoad]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["loadLess"] = 0;
    }
    ;

    /**
     * @private
     * @param {function} fOnLoad function to call
     */
    UCF_Page["prototype"]["loadLessCallback"] = function (fOnLoad) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["loadLessCallback"]++;
        }
        ;
        if (!window["less"]) {
            UCF_JsUtil["delayedCall"](20, this, "loadLessCallback", [fOnLoad]);
        } else if (fOnLoad) {
            fOnLoad();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["loadLessCallback"] = 0;
    }
    ;

    /**
     * @public
     * @param {map} mConditionalRules
     */
    UCF_Page["prototype"]["setConditionalRules"] = function (mConditionalRules) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setConditionalRules"]++;
        }
        ;
        var mDefaults = {
                "fontSize": "ignore",
                "fontColor": "ignore",
                "backgroundColor": "ignore",
                "fontWeight": "ignore",
                "fontStyle": "ignore",
                "textDecoration": "ignore"
            },
            m, n, oRule;

        if (typeof mConditionalRules === "string") {
            try {
                mConditionalRules = UCF_JsUtil["oJsonParse"](mConditionalRules);
            } catch (ex) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, "Failed to parse JSON", "Page.js(2191): setConditionalRules");
                }
                ;
                mConditionalRules = {};
            }
        }
        if (this["mConditionalRules"]) {
            this["applyCustomStyles"]("-CFS", []); //remove the current ruleset classes
        }
        this["mConditionalRules"] = mConditionalRules;

        //enrich conditional styles with defaults
        for (n in this["mConditionalRules"]) {
            oRule = this["mConditionalRules"][n];
            if (oRule["style"]) {
                for (m in mDefaults) {
                    if (!oRule["style"][m]) {
                        oRule["style"][m] = mDefaults[m];
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setConditionalRules"] = 0;
    }
    ;

    /**
     * @public
     * @param {map} mConditionalControlMap
     */
    UCF_Page["prototype"]["setConditionalControlMapping"] = function (mConditionalControlMap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setConditionalControlMapping"]++;
        }
        ;
        if (typeof (mConditionalControlMap) === "string") {
            try {
                mConditionalControlMap = UCF_JsUtil["oJsonParse"](mConditionalControlMap);
            } catch (ex) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace("INFO", "Failed to parse JSON", "Page.js(2222): setConditionalControlMapping");
                }
                ;
                mConditionalControlMap = {};
            }
        }
        if (this["mConditionalControlMap"]) {
            this["applyCustomStyles"]("-CFS", []);
        }
        this["mConditionalControlMap"] = mConditionalControlMap;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setConditionalControlMapping"] = 0;
    }
    ;

    /**
     * @public
     */
    UCF_Page["prototype"]["applyConditionalRules"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["applyConditionalRules"]++;
        }
        ;
        var n, oControl, aUniqueConditionalsStyles = [],
            mStyles, m;

        if (this["mConditionalControlMap"] && this["mConditionalRules"]) {
            for (n in this["mConditionalControlMap"]) {
                oControl = this["oLS"]["oControlFactory"]["oGetControlById"](n);
                if (oControl) {
                    oControl["getMatchingConditionalStyles"](this["mConditionalControlMap"][n], this["mConditionalRules"]);
                }
            }
            for (n in this["mConditionalRules"]) {
                mStyles = this["mConditionalRules"][n]["mStyles"];
                if (mStyles) {
                    for (m in mStyles) {
                        aUniqueConditionalsStyles["push"](mStyles[m]);
                    }
                }
            }
            this["applyCustomStyles"]("-CFS", aUniqueConditionalsStyles);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["applyConditionalRules"] = 0;
    }
    ;

    /**
     * Sets the default button id for the control
     *
     * @param {string} sDefaultButtonId string Id of the button that is executed if the user presses enter
     * @public
     */
    UCF_Page["prototype"]["setDefaultButtonId"] = function (sDefaultButtonId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setDefaultButtonId"]++;
        }
        ;
        UCF_Control.prototype["setDefaultButtonId"]["call"](this, sDefaultButtonId);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setDefaultButtonId"] = 0;
    }
    ;

    /**
     * Initializes the animations of the page from the animation span tag on the page.
     * Attaches to control event and semantic events of any kind on the LS object.
     */
    UCF_Page["prototype"]["initAnimations"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["initAnimations"]++;
        }
        ;
        this["mAnimations"] = {};
        this["updateAnimations"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["initAnimations"] = 0;
    }
    ;

    UCF_Page["prototype"]["updateAnimations"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["updateAnimations"]++;
        }
        ;
        var self = this,
            n, oDomRef, oAnimation, bUserTriggerRegistered = false,
            bSemanticTriggerRegistered = false;

        if (!window["UCF_System"]["bUseAnimation"] //only if animations are turned on
            || !window['JSON'] //only do the animations for modern browsers
            || !UCF_UserAgent["bIsIE"](8) && !UCF_UserAgent["bIsFirefox"](4) && !UCF_UserAgent["bIsWebKit"]()) {
            return;
        }

        //delete the old animations if they were updated
        for (n in this["mAnimations"]) {
            oDomRef = this["mAnimations"][n]["domref"];
            if (!UCF_DomUtil["bIsInActiveDom"](oDomRef)) {
                oAnimation = this["mAnimations"][n]["animation"];
                if (oAnimation["bIsRunning"]) {
                    oAnimation["callbackFinish"](this, "updateAnimations");
                }
                if (oAnimation) {
                    oAnimation["destroy"]();
                }
                delete this["mAnimations"][n];
            }
        }

        UCF_JsUtil["forEach"](UCF_DomUtil["$"](this["sId"] + '-animations')["getElementsByTagName"]('SPAN'), function (oChildAnim) {
            var oConfig = UCF_JsUtil["oJsonParse"](UCF_DomUtil["sGetInnerText"](oChildAnim));

            if (self["mAnimations"][oChildAnim["id"]]) {
                if (oChildAnim["getAttribute"]('duration') === '-1') {
                    delete self["mAnimations"][oChildAnim["id"]];
                }
            } else {
                self["mAnimations"][oChildAnim["id"]] = {
                    "duration": parseInt(oChildAnim["getAttribute"]('duration')) || 300,
                    "controlid": oChildAnim["getAttribute"]('controlid'),
                    "domref": oChildAnim,
                    "config": oConfig,
                    "animation": null
                };
                UCF_JsUtil["forEach"](self["mAnimations"][oChildAnim["id"]]["config"]["Triggers"], function (trigger) {
                    var sEventName = trigger["EventName"],
                        sKey;

                    if (trigger["EventType"] === 'USER') {
                        sEventName = sEventName["toLowerCase"]();
                    }
                    sKey = trigger["EventType"] + '_' + trigger["SourceControlId"] + '_' + sEventName;

                    if (!self["mAnimationTriggers"][sKey]) {
                        self["mAnimationTriggers"][sKey] = [];
                    }
                    self["mAnimationsTriggers"][sKey]["push"](self["mAnimations"][oChildAnim["id"]]);

                    if (!bUserTriggerRegistered && trigger["EventType"] === 'USER') {
                        self["oLS"]["oBrowserWindow"]["attachEvent"](self["oLS"]["oBrowserWindow"]["E_EVENTS"]["ControlEvent"], self, 'triggerAnimation');
                        bUserTriggerRegistered = true;
                    } else if (!bSemanticTriggerRegistered && trigger["EventType"] === 'SEMANTIC') {
                        self["oLS"]["attachEvent"](self["oLS"]["E_EVENTS"]["SemanticEvent"], self, 'triggerAnimation');
                        bSemanticTriggerRegistered = true;
                    }
                });
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["updateAnimations"] = 0;
    }
    ;

    /**
     * @private
     * Creates and runs an animation from the given AnimationDefiniton for the trigger and adds the animation
     * to the internal storyboard for other phases like BEFOREREQUEST, AFTERRESPONSE, UPDATECOMPLETE
     * @param {Object} oAnimationDefinition an AnimationDefinition object
     */
    UCF_Page["prototype"]["runAnimation"] = function (oAnimationDefinition) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["runAnimation"]++;
        }
        ;
        var self = this,
            sControlId = oAnimationDefinition["controlid"],
            oDomRef, n, bDomRefInvalid, mPhasedAnimations;

        if (!sControlId) {
            return;
        }

        oDomRef = this["oLS"]["oControlFactory"]["oGetControlById"](sControlId)["oRootRef"];
        // the dom ref is not valid anymore - delete and destroy all animations
        if (!oDomRef && oAnimationDefinition["animations"]) {
            for (n in oAnimationDefinition["animations"]) {
                oAnimationDefinition["animations"][n]["destroy"]();
                delete oAnimationDefinition["animations"][n];
            }
            oAnimationDefinition["animations"] = null;
        }

        if (oAnimationDefinition["animations"]) {
            bDomRefInvalid = false;
            for (n in oAnimationDefinition["animations"]) {
                if (!UCF_DomUtil["bIsInActiveDom"](oAnimationDefinition["animations"][n]["oDomRef"])) {
                    oAnimationDefinition["animations"][n]["destroy"]();
                    delete oAnimationDefinition["animations"][n];
                    bDomRefInvalid = true;
                }
            }
            if (bDomRefInvalid) {
                oAnimationDefinition["animations"] = null;
            }
        }

        if (!oAnimationDefinition["animations"]) {
            if (!oAnimationDefinition["config"]["Steps"]) {
                return;
            }

            mPhasedAnimations = {};
            UCF_JsUtil["forEach"](oAnimationDefinition["config"]["Steps"], function (oStep) {
                if (!mPhasedAnimations[oStep["Phase"]]) {
                    mPhasedAnimations[oStep["Phase"]] = new (UCF_ClassLoader["oGetClass"]("UCF_Animation"))(oDomRef, oAnimationDefinition["duration"]);
                }
                var oAnimation = mPhasedAnimations[oStep["Phase"]],
                    iInitialValue = oStep["InitalValue"],
                    iFinalValue = oStep["FinalValue"],
                    iStartValue = oStep["StartValue"],
                    iEndValue = oStep["EndValue"],
                    sAttribute = oStep["Attribute"],
                    sFunction = oStep["Function"],
                    sControlId = oStep["ControlId"],
                    eFunction = oAnimation["M_TRANSITIONS"]["Linear"],
                    oStepDomRef = null,
                    sStyleAttribute, sTransform;

                if (sControlId) {
                    oStepDomRef = self["oLS"]["oControlFactory"]["oGetControlById"](sControlId)["oRootRef"];
                }

                if (sFunction === "EASEIN") {
                    eFunction = oAnimation["M_TRANSITIONS"]["EaseIn"];
                } else if (sFunction === "EASEOUT") {
                    eFunction = oAnimation["M_TRANSITIONS"]["EaseOut"];
                } else if (sFunction === "EASEINOUT") {
                    eFunction = oAnimation["M_TRANSITIONS"]["EaseInOut"];
                } else if (sFunction === "EASELOOPBACK") {
                    eFunction = oAnimation["M_TRANSITIONS"]["EaseLoopBack"];
                }
                if (sAttribute === "OPACITY") {
                    if (typeof iInitialValue === "number") {
                        oAnimation["addInitialOpacityValue"](iInitialValue, oStepDomRef);
                    }
                    oAnimation["addOpacityChange"](iStartValue, iEndValue, eFunction, oStepDomRef);
                    if (typeof iFinalValue === "number") {
                        oAnimation["addFinalOpacityValue"](iFinalValue, oStepDomRef);
                    }
                } else if (sAttribute === "HEIGHT" || sAttribute === "WIDTH") {
                    sStyleAttribute = sAttribute["toLowerCase"]();
                    if (typeof iInitialValue === "number") {
                        oAnimation["addInitialStyleValue"](sStyleAttribute, iInitialValue + "px", oStepDomRef);
                    }
                    oAnimation["addStyleChange"](sStyleAttribute, "", "px", iStartValue, iEndValue, eFunction, oStepDomRef);
                    if (typeof iFinalValue === "number") {
                        oAnimation["addFinalStyleValue"](sStyleAttribute, iFinalValue + "px", oStepDomRef);
                    }
                } else if (sAttribute === "LEFT" || sAttribute === "TOP") {
                    sStyleAttribute = sAttribute["toLowerCase"]();
                    if (typeof iInitialValue === "number") {
                        oAnimation["addInitialStyleValue"]("position", "relative", oStepDomRef);
                        oAnimation["addInitialStyleValue"]("margin-" + sStyleAttribute, iInitialValue + "px", oStepDomRef);
                    }
                    oAnimation["addStyleChange"]("margin-" + sStyleAttribute, "", "px", iStartValue, iEndValue, eFunction, oStepDomRef);
                    if (typeof iFinalValue === "number") {
                        oAnimation["addFinalStyleValue"]("position", "relative", oStepDomRef);
                        oAnimation["addFinalStyleValue"]("margin-" + sStyleAttribute, iFinalValue + "px", oStepDomRef);
                    }
                } else if (sAttribute === "SCALEX"
                    || sAttribute === "SCALEY"
                    || sAttribute === "TRANSLATEX"
                    || sAttribute === "TRANSLATEY"
                    || sAttribute === "ROTATE"
                    || sAttribute === "SKEWX"
                    || sAttribute === "SKEWY") {
                    sTransform = sAttribute["toLowerCase"]()["replace"](/([xy]$)/, function (m, p) {
                        return p["toUpperCase"]();
                    });
                    if (typeof iInitialValue === "number") {
                        oAnimation["addInitialTransformValue"](sTransform, [iInitialValue], oStepDomRef);
                    }
                    oAnimation["addTransformChange"](sTransform, [iStartValue], [iEndValue], eFunction, oStepDomRef);
                    if (typeof iFinalValue === "number") {
                        oAnimation["addFinalTransformValue"](sTransform, [iFinalValue], oStepDomRef);
                    }
                }
            });
            oAnimationDefinition["animations"] = mPhasedAnimations;
        }
        for (n in oAnimationDefinition["animations"]) {
            this["addNextAnimation"](oAnimationDefinition["animations"][n], n);
        }
        this["playAnimations"]("TRIGGER");
        if (!this["bAnimationEventsAttached"]) {
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["BeforeRequest"], this, "playBeforeRequest");
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["AfterRequest"], this, "playAfterRequest");
            if (!this["bAfterResponseEventAttached4Animation"] && !this["bAfterResponseEventAttached4SessionState"]) {
                this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["AfterResponse"], this, "handleAfterResponse");
            }
            this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["UpdateComplete"], this, "playUpdateComplete");
            this["bAfterResponseEventAttached4Animation"] = true;
            this["bAnimationEventsAttached"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["runAnimation"] = 0;
    }
    ;

    /**
     * @private
     * Adds an animation to the internal storyboard that is played if a certain event occurs
     * @param {Object} oAnimation an AnimationDefinition object
     * @param {string} sEvent triggering event
     */
    UCF_Page["prototype"]["addNextAnimation"] = function (oAnimation, sEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["addNextAnimation"]++;
        }
        ;
        if (!this["mNextAnimations"]) {
            this["mNextAnimations"] = {};
        }
        if (!this["mNextAnimations"][sEvent]) {
            this["mNextAnimations"][sEvent] = [];
        }
        this["mNextAnimations"][sEvent]["push"](oAnimation);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["addNextAnimation"] = 0;
    }
    ;

    /**
     * @private
     * Adds an animation to the internal storyboard that is played if a certain event occurs
     */
    UCF_Page["prototype"]["playBeforeRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["playBeforeRequest"]++;
        }
        ;
        this["playAnimations"]("BEFOREREQUEST");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["playBeforeRequest"] = 0;
    }
    ;

    /**
     * @private
     * Internal use, play the animations for the After Request phase
     */
    UCF_Page["prototype"]["playAfterRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["playAfterRequest"]++;
        }
        ;
        this["playAnimations"]("AFTERREQUEST");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["playAfterRequest"] = 0;
    }
    ;

    /**
     * @private
     * Internal use, play the animations for the After Response phase
     */
    UCF_Page["prototype"]["playAfterResponse"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["playAfterResponse"]++;
        }
        ;
        this["playAnimations"]("AFTERRESPONSE");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["playAfterResponse"] = 0;
    }
    ;

    /**
     * @private
     * Internal use, play the animations for the UpdateComplete phase
     */
    UCF_Page["prototype"]["playUpdateComplete"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["playUpdateComplete"]++;
        }
        ;
        this["playAnimations"]("UPDATECOMPLETE");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["playUpdateComplete"] = 0;
    }
    ;

    /**
     * @private
     * Internal use, play the animation.
     * @param {string} sEvent triggering event
     */
    UCF_Page["prototype"]["playAnimations"] = function (sEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["playAnimations"]++;
        }
        ;
        if (this["oCurrentAnimation"] && this["oCurrentAnimation"]["bRunning"]) {
            UCF_JsUtil["delayedCall"](this["oCurrentAnimation"]["iDuration"] - this["oCurrentAnimation"]["iElapsedTime"], this, "playAnimations", [sEvent]);
        } else {
            if (!this["mNextAnimations"]) {
                return;
            }
            if (this["mNextAnimations"][sEvent] && this["mNextAnimations"][sEvent]["length"] > 0) {
                this["oCurrentAnimation"] = this["mNextAnimations"][sEvent][0];
                if (sEvent === "UPDATECOMPLETE") {
                    this["oCurrentAnimation"]["setDomRef"](UCF_DomUtil["$"](this["oCurrentAnimation"]["oDomRef"]["id"]));
                }
                this["oCurrentAnimation"]["play"]();
                this["mNextAnimations"][sEvent]["splice"](0, 1);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["playAnimations"] = 0;
    }
    ;

    /**
     * @private
     * Internal use, callback for user and semantic event that trigger animations
     * @param {Object} oEvent triggering event
     */
    UCF_Page["prototype"]["triggerAnimation"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["triggerAnimation"]++;
        }
        ;
        var sEventType, sControlId, sEventName, oControl, sKey;

        if (oEvent["mGetParameters"]()["oBrowserEvent"]) {
            sEventType = "USER";
            sControlId = "";
            sEventName = oEvent["mGetParameters"]()["oBrowserEvent"]["sName"];
            oControl = oEvent["mGetParameters"]()["oBrowserEvent"]["oSourceControl"];

            if (oControl && oControl["sId"]) {
                sControlId = oControl["sId"];
            }
            if (sControlId) {
                sKey = sEventType + "_" + sControlId + "_" + sEventName;
                if (this["mAnimationTriggers"][sKey]) {

                    this["runAnimation"](this["mAnimationTriggers"][sKey]);
                }
            }
        } else if (oEvent["mGetParameters"]()["oSemanticEvent"]) {
            sEventType = "SEMANTIC";
            sEventName = oEvent["mGetParameters"]()["oSemanticEvent"]["sName"];
            sControlId = oEvent["mGetParameters"]()["oSemanticEvent"]["mParameters"]["Id"];

            if (sControlId) {
                sKey = sEventType + "_" + sControlId + "_" + sEventName;
                UCF_JsUtil["forEach"](this["mAnimationTriggers"][sKey], this["runAnimation"]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["triggerAnimation"] = 0;
    }
    ;

    /**
     */
    UCF_Page["prototype"]["handleAfterResponse"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["handleAfterResponse"]++;
        }
        ;
        if (this["mSessionState"]["validity"] === "ROUNDTRIP" && this["bAfterResponseEventAttached4SessionState"]) {
            this["mSessionState"] = {};
        }
        if (this["bAfterResponseEventAttached4Animation"]) {
            this["playAnimations"]("AFTERRESPONSE");
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["handleAfterResponse"] = 0;
    }
    ;

    UCF_Page["prototype"]["registerModel"] = function (sId, oModel, bDefault) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["registerModel"]++;
        }
        ;
        if (!this["mModels"][sId]) {
            if (!this["sDefaultModelId"] && bDefault) {
                this["sDefaultModelId"] = sId;
            }
            this["mModels"][sId] = oModel;
            this["oLS"]["oControlFactory"]["updateControlTreeBindings"](null, false);
            this["fireEvent"](this["E_EVENTS"]["ModelAvailable"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["registerModel"] = 0;
    }
    ;

    UCF_Page["prototype"]["unregisterModel"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["unregisterModel"]++;
        }
        ;
        if (this["mModels"][sId]) {
            if (this["sDefaultModelId"] === sId) {
                this["sDefaultModelId"] = "";
            }
            delete this["mModels"][sId];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["unregisterModel"] = 0;
    }
    ;

    if (__UCF_DEBUG__) {
        /**
         * @see debug.js createModel() -- only called there => debug-only
         * @param {string} sModelId
         * @param {Object} oData
         * @param {boolean} bMerge
         * @param {boolean} bIsDefault
         * @param {HTMLElement} oDomRef
         */
        UCF_Page["prototype"]["setModelData"] = function (sModelId, oData, bMerge, bIsDefault, oDomRef) {
            ;
            if (__UCF_COVERAGE__) {
                UCF_Page["_"]["setModelData"]++;
            }
            ;
            /** @type {UCF_Control} */
            var oUCFInstance;
            /** @type {string} */
            var n;

            if (this["mModels"][sModelId]) {
                this["mModels"][sModelId]["setData"](oData, bMerge);
            } else {
                this["mModels"][sModelId] = new (UCF_ClassLoader["oGetClass"]("UCF_JSONModel"))();
                oUCFInstance = new (UCF_ClassLoader["oGetClass"]("UCF_ModelControl"))(oDomRef, this["oLS"], sModelId);
                this["mModels"][sModelId]["setUCFInstance"](oUCFInstance);
                this["mModels"][sModelId]["setData"](oData, false);
            }

            if ((bIsDefault && this["sDefaultModelId"] && this["sDefaultModelId"] !== sModelId)
                || !this["sDefaultModelId"]) {
                this["sDefaultModelId"] = sModelId;
                for (n in this["mModels"]) { // eslint-disable-line no-unused-vars
                    this["mModels"][sModelId]["checkUpdate"](true); //force an update of all bindings.
                }
            }
        };
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setModelData"] = 0;
        }
        ;
    }

    /**
     * Triggers the creation of a client side control tree after the page and
     * all controls where initialized
     */
    UCF_Page["prototype"]["createClientControlTrees"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["createClientControlTrees"]++;
        }
        ;
        var self = this,
            oDomRef, sControlTree = '',
            aControlTrees;

        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, "createClientControlTrees");

        oDomRef = UCF_DomUtil["$"](this["sId"] + "-controltree");
        if (!oDomRef) {
            oDomRef = UCF_DomUtil["$"](this["sId"] + "-lsx");
            if (oDomRef) {
                sControlTree = UCF_ClientControlTree["sXMLtoJSON"](oDomRef["innerHTML"], oDomRef["getAttribute"]("applyto"));
            }
        } else {
            sControlTree = oDomRef["innerHTML"];
        }

        if (oDomRef) {
            //remove the dom ref of the controltrees
            oDomRef["parentNode"]["removeChild"](oDomRef);
        }
        if (sControlTree) {
            this["oLS"]["prepareClientSideRendering"]();
            aControlTrees = UCF_ClientControlTree["parse"](sControlTree);
            if (!UCF_JsUtil["bIsArray"](aControlTrees)) {
                aControlTrees = [aControlTrees];
            }
            if (aControlTrees && aControlTrees["length"] > 0) {
                UCF_JsUtil["forEach"](aControlTrees, function (controltree) {
                    //add the controltree and render it immediately
                    self["oLS"]["oControlFactory"]["updateClientControlTree"](new (UCF_ClassLoader["oGetClass"]("UCF_ClientControlTree"))(self["oLS"], controltree, false), false);
                });
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["createClientControlTrees"] = 0;
    }
    ;

    /**
     * Returns whether the page has models.
     * @see {@link UCF_ClientElement#getModel()}
     * @protected
     * @return {boolean} true if there is at least one model in #mModels
     */
    UCF_Page["prototype"]["hasModels"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["hasModels"]++;
        }
        ;
        var n;
        for (n in this["mModels"]) {
            return true;
        }
        ;
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["hasModels"] = 0;
    }
    ;

    /**
     * Returns the model with a given id.
     * @protected
     * @param {string} sModelId
     * @return {void|Object}
     */
    UCF_Page["prototype"]["getModel"] = function (sModelId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["getModel"]++;
        }
        ;
        if (!sModelId && this["sDefaultModelId"]) {
            sModelId = this["sDefaultModelId"];
        }
        if (!sModelId) {
            return null;
        }
        if (this["mModels"][sModelId]) {
            this["mModels"][sModelId]["oLS"] = this["oLS"];
        }
        return this["mModels"][sModelId];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["getModel"] = 0;
    }
    ;

    /**
     * Updates the model for the given model id. If no model id is given the default model is updated.
     * @public
     * @param {string} sModelId
     * @param {Object} oData
     * @param {boolean} bMerge
     */
    UCF_Page["prototype"]["updateModel"] = function (sModelId, oData, bMerge) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["updateModel"]++;
        }
        ;
        var oModel;

        if (typeof sModelId !== "string") {
            bMerge = oData;
            oData = sModelId;
            sModelId = "";
        }

        oModel = this["getModel"](sModelId);
        oModel["setData"](oData, bMerge);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["updateModel"] = 0;
    }
    ;

    /**
     * Enable JS test frameworks from inside a page (e.g. QUnit)
     * @private
     * @param {string} sType
     */
    UCF_Page["prototype"]["initTestEnvironment"] = function (sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["initTestEnvironment"]++;
        }
        ;
        if (sType === "qunit") {
            var sUrl = UCF_ResourceUtil["sGetQUnitRoot"]() + "/QUnitHelper.js";
            UCF_ClassLoader["oGetClass"]("UCF_QUnitHelper", sUrl);
            window["UCF_QUnitHelper"]["initPage"](this["oLS"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["initTestEnvironment"] = 0;
    }
    ;

    /**
     * Announce existing messages for ARIA users. Call the method always if a new message occurs on the screen.
     * A single messages is announced with type and text
     * For several messages only the message count and the hightes priority are announced e.g. 5 messages and 3 error messages.
     *
     * @param {int} iCount Number of exsting messages
     * @param {int} iErrorCount Number of existing error messages. Used only if count > 1
     * @param {int} iWarningCount Number of existing warning messages. Used only if count > 1 and errorCount < 1
     * @param {string} sText Text of the message. Used only if count=1
     * @param {MessageType} sType Type of the message. Used only if count=1. See MessageType enumeration
     *
     * @public
     */
    UCF_Page["prototype"]["ariaAlertMessage"] = function (iCount, iErrorCount, iWarningCount, sText, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["ariaAlertMessage"]++;
        }
        ;
        var sMessageText = "";

        if (!window["UCF_System"]["bIsAria"] || iCount === 0 || !this["oLS"]["oBrowserWindow"]["bIsFocussed"]()) return; //Announce messages only if the browser window is active and has the focus

        if (iCount > 1) {
            sMessageText = this["oLS"]["sGetText"]("SAPUR_MA_MESSAGES", [iCount]);
            if (iErrorCount > 0) {
                sMessageText = sMessageText + " - " + this["oLS"]["sGetText"]("SAPUR_MA_MESSAGE_ERRORS", [iErrorCount]);
            } else if (iWarningCount > 0) {
                sMessageText = sMessageText + " - " + this["oLS"]["sGetText"]("SAPUR_MA_MESSAGE_WARNINGS", [iWarningCount]);
            } // do not announce message count <> warnings/errors
        } else {
            sMessageText = UCF_AriaStateHelper["sGetMessageTypeString"](this["oLS"], sType) + ": " + sText;
        }

        UCF_AriaStateHelper["setAlert"](sMessageText);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["ariaAlertMessage"] = 0;
    }
    ;

    /**
     * Enables toggling Message Area focus with Ctrl+Shift+Alt+M
     *
     * When active, the focus can be toggled between the Message Area (or any sub-part of the Message Area like
     * Message, Filter Icon, etc.) and the target focused element.
     * The framework sets the target element when activating the feature. Once activated, a handler listens to
     * focus change events of the Page to update the target focus, if needed. In addition, a handler listens to
     * focus change events of the Message Area to update the Message Area focus, in case the user navigates/clicks
     * inside the Message Area.
     *
     * @param {string} sMessageAreaId    Id of Message Area Control
     * @param {string} sFocusedMessageId  Id of focused message (if a message is focused)
     * @param {string} sTargetFocusInfo   Focus Info of target element
     * @param {Object} oCallbackObject    Callback object, which handles the 'setFocus' call. Needed for WDA to handle
     *                                    situations where the focus is to be set inside the form.
     * @param {string} sCallbackMethod    Callback method
     * @private
     */
    UCF_Page["prototype"]["setMessageFocusToggleInfoInternal"] = function (sMessageAreaId, sFocusedMessageId, sTargetFocusInfo, oCallbackObject, sCallbackMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setMessageFocusToggleInfoInternal"]++;
        }
        ;

        var oMessageArea = null,
            sMessageFocusInfo = null,
            oChild = null;

        // Find Message Area Control
        oMessageArea = this["oLS"]["oControlFactory"]["oGetControlById"](sMessageAreaId);
        if (!oMessageArea) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "No control found for ID " + sMessageAreaId + " Cannot activate focus toggle", "Page.js(2816): setMessageFocusToggleInfoInternal");
            }
            ;
            return;
        }

        // initialize sFocusedMessageId: If not provided, use first focusable child of Message Area
        if (!sFocusedMessageId) {
            if (oMessageArea["bIsFocusable"]()) {
                sMessageFocusInfo = oMessageArea["sId"];
            } else {
                oChild = oMessageArea["oGetFirstFocusableChild"]();
                if (!oChild) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, "No focusable child control found in Message Area " + sMessageAreaId, "Page.js(2827): setMessageFocusToggleInfoInternal");
                    }
                    ;
                }
                sMessageFocusInfo = (oChild) ? oChild["sId"] : null;
            }
        } else {
            sMessageFocusInfo = sFocusedMessageId;
        }

        // inform Message Area, that focus toggle is active (for setting tutor text)
        if (UCF_JsUtil["bInstanceOf"](oMessageArea, "UCF_MessageArea") || UCF_JsUtil["bInstanceOf"](oMessageArea, "UCF_MessageBar")) {
            oMessageArea["notifyMessageFocusToggleActive"](true);
        }

        // initialize info object
        this["oMessageFocusToggleInfo"] = {
            "oMessageArea": oMessageArea,
            "oCallback": {"o": oCallbackObject, "sMethod": sCallbackMethod},
            "sTargetFocusInfo": sTargetFocusInfo,
            "sMessageFocusInfo": sMessageFocusInfo,
            "bFocusOnMsg": (sFocusedMessageId) ? true : false
        };

        // attach toggle handler
        this["oLS"]["oBrowserWindow"]["attachEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["ToggleMessageFocus"], this, "toggleMessageFocus");

        // attach a handler which is called before each request to cleanup the info object
        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["BeforeRequest"], this, "cleanupMessageFocusInfo");

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setMessageFocusToggleInfoInternal"] = 0;
    }
    ;

    /**
     * Enables toggling Message Area focus with Ctrl+Shift+Alt+M
     *
     * @param {string} sMessageAreaId    Id of Message Area Control
     * @param {string} sFocusedMessageId  Id of focused message (if a message is focused)
     * @param {string} sTargetFocusInfo   Focus Info of target element
     * @public
     */
    UCF_Page["prototype"]["setMessageFocusToggleInfo"] = function (sMessageAreaId, sFocusedMessageId, sTargetFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setMessageFocusToggleInfo"]++;
        }
        ;
        this["setMessageFocusToggleInfoInternal"](sMessageAreaId, sFocusedMessageId, sTargetFocusInfo);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setMessageFocusToggleInfo"] = 0;
    }
    ;

    /**
     * Updates Messag Focus Toggle Info (called from onlscontainerfocus)
     *
     * @param {UCF_Control} oFocusedControl     Control which currently has the focus
     * @param {string} sFocusInfo               Focus Info of new focused element
     * @private
     */
    UCF_Page["prototype"]["updateMessageFocusToggleInfo"] = function (oFocusedControl, sFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["updateMessageFocusToggleInfo"]++;
        }
        ;

        if (!this["oMessageFocusToggleInfo"]) return;

        if (!oFocusedControl) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, "No focsued Control", "Page.js(2882): updateMessageFocusToggleInfo");
            }
            ;
            return;
        }

        if (oFocusedControl === this["oMessageFocusToggleInfo"]["oMessageArea"] ||
            UCF_DomUtil["bContains"](this["oMessageFocusToggleInfo"]["oMessageArea"]["oDomRef"], oFocusedControl["oDomRef"])) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "Updating Message Focus Info: sMessageFocusInfo =  " + sFocusInfo, "Page.js(2888): updateMessageFocusToggleInfo");
            }
            ;
            this["oMessageFocusToggleInfo"]["sMessageFocusInfo"] = sFocusInfo;
            this["oMessageFocusToggleInfo"]["bFocusOnMsg"] = true;
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "Updating Target Focus Info: sTargetFocusInfo =  " + sFocusInfo, "Page.js(2892): updateMessageFocusToggleInfo");
            }
            ;
            this["oMessageFocusToggleInfo"]["sTargetFocusInfo"] = sFocusInfo;
            this["oMessageFocusToggleInfo"]["bFocusOnMsg"] = false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["updateMessageFocusToggleInfo"] = 0;
    }
    ;

    /**
     * Handler for Toggling Message Focus
     *
     * @private
     */
    UCF_Page["prototype"]["toggleMessageFocus"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["toggleMessageFocus"]++;
        }
        ;

        if (!this["oMessageFocusToggleInfo"]) return;

        var oCallback = this["oMessageFocusToggleInfo"]["oCallback"];

        if (this["oMessageFocusToggleInfo"]["bFocusOnMsg"]) {
            //Focus is on Message Area => focus target element

            this["oMessageFocusToggleInfo"]["bFocusOnMsg"] = false;
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "ToggleMessageFocus: sTargetFocusInfo = " + this["oMessageFocusToggleInfo"]["sTargetFocusInfo"], "Page.js(2913): toggleMessageFocus");
            }
            ;

            if (oCallback && oCallback["o"] && oCallback["sMethod"] && oCallback["o"][oCallback["sMethod"]]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, "ToggleMessageFocus: Call callback method to set focus", "Page.js(2916): toggleMessageFocus");
                }
                ;
                oCallback["o"][oCallback["sMethod"]](this["oMessageFocusToggleInfo"]["sTargetFocusInfo"]);

            } else if (this["oMessageFocusToggleInfo"]["sTargetFocusInfo"]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, "ToggleMessageFocus: Set focus " + this["oMessageFocusToggleInfo"]["sTargetFocusInfo"], "Page.js(2920): toggleMessageFocus");
                }
                ;
                this["oLS"]["focusElement"](this["oMessageFocusToggleInfo"]["sTargetFocusInfo"]);
            }
        } else {
            // Set Focus back to Message Area
            this["oMessageFocusToggleInfo"]["bFocusOnMsg"] = true;
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, "ToggleMessageFocus: Set focus to message " + this["oMessageFocusToggleInfo"]["sMessageFocusInfo"], "Page.js(2926): toggleMessageFocus");
            }
            ;
            this["oLS"]["focusElement"](this["oMessageFocusToggleInfo"]["sMessageFocusInfo"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["toggleMessageFocus"] = 0;
    }
    ;

    /**
     * Clears Message Focus Toggle Info (before each request)
     *
     * @private
     */
    UCF_Page["prototype"]["cleanupMessageFocusInfo"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["cleanupMessageFocusInfo"]++;
        }
        ;

        if (!this["oMessageFocusToggleInfo"]) return;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, "Cleanup MessageFocusToggleInfo", "Page.js(2939): cleanupMessageFocusInfo");
        }
        ;

        if (UCF_JsUtil["bInstanceOf"](this["oMessageFocusToggleInfo"]["oMessageArea"], "UCF_MessageArea") ||
            UCF_JsUtil["bInstanceOf"](this["oMessageFocusToggleInfo"]["oMessageArea"], "UCF_MessageBar")) {
            this["oMessageFocusToggleInfo"]["oMessageArea"]["notifyMessageFocusToggleActive"](true);
        }

        // detach toggle handler
        this["oLS"]["oBrowserWindow"]["detachEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["ToggleMessageFocus"], this, "toggleMessageFocus");

        // dettach a handler which is called before each request to cleanup the info object
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["BeforeRequest"], this, "cleanupMessageFocusInfo");

        this["oMessageFocusToggleInfo"] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["cleanupMessageFocusInfo"] = 0;
    }
    ;

    /**
     * Sets the accessibility mode for client side functionality. It does not influence the server side rendering.
     * Possible values:
     * "ARIA" to enable ARIA
     * "CLASSIC" to enable the classic 508 support
     * "NONE" to disabled accessibility
     *
     * @param {UCF_System_AccessibilityMode} sAccessibilityStd sets the accessibility mode
     *
     * @public
     */
    UCF_Page["prototype"]["setAccessibility"] = function (sAccessibilityStd) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setAccessibility"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sAccessibilityStd === 'string', "typeof sAccessibilityStd === 'string'", "Page.js(2967): setAccessibility");
        }
        ;

        this["oLS"]["setSystemParameters"]({"Accessibility": sAccessibilityStd["toUpperCase"]()});
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setAccessibility"] = 0;
    }
    ;

    /**
     * Provide internal stuff for QUnit test recording and playback
     * @private
     * @return {Object}
     */
    UCF_Page["prototype"]["oGetTestData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["oGetTestData"]++;
        }
        ;
        var o = UCF_Control.prototype["oGetTestData"]["apply"](this, arguments);

        var oBody = document["getElementsByTagName"]("BODY");
        if (!this["oTestData"]) this["oTestData"] = {};

        o["internals"]["PREVIOUS-VALUE:BODY:scrollLeft"] = this["oTestData"]["iScrollLeft"] || "";
        o["internals"]["PREVIOUS-VALUE:BODY:scrollTop"] = this["oTestData"]["iScrollTop"] || "";
        this["oTestData"]["iScrollLeft"] = o["internals"]["BODY:scrollLeft"] = oBody[0]["scrollLeft"];
        this["oTestData"]["iScrollTop"] = o["internals"]["BODY:scrollTop"] = oBody[0]["scrollTop"];

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["oGetTestData"] = 0;
    }
    ;

    /**
     *  Handle touch/mouse detection, mouse "mode" is assumed as default;
     *  note that on touch sensitive devices, a "mousemove" event is
     *  issued as follow-up of a tap gesture (and AFTER the "touchend"),
     *  so we just ignore the first "mousemove" after a "touchstart".
     *
     * @param { UCF_BrowserEvent } oEvent
     *
     * @private
     * @type {Object} oEvent  The Touchstart Event
     */
    UCF_Page["prototype"]["ontouchstart"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["ontouchstart"]++;
        }
        ;
        this["bIgnoreFirstMouseMove"] = true;

        if (!this["fForwardMouseMoveEvent"]) {
            var oSelf = this;
            // eslint-disable-next-line ur/no-memory-leaks
            this["fForwardMouseMoveEvent"] = function (oEvent) {
                if (oSelf["bIgnoreFirstMouseMove"])
                    return oSelf["bIgnoreFirstMouseMove"] = false;

                // adjust CSS
                UCF_DomUtil["removeClass"](document["body"], "lsPage--touch");
                UCF_DomUtil["removeClass"](document["body"], "lsDevice--touch");
                UCF_DomUtil["addClass"](document["body"], "lsPage--mouse");

                // adjust event handlers
                UCF_DomUtil["detachEvent"](document["body"], "mousemove", oSelf["fForwardMouseMoveEvent"]);
                delete oSelf["fForwardMouseMoveEvent"];
                return true;
            };

            // adjust CSS
            UCF_DomUtil["addClass"](document["body"], "lsPage--touch");
            UCF_DomUtil["addClass"](document["body"], "lsDevice--touch");
            UCF_DomUtil["removeClass"](document["body"], "lsPage--mouse");

            // adjust event handlers
            UCF_DomUtil["attachEvent"](document["body"], "mousemove", this["fForwardMouseMoveEvent"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["ontouchstart"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @type {boolean}
     */
    UCF_Page["bIsPageVisualizeAccesskeysEnabled"] = null;

    /**
     * @public
     * @return {boolean}
     */
    UCF_Page["prototype"]["bIsPageVisualizeAccesskeysEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["bIsPageVisualizeAccesskeysEnabled"]++;
        }
        ;
        if (typeof UCF_Page["bIsPageVisualizeAccesskeysEnabled"] !== 'boolean') {
            UCF_Page["bIsPageVisualizeAccesskeysEnabled"] = this["oLS"]["oGetRenderManager"]()["callFragment"](
                'IsEnabled',
                'FeatureFlags', {"Feature": 'Page.VisualizeAccesskeys'}
            );
        }

        return UCF_Page["bIsPageVisualizeAccesskeysEnabled"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["bIsPageVisualizeAccesskeysEnabled"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oKeydown the keydown event
     */
    UCF_Page["prototype"]["onkeydown"] = function (oKeydown) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onkeydown"]++;
        }
        ;
        /** @type {number} */
        var iKeyCode = oKeydown["iKeyCode"]();
        /** @type {HTMLDivElement[]} */
        var aAllAccesskeyRefs = [];
        /** @type {HTMLDivElement[]} */
        var aMatchingAccesskeyRefs = [];

        if (this["bIsPageVisualizeAccesskeysEnabled"]() && UCF_KeyboardHelper["bIsValidAccessKeyShortcut"](oKeydown)) {
            if (!this["bAccessKeyIsHighlighted"]) {
                UCF_DomUtil["addClass"](this["oRootRef"], 'lsHighlightAccessKeys');
                this["bAccessKeyIsHighlighted"] = true;
                oKeydown["cancelBubble"]();
                oKeydown["cancel"]();
            }
        }

        if (
            UCF_KeyboardHelper["bShouldHandleAccessKey"](oKeydown, iKeyCode)
        ) {
            if (this["bIsPageVisualizeAccesskeysEnabled"]() && this["bAccessKeyIsHighlighted"]) {
                UCF_DomUtil["removeClass"](this["oRootRef"], 'lsHighlightAccessKeys');
                this["bAccessKeyIsHighlighted"] = false;
                // oKeydown.cancelBubble();
                // oKeydown.cancel();
            }
            if (this["oCache"]["has"]('aAllAccesskeyRefs')) {
                aAllAccesskeyRefs = this["oCache"]["get"]('aAllAccesskeyRefs', aAllAccesskeyRefs);
            } else {
                aAllAccesskeyRefs = UCF_JsUtil["arrayFrom"](
                    UCF_DomUtil["querySelectorAll"]('[accesskey]')
                );
                this["oCache"]["set"]('aAllAccesskeyRefs', aAllAccesskeyRefs);
            }

            if (this["oCache"]["has"](iKeyCode)) {
                aMatchingAccesskeyRefs = this["oCache"]["get"](iKeyCode, aMatchingAccesskeyRefs);
            } else {
                aMatchingAccesskeyRefs = UCF_JsUtil["reduce"](aAllAccesskeyRefs,
                    function (aMatchingAccesskeyRefs, sAccessKeyRef) {
                        if (document["getElementById"](sAccessKeyRef["id"]) &&
                        UCF_DomUtil["bIsVisible"](sAccessKeyRef, true) &&
                        isNaN(sAccessKeyRef["accessKey"])
                            ? UCF_KeyCodes[sAccessKeyRef["accessKey"]["toUpperCase"]()] === iKeyCode
                            : UCF_KeyCodes['_' + sAccessKeyRef["accessKey"]] === iKeyCode) {
                            aMatchingAccesskeyRefs["push"](sAccessKeyRef);
                        }
                        return aMatchingAccesskeyRefs;
                    },
                    []);
                this["oCache"]["set"](iKeyCode, aMatchingAccesskeyRefs);
            }

            try {
                UCF_JsUtil["forEach"](aMatchingAccesskeyRefs, function (oAccesskeyRef) {
                    aMatchingAccesskeyRefs["splice"](oAccesskeyRef, 1);
                    oKeydown["cancelBubble"]();
                    oKeydown["cancel"]();
                    UCF_DomUtil["moveFocusDomElement"](oAccesskeyRef);
                    aMatchingAccesskeyRefs["push"](oAccesskeyRef);
                    throw 'AccessKeyFound';
                });
            } catch (e) {
                if (e !== 'AccessKeyFound') throw e;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onkeydown"] = 0;
    }
    ;

    /**
     * @protected
     * @param {UCF_BrowserEvent} oKeyup the keyup event
     */
    UCF_Page["prototype"]["onkeyup"] = function (oKeyup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onkeyup"]++;
        }
        ;
        if (!this["bIsPageVisualizeAccesskeysEnabled"]()) {
            return;
        }

        //if (UCF_KeyboardHelper.bIsValidAccessKeyShortcut(oKeyup)) {  // why not?
        if (oKeyup["oDomEvent"]["key"] === 'Alt') {
            if (this["bAccessKeyIsHighlighted"]) {
                UCF_DomUtil["removeClass"](this["oRootRef"], 'lsHighlightAccessKeys');
                this["bAccessKeyIsHighlighted"] = false;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onkeyup"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_Page["prototype"]["onPendingRequest"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["onPendingRequest"]++;
        }
        ;
        this["oCache"]["invalidate"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["onPendingRequest"] = 0;
    }
    ;

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #sFormId}
     * - {@link #sScrollingMode}
     * - {@link #sHotkeysId}
     * - {@link #sBrowserHistory}
     * - {@link #sUnloadUrl}
     * - {@link #iScrollTop}
     * - {@link #iScrollLeft}
     * - {@link #sDirtyMode}
     * - {@link #bDirty}
     * - {@link #sHash}
     * - {@link #bHashChangedNotification}
     * - {@link #bHasEventQueue}
     * - {@link #iSessionTimeout}
     * - {@link #sSessionKeepAliveUrl}
     * - {@link #sDefaultButtonId}
     * - {@link #sCustomStyle}
     * - {@link #sCustomData}
     * - {@link #sSessionTimeoutActionUrl}
     * - {@link #sSessionTimeoutActionTarget}
     * - {@link #sSessionTimeoutActionText}
     * - {@link #sSessionHandling}
     * - {@link #sSessionTimeoutBehavior}
     * - {@link #sSessionLogoutServiceName}
     * - {@link #sSessionExtendServiceName}
     * @private
     * @type {string[]}
     */
    UCF_Page["prototype"]["aAttributeNames"] = ['sFormId', 'sScrollingMode', 'sHotkeysId', 'sBrowserHistory', 'sUnloadUrl', 'iScrollTop', 'iScrollLeft', 'sDirtyMode', 'bDirty', 'sHash', 'bHashChangedNotification', 'bHasEventQueue', 'iSessionTimeout', 'sSessionKeepAliveUrl', 'sDefaultButtonId', 'sCustomStyle', 'sCustomData', 'sSessionTimeoutActionUrl', 'sSessionTimeoutActionTarget', 'sSessionTimeoutActionText', 'sSessionHandling', 'sSessionTimeoutBehavior', 'sSessionLogoutServiceName', 'sSessionExtendServiceName'];

    /**
     * Array of names of events of the control:
     * - Help
     * - ContextMenu
     * - FocusChange
     * - Hotkey
     * - Back
     * - Scroll
     * - Request
     * - Resize
     * - HashChanged
     * - DragEnter
     * - DragLeave
     * - Initialized
     * @type {string[]}
     */
    UCF_Page["prototype"]["aEventNames"] = ['Help', 'ContextMenu', 'FocusChange', 'Hotkey', 'Back', 'Scroll', 'Request', 'Resize', 'HashChanged', 'DragEnter', 'DragLeave', 'Initialized'];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * {@link #setTitle}
     * Sets the page title in the browser window
     * Parameter: {string} Title -
     *
     * {@link #setHasMargin}
     * Sets or unsets the margin of the page
     * Parameter: {bool} HasMargin -
     *
     * {@link #setBrowserHistory}
     * Sets the value for the browser history. Use the Enum value as a string in this case.
     * Parameter: {string} BrowserHistory -
     *
     * {@link #setFocus}
     * Sets the active element
     * Parameter: {string} FocusInfo - Detailed focus information that was passed with the FocusChange event or the control id to focus.
     *
     * {@link #showModalDialog}
     * Opens a modal PopupWindow. deprecated, use openModalPopup
     * Parameter: {string} Id -
     * Parameter: {string} URL -
     *
     * {@link #openModalPopup}
     * Opens a modal PopupWindow.
     * Parameter: {string} Id -
     * Parameter: {string} URL -
     *
     * {@link #closePopup}
     * Closes a PopupWindow.
     * Parameter: {string} Id -
     *
     * {@link #closeAllModalPopups}
     * Closes all internal PopupWindows.
     *
     * {@link #openExternalWindow}
     * Opens an external browser window
     * Parameter: {string} Id -
     * Parameter: {string} URL -
     * Parameter: {int} Top -
     * Parameter: {int} Left -
     * Parameter: {int} Width -
     * Parameter: {int} Height -
     * Parameter: {bool} HasMenubar -
     * Parameter: {bool} HasStatusbar -
     * Parameter: {bool} HasToolbar -
     * Parameter: {bool} HasAddressbar -
     * Parameter: {bool} bDisableOpener -
     *
     * {@link #openExternalWindowByPost}
     * Opens an external browser window
     * Parameter: {string} Id -
     * Parameter: {string} URL -
     * Parameter: {string} PostParameters -
     * Parameter: {int} Top -
     * Parameter: {int} Left -
     * Parameter: {int} Width -
     * Parameter: {int} Height -
     * Parameter: {bool} HasMenubar -
     * Parameter: {bool} HasStatusbar -
     * Parameter: {bool} HasToolbar -
     * Parameter: {bool} HasAddressbar -
     * Parameter: {bool} bDisableOpener -
     *
     * {@link #closeExternalWindow}
     * Closes an external browser window
     * Parameter: {string} Id -
     *
     * {@link #closeWindow}
     * Closes a browser window.
     *
     * {@link #setKeepAlive}
     * Sets the keepalive state for the control with the given id
     * Parameter: {string} Id -
     * Parameter: {bool} KeepAlive -
     *
     * {@link #setDragData}
     * Sets the drag data for the current drag operation
     * Parameter: {string} Data -
     * Parameter: {string} MimeType -
     * Parameter: {string} DragSessionIdId -
     *
     * {@link #downloadFile}
     * Triggers the download of the file referenced by the given URL
     * Parameter: {string} Url -
     *
     * {@link #scrollIntoView}
     * Scroll the control with the given ID into view
     * Parameter: {string} Id -
     * Parameter: {bool} AlignToTop -
     *
     * {@link #setDirty}
     * Sets the dirty flag of the page
     * Parameter: {bool} Dirty -
     *
     * {@link #print}
     * Prints the pages content area.
     *
     * {@link #setUnloadUrl}
     * Sets the unload Url that is called if the page is unloaded.
     * Parameter: {string} Url -
     *
     * {@link #redirect}
     * Redirects to a given URL. The Url can contain URL parameters. Additionally URL encoded Post Parameters can be added via PostParameter. The Method can be GET, POST
     * Parameter: {string} Method -
     * Parameter: {string} Url -
     * Parameter: {string} PostParameter -
     *
     * {@link #setHash}
     * Sets the hash of the pages URL
     * Parameter: {string} Hash -
     * Parameter: {bool} SuppressHashChanged - This parmeter has been deprecated and has no effect. The method does not fire any events when used.
     *
     * {@link #getHash}
     * Returns the currently set hash
     *
     * {@link #setHashChangedNotification}
     * Switches the hash change notification on/off if a HashChanged event is bound.
     * Parameter: {bool} HashChangedNotification - true is 'on', false is 'off'
     *
     * {@link #setDirtyMode}
     * Sets the dirty mode of the page
     * Parameter: {DirtyMode} Dirty -
     *
     * {@link #enableDataLossPopup}
     * Show browser data loss popup in case of LS is dirty. Default is false.
     * Parameter: {bool} ShowPopup -
     *
     * {@link #setScrollingMode}
     * Sets the scroll mode for the Page control. For the parameter values see enumeration 'ScrollingMode'. Default is 'NONE' - in this mode no scrollbar viualization is set and the browser default (overflow:inherit) is used.
     * Parameter: {string} ScrollingMode -
     *
     * {@link #setDefaultButtonId}
     * Changes the DefaultButtonId.
     * Parameter: {string} DefaultButtonId -
     *
     * {@link #addStyle}
     * Adds a style link to the head of the page.
     * Parameter: {string} StyleURL - The url for the style
     * Parameter: {string} StyleContent - The content for the style
     *
     * {@link #addScript}
     * Adds a script to the head of the page.
     * Parameter: {string} ScriptURL - The url of the script
     * Parameter: {string} ScriptContent - The optional content of the script
     * Parameter: {string} CustomAttributes -
     *
     * {@link #changeThemeUrl}
     * Returns the SemanticColor
     * Parameter: {string} ThemeUrl -
     *
     * {@link #addCustomStyleClass}
     * Adds a custom style class
     * Parameter: {string} ClassName -
     *
     * {@link #removeCustomStyleClass}
     * Removes a custom style class
     * Parameter: {string} ClassName -
     *
     * {@link #applyCustomStyles}
     * Adds a given array of custom styles to the page. If the object in the array are CustomStyleObects provided by CustomStyleProvider the classes are generated using less.
     * Parameter: {string} Id -
     * Parameter: {string} Styles -
     *
     * {@link #setConditionalRules}
     * Sets the rules to the page that can be used for conditional formatting of controls
     * Parameter: {string} RuleMap -
     *
     * {@link #setConditionalControlMapping}
     * Sets the controllist and the rules that apply to a control for conditional
     * Parameter: {string} ControlIdRuleMap -
     *
     * {@link #applyConditionalRules}
     * Triggers apply of a given conditional ruleset
     *
     * {@link #applyPositions}
     * DEPRECATED: Not implemented
     *
     * {@link #applyMargins}
     * DEPRECATED: Not implemented
     *
     * {@link #disableContextMenuEvent}
     * Disables the semantic event for context menus to be sent
     *
     * {@link #enableContextMenuEvent}
     * Enables the semantic event for context menus to be sent
     *
     * {@link #setPreunloadUrl}
     * Sets a Url for a specific session state to be sent via xmlHttpRequest before Unload. ServiceProviderId identifies the eventing service hub.
     * Parameter: {string} SessionState -
     * Parameter: {string} Url -
     * Parameter: {string} ServiceProviderId -
     *
     * {@link #setSessionState}
     * Sets the current session state. The validity parameter defines the validity of the sessionState. For possible values see enumeration SessionStateValidity
     * Parameter: {string} SessionState -
     * Parameter: {SessionStateValidity} Validity -
     *
     * {@link #sendPreunloadRequest}
     * Sends the Preunload request.
     *
     * {@link #loadLess}
     * Load less compiler for custom styles
     *
     * {@link #setMessageFocusToggleInfo}
     * Enables toggling Message Area Focus focus with Ctrl+Shift+Alt+M.
     * Parameter: {string} MessageAreaId - Id of Message Area Control
     * Parameter: {string} FocusedMessageId - Control Id of the message to focus, if focus is set to a message, otherwise empty
     * Parameter: {string} TargetFocusInfo - Detailed focus information that was passed with the FocusChange event or the control id to focus.
     *
     * {@link #ariaAlertMessage}
     * Announce messsages in ARIA mode
     * Parameter: {int} Count - Number of existing messages
     * Parameter: {int} ErrorCount - Number of existing error messages. Used only if count > 1
     * Parameter: {int} WarningCount - Number of existing warning messages. Used only if count > 1 and errorCount < 1
     * Parameter: {string} Text - Text of the message. Used only if count=1
     * Parameter: {MessageType} Type - Type of the message. Used only if count=1. See MessageType enumeration
     *
     * {@link #setAccessibility}
     * Sets the accessibility mode. It does not influence the server side rendering. It should be set latest on the second roundtrip. ARIA should be enabled for the Page if 508 is false. The page will not be rendered and ARIA attributes will not remove.
     * Parameter: {string} AccessibilityStd - Accessibility Standard. Supported are ARIA and NONE
     *
     * {@link #fileSelect}
     * Display a file upload dialog and retruns a promise.
     * Parameter: {string} Options - Options as JSON -  multiple: true/fale, accept: value
     *
     * @private
     * @type {string[]}
     */
    UCF_Page["prototype"]["aMethodNames"] = ['setTitle', 'setHasMargin', 'setBrowserHistory', 'setFocus', 'showModalDialog', 'openModalPopup', 'closePopup', 'closeAllModalPopups', 'openExternalWindow', 'openExternalWindowByPost', 'closeExternalWindow', 'closeWindow', 'setKeepAlive', 'setDragData', 'downloadFile', 'scrollIntoView', 'setDirty', 'print', 'setUnloadUrl', 'redirect', 'setHash', 'getHash', 'setHashChangedNotification', 'setDirtyMode', 'enableDataLossPopup', 'setScrollingMode', 'setDefaultButtonId', 'addStyle', 'addScript', 'changeThemeUrl', 'addCustomStyleClass', 'removeCustomStyleClass', 'applyCustomStyles', 'setConditionalRules', 'setConditionalControlMapping', 'applyConditionalRules', 'applyPositions', 'applyMargins', 'disableContextMenuEvent', 'enableContextMenuEvent', 'setPreunloadUrl', 'setSessionState', 'sendPreunloadRequest', 'loadLess', 'setMessageFocusToggleInfo', 'ariaAlertMessage', 'setAccessibility', 'fileSelect', 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     * Additional ID of the Form for sending of EventQueue
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sFormId"] = '';

    /**
     * Sets the scroll mode for the Page control. For the parameter values see enumeration 'ScrollingMode'. Default is 'NONE' - in this mode no scrollbar viualization is set and the browser default (overflow:inherit) is used.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sScrollingMode"] = "NONE";

    /**
     * Specifies a hotkeys collection. If hotkeys are specified the container handles the defined hotkeys locally.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sHotkeysId"] = '';

    /**
     * Allows to control the browser history buttons for back and forward navigation. Default is ENABLED, the buttons are enabled and allow normal browser history access.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sBrowserHistory"] = "ENABLED";

    /**
     * Url that is fired at the unload of the page.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sUnloadUrl"] = '';

    /**
     * The new position of the vertical scroll bar in pixels. The browser doesn't scroll if the event is not attached.
     *
     * @private
     * @type {number}
     */
    UCF_Page["prototype"]["iScrollTop"] = 0;

    /**
     * The new position of the horizontal scroll bar in pixels.  The browser doesn't scroll if the event is not attached.
     *
     * @private
     * @type {number}
     */
    UCF_Page["prototype"]["iScrollLeft"] = 0;

    /**
     * Defines the dirty mode of the page. NONE - No Dirty Mode is used. SERVER - The server will set the Dirty Flag explicitly. CLIENTSERVER - The client will set the dirty flag for all events with the markDirty flag set to true and the server can mark the dirty flag explicitly. NONE will be the default.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sDirtyMode"] = "CLIENTSERVER";

    /**
     * Defines the the page is currently dirty. Use this flag together with the DirtyMode SERVER or CLIENTSERVER
     *
     * @private
     * @type {boolean}
     */
    UCF_Page["prototype"]["bDirty"] = false;

    /**
     * The hash that was processed by the server.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sHash"] = '';

    /**
     * Switches the hash change notification on/off if a HashChanged event is bound.
     *
     * @private
     * @type {boolean}
     */
    UCF_Page["prototype"]["bHashChangedNotification"] = true;

    /**
     * Specifies whether page keeps default event queue. When disabled (false), then the FormId parameter have to specify a valid Form with own event queue
     *
     * @private
     * @type {boolean}
     */
    UCF_Page["prototype"]["bHasEventQueue"] = true;

    /**
     * Sets the session timeout on the server in seconds for the application. If the value is set, a session timeout warning dialogue will be displayed before the session is destroyed.
     *
     * @private
     * @type {number}
     */
    UCF_Page["prototype"]["iSessionTimeout"] = 0;

    /**
     * Sets the keepalive URL which can be used to prolong the session timeout on the server. If the url contains the variable $time it will be replaced by the elapsed time since the last user interaction in seconds.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionKeepAliveUrl"] = '';

    /**
     * This parameter has the default button Id for the Page
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sDefaultButtonId"] = '';

    /**
     * Sets the custom style class for a control.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sCustomStyle"] = '';

    /**
     * Sets a custom data string that can be retrieved on the client via method sGetCustomData() or getCustomData(sJsonPropertyName) in case it is a JSON string
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sCustomData"] = '';

    /**
     * URL to trigger for the action-button in the session-timeout system-popup. It will be shown instead of the default close-button
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionTimeoutActionUrl"] = '';

    /**
     * The target (like target attribute of a link, e.g. _TOP, _BLANK) for the action URL
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionTimeoutActionTarget"] = '';

    /**
     * The text for the session-timeout action-button
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionTimeoutActionText"] = '';

    /**
     * Once unloadURL is provided the session handling will be synchronous or asynchronous. Default is to use synchronous session handling where possible otherwise asynchronous.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionHandling"] = "DEFAULT";

    /**
     * Determines how to react on timeout events.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionTimeoutBehavior"] = "PAGE";

    /**
     * The postmessage service called for logging off.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionLogoutServiceName"] = 'sap.ushell.sessionHandler.logout';

    /**
     * The postmessage service called for extending the session.
     *
     * @private
     * @type {string}
     */
    UCF_Page["prototype"]["sSessionExtendServiceName"] = 'sap.ushell.sessionHandler.extendSession';


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_Page["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["setDefaultValues"]++;
        }
        ;
        this["sFormId"] = '';
        this["sScrollingMode"] = "NONE";
        this["sHotkeysId"] = '';
        this["sBrowserHistory"] = "ENABLED";
        this["sUnloadUrl"] = '';
        this["iScrollTop"] = 0;
        this["iScrollLeft"] = 0;
        this["sDirtyMode"] = "CLIENTSERVER";
        this["bDirty"] = false;
        this["sHash"] = '';
        this["bHashChangedNotification"] = true;
        this["bHasEventQueue"] = true;
        this["iSessionTimeout"] = 0;
        this["sSessionKeepAliveUrl"] = '';
        this["sDefaultButtonId"] = '';
        this["sCustomStyle"] = '';
        this["sCustomData"] = '';
        this["sSessionTimeoutActionUrl"] = '';
        this["sSessionTimeoutActionTarget"] = '';
        this["sSessionTimeoutActionText"] = '';
        this["sSessionHandling"] = "DEFAULT";
        this["sSessionTimeoutBehavior"] = "PAGE";
        this["sSessionLogoutServiceName"] = 'sap.ushell.sessionHandler.logout';
        this["sSessionExtendServiceName"] = 'sap.ushell.sessionHandler.extendSession';

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', "NONE", true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', "ENABLED", true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', 0, true);
            this["setClientProperty"]('', 0, true);
            this["setClientProperty"]('', "CLIENTSERVER", true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', 0, true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', "DEFAULT", true);
            this["setClientProperty"]('', "PAGE", true);
            this["setClientProperty"]('', 'sap.ushell.sessionHandler.logout', true);
            this["setClientProperty"]('', 'sap.ushell.sessionHandler.extendSession', true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    /**
     * Help event (triggered by pressing F1)
     *
     * @private
     * @param {string} sId The Id of the page control
     * @param {string} sControlId The Id of the control where the event occured
     * @fires Page:Help
     */
    UCF_Page["prototype"]["fireHelp"] = function (sId, sControlId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireHelp"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, ControlId: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 2, "arguments.length == 2", "Page.js(3708): fireHelp");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3709): fireHelp");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3710): fireHelp");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControlId != null, "sControlId != null", "Page.js(3711): fireHelp");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControlId === 'string', "typeof sControlId === 'string'", "Page.js(3712): fireHelp");
        }
        ;

        mParams = {
            "Id": sId,
            "ControlId": sControlId
        };
        if (sControlId) {
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sControlId);

            if (oControl) {
                oControl["enrichSemanticEventParamsWithBindingContext"](mParams, 'ControlId');
            }
        }

        this["fireSemanticEvent"]('Page', 'Help', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireHelp"] = 0;
    }
    ;

    /**
     * Context menu event (triggered by right click, context menu key or Shift-F10)
     *
     * @private
     * @param {string} sId The Id of the page control
     * @param {string} sControlId The Id of the control where the event occured
     * @param {number} iPosX The horizontal position
     * @param {number} iPosY The vertical position
     * @param {boolean} bShift Indicates whether the shift key was pressed when the event occured.
     * @param {boolean} bCtrl Indicates whether the control key was pressed when the event occured.
     * @param {boolean} bAlt Indicates whether the alt key was pressed when the event occured.
     * @fires Page:ContextMenu
     */
    UCF_Page["prototype"]["fireContextMenu"] = function (sId, sControlId, iPosX, iPosY, bShift, bCtrl, bAlt) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireContextMenu"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, ControlId: string, PosX: number, PosY: number, Shift: boolean, Ctrl: boolean, Alt: boolean}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 7, "arguments.length == 7", "Page.js(3748): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3749): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3750): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControlId != null, "sControlId != null", "Page.js(3751): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControlId === 'string', "typeof sControlId === 'string'", "Page.js(3752): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iPosX != null, "iPosX != null", "Page.js(3753): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iPosX === 'number', "typeof iPosX === 'number'", "Page.js(3754): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iPosY != null, "iPosY != null", "Page.js(3755): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iPosY === 'number', "typeof iPosY === 'number'", "Page.js(3756): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bShift != null, "bShift != null", "Page.js(3757): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bShift === 'boolean', "typeof bShift === 'boolean'", "Page.js(3758): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bCtrl != null, "bCtrl != null", "Page.js(3759): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bCtrl === 'boolean', "typeof bCtrl === 'boolean'", "Page.js(3760): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bAlt != null, "bAlt != null", "Page.js(3761): fireContextMenu");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bAlt === 'boolean', "typeof bAlt === 'boolean'", "Page.js(3762): fireContextMenu");
        }
        ;

        mParams = {
            "Id": sId,
            "ControlId": sControlId,
            "PosX": Math["round"](iPosX),
            "PosY": Math["round"](iPosY),
            "Shift": bShift,
            "Ctrl": bCtrl,
            "Alt": bAlt
        };
        if (sControlId) {
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sControlId);

            if (oControl) {
                oControl["enrichSemanticEventParamsWithBindingContext"](mParams, 'ControlId');
            }
        }

        this["fireSemanticEvent"]('Page', 'ContextMenu', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireContextMenu"] = 0;
    }
    ;

    /**
     * Fires if the focus moves a another control
     *
     * @private
     * @param {string} sId The control where the event occured
     * @param {string} sControlId The id of the control that got the focus.
     * @param {string} sLastFocusedId The id of the control that had the focus before.
     * @param {string} sFocusInfo Detailed focus information including cursor position and internal control settings. Pass this string to the method setFocus() on the page to the client in order to apply the focus information again after a roundtrip.
     * @fires Page:FocusChange
     */
    UCF_Page["prototype"]["fireFocusChange"] = function (sId, sControlId, sLastFocusedId, sFocusInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireFocusChange"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, ControlId: string, LastFocusedId: string, FocusInfo: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 4, "arguments.length == 4", "Page.js(3800): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3801): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3802): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControlId != null, "sControlId != null", "Page.js(3803): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControlId === 'string', "typeof sControlId === 'string'", "Page.js(3804): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sLastFocusedId != null, "sLastFocusedId != null", "Page.js(3805): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sLastFocusedId === 'string', "typeof sLastFocusedId === 'string'", "Page.js(3806): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sFocusInfo != null, "sFocusInfo != null", "Page.js(3807): fireFocusChange");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sFocusInfo === 'string', "typeof sFocusInfo === 'string'", "Page.js(3808): fireFocusChange");
        }
        ;

        mParams = {
            "Id": sId,
            "ControlId": sControlId,
            "LastFocusedId": sLastFocusedId,
            "FocusInfo": sFocusInfo
        };
        if (sControlId) {
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sControlId);

            if (oControl) {
                oControl["enrichSemanticEventParamsWithBindingContext"](mParams, 'ControlId');
            }
        }
        if (sLastFocusedId) {
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sLastFocusedId);

            if (oControl) {
                oControl["enrichSemanticEventParamsWithBindingContext"](mParams, 'LastFocusedId');
            }
        }

        this["fireSemanticEvent"]('Page', 'FocusChange', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireFocusChange"] = 0;
    }
    ;

    /**
     * Event fires when a hotkey occurs which is specified in the Hotkeys collection with the parameter HotkeysId.
     *
     * @private
     * @param {string} sId Identifier of the control
     * @param {string} sHotkey The fired hotkey
     * @param {string} sProviderId ID of the hotkey provider
     * @param {string} sControlId The Id of the control where the event occured
     * @fires Page:Hotkey
     */
    UCF_Page["prototype"]["fireHotkey"] = function (sId, sHotkey, sProviderId, sControlId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireHotkey"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Hotkey: string, ProviderId: string, ControlId: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 4, "arguments.length == 4", "Page.js(3850): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3851): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3852): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sHotkey != null, "sHotkey != null", "Page.js(3853): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHotkey === 'string', "typeof sHotkey === 'string'", "Page.js(3854): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sProviderId != null, "sProviderId != null", "Page.js(3855): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sProviderId === 'string', "typeof sProviderId === 'string'", "Page.js(3856): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControlId != null, "sControlId != null", "Page.js(3857): fireHotkey");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControlId === 'string', "typeof sControlId === 'string'", "Page.js(3858): fireHotkey");
        }
        ;

        mParams = {
            "Id": sId,
            "Hotkey": sHotkey,
            "ProviderId": sProviderId,
            "ControlId": sControlId
        };
        if (sControlId) {
            oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sControlId);

            if (oControl) {
                oControl["enrichSemanticEventParamsWithBindingContext"](mParams, 'ControlId');
            }
        }

        this["fireSemanticEvent"]('Page', 'Hotkey', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireHotkey"] = 0;
    }
    ;

    /**
     * Event fires if the user hits the back button of the browser history
     *
     * @private
     * @param {string} sId The Id of the page control
     * @fires Page:Back
     */
    UCF_Page["prototype"]["fireBack"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireBack"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 1, "arguments.length == 1", "Page.js(3890): fireBack");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3891): fireBack");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3892): fireBack");
        }
        ;

        mParams = {
            "Id": sId
        };

        this["fireSemanticEvent"]('Page', 'Back', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireBack"] = 0;
    }
    ;

    /**
     * Event fires when the user scrolls either vertically or horizontally.
     *
     * @private
     * @param {string} sId Identifier of the control
     * @param {number} iScrollTop The new position of the vertical scroll bar in pixels.
     * @param {number} iScrollLeft The new position of the horizontal scroll bar in pixels.
     * @fires Page:Scroll
     */
    UCF_Page["prototype"]["fireScroll"] = function (sId, iScrollTop, iScrollLeft) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireScroll"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, ScrollTop: number, ScrollLeft: number}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 3, "arguments.length == 3", "Page.js(3916): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3917): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3918): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iScrollTop != null, "iScrollTop != null", "Page.js(3919): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iScrollTop === 'number', "typeof iScrollTop === 'number'", "Page.js(3920): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iScrollLeft != null, "iScrollLeft != null", "Page.js(3921): fireScroll");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iScrollLeft === 'number', "typeof iScrollLeft === 'number'", "Page.js(3922): fireScroll");
        }
        ;

        mParams = {
            "Id": sId,
            "ScrollTop": Math["round"](iScrollTop),
            "ScrollLeft": Math["round"](iScrollLeft)
        };

        this["fireSemanticEvent"]('Page', 'Scroll', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireScroll"] = 0;
    }
    ;

    /**
     * Event fires if a request is send to the server
     *
     * @private
     * @param {string} sId Identifier of the page control
     * @param {boolean} bAsync Determines whether the request is sent synchronously (false,default) or asynchronously(true)
     * @param {string} sFocusInfo Detailed focus information including cursor position and internal control settings. Pass this string to the method setFocus() on the page to the client in order to apply the focus information again after a roundtrip.
     * @param {string} sHash Hash part of the current URL
     * @param {boolean} bDomChanged Determines whether the client side browser dom was changed on the client by a user interaction after the last request.
     * @param {boolean} bIsDirty Deterimines the current value of Dirty Flag needed for WorkProtect feature.
     * @fires Page:Request
     */
    UCF_Page["prototype"]["fireRequest"] = function (sId, bAsync, sFocusInfo, sHash, bDomChanged, bIsDirty) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireRequest"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Async: boolean, FocusInfo: string, Hash: string, DomChanged: boolean, IsDirty: boolean}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 6, "arguments.length == 6", "Page.js(3951): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3952): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3953): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bAsync != null, "bAsync != null", "Page.js(3954): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bAsync === 'boolean', "typeof bAsync === 'boolean'", "Page.js(3955): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sFocusInfo != null, "sFocusInfo != null", "Page.js(3956): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sFocusInfo === 'string', "typeof sFocusInfo === 'string'", "Page.js(3957): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sHash != null, "sHash != null", "Page.js(3958): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === 'string', "typeof sHash === 'string'", "Page.js(3959): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bDomChanged != null, "bDomChanged != null", "Page.js(3960): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bDomChanged === 'boolean', "typeof bDomChanged === 'boolean'", "Page.js(3961): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(bIsDirty != null, "bIsDirty != null", "Page.js(3962): fireRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bIsDirty === 'boolean', "typeof bIsDirty === 'boolean'", "Page.js(3963): fireRequest");
        }
        ;

        mParams = {
            "Id": sId,
            "Async": bAsync,
            "FocusInfo": sFocusInfo,
            "Hash": sHash,
            "DomChanged": bDomChanged,
            "IsDirty": bIsDirty
        };

        this["fireSemanticEvent"]('Page', 'Request', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireRequest"] = 0;
    }
    ;

    /**
     * Event fires when the window was resized and this causes a resize of the page
     *
     * @private
     * @param {string} sId Identifier of the control
     * @param {number} iWidth Width after the resize operation
     * @param {number} iHeight Height after the resize operation
     * @fires Page:Resize
     */
    UCF_Page["prototype"]["fireResize"] = function (sId, iWidth, iHeight) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireResize"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Width: number, Height: number}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 3, "arguments.length == 3", "Page.js(3992): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(3993): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(3994): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iWidth != null, "iWidth != null", "Page.js(3995): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iWidth === 'number', "typeof iWidth === 'number'", "Page.js(3996): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iHeight != null, "iHeight != null", "Page.js(3997): fireResize");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iHeight === 'number', "typeof iHeight === 'number'", "Page.js(3998): fireResize");
        }
        ;

        mParams = {
            "Id": sId,
            "Width": Math["round"](iWidth),
            "Height": Math["round"](iHeight)
        };

        this["fireSemanticEvent"]('Page', 'Resize', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireResize"] = 0;
    }
    ;

    /**
     * Fires if the location hash changed
     *
     * @private
     * @param {string} sId Identifier of the control.
     * @param {string} sHash The new hash of the page.
     * @param {string} sPreviousHash The old hash of the page.
     * @fires Page:HashChanged
     */
    UCF_Page["prototype"]["fireHashChanged"] = function (sId, sHash, sPreviousHash) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireHashChanged"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Hash: string, PreviousHash: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 3, "arguments.length == 3", "Page.js(4024): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(4025): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(4026): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sHash != null, "sHash != null", "Page.js(4027): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sHash === 'string', "typeof sHash === 'string'", "Page.js(4028): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sPreviousHash != null, "sPreviousHash != null", "Page.js(4029): fireHashChanged");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sPreviousHash === 'string', "typeof sPreviousHash === 'string'", "Page.js(4030): fireHashChanged");
        }
        ;

        mParams = {
            "Id": sId,
            "Hash": sHash,
            "PreviousHash": sPreviousHash
        };

        this["fireSemanticEvent"]('Page', 'HashChanged', mParams, false, true, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireHashChanged"] = 0;
    }
    ;

    /**
     * Event fires if the dragged element enters the page
     *
     * @private
     * @param {string} sId Identifier of the control.
     * @fires Page:DragEnter
     */
    UCF_Page["prototype"]["fireDragEnter"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireDragEnter"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 1, "arguments.length == 1", "Page.js(4054): fireDragEnter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(4055): fireDragEnter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(4056): fireDragEnter");
        }
        ;

        mParams = {
            "Id": sId
        };

        this["fireSemanticEvent"]('Page', 'DragEnter', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireDragEnter"] = 0;
    }
    ;

    /**
     * Event fires if the dragged element leaves the page
     *
     * @private
     * @param {string} sId Identifier of the control.
     * @fires Page:DragLeave
     */
    UCF_Page["prototype"]["fireDragLeave"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireDragLeave"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 1, "arguments.length == 1", "Page.js(4078): fireDragLeave");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(4079): fireDragLeave");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(4080): fireDragLeave");
        }
        ;

        mParams = {
            "Id": sId
        };

        this["fireSemanticEvent"]('Page', 'DragLeave', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireDragLeave"] = 0;
    }
    ;

    /**
     * Fires if the page has been initialized
     *
     * @private
     * @param {string} sId The control where the event occured
     * @fires Page:Initialized
     */
    UCF_Page["prototype"]["fireInitialized"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Page["_"]["fireInitialized"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 1, "arguments.length == 1", "Page.js(4102): fireInitialized");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "Page.js(4103): fireInitialized");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "Page.js(4104): fireInitialized");
        }
        ;

        mParams = {
            "Id": sId
        };

        this["fireSemanticEvent"]('Page', 'Initialized', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Page["_"]["fireInitialized"] = 0;
    }
    ;

    UCF_Page.prototype["aPublicMethods"] = ["setPreunloadUrl", "setSessionState", "disableContextMenuEvent", "enableContextMenuEvent", "setScrollPosition", "setTitle", "setHasMargin", "openModalPopup", "closePopup", "closeAllModalPopups", "openExternalWindow", "openExternalWindowByPost", "closeExternalWindow", "closeWindow", "setFocus", "setKeepAlive", "addStyle", "addScript", "setDragData", "downloadFile", "fileSelect", "scrollIntoView", "setDirty", "print", "setUnloadUrl", "redirect", "setDirtyMode", "setBrowserHistory", "setHash", "getHash", "setHashChangedNotification", "setScrollingMode", "sGetScrollingMode", "changeThemeUrl", "addCustomStyleClass", "removeCustomStyleClass", "applyCustomStyles", "loadLess", "setConditionalRules", "setConditionalControlMapping", "applyConditionalRules", "setDefaultButtonId", "updateModel", "ariaAlertMessage", "setMessageFocusToggleInfo", "setAccessibility", "bIsPageVisualizeAccesskeysEnabled"].concat(UCF_Page.prototype.aPublicMethods || []);
    /* global UCF_Exception */

/// <reference path="./Exception.js"/>

    /**
     * ParseException class
     *
     * This exception is thrown, when a parse error occurs while converting a
     * string value to a specific property type in the model.
     * @param {string} message exception message
     */
    function UCF_ParseException(message) {
        if (__UCF_COVERAGE__) {
            UCF_ParseException["_"]["UCF_ParseException"]++;
        }
        ;
        if (arguments["length"] === 0) return;

        this["name"] = "ParseException"; // eslint-disable-line ur/no-memory-leaks
        this["message"] = message;       // eslint-disable-line ur/no-memory-leaks
    };window["UCF_ParseException"] = UCF_ParseException;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ParseException");
        UCF_ParseException["_"] = {UCF_ParseException: 0};
    }
    ;
    ;
    UCF_ParseException["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Exception"))();
    UCF_ParseException.prototype["sClassName"] = "UCF_ParseException";


    UCF_ParseException["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ParseException["_"]["destroy"]++;
        }
        ;
        UCF_Exception.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ParseException["_"]["destroy"] = 0;
    }
    ;


    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_FesrUtil */
/// <reference path="../../core/util/FesrUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_PerformanceLog */
/// <reference path="./PerformanceLog.js"/>
    /* global UCF_System */
/// <reference path="./System.js"/>
    /* global  _assert,_trace,INFO, DEBUG, WARNING */
/// <reference path="../../core/debug/Tracer.js"/>
    /* eslint consistent-this:0 */

    /**
     * Performance-measurements for the LightSpeed framework. Attaches to internal
     * LightSpeed events, converts them to "Marks" (i.e. measured points in time),
     * and constructs "Ranges" (i.e. spans between two marks) which are measured.
     *
     * Emits "Mark" and "Range" events whenever one of them happens. Internally
     * attaches a UCF_PerformanceLog to those events, which will log to the console
     * and create timeStamp entries. Attach to those events as well for
     * different purposes (e.g. testing, creation of Frontend Subrecords etc.)
     *
     *
     * @class UCF_Performance
     * @extends UCF_EventProvider
     * @param {UCF_LS} oLS the Lightspeed instance to measure
     */
    function UCF_Performance(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["UCF_Performance"]++;
        }
        ;
        /** @type {UCF_Performance} */
        /* pseudo coding once the ITS will not register serveral event handlers
		var self;
	*/

        if (arguments["length"] > 0) {
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oLS, 'UCF_LS'), "UCF_JsUtil.bInstanceOf(oLS, 'UCF_LS')", "Performance.js(39): UCF_Performance");
            }
            ;

            UCF_EventProvider["apply"](this, [oLS]); // super() call

            this["defineEvents"](['Range', 'Mark']);

            /** @type {UCF_LS} */
            this["oLS"] = oLS;

            /** @type {Object.<string,number>} */
            this["oTimestamps"] = window["sap"]["ls"]["performance"] || {};

            /** @type {number} assume 2-roundtrip-start */
            this["iRoundTripsUntilStartup"] = 1;

            /** @type {number} all roundtrips that have been completed since constructor */
            this["iRoundTrips"] = 0;

            /** @type {UCF_PopupManager}  popup manager of main LS*/
            this["oMainPopupManager"] = this["oLS"]["oGetPopupManagerInternal"]();

            /** @type {integer}  number of open popups */
            this["iPopupWindowCount"] = 0;

            /**
             * Logging is implemented with an event listener mainly to allow multiple
             * log targets (e.g. a QUnit test log function that asserts instead of
             * printing, or a FESR-creating function that filters only the necessary
             * ranges).
             *
             * @type {UCF_PerformanceLog} the log target
             */
            if (window["UCF_System"]["bIsDebugLevelActive"](window["UCF_System"]["E_LOG_LEVELS"]["Performance"])) {
                this["oLog"] = new (UCF_ClassLoader["oGetClass"]("UCF_PerformanceLog"))(this["oLS"]);
                this["attachEvent"](this["E_EVENTS"]["Range"], this["oLog"], 'log');
                this["attachEvent"](this["E_EVENTS"]["Mark"], this["oLog"], 'timeStamp');
            }

            UCF_DomUtil["removeFromDom"](UCF_DomUtil["$"]('ls-performance-render-timestamp'));

            this["oLS"]["attachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeControlsInitialized"], this, 'onBeforeControlsInitialized');
            this["oLS"]["attachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeUpdateDocument"], this, 'onBeforeUpdateDocument');
            this["oLS"]["attachBeforeEvent"](this["oLS"]["E_EVENTS"]["AfterResponse"], this, 'onAfterResponse');
            this["oLS"]["attachAfterEvent"](this["oLS"]["E_EVENTS"]["UpdateDocumentComplete"], this, 'onUpdateDocumentComplete');
            this["oLS"]["attachAfterEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, 'onControlsInitialized');
            this["oLS"]["attachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeRequest"], this, 'onBeforeRequest');
            this["oLS"]["attachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeSemanticEvent"], this, 'onBeforeSemanticEvent');
            this["oLS"]["attachAfterEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, 'onUnlock');
            this["oLS"]["oBrowserWindow"]["attachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["AnyEvent"], this, 'onAnyEvent');
            this["oMainPopupManager"]["attachAfterEvent"](this["oMainPopupManager"]["E_EVENTS"]["WindowOpen"], this, 'onIframePopupOpen');
            this["oMainPopupManager"]["attachAfterEvent"](this["oMainPopupManager"]["E_EVENTS"]["WindowClose"], this, 'onIframePopupClose');

            if (!UCF_Performance["MARKS_INVERSE"]) {
                /** @type {Object.<number,string>} */
                UCF_Performance["MARKS_INVERSE"] = UCF_JsUtil["reduce"](
                    UCF_JsUtil["keys"](UCF_Performance["MARKS"]),
                    function (oMarksInverse, sKey) {
                        oMarksInverse[UCF_Performance["MARKS"][sKey]] = sKey;

                        return oMarksInverse;
                    }, {}
                );
            }

            this["onMark"](UCF_Performance["MARKS"]["LightspeedConstructor"]);
        }
    };window["UCF_Performance"] = UCF_Performance;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Performance");
        UCF_Performance["_"] = {UCF_Performance: 0};
    }
    ;
    ;
    UCF_Performance["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_Performance.prototype["sClassName"] = "UCF_Performance";

    /** @type {Object.<string,number>} */
    UCF_Performance["MARKS"] = {
        "BeforeHtmlParse": 0, // window.sap.ls.performance["0"] is set in page renderer
        "LightspeedConstructor": 1,
        "BeforeControlsInitialized": 2,
        "ControlsInitialized": 3,
        "AnyEvent": 4,
        "BeforeRequest": 5,
        "AfterResponse": 6,
        "BeforeUpdateDocument": 7,
        "UpdateDocumentComplete": 8,
        "Unlock": 9
    };

    /**
     * @example
     * UCF_Performance.sGetMarkName(UCF_Performance.MARKS.Unlock) // => 'Unlock'
     * UCF_Performance.sGetMarkName(0) // => 'BeforeHtmlParse'
     * @private
     * @static
     * @param {number} iMark the mark id
     * @return {string} the mark name
     */
    UCF_Performance["sGetMarkName"] = function (iMark) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["sGetMarkName"]++;
        }
        ;
        return UCF_Performance["MARKS_INVERSE"][iMark];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["sGetMarkName"] = 0;
    }
    ;

    /**
     * @typedef {Object} PerformanceRange
     * @property {number} iStart UCF_Performance.MARKS to calculate the range from
     * @property {number} iEnd UCF_Performance.MARKS to store when range is emitted
     * @property {number} [iThreshold=UCF_Performance.FRAME_MS] threshold when to consider
     * the range as "slow"
     * @property {function(UCF_Performance): boolean} [fWhen] predicate when to emit
     * the range (in addition to iEnd and iTimes)
     * @property {number} [iTimes] number of times to emit the range
     * @property {string} sName
     */
    /** @type {Array.<PerformanceRange>} */
    UCF_Performance["RANGES"] = [{
        "sName": 'Application Startup (HTML parse/asset load .. LS startup .. ClientInspector .. PageUpdate .. Unlock)',
        "iStart": UCF_Performance["MARKS"]["BeforeHtmlParse"],
        "iEnd": UCF_Performance["MARKS"]["Unlock"],
        "iThreshold": 500,
        "fWhen": UCF_Performance["bIsStartupRoundtrip"],
        "iTimes": 1
    }, {
        "sName": 'HTML parse + asset load',
        "iStart": UCF_Performance["MARKS"]["BeforeHtmlParse"],
        "iEnd": UCF_Performance["MARKS"]["LightspeedConstructor"],
        "iThreshold": 150
    }, {
        "sName": 'Lightspeed Startup',
        "iStart": UCF_Performance["MARKS"]["LightspeedConstructor"],
        "iEnd": UCF_Performance["MARKS"]["ControlsInitialized"],
        "iThreshold": 350,
        "iTimes": 1
    }, {
        "sName": 'Event->Request',
        "iStart": UCF_Performance["MARKS"]["AnyEvent"],
        "iEnd": UCF_Performance["MARKS"]["BeforeRequest"],
        "iThreshold": 50
    }, {
        "sName": 'Request->Response',
        "iStart": UCF_Performance["MARKS"]["BeforeRequest"],
        "iEnd": UCF_Performance["MARKS"]["AfterResponse"],
        "iThreshold": 200
    }, {
        "sName": 'Response->Unlock',
        "iStart": UCF_Performance["MARKS"]["AfterResponse"],
        "iEnd": UCF_Performance["MARKS"]["Unlock"],
        "iThreshold": 250
    }, {
        "sName": 'InitializeIds',
        "iStart": UCF_Performance["MARKS"]["BeforeControlsInitialized"],
        "iEnd": UCF_Performance["MARKS"]["ControlsInitialized"],
        "iThreshold": 50
    }, {
        "sName": 'PageUpdate',
        "iStart": UCF_Performance["MARKS"]["BeforeUpdateDocument"],
        "iEnd": UCF_Performance["MARKS"]["UpdateDocumentComplete"],
        "iThreshold": 75
    }, {
        "sName": 'Roundtrip (Event .. Request .. Response .. Update .. Unlock)',
        "iStart": UCF_Performance["MARKS"]["AnyEvent"],
        "iEnd": UCF_Performance["MARKS"]["Unlock"],
        "iThreshold": 500
    }];

    UCF_Performance["bIsStartupRoundtrip"] = function (self) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["bIsStartupRoundtrip"]++;
        }
        ;
        return self["iRoundTripsUntilStartup"] >= self["iRoundTrips"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["bIsStartupRoundtrip"] = 0;
    }
    ;

    /**
     * @private
     * @return {UCF_LS} oLS the LS instance of the focused popup window
     */
    UCF_Performance["prototype"]["oGetPopupLS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["oGetPopupLS"]++;
        }
        ;
        /** @type {string} */
        var sPopupWindowId = this["oMainPopupManager"]["sGetFocusedPopupId"]();
        /** @type {UCF_LS} */
        var oPopupLS = null;
        /** @type {string} */
        var sThisWindowId = this["oMainPopupManager"]["sGetPopupIdByWindow"](window);

        if (sPopupWindowId && sPopupWindowId !== sThisWindowId) {
            oPopupLS = this["oMainPopupManager"]["oGetLSByPopupId"](sPopupWindowId);
        }

        return oPopupLS;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["oGetPopupLS"] = 0;
    }
    ;

    /** @private */
    UCF_Performance["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["destroy"]++;
        }
        ;
        if (this["oLog"]) {
            this["detachEvent"](this["E_EVENTS"]["Range"], this["oLog"], 'log');
            this["detachEvent"](this["E_EVENTS"]["Mark"], this["oLog"], 'timeStamp');
            this["oLog"]["destroy"]();
            this["oLog"] = null;
        }
        this["oLS"]["oBrowserWindow"]["detachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["AnyEvent"], this, 'onAnyEvent');
        this["oLS"]["detachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeControlsInitialized"], this, 'onBeforeControlsInitialized');
        this["oLS"]["detachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeUpdateDocument"], this, 'onBeforeUpdateDocument');
        this["oLS"]["detachBeforeEvent"](this["oLS"]["E_EVENTS"]["AfterResponse"], this, 'onAfterResponse');
        this["oLS"]["detachAfterEvent"](this["oLS"]["E_EVENTS"]["UpdateDocumentComplete"], this, 'onUpdateDocumentComplete');
        this["oLS"]["detachAfterEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, 'onControlsInitialized');
        this["oLS"]["detachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeSemanticEvent"], this, 'onBeforeSemanticEvent');
        this["oLS"]["detachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeRequest"], this, 'onBeforeRequest');
        this["oLS"]["detachAfterEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, 'onUnlock');
        this["oMainPopupManager"]["detachAfterEvent"](this["oMainPopupManager"]["E_EVENTS"]["WindowOpen"], this, 'onIframePopupOpen');
        this["oMainPopupManager"]["detachAfterEvent"](this["oMainPopupManager"]["E_EVENTS"]["WindowClose"], this, 'onIframePopupClose');

        this["iPopupWindowCount"] = null;
        this["oMainPopupManager"] = null;
        this["oTimestamps"] = null;
        this["oLS"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["destroy"] = 0;
    }
    ;

    /**
     * @private
     * @return {number} the current timestamp in milliseconds
     * granularity, if possible
     */
    UCF_Performance["iNow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["iNow"]++;
        }
        ;
        return new Date()["getTime"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["iNow"] = 0;
    }
    ;

    /**
     * @see UCF_Performance.MARKS
     * @param {number} iMark the timestamp-id to get
     * @return {number} the current timestamp registered for iMark
     */
    UCF_Performance["prototype"]["iGetTimestamp"] = function (iMark) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["iGetTimestamp"]++;
        }
        ;
        return this["oTimestamps"][iMark];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["iGetTimestamp"] = 0;
    }
    ;

    /**
     * @private
     * @see UCF_Performance.MARKS
     * @param {number} iMark the timestamp-id to set
     * @param {number} [iTime=UCF_Performance.iNow()] the timestamp to register for
     * iMark
     * @param {boolean} [bHideTimelineEntry=false] set `false` to create a timeline
     * entry (`true` to not create an entry)
     */
    UCF_Performance["prototype"]["putTimestamp"] = function (iMark, iTime, bHideTimelineEntry) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["putTimestamp"]++;
        }
        ;

        if (!iTime) {
            iTime = UCF_Performance["iNow"]();
        }

        this["oTimestamps"][iMark] = iTime;
        if (!bHideTimelineEntry) {
            this["fireMark"](iMark);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["putTimestamp"] = 0;
    }
    ;

    /**
     * @private
     * @see UCF_Performance.MARKS
     * @param {number} iMark the timestamp to delete
     */
    UCF_Performance["prototype"]["deleteTimestamp"] = function (iMark) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["deleteTimestamp"]++;
        }
        ;
        delete this["oTimestamps"][iMark];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["deleteTimestamp"] = 0;
    }
    ;

// ===== handlers =============================================================

// ----- generic mark handler -------------------------------------------------

    /**
     * For a given performance mark, fires all ending ranges, by default adding a
     * timeline entry for the mark.
     *
     * @private
     * @see UCF_Performance.MARKS
     * @param {number} iMark the mark, e.g. `UCF_Performance.MARKS.BeforeRequest`
     * @param {boolean} [bHideTimelineEntry=false] set to `true` to omit the
     * timeline entry
     * @fires UCF_Performance.E_EVENTS.Range
     */
    UCF_Performance["prototype"]["onMark"] = function (iMark, bHideTimelineEntry) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onMark"]++;
        }
        ;

        if (!window["performance"]["mark"]) return; // on IE Quirks mode is undefined

        /** @type {number} */
        var iNow = UCF_Performance["iNow"]();
        /** @type {PerformanceRange} */
        var oRange;
        /** @type {number} */
        var i;

        /** @type {string} */
        var sMarkName = UCF_Performance["sGetMarkName"](iMark);

        try {
            window["performance"]["mark"](sMarkName);
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, e["message"], "Performance.js(328): onMark");
            }
            ;
        }

        for (i = 0; i < UCF_Performance["RANGES"]["length"]; i++) {
            oRange = UCF_Performance["RANGES"][i];

            if (oRange["iEnd"] === iMark &&
                (oRange["iTimes"] === undefined || oRange["iTimes"] > 0) &&
                (!oRange["fWhen"] || oRange["fWhen"](this))
            ) {
                this["fireRange"](oRange, iNow);

                try {
                    window["performance"]["measure"](
                        oRange["sName"],
                        UCF_Performance["sGetMarkName"](oRange["iStart"]),
                        sMarkName
                    );
                } catch (e) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, e["message"], "Performance.js(347): onMark");
                    }
                    ;
                }

                if (typeof oRange["iTimes"] === 'number') {
                    oRange["iTimes"] -= 1;
                }
            }
        }

        this["putTimestamp"](iMark, iNow, bHideTimelineEntry);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onMark"] = 0;
    }
    ;

// ----- BeforeControlsInitialized --------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the BeforeControlsInitialized
     */
    UCF_Performance["prototype"]["onBeforeControlsInitialized"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onBeforeControlsInitialized"]++;
        }
        ;
        this["onMark"](UCF_Performance["MARKS"]["BeforeControlsInitialized"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onBeforeControlsInitialized"] = 0;
    }
    ;

// ----- ControlsInitialized --------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the ControlsInitialized
     */
    UCF_Performance["prototype"]["onControlsInitialized"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onControlsInitialized"]++;
        }
        ;
        this["onMark"](UCF_Performance["MARKS"]["ControlsInitialized"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onControlsInitialized"] = 0;
    }
    ;

// ----- AnyEvent -------------------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the AnyEvent
     */
    UCF_Performance["prototype"]["onAnyEvent"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onAnyEvent"]++;
        }
        ;
        this["putTimestamp"](UCF_Performance["MARKS"]["AnyEvent"], UCF_Performance["iNow"](), true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onAnyEvent"] = 0;
    }
    ;

// ----- BeforeRequest --------------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the BeforeRequest
     */
    UCF_Performance["prototype"]["onBeforeRequest"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onBeforeRequest"]++;
        }
        ;

        var oEventMetaData = {};

        if (UCF_FesrUtil["bIsFESREnabled"]() && !UCF_FesrUtil["bGetFESRHandledByFramework"]()) {

            oEventMetaData["bFrameworkStart"] = UCF_Performance["bIsStartupRoundtrip"](this);

            if (!oEventMetaData["bFrameworkStart"]) {
                oEventMetaData["iEventTriggerTime"] = this["iGetTimestamp"](UCF_Performance["MARKS"]["AnyEvent"]);
            }
            UCF_FesrUtil["logEvent"]('DialogStepStart', oEventMetaData);

            UCF_FesrUtil["logEvent"]('SendReq', null);
        }

        this["onMark"](UCF_Performance["MARKS"]["BeforeRequest"]);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onBeforeRequest"] = 0;
    }
    ;

// ----- AfterResponse --------------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the AfterRequest
     */
    UCF_Performance["prototype"]["onAfterResponse"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onAfterResponse"]++;
        }
        ;
        if (UCF_FesrUtil["bIsFESREnabled"]() && !UCF_FesrUtil["bGetFESRHandledByFramework"]()) {
            UCF_FesrUtil["logEvent"]('GetResp');
        }

        this["iPopupWindowCount"] = this["oMainPopupManager"]["iGetPopupCount"]();
        this["onMark"](UCF_Performance["MARKS"]["AfterResponse"]);
        this["iRoundTrips"] += 1;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onAfterResponse"] = 0;
    }
    ;

// ----- BeforeUpdateDocument -------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the BeforeUpdateDocument
     */
    UCF_Performance["prototype"]["onBeforeUpdateDocument"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onBeforeUpdateDocument"]++;
        }
        ;
        this["onMark"](UCF_Performance["MARKS"]["BeforeUpdateDocument"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onBeforeUpdateDocument"] = 0;
    }
    ;

// ----- UpdateDocumentComplete -----------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the UpdateDocumentComplete
     */
    UCF_Performance["prototype"]["onUpdateDocumentComplete"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onUpdateDocumentComplete"]++;
        }
        ;
        this["onMark"](UCF_Performance["MARKS"]["UpdateDocumentComplete"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onUpdateDocumentComplete"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent the Before Semantic Event occurs
     */
    UCF_Performance["prototype"]["onBeforeSemanticEvent"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onBeforeSemanticEvent"]++;
        }
        ;
        UCF_FesrUtil["calculateOnBeforeSemanticEvent"](oEvent, UCF_Performance["bIsStartupRoundtrip"](this));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onBeforeSemanticEvent"] = 0;
    }
    ;

// ----- Unlock ---------------------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the Unlock
     */
    UCF_Performance["prototype"]["onUnlock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onUnlock"]++;
        }
        ;

        var bIsPopupOpenInProgress = (this["oMainPopupManager"]["iGetPopupCount"]() > this["iPopupWindowCount"]) ? true : false;
        var bIsDialogStepEnd = !bIsPopupOpenInProgress;

        if (UCF_FesrUtil["bIsFESREnabled"]() && !UCF_FesrUtil["bGetFESRHandledByFramework"]()) {
            UCF_FesrUtil["logEvent"]('DialogStepEnd', {"bIsDialogStepEnd": bIsDialogStepEnd});
        }

        this["onMark"](UCF_Performance["MARKS"]["Unlock"]);
        if (this["iRoundTripsUntilStartup"] === this["iRoundTrips"]) {
            this["iRoundTripsUntilStartup"] = null;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onUnlock"] = 0;
    }
    ;

// ----- Open iFrame Popup-----------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the popup open event
     */
    UCF_Performance["prototype"]["onIframePopupOpen"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onIframePopupOpen"]++;
        }
        ;

        var oPopupLS = this["oGetPopupLS"]();

        if (oPopupLS) {
            oPopupLS["attachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeControlsInitialized"], this, 'onBeforeControlsInitialized');
            oPopupLS["attachAfterEvent"](this["oLS"]["E_EVENTS"]["UpdateDocumentComplete"], this, 'onUpdateDocumentComplete');
            oPopupLS["attachAfterEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, 'onControlsInitialized');
            oPopupLS["attachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeSemanticEvent"], this, 'onBeforeSemanticEvent');
            oPopupLS["oBrowserWindow"]["attachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["AnyEvent"], this, 'onAnyEvent');
        }

        if (UCF_FesrUtil["bIsFESREnabled"]() && !UCF_FesrUtil["bGetFESRHandledByFramework"]()) {
            UCF_FesrUtil["logEvent"]('DialogStepEnd', {"bIsDialogStepEnd": true});
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onIframePopupOpen"] = 0;
    }
    ;

// ----- Close iFrame Popup-----------------------------------------------------

    /**
     * @private
     * @param {UCF_Event} oEvent the popup close event
     */
    UCF_Performance["prototype"]["onIframePopupClose"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["onIframePopupClose"]++;
        }
        ;

        var oPopupLS = this["oGetPopupLS"]();

        if (oPopupLS) {
            oPopupLS["detachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeControlsInitialized"], this, 'onBeforeControlsInitialized');
            oPopupLS["detachAfterEvent"](this["oLS"]["E_EVENTS"]["UpdateDocumentComplete"], this, 'onUpdateDocumentComplete');
            oPopupLS["detachAfterEvent"](this["oLS"]["E_EVENTS"]["ControlsInitialized"], this, 'onControlsInitialized');
            oPopupLS["detachAfterEvent"](this["oLS"]["E_EVENTS"]["BeforeSemanticEvent"], this, 'onBeforeSemanticEvent');
            oPopupLS["oBrowserWindow"]["detachBeforeEvent"](this["oLS"]["oBrowserWindow"]["E_EVENTS"]["AnyEvent"], this, 'onAnyEvent');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["onIframePopupClose"] = 0;
    }
    ;
// ===== events ===============================================================

// ----- range ----------------------------------------------------------------

    /**
     * - will emit `UCF_Performance.iNow() - this.get(oRange.iStart)` if it is given
     * - will `this.put(oRange.iEnd)` if it is given
     *
     * @private
     * @param {PerformanceRange} oRange the range to fire
     * @param {number} [iEndTime=UCF_Performance.iNow()] time of the end mark of `oRange`
     * @fires UCF_Performance.E_EVENTS.Range
     */
    UCF_Performance["prototype"]["fireRange"] = function (oRange, iEndTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["fireRange"]++;
        }
        ;
        /** @type {string} */
        /** @type {number} */
        var iStartTime = this["iGetTimestamp"](oRange["iStart"]);

        if (!iEndTime) {
            iEndTime = UCF_Performance["iNow"]();
        }

        if (iStartTime) {

            this["fireEvent"](this["E_EVENTS"]["Range"], {
                "sName": oRange["sName"]
                    || (UCF_Performance["sGetMarkName"](oRange["iStart"]) +
                        '->' +
                        UCF_Performance["sGetMarkName"](oRange["iEnd"])),
                "iDurationInMs": iEndTime - iStartTime,
                "iThresholdInMs": oRange["iThreshold"]
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["fireRange"] = 0;
    }
    ;

// ----- mark -----------------------------------------------------------------

    /**
     * @private
     * @param {number} iMark the id of the mark to fire
     * @fires UCF_Performance.E_EVENTS.Mark
     */
    UCF_Performance["prototype"]["fireMark"] = function (iMark) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Performance["_"]["fireMark"]++;
        }
        ;
        this["fireEvent"](this["E_EVENTS"]["Mark"], {
            "iId": iMark,
            "sName": UCF_Performance["sGetMarkName"](iMark)
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Performance["_"]["fireMark"] = 0;
    }
    ;

    /* global _assert, _trace, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_System */

/// <reference path="./System.js"/>

    /**
     * Listens to the UCF_Performance tracker and logs the occuring ranges to
     * either the UCF_Tracer (if `__UCF_DEBUG__`) or the window console.
     *
     * @class UCF_PerformanceLog
     * @extends UCF_Object
     * @param {UCF_LS} oLS the lightspeed instance
     */
    function UCF_PerformanceLog(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_PerformanceLog["_"]["UCF_PerformanceLog"]++;
        }
        ;
        if (arguments["length"] > 0) {
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oLS, 'UCF_LS'), "UCF_JsUtil.bInstanceOf(oLS, 'UCF_LS')", "PerformanceLog.js(22): UCF_PerformanceLog");
            }
            ;

            UCF_Object["apply"](this, [oLS]); // super() call

            /** @type {UCF_LS} */
            this["oLS"] = oLS;

            /** @type {boolean} */
            this["bHasAdvancedConsoleApi"] = UCF_UserAgent["bIsWebKit"]() || UCF_UserAgent["bIsFirefox"]();
        }
    };window["UCF_PerformanceLog"] = UCF_PerformanceLog;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_PerformanceLog");
        UCF_PerformanceLog["_"] = {UCF_PerformanceLog: 0};
    }
    ;
    ;
    UCF_PerformanceLog["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_PerformanceLog.prototype["sClassName"] = "UCF_PerformanceLog";

    /** @override */
    UCF_PerformanceLog["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PerformanceLog["_"]["destroy"]++;
        }
        ;
        this["bHasAdvancedConsoleApi"] = null;
        this["oLS"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PerformanceLog["_"]["destroy"] = 0;
    }
    ;

    /** @type {number} */
    UCF_PerformanceLog["FRAME_MS"] = 1000 / 16; // eslint-disable-line no-magic-numbers

    /** @type {string} */
    UCF_PerformanceLog["LOG_PREFIX"] = '[PERFORMANCE]';

    /**
     * @private
     * @param {UCF_Event} oEvent the range event to log
     */
    UCF_PerformanceLog["prototype"]["log"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PerformanceLog["_"]["log"]++;
        }
        ;
        /** @type {string} */
        var sRange = oEvent["oGetParam"]('sName');
        /** @type {number} */
        var iMs = oEvent["oGetParam"]('iDurationInMs');

        if (__UCF_DEBUG__) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, sRange + ' in ' + iMs + 'ms', "PerformanceLog.js(60): log");
            }
            ;
        } else {
            try {
                if (this["bHasAdvancedConsoleApi"]) {
                    console["log"](
                        '%c' + UCF_PerformanceLog["LOG_PREFIX"] + ' %c' + sRange + ' %cin %c' + iMs + 'ms',
                        'color:#bbb',
                        'color:#00b',
                        'color:#000',
                        'color:#' + (iMs > (oEvent["oGetParam"]('iThresholdInMs') || UCF_PerformanceLog["FRAME_MS"]) ? 'b00' : '0b0')
                    );
                } else {
                    console["log"](UCF_PerformanceLog["LOG_PREFIX"] + ' ' + sRange + ' in ' + iMs + 'ms');
                }
            } catch (ignored) {
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PerformanceLog["_"]["log"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_Event} oEvent the mark event to create the timeStamp for
     */
    UCF_PerformanceLog["prototype"]["timeStamp"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PerformanceLog["_"]["timeStamp"]++;
        }
        ;
        if (this["bHasAdvancedConsoleApi"]) {
            try {
                console["timeStamp"](UCF_PerformanceLog["LOG_PREFIX"] + ' ' + oEvent["oGetParam"]('sName'));
            } catch (ignored) {
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PerformanceLog["_"]["timeStamp"] = 0;
    }
    ;

    /* global _assert */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ControlInfo */

/// <reference path="./ControlInfo.js"/>

    /**
     * A Property control
     *
     *
     *
     * @class
     * @version
     * @param {HTMLElement} oDomRef
     * @param {UCF_LS} oLS
     */
    function UCF_Property(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_Property["_"]["UCF_Property"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "Property.js(18): UCF_Property");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "Property.js(19): UCF_Property");
        }
        ;

        UCF_ControlInfo["apply"](this, [oDomRef, oLS]);
    };window["UCF_Property"] = UCF_Property;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_Property");
        UCF_Property["_"] = {UCF_Property: 0};
    }
    ;
    ;

    UCF_Property["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_ControlInfo"))();
    UCF_Property.prototype["sClassName"] = "UCF_Property";

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #sKey}
     * - {@link #sValue}
     * @private
     * @type {string[]}
     */
    UCF_Property["prototype"]["aAttributeNames"] = ['sKey', 'sValue'];

    /**
     * Array of names of events of the control:
     * @type {string[]}
     */
    UCF_Property["prototype"]["aEventNames"] = [];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * no public API available
     *
     * @private
     * @type {string[]}
     */
    UCF_Property["prototype"]["aMethodNames"] = [, 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     *
     *
     * @private
     * @type {string}
     */
    UCF_Property["prototype"]["sKey"] = '';

    /**
     *
     *
     * @private
     * @type {string}
     */
    UCF_Property["prototype"]["sValue"] = '';


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_Property["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_Property["_"]["setDefaultValues"]++;
        }
        ;
        this["sKey"] = '';
        this["sValue"] = '';

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_Property["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    /* global _trace, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="./ResourceUtil.js"/>
    /* global UCF_System */
/// <reference path="./System.js"/>

    /**
     * @typedef {Object} UCF_RenderManager_Renderer
     * @property {function(): void} render
     */

    /** @typedef {'xml'|'xml-handlelinebreaks'|'xml-ignorespaces'|'cdata'|'jsattribute'} UCF_RenderManager_Escape */
    /**
     * Manages the rendering of controls on the client side.
     * It provides several method to render a control tree on the client.
     * The renderJSON method is actually internally call the renderer of a control.
     * The renderXMLStream can be used to pass in a lsx control tree.
     * Please ensure to render only inside a Page controls content
     *
     * @private
     * @class
     * @extends UCF_Object
     *
     * @param {UCF_LS} oLS
     */
    function UCF_RenderManager(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["UCF_RenderManager"]++;
        }
        ;
        if (arguments["length"] > 0) {
            UCF_Object["apply"](this);
            /**
             * LS reference
             * @private
             * @type {UCF_LS}
             */
            this["oLS"] = oLS;
            /**
             * The string array with the HTML while rendering
             * @private
             * @type {string[]}
             */
            this["aActiveWriter"] = [];

            /**
             * The array of initial IDs loaded at the initial rendeirng of the page
             * @private
             * @type {string[]}
             */
            this["aInitializeIds"] = [];

            /**
             * The array of initial IDs loaded at the initial rendeirng of the page
             * @private
             * @type {UCF_ClientElement[]}
             */
            this["aTempInvisibleControls"] = [];

            /**
             * Stack of controls that were rendered
             * @type {Object<string, UCF_ClientElement>}
             */
            this["mRenderControlStack"] = {};
        }
    };window["UCF_RenderManager"] = UCF_RenderManager;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_RenderManager");
        UCF_RenderManager["_"] = {UCF_RenderManager: 0};
    }
    ;
    ;
    UCF_RenderManager["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_RenderManager.prototype["sClassName"] = "UCF_RenderManager";

    /** @override */
    UCF_RenderManager["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["destroy"]++;
        }
        ;
        this["oLS"] = null;
        this["aTempInvisibleControls"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["destroy"] = 0;
    }
    ;

    /**
     * Returns the Renderer instance of a given Control
     * @param {string} sControlName the control for the renderer
     * @return {UCF_Renderer} the renderer for the control
     */
    UCF_RenderManager["prototype"]["getRenderer"] = function (sControlName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["getRenderer"]++;
        }
        ;
        return UCF_ClassLoader["oGetClass"]('UCF_' + sControlName + 'Renderer');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["getRenderer"] = 0;
    }
    ;

    /**
     * Adds the renderedControl to the control stack for initialization after the
     * HTML is applied, called from Renderer in render method
     * @see client/renderer.xslt
     * @private
     * @param {UCF_Control} oControl the control to add to the control stack
     */
    UCF_RenderManager["prototype"]["addRenderedControl"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["addRenderedControl"]++;
        }
        ;
        this["mRenderControlStack"][oControl["getId"]()] = oControl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["addRenderedControl"] = 0;
    }
    ;

    /**
     * Callback function used by the controls to render their content controls
     * @private
     * @param {UCF_ClientElement_RenderInfo} oRenderInfo info to render
     * @param {HTMLElement} oDomRef to add the control
     */
    UCF_RenderManager["prototype"]["renderControl"] = function (oRenderInfo, oDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["renderControl"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl = oRenderInfo["_oControl"];
        /** @type {string} */
        var sClassName;
        /** @type {UCF_RenderManager_Renderer} */
        var oRenderer;
        /** @type {HTMLDivElement} */
        var oDomElement;
        /** @type {HTMLElement} */
        var oControlDomRef;

        if (UCF_JsUtil["bInstanceOf"](oControl, 'UCF_ClientControl')) {
            sClassName = oControl["sClassName"];
            oRenderer = this["getRenderer"](sClassName);

            if (oRenderer) {
                oControl["_sSavedStyleAttribute"] = null;
                // rerender the control if invalidated
                if (
                    oControl["getVisibility"] &&
                    oControl["getRenderInvisibleContent"]() &&
                    (
                        oControl["getVisibility"]() === 'NONE' ||
                        oControl["getVisibility"]() === 'BLANK'
                    )
                ) {
                    // if the parent or the control needs a visibility none rendering then
                    // render myself as visibilty blank and after rendering call
                    // setInvisibilty on UCF instance. ->this.reinitializeControls
                    this["aTempInvisibleControls"]["push"](oControl);
                    // do not add to an additional rendering cycle
                    oControl["setVisibility"]('VISIBLE', true);
                }
                UCF_RenderManager["bPending"] = true;
                oRenderer["render"](oRenderInfo, this);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Class ' + sClassName + ' could not be loaded.', "RenderManager.js(142): renderControl");
                }
                ;

                return;
            }
        }

        if (oDomRef) {
            oDomElement = document["createElement"]('DIV');

            // eslint-disable-next-line no-unsanitized/property
            oDomElement["innerHTML"] = this["getHTMLString"]();

            oControlDomRef = oDomElement["firstChild"];
            if (oControlDomRef) {
                oDomRef["parentNode"]["replaceChild"](oControlDomRef, oDomRef);
            }
            this["clearBuffer"]();
            this["reinitializeUCFControls"](oRenderInfo["Id"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["renderControl"] = 0;
    }
    ;

    /**
     * Reinitializes the UCF Controls after they were (re)rendered
     * Fires an internal BrowseWindow.LayoutChange event.
     * @private
     * @param {string} sRenderedControlId control id to reinitialize
     */
    UCF_RenderManager["prototype"]["reinitializeUCFControls"] = function (sRenderedControlId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["reinitializeUCFControls"]++;
        }
        ;
        /** @type {UCF_ClientControlTree} */
        var oControlTree = null;
        /** @type {UCF_ClientElement} */
        var oControl = null;
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement} */
        var aUnavailableControls;
        /** @type {number} */
        var i;
        /** @type {UCF_Control} */
        var oUCFControl;

        for (n in this["mRenderControlStack"]) {
            oControl = this["mRenderControlStack"][n];
            oControl["onAfterRendering"]();
            if (!oControlTree) {
                oControlTree = oControl["getControlTree"]();
            }
        }
        this["mRenderControlStack"] = {};
        this["oLS"]["purgeControls"]();
        this["oLS"]["processInitializeIDs"](this["aInitializeIds"]);

        aUnavailableControls = [];
        if (this["aTempInvisibleControls"]["length"] > 0) {
            for (i = 0; i < this["aTempInvisibleControls"]["length"]; i++) {
                oControl = this["aTempInvisibleControls"][i];
                oUCFControl = oControl["getUCFInstance"]();

                if (oUCFControl) {
                    if (oControl["_sSavedStyleAttribute"]) {
                        oUCFControl["intializeInvisibilityAfterRerendering"](
                            oControl["_sSavedStyleAttribute"]
                        );
                    } else {
                        oUCFControl["setInvisibility"](true);
                    }
                } else {
                    aUnavailableControls["push"](oControl);
                }
            }
        }

        this["aTempInvisibleControls"] = aUnavailableControls;
        this["resetInitializeIds"]();
        this["oLS"]["oBrowserWindow"]["notifyLayoutChangeFrom"](
            null,
            'UCF_RenderManager',
            {"sRenderedControlId": sRenderedControlId}
        );

        if (oControlTree) {
            oControlTree["fireAfterRendering"]();
        }
        UCF_RenderManager["bPending"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["reinitializeUCFControls"] = 0;
    }
    ;

    /**
     * Translates a given text message and replaces the parameters
     * @private
     * @param {string} sTextKey the key to translate
     * @param {string[]}  aParameters the parameters that will replace the
     * placeholders in the text (e.g. {0})
     * @return {string} The translated text
     */
    UCF_RenderManager["prototype"]["translate"] = function (sTextKey, aParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["translate"]++;
        }
        ;
        return this["oLS"]["sGetText"](sTextKey, aParameters);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["translate"] = 0;
    }
    ;

    /**
     * Writes a given string to {@link #aActiveWriter}
     * @private
     */
    UCF_RenderManager["prototype"]["write"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["write"]++;
        }
        ;
        this["aActiveWriter"]["push"]["apply"](this["aActiveWriter"], arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["write"] = 0;
    }
    ;

    /**
     * Pushes a given string
     * @private
     */
    UCF_RenderManager["prototype"]["p"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["p"]++;
        }
        ;
        this["write"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["p"] = 0;
    }
    ;

    /**
     * Adds a given id to the initialization array. Controls with these ids will be
     * initialized after the rendering process is finished
     * @private
     * @param {string} sId the id of the control that needs to be initialized
     */
    UCF_RenderManager["prototype"]["addInitializeId"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["addInitializeId"]++;
        }
        ;
        /** @type {string} */
        var c;
        /** @type {number} */
        var i;
        /** @type {string} */
        var s;
        /** @type {string} */
        var sError;

        if (__UCF_DEBUG__ && (!sId || sId === '')) {
            c = (this["addInitializeId"]["caller"] ? this["addInitializeId"]["caller"] : '') + '';
            i = UCF_JsUtil["indexOf"](c, '{');
            s = c["substring"](0, i);
            sError = 'NullPointerException - Could not initialize control with ID "' +
                sId + '" called by ' + s;

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, sError, "RenderManager.js(279): addInitializeId");
            }
            ;
            throw sError;
        }
        if (!UCF_JsUtil["contains"](this["aInitializeIds"], sId)) {
            this["aInitializeIds"]["push"](sId);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["addInitializeId"] = 0;
    }
    ;

    /**
     * Resets the initialized id array
     * @private
     */
    UCF_RenderManager["prototype"]["resetInitializeIds"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["resetInitializeIds"]++;
        }
        ;
        this["aInitializeIds"] = [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["resetInitializeIds"] = 0;
    }
    ;

    /**
     * Clears the Active Render writer
     * @private
     */
    UCF_RenderManager["prototype"]["clearBuffer"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["clearBuffer"]++;
        }
        ;
        this["aActiveWriter"] = [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["clearBuffer"] = 0;
    }
    ;

    /**
     * Gets the current string contained in the writer
     * @private
     * @return {string}
     */
    UCF_RenderManager["prototype"]["getHTMLString"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["getHTMLString"]++;
        }
        ;
        return UCF_ResourceUtil["sInlineSvgByHtmlExchange"](
            this["aActiveWriter"]["join"](''),
            this["oLS"]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["getHTMLString"] = 0;
    }
    ;

    /**
     * Returns the current HTML element defined by the string contained
     * in the writer
     * @private
     * @return {HTMLElement}
     */
    UCF_RenderManager["prototype"]["oGetElementFromHtml"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["oGetElementFromHtml"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oRef = document["createElement"]('div');

        // operates on the string built by the rendermanager itself only
        // eslint-disable-next-line no-unsanitized/property
        oRef["innerHTML"] = this["getHTMLString"]();

        return oRef["firstChild"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["oGetElementFromHtml"] = 0;
    }
    ;

    /**
     * Helper function used by the renderers to render the accelerator key HTML
     * representation
     * @param {string} sKey the accelerator char
     * @param {string} sValue the strng where the accelerator key is included
     * @param {string} sPrefix the prefix to be inserted before the key
     * @param {string} sSuffix the suffix to be inserted after the key
     * @private
     */
    UCF_RenderManager["prototype"]["writeAcceleratorKey"] = function (sKey, sValue, sPrefix, sSuffix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["writeAcceleratorKey"]++;
        }
        ;
        /** @type {number} */
        var iStart = sValue["indexOf"](sKey);
        /** @type {number} */
        var iEnd;

        if (iStart < 0) {
            this["write"](sValue);
        } else {
            // renders the part in front of the key
            this["write"](sValue["substring"](0, iStart));
            // renders the prefix e.g. <u>
            this["write"](sPrefix);
            iEnd = iStart + sKey["length"];
            // renders the key
            this["write"](sValue["substring"](iStart, iEnd));
            // renders the suffix e.g. </u>
            this["write"](sSuffix || '');
            // renders the part of the text after the key
            this["write"](sValue["substring"](iEnd, sValue["length"]));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["writeAcceleratorKey"] = 0;
    }
    ;

    /**
     * Renders the events
     * @param {Object<string,any>} oEvents the events object of the JSON control
     */
    UCF_RenderManager["prototype"]["writeEvents"] = function (oEvents) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["writeEvents"]++;
        }
        ;
        /** @type {number} */
        var iEvent;
        /** @type {string} */
        var sEvent;
        /** @type {any[]} */
        var aEvent;
        /** @type {number} */
        var j;
        /** @type {number} */
        var iPropertyIndex;
        /** @type {string} */
        var m;
        /** @type {any} */
        var oEventParameter;
        /** @type {string} */
        var sType;
        /** @type {boolean} */
        var bWritten = false;

        if (oEvents) {
            iEvent = 0;

            this["write"](" lsevents='{"); // eslint-disable-line quotes

            for (sEvent in oEvents) {
                aEvent = oEvents[sEvent];

                if (aEvent) {
                    if (bWritten) {
                        this["write"](',');
                    } else {
                        bWritten = true;
                    }

                    this["write"]('"', window["UCF_System"]["bClientDebug"] ? sEvent : iEvent, '":[{');

                    for (j = 0; j < aEvent["length"]; j++) {
                        if (j > 0) { // eslint-disable-line max-depth
                            this["write"]('},{');
                        }

                        iPropertyIndex = 0;
                        for (m in aEvent[j]) { // eslint-disable-line max-depth
                            if (iPropertyIndex > 0) { // eslint-disable-line max-depth
                                this["write"](',');
                            }

                            oEventParameter = aEvent[j][m];
                            if (oEventParameter) { // eslint-disable-line max-depth
                                if (m === 'Enabled') { // eslint-disable-line max-depth
                                    oEventParameter = oEventParameter === 'true';
                                }
                                sType = typeof oEventParameter;

                                this["write"]('"', m, '":');

                                if (sType === 'string') { // eslint-disable-line max-depth
                                    this["write"](
                                        '"',
                                        this["sGetEscaped"](oEventParameter)
                                            ["replace"](/&quot;/g, '\\&quot;'),
                                        '"'
                                    );
                                } else if (sType === 'object') {
                                    this["write"](
                                        '"',
                                        this["sGetEscaped"](UCF_JsUtil["sJsonStringify"](oEventParameter))
                                            ["replace"](/&quot;/g, '\\&quot;'),
                                        '"'
                                    );
                                } else {
                                    this["write"](oEventParameter);
                                }
                            } else {
                                this["write"](m, ':null');
                            }

                            iPropertyIndex += 1;
                        }
                    }
                    this["write"]('}]');
                }

                iEvent += 1;
            }
            this["write"]("}' "); // eslint-disable-line quotes
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["writeEvents"] = 0;
    }
    ;

    /**
     * @see {@link UCF_RenderManager.addCustomStyleSuffix()} (static)
     * @param {string} sClasses classes to add
     * @param {string} sSuffix suffix of the custom style
     * @param {Object} oRenderInfo info to render
     * @return {string}
     */
    UCF_RenderManager["prototype"]["addCustomStyleSuffix"] = function (sClasses, sSuffix, oRenderInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["addCustomStyleSuffix"]++;
        }
        ;
        if (sSuffix !== '' && oRenderInfo && oRenderInfo["_oControl"]) {
            oRenderInfo["_oControl"]["mCustomStyleSuffix"][sSuffix] = true;
        }

        return UCF_RenderManager["addCustomStyleSuffix"](sClasses, sSuffix);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["addCustomStyleSuffix"] = 0;
    }
    ;

    /**
     * @see sGetEscaped (static)
     * @param {string} s the string to be escaped
     * @param {UCF_RenderManager_Escape} [sType='xml'] The escaping type
     * @return {string} The escaped string
     */
    UCF_RenderManager["prototype"]["sGetEscaped"] = function (s, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["sGetEscaped"]++;
        }
        ;
        return UCF_RenderManager["sGetEscaped"](s, sType);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["sGetEscaped"] = 0;
    }
    ;

    /**
     * Adds the given suffix to all strings in sClasses after the seperation space.
     * @param {string} sClasses space separated string where the suffix is added
     * @param {string} sSuffix
     * @private
     * @return {string}
     * @static
     */
    UCF_RenderManager["addCustomStyleSuffix"] = function (sClasses, sSuffix) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["addCustomStyleSuffix"]++;
        }
        ;
        return typeof sClasses === 'string'
            ? sClasses["replace"](/  /g, ' ')["replace"](/ /g, sSuffix + ' ') + sSuffix
            : '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["addCustomStyleSuffix"] = 0;
    }
    ;

    /**
     * Returns an escaped string of a given excaping type
     * @private
     * @static
     * @param {string} s the string to be escaped
     * @param {UCF_RenderManager_Escape} [sType='xml'] The escaping type
     * @return {string} The escaped string
     */
    UCF_RenderManager["sGetEscaped"] = function (s, sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["sGetEscaped"]++;
        }
        ;
        if (typeof s === 'string') {
            switch (sType) {
                case 'xml-handlelinebreaks':
                    s = s["replace"](/&/gi, '&amp;')
                        ["replace"](/"/gi, '&quot;')
                        ["replace"](/>/gi, '&gt;')
                        ["replace"](/</gi, '&lt;')
                        ["replace"](/  /gi, ' &nbsp;')
                        ["replace"](/\n/gi, '<br>');
                    if (s["charAt"](0) === ' ') {
                        s = '&nbsp' + s["substring"](1);
                    }
                    if (s["charAt"](s["length"] - 1) === ' ') {
                        s = s["substring"](0, s["length"] - 1) + '&nbsp';
                    }

                    return s;
                case 'xml-ignorespaces':
                    return s["replace"](/&/gi, '&amp;')
                        ["replace"](/"/gi, '&quot;')
                        ["replace"](/>/gi, '&gt;')
                        ["replace"](/</gi, '&lt;');
                case 'cdata':
                    return s;
                case 'jsattribute':
                    return s["replace"](/\\/gi, '\\\\')
                        ["replace"](/'/gi, "\\'") // eslint-disable-line quotes
                        ["replace"](/"/gi, '\\"')
                        ["replace"](/\r/gi, '\\r')
                        ["replace"](/\n/gi, '\\n');
                case 'jsonattribute':
                    return s["replace"](/\\/gi, '\\\\')
                        ["replace"](/'/gi, '&#39;')
                        ["replace"](/"/gi, '\\"')
                        ["replace"](/\r/gi, '\\r')
                        ["replace"](/\n/gi, '\\n');
                case 'xml':
                default:
                    return s["replace"](/&/gi, '&amp;')
                        ["replace"](/"/gi, '&quot;')
                        ["replace"](/'/gi, '&#39;')
                        ["replace"](/>/gi, '&gt;')
                        ["replace"](/</gi, '&lt;')
                        ["replace"](/\n/gi, ' ');
            }
        } else {
            return s;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["sGetEscaped"] = 0;
    }
    ;

    /**
     * @protected
     * @param {string} sName
     * @param {string} sUseControl
     * @param {Object} [oParameters={}]
     * @return {any}
     */
    UCF_RenderManager["prototype"]["callFragment"] = function (sName, sUseControl, oParameters) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_RenderManager["_"]["callFragment"]++;
        }
        ;
        /** @type {UCF_RenderManager_Renderer} */
        var oRenderer = this["getRenderer"](sUseControl);
        /** @type {string} */
        var sFragment;
        /** @type {UCF_RenderManager} */
        var oRenderManager;
        /** @type {any} */
        var oResult;

        if (oRenderer) {
            sFragment = 'render' + sName;

            if (sFragment in oRenderer) {
                oRenderManager = new (UCF_ClassLoader["oGetClass"]("UCF_RenderManager"))(this["oLS"]);

                oResult = oRenderer[sFragment](oParameters || {}, oRenderManager);

                if (!oResult) {
                    oResult = oRenderManager["getHTMLString"]();
                }

                oRenderManager["clearBuffer"]();

                return oResult;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'unknown fragment "' + sName + '" in renderer "' + sUseControl + '"', "RenderManager.js(589): callFragment");
                }
                ;

                return null;
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'unknown renderer "' + sUseControl + '"', "RenderManager.js(594): callFragment");
            }
            ;

            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_RenderManager["_"]["callFragment"] = 0;
    }
    ;

    /* global _measure, _trace, START, STOP, INFO WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="../../core/util/XSSEncoder.js"/>
    /* global UCF_Promise */
/// <reference path="../../core/util/Promise.js"/>
    /* global UCF_System */
/// <reference path="./System.js"/>
    /* global UCF_ColorUtil */
/// <reference path="../../core/util/ColorUtil.js"/>
    /**
     * @typedef {Object} UCF_ResourceUtil_VersionInfo
     * @property {string} versionCss the actual version of the css
     * @property {string} versionCssRequired the minimum required version of the
     * css
     * @property {string} versionRuntime the actual runtime version
     * @property {string} versionRuntimeRequired the minimum required runtime
     * version
     * @property {UCF_ResourceUtil.MATCH_RESULT} matchResult
     * the result of matching actual and required versions
     * @property {boolean} isRejected `true` if the actual version is rejected
     */
    /**
     * @typedef {Object} UCF_ResourceUtil_MetaData
     * @property {string} Path e.g. `UR.ls.sap_belize.standards`
     * @property {string} PathPattern e.g. `/%frameworkId%/%libId%/%themeId%/%fileId%.css`
     * @property {string[]} Extends e.g. `["sap_base_fiori", "baseTheme"]`
     * @property {string[]} Tags e.g. `["Fiori_2", "Fiori_3"]`
     * @property {UCF_ResourceUtil_CssVersion} Version
     */
    /**
     * @typedef {Object} UCF_ResourceUtil_CssVersion
     * @property {string} Build e.g. `10.30.7.312805.20190417231809`
     * @property {string} Source e.g. `10.30.7.312805.0`
     * @property {string} Required e.g. `10.30.5`
     * @property {string} Engine e.g. `1.40.1`
     */
    /**
     * @typedef {Object} UCF_ResourceUtil_CssVersion
     * @property {string} Build e.g. `0.0.0.0.20190405072746`
     * @property {string} Engine e.g. `1.40.0-SNAPSHOT`
     * @property {string} Required e.g. `10.30.7.307232`
     * @property {string} Source e.g. `0.0.0.0.0`
     */
    /**
     * @typedef {Object} UCF_ResourceUtil_CssMetaData
     * @property {string} Path e.g. `UR.ls.sap_fiori_3_hcb.standards`
     * @property {string} PathPattern e.g. `/%frameworkId%/%libId%/%themeId%/%fileId%.css`
     * @property {string[]} Extends e.g. `["sap_base_fiori_hcb", "sap_base_fiori", "baseTheme"]`
     * @property {string[]} Tags e.g. `["Fiori_3", "HighContrast"]`
     * @property {UCF_ResourceUtil_CssVersion} Version
     */
    /**
     * @typedef {Object} UCF_ResourceUtil_CssLoadedCallback
     * @property {function(): void} fCallback the callback to call when the css is
     * loaded
     * @property {HTMLLinkElement} [oLightspeedCssLink] the link element
     */
    /** @typedef {string} UCF_ResourceUtil_FallbackThemeID the FallbackThemeID as defined in the theme metadata */
    /** @typedef {string} UCF_ResourceUtil_ExtendsThemeID the first ThemeID starting with sap_ in the Extends theme metadata */
    /**
     * @typedef {Object} UCF_ResourceUtil_SvgLibInfo
     * @property {string} sLibId the ID of the library
     * @property {string} sLibUrl the URL of the library
     * @property {boolean} bSameOrigin `true` if the library comes from the same
     * origin
     * @property {string} sInlineIdPrefix prefix for inlined IDs, roughly
     * _${sLibId}_${Prefixcount+1}_
     * @property {string} sLoadingMethod the method the library is loaded with
     * @property {string} sReadyState the current state of loading the library
     * @property {Array.<{0: string, 1: string, 2:UCF_ResourceUtil_SvgLibInfo}>} aPendingApplyUseTag
     * @property {Object.<string,Array.<string>>} mCssClassToIdMap list of css
     * classes and the ids of the svg images that have this class applied
     * @property {Object.<string,Array.<string>>} mIdToCssClassMap list of ids of
     * svg images and the css classes applied to them (mCssClassToIdMap transposed)
     * @property {Object.<string,UCF_ResourceUtil_SvgInfo>} mSvgs map of internal
     * IDs to svg content
     */
    /**
     * @typedef UCF_ResourceUtil_SvgInfo
     * @type {Object}
     * @property {string} sSvg* @property {boolean} bInlined
     */

    /**
     * @typedef {Object} UCF_ResourceUtil_SvgLibPassInfo
     * @property {string} sLibId
     * @property {string} sContent
     * @property {Object<string,UCF_ResourceUtil_SvgInfo>} mSvgs
     */

    /**
     * Utility methods for mime access and handling
     * @class
     *
     */
    function UCF_ResourceUtil() {
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["UCF_ResourceUtil"]++;
        }
        ;

    };window["UCF_ResourceUtil"] = UCF_ResourceUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ResourceUtil");
        UCF_ResourceUtil["_"] = {UCF_ResourceUtil: 0};
    }
    ;
    ;

    /**
     * @private
     * @readonly
     * @enum {number}
     */
    UCF_ResourceUtil["VERSION"] = {
        "Repository": 2.0,
        "Legacy": 1.0,
        "Unknown": 0.0
    };

    /**
     * @private
     * @readonly
     * @enum {string}
     */
    UCF_ResourceUtil["MATCH_RESULT"] = {
        "Match": 'MATCH',
        "MismatchCss": 'MISMATCH_CSS',
        "MismatchRuntime": 'MISMATCH_RUNTIME',
        "RequiredVersionUnavailable": 'REQUIRED_VERSION_UNAVAILABLE',
        "RuntimeVersionUnavailable": 'RUNTIME_VERSION_UNAVAILABLE',
        "ResourceUnavailable": 'RESOURCE_UNAVAILABLE',
        "MetadataUnavailable": 'METADATA_UNAVAILABLE',
        "Unavailable": 'UNAVAILABLE',
        "Unsupported": 'UNSUPPORTED'
    };

    /**
     * @private
     * @readonly
     * @enum {string}
     */
    UCF_ResourceUtil["READY_STATE"] = {
        "Ready": 'READY',
        "Pending": 'PENDING'
    };

    /**
     * @private
     * @readonly
     * @enum {string}
     */
    UCF_ResourceUtil["LOADING_METHOD"] = {
        "Xhr": 'XMLHttpRequest',
        "Content": 'PassedSvgContent',
        "Css": 'CSS'
    };

    /**
     * @private
     * @type {boolean}
     */
    UCF_ResourceUtil["bSVGEnabled"] = false;

    /**
     * @public
     * @return {number} the version of the used theming approach.
     * >= 1.0 => Legacy Theming
     * >= 2.0 => Theming wth the repository approach
     */
    UCF_ResourceUtil["fGetThemingVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["fGetThemingVersion"]++;
        }
        ;
        if (typeof UCF_ResourceUtil["fThemingVersion"] !== 'number') {
            if (window["UCF_System"]["sThemeRepositoryURL"]) {
                UCF_ResourceUtil["fThemingVersion"] = UCF_ResourceUtil["VERSION"]["Repository"];
            } else if (window["UCF_System"]["sExternalThemeRoot"]) {
                UCF_ResourceUtil["fThemingVersion"] = UCF_ResourceUtil["VERSION"]["Legacy"];
            } else {
                UCF_ResourceUtil["fThemingVersion"] = UCF_ResourceUtil["VERSION"]["Unknown"];
            }
        }

        return UCF_ResourceUtil["fThemingVersion"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["fGetThemingVersion"] = 0;
    }
    ;

    /**
     * @private
     * @return {boolean} bRepositoryMode
     */
    UCF_ResourceUtil["bIsRepositoryMode"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsRepositoryMode"]++;
        }
        ;
        if (typeof UCF_ResourceUtil["bRepositoryMode"] !== 'boolean') {
            UCF_ResourceUtil["bRepositoryMode"] = UCF_ResourceUtil["fGetThemingVersion"]() >=
                UCF_ResourceUtil["VERSION"]["Repository"];
        }

        return UCF_ResourceUtil["bRepositoryMode"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsRepositoryMode"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL parameter appendix including a leading "?"
     */
    UCF_ResourceUtil["sGetThemeUrlAppendix"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeUrlAppendix"]++;
        }
        ;
        if (UCF_ResourceUtil["bIsRepositoryMode"]()) {
            return window["UCF_System"]["sThemeRepositoryURLAppendix"]
                ? '?' + window["UCF_System"]["sThemeRepositoryURLAppendix"]
                : '';
        } else {
            return window["UCF_System"]["sClientVersionKey"]
                ? '?' + window["UCF_System"]["sClientVersionKey"]
                : '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeUrlAppendix"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [bIsRtl=UCF_System.bIsRTL] the rtl setting
     * @return {string} the CSS file name of the main lightspeed stylesheet
     */
    UCF_ResourceUtil["sGetCssFileName"] = function (bIsRtl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetCssFileName"]++;
        }
        ;
        return UCF_ResourceUtil["bIsRepositoryMode"]()
            ? (
                (window["UCF_System"]["sThemeFileName"] || window["UCF_System"]["sDevice"]) +
                ((typeof bIsRtl === 'undefined' ? window["UCF_System"]["bIsRtl"] : bIsRtl) ? '-RTL' : '') +
                '.css'
            )
            : (
                'ls_' +
                (window["UCF_System"]["sDevice"] === 'ff1' ? 'nn7' : window["UCF_System"]["sDevice"]) +
                '.css'
            );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetCssFileName"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the deepest theme folder all lightspeed themes have in
     * common
     */
    UCF_ResourceUtil["sGetThemesRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemesRoot"]++;
        }
        ;
        /** @type {string} */
        var sExternalThemeRoot;

        if (UCF_ResourceUtil["bIsRepositoryMode"]()) {
            return window["UCF_System"]["sThemeRepositoryURL"] + '/UR/ls';
        } else {
            sExternalThemeRoot = window["UCF_System"]["sExternalThemeRoot"];

            return sExternalThemeRoot["substring"](
                0,
                sExternalThemeRoot["lastIndexOf"]('/')
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemesRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [sThemeId=UCF_System.sThemeID] the theme id
     * @param {boolean} [bIsRtl=UCF_System.bIsRTL] the rtl setting
     * @return {string} the deepest theme folder the theme has in common for all
     * devices and RTL variants
     */
    UCF_ResourceUtil["sGetThemeRoot"] = function (sThemeId, bIsRtl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeRoot"]++;
        }
        ;
        /** @type {string} */
        var sThemesRoot = UCF_ResourceUtil["sGetThemesRoot"]();

        if (typeof bIsRtl === 'undefined') {
            bIsRtl = window["UCF_System"]["bIsRTL"];
        }

        if (UCF_ResourceUtil["bIsRepositoryMode"]()) {
            return sThemesRoot + '/' + (sThemeId || window["UCF_System"]["sThemeID"]);
        } else {
            return sThemesRoot +
                '/' +
                (sThemeId || window["UCF_System"]["sThemeID"]) +
                (bIsRtl ? '/r' : '');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [sThemeId=UCF_System.sThemeID] the theme id
     * @param {boolean} [bIsRtl=UCF_System.bIsRTL] the rtl setting
     * @return {string} the URL to the folder of the currently used CSS file
     */
    UCF_ResourceUtil["sGetCssRoot"] = function (sThemeId, bIsRtl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetCssRoot"]++;
        }
        ;
        return UCF_ResourceUtil["sGetThemeRoot"](sThemeId, bIsRtl) +
            (UCF_ResourceUtil["bIsRepositoryMode"]() ? '' : '/ls');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetCssRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [sThemeId=UCF_System.sThemeID] the theme id
     * @param {boolean} [bIsRtl=UCF_System.bIsRTL] the rtl setting
     * @return {string} the URL to the folder of the currently used asset or
     * control images folder.
     */
    UCF_ResourceUtil["sGetControlAssetsRoot"] = function (sThemeId, bIsRtl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetControlAssetsRoot"]++;
        }
        ;
        /** @type {string} */
        var sThemeRoot;

        if (typeof bIsRtl === 'undefined') {
            bIsRtl = window["UCF_System"]["bIsRTL"];
        }

        sThemeRoot = UCF_ResourceUtil["sGetThemeRoot"](sThemeId, bIsRtl);

        return UCF_ResourceUtil["bIsRepositoryMode"]()
            ? sThemeRoot + '/img' + (bIsRtl ? '-RTL' : '')
            : sThemeRoot + '/common';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetControlAssetsRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [sThemeId=UCF_System.sThemeID] the theme id
     * @return {string} the URL to the folder where the fonts of the wanted theme
     * is located
     */
    UCF_ResourceUtil["sGetFontsRoot"] = function (sThemeId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetFontsRoot"]++;
        }
        ;
        // Fonts are not RTL dependent
        return UCF_ResourceUtil["sGetThemeRoot"](sThemeId, false) +
            (UCF_ResourceUtil["bIsRepositoryMode"]() ? '/img/fonts' : '/common/fonts');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetFontsRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sAssetSubPath the sub path to the asset e.g.
     * "/button/arrow.gif"
     * @return {string} the URL to control asset
     */
    UCF_ResourceUtil["sGetControlAssetUrl"] = function (sAssetSubPath) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetControlAssetUrl"]++;
        }
        ;
        return UCF_ResourceUtil["sGetControlAssetsRoot"]() +
            sAssetSubPath +
            UCF_ResourceUtil["sGetThemeUrlAppendix"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetControlAssetUrl"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} [sThemeId=UCF_System.sThemeID] the theme id
     * @param {boolean} [bIsRtl=UCF_System.bIsRTL] the rtl setting
     * @return {string} the URL to stylesheet including the appendix
     */
    UCF_ResourceUtil["sGetCssUrl"] = function (sThemeId, bIsRtl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetCssUrl"]++;
        }
        ;
        if (typeof bIsRtl === 'undefined') {
            bIsRtl = window["UCF_System"]["bIsRTL"];
        }

        return UCF_ResourceUtil["sGetCssRoot"](sThemeId, bIsRtl) +
            '/' +
            UCF_ResourceUtil["sGetCssFileName"](bIsRtl) +
            UCF_ResourceUtil["sGetThemeUrlAppendix"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetCssUrl"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL to the spacer-image (1x1.gif) including the
     * appendix
     */
    UCF_ResourceUtil["sGetSpacerImageUrl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetSpacerImageUrl"]++;
        }
        ;
        if (window["UCF_System"]["sResourceRoot"]) {
            return window["UCF_System"]["sResourceRoot"] + '/js/img/1x1.gif';
        } else if (window["UCF_System"]["sSpaceGif"]) {
            return window["UCF_System"]["sSpaceGif"];
        } else {
            return UCF_ResourceUtil["sGetControlAssetUrl"]('1x1.gif');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetSpacerImageUrl"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL to Lightspeed JS files
     */
    UCF_ResourceUtil["sGetJsRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetJsRoot"]++;
        }
        ;
        return window["UCF_System"]["sResourceRoot"] + '/js';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetJsRoot"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL to Lightspeed HTML files
     */
    UCF_ResourceUtil["sGetHtmlRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetHtmlRoot"]++;
        }
        ;
        return window["UCF_System"]["sResourceRoot"] + '/js/html';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetHtmlRoot"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL to Lightspeed message bundles
     */
    UCF_ResourceUtil["sGetMessageBundlesRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetMessageBundlesRoot"]++;
        }
        ;
        return window["UCF_System"]["sResourceRoot"] + '/js/texts';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetMessageBundlesRoot"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the URL to Lightspeed QUinit resource folder
     */
    UCF_ResourceUtil["sGetQUnitRoot"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetQUnitRoot"]++;
        }
        ;
        return window["UCF_System"]["sResourceRoot"] + '/testframework/js/qunit';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetQUnitRoot"] = 0;
    }
    ;

    /**
     * @public
     * @param {HTMLLinkElement} oDomRefLink the LINK DOM element of the stylesheet
     * @return {boolean} `true` if the passed LINK DOM element refers to a
     * lightspeed CSS URL
     */
    UCF_ResourceUtil["bIsLightspeedCssLink"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsLightspeedCssLink"]++;
        }
        ;
        return !!(
            oDomRefLink &&
            oDomRefLink["getAttribute"] &&
            (
                oDomRefLink["getAttribute"]('data-sap-ls-css') ||
                /(\/ls\/ls_|\/UR\/ls\/).*\.css/["test"](oDomRefLink["getAttribute"]('href'))
            )
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsLightspeedCssLink"] = 0;
    }
    ;

    /**
     * Sets an given URL to the LS stylesheet element
     * @public
     * @param {string} sCssLinkUrl The CSS URL
     * @param {HTMLLinkElement} [oLinkRef=UCF_ResourceUtil.oGetLightspeedCssLink()] the link element
     */
    UCF_ResourceUtil["setLightspeedCssLinkUrl"] = function (sCssLinkUrl, oLinkRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["setLightspeedCssLinkUrl"]++;
        }
        ;
        /** @type {function(): void} */
        var fLoaded;
        /** @type {HTMLLinkElement} */
        var oNewLink;
        /** @type {number} */
        var i;

        if (sCssLinkUrl) {
            if (!oLinkRef) {
                oLinkRef = UCF_ResourceUtil["oGetLightspeedCssLink"]();
            }

            if (oLinkRef &&
                sCssLinkUrl !== UCF_ResourceUtil["sGetLightspeedCssLinkUrl"](oLinkRef)
            ) {
                oLinkRef["setAttribute"]('bLsLoaded', 'false');

                fLoaded = function () {
                    UCF_DomUtil["detachEvent"](oNewLink || oLinkRef, 'load', fLoaded);
                    UCF_DomUtil["detachEvent"](oNewLink || oLinkRef, 'error', fLoaded);
                    if (UCF_UserAgent["bIsChromium"]() || UCF_UserAgent["bIsWebKit"]() || UCF_UserAgent["bIsMSEdge"]()) {
                        // Chrome would not really write the changed value to the DOM
                        // otherwise(?!)
                        UCF_JsUtil["setImmediate"](function () {
                            UCF_ResourceUtil["onLoad"](oLinkRef);
                        });
                    } else {
                        UCF_ResourceUtil["onLoad"](oLinkRef);
                    }
                };

                if (UCF_UserAgent["bIsChromium"]() || UCF_UserAgent["bIsWebKit"]()) {
                    // Workaround: Chrome would not trigger load event when loading the css
                    // from a changed href
                    // Note: cloneNode() did not work - it must be a completely fresh new
                    // link element
                    oNewLink = document["createElement"]('LINK');
                    for (i = 0; i < oLinkRef["attributes"]["length"]; i++) {
                        // eslint-disable-next-line max-depth
                        if (oLinkRef["attributes"][i]["name"] !== 'href') {
                            oNewLink["setAttribute"](
                                oLinkRef["attributes"][i]["name"],
                                oLinkRef["attributes"][i]["value"]
                            );
                        }
                    }
                    oNewLink["setAttribute"]('href', sCssLinkUrl);
                    oLinkRef["parentNode"]["replaceChild"](oNewLink, oLinkRef);
                    UCF_DomUtil["attachEvent"](oNewLink, 'load', fLoaded);
                    UCF_DomUtil["attachEvent"](oNewLink, 'error', fLoaded);
                } else {
                    UCF_DomUtil["attachEvent"](oLinkRef, 'load', fLoaded);
                    UCF_DomUtil["attachEvent"](oLinkRef, 'error', fLoaded);
                    oLinkRef["setAttribute"]('href', sCssLinkUrl);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["setLightspeedCssLinkUrl"] = 0;
    }
    ;

    /**
     * @private
     * @param {HTMLLinkElement} oLinkRef
     */
    UCF_ResourceUtil["onLoad"] = function (oLinkRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["onLoad"]++;
        }
        ;
        /** @type {Array.<UCF_ResourceUtil_CssLoadedCallback>} */
        var aCallbacks = [];
        /** @type {number} */
        var i;
        /** @type {UCF_ResourceUtil_CssLoadedCallback} */
        var oCallback;

        if (UCF_UserAgent["bIsChromium"]() || UCF_UserAgent["bIsWebKit"]()) {
            // See workaround below...
            oLinkRef = UCF_DomUtil["$"](oLinkRef["id"]);
        }
        oLinkRef["setAttribute"]('bLsLoaded', 'true');

        if (UCF_ResourceUtil["aCssLoadedCallbacks"]) {
            for (i = 0; i < UCF_ResourceUtil["aCssLoadedCallbacks"]["length"]; i++) {
                oCallback = UCF_ResourceUtil["aCssLoadedCallbacks"][i];
                if (oLinkRef === oCallback["oLightspeedCssLink"]) {
                    oCallback["fCallback"]();
                } else {
                    aCallbacks["push"](oCallback);
                }
            }
            UCF_ResourceUtil["aCssLoadedCallbacks"] = aCallbacks;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["onLoad"] = 0;
    }
    ;

    /**
     * Executes the given callback when the the CSS is loaded
     * @public
     * @return {UCF_Promise<void,void>}
     */
    UCF_ResourceUtil["ensureLightspeedCssLoaded"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["ensureLightspeedCssLoaded"]++;
        }
        ;
        return new (UCF_ClassLoader["oGetClass"]("UCF_Promise"))(function (resolve) {
            if (UCF_ResourceUtil["bLightspeedCssLoaded"]()) {
                resolve();
            } else {
                if (!UCF_ResourceUtil["aCssLoadedCallbacks"]) {
                    UCF_ResourceUtil["aCssLoadedCallbacks"] = [];
                }
                UCF_ResourceUtil["aCssLoadedCallbacks"]["push"]({
                    "fCallback": resolve,
                    "oLightspeedCssLink": UCF_ResourceUtil["oGetLightspeedCssLink"]()
                });
            }
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["ensureLightspeedCssLoaded"] = 0;
    }
    ;

    /**
     * @public
     * @return {boolean} whether the CSS is loaded or not.
     */
    UCF_ResourceUtil["bLightspeedCssLoaded"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bLightspeedCssLoaded"]++;
        }
        ;
        return UCF_ResourceUtil["oGetLightspeedCssLink"]()["getAttribute"]('bLsLoaded') !== 'false';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bLightspeedCssLoaded"] = 0;
    }
    ;

    /**
     * @public
     * @param {HTMLLinkElement} oLightspeedCssLink optional
     * @return {string} the URL of the LS stylesheet element
     */
    UCF_ResourceUtil["sGetLightspeedCssLinkUrl"] = function (oLightspeedCssLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetLightspeedCssLinkUrl"]++;
        }
        ;
        if (!oLightspeedCssLink) {
            oLightspeedCssLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
        }

        return oLightspeedCssLink ? oLightspeedCssLink["getAttribute"]('href') : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetLightspeedCssLinkUrl"] = 0;
    }
    ;

    /**
     * @public
     * @return {HTMLLinkElement} the link element refering to the main CSS
     * stylesheet
     */
    UCF_ResourceUtil["oGetLightspeedCssLink"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["oGetLightspeedCssLink"]++;
        }
        ;
        /** @type {NodeList.<HTMLLinkElement>} */
        var aDomRefLinks = document["getElementsByTagName"]('LINK');
        /** @type {number} */
        var i;

        for (i = 0; i < aDomRefLinks["length"]; i++) {
            if (UCF_ResourceUtil["bIsLightspeedCssLink"](aDomRefLinks[i])) {
                return aDomRefLinks[i];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["oGetLightspeedCssLink"] = 0;
    }
    ;

    /**
     * @public
     * @return {Object} the link element refering to the main CSS sytlesheet
     */
    UCF_ResourceUtil["oGetLightspeedCssStylesheet"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["oGetLightspeedCssStylesheet"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oDomRefLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();

        return oDomRefLink
            ? (oDomRefLink["sheet"] || oDomRefLink["styleSheet"])
            : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["oGetLightspeedCssStylesheet"] = 0;
    }
    ;

    /**
     * IE <= 9 has a limit of 4096 rules (12bit) per stylesheet. Therefore we have
     * to live with a hack that the files have to be splitted and stored seperatly
     * so that IE9 can request it.
     * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/10164546.aspx
     *
     * This method checks if the leading stylesheet has claims that it has an
     * additional artifact to load and loads it
     *
     * @param {HTMLLinkElement} oDomRefLink the LINK DOM element of the stylesheet
     * @public
     */
    UCF_ResourceUtil["applyIECssRuleLimitWorkaround"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["applyIECssRuleLimitWorkaround"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_CssMetaData} */
        var oCssMetaData;
        /** @type {string} */
        var oDomRefSplitLinkId;
        /** @type {HTMLLinkElement} */
        var oDomRefSplitLink;
        /** @type {string} */
        var sHrefSplit;

        if (window["UCF_System"]["sDevice"] === 'standards' &&
            UCF_UserAgent["bIsIE"]() &&
            !UCF_UserAgent["bIsIE"](10) // eslint-disable-line no-magic-numbers
        ) {
            if (!oDomRefLink) {
                oDomRefLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
            }

            if (oDomRefLink) {
                oCssMetaData = UCF_ResourceUtil["oExtractCssMetaData"](oDomRefLink);
                oDomRefSplitLinkId = 'IE_CSS_RULE_LIMIT';
                oDomRefSplitLink = UCF_DomUtil["$"](oDomRefSplitLinkId);

                if (!oDomRefLink["onload"]) {
                    oDomRefLink["onload"] = function () {
                        UCF_ResourceUtil["applyIECssRuleLimitWorkaround"]();
                    };
                }

                if (oCssMetaData &&
                    oCssMetaData["IECssRuleLimitFiles"] &&
                    oCssMetaData["IECssRuleLimitFiles"]["length"]
                ) {
                    sHrefSplit = oDomRefLink
                        ["getAttribute"]('href')
                        ["replace"](
                        /(.*\/)(.*\.css)(.*)/,
                        '$1' + oCssMetaData["IECssRuleLimitFiles"][0] + '$3'
                    );

                    if (oDomRefSplitLink) {
                        // eslint-disable-next-line max-depth
                        if (sHrefSplit !== oDomRefSplitLink["getAttribute"]('href')) {
                            oDomRefSplitLink["setAttribute"]('href', sHrefSplit);
                        }
                    } else {
                        oDomRefSplitLink = document["createElement"]('link');
                        oDomRefSplitLink["setAttribute"]('id', oDomRefSplitLinkId);
                        oDomRefSplitLink["setAttribute"]('rel', 'stylesheet');
                        oDomRefSplitLink["setAttribute"]('type', 'text/css');
                        oDomRefSplitLink["setAttribute"]('href', sHrefSplit);
                        oDomRefLink["parentNode"]["insertBefore"](
                            oDomRefSplitLink,
                            oDomRefLink["nextSibling"]
                        );
                    }
                } else if (oDomRefSplitLink) {
                    oDomRefLink["parentNode"]["removeChild"](oDomRefSplitLink);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["applyIECssRuleLimitWorkaround"] = 0;
    }
    ;

    /**
     * @public
     * @param {HTMLLinkElement} [oDomRefLink=UCF_ResourceUtil.oGetLightspeedCssLink()]
     * the LINK DOM element of the stylesheet
     * @return {UCF_ResourceUtil_CssMetaData} the CSS meta data from an passed link element
     */
    UCF_ResourceUtil["oExtractCssMetaData"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["oExtractCssMetaData"]++;
        }
        ;
        /** @type {string} */
        var sInfoStyle;
        /** @type {Array.<string>} */
        var aMatch;
        /** @type {string} */
        var sJSON;

        if (!oDomRefLink) {
            oDomRefLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
        }

        if (oDomRefLink && oDomRefLink["className"]) {
            sInfoStyle = UCF_DomUtil["sGetCurrentStyle"](oDomRefLink, 'backgroundImage');

            if (sInfoStyle && sInfoStyle !== 'none') {
                aMatch = sInfoStyle["match"](/\{.*\}/);
                if (aMatch) {
                    sJSON = aMatch[0]["replace"](/\\"/g, '"')["replace"](/\%20/g, ' ');

                    try {
                        return UCF_JsUtil["oJsonParse"](sJSON);
                    } catch (e) {
                        if (__UCF_TRACE__) {
                            UCF_Tracer.trace(ERROR, 'Chaught error in UCF_JsUtil.oJsonParse:' + e["message"], "ResourceUtil.js(691): oExtractCssMetaData");
                        }
                        ;
                    }
                    ;
                }
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["oExtractCssMetaData"] = 0;
    }
    ;

    /**
     * @example
     * ```html
     * <style>.myelement__metadata {
     *   background-image: url("data:application/json;charset=utf8,{%22myheight%22:%2014}")
     * }</style>
     * <script>
     * UCF_ResourceUtil.oGetMetadataFromTheme('myelement__metadata') // => {myheight: 14}
     * UCF_ResourceUtil.oGetMetadataFromTheme('.myelement__metadata') // => {myheight: 14}
     * var m = document.createElement('div');
     * m.className = 'myelement_metadata';
     * UCF_ResourceUtil.oGetMetadataFromTheme(m) // => {myheight: 14}
     * </script>
     * ```
     * @protected
     * @param {HTMLElement|string} oElementOrClassName
     * @return {Object}
     */
    UCF_ResourceUtil["oGetMetadataFromTheme"] = function (oElementOrClassName) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["oGetMetadataFromTheme"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oElement;
        /** @type {string} */
        var sBackgroundImage;

        if (typeof oElementOrClassName === 'string') {
            oElement = document["createElement"]('div');
            oElement["className"] = oElementOrClassName["replace"](/^\./, '');
            UCF_DomUtil["setStyle"](oElement, {
                "position": 'absolute',
                "top": '-10000px',
                "display": 'block',
                "height": 0,
                "width": 0
            });
            UCF_DomUtil["prepend"](document["body"], oElement);
        } else {
            oElement = oElementOrClassName;
        }

        if (oElement) {
            try {
                sBackgroundImage = decodeURIComponent(
                    UCF_DomUtil["sGetCurrentStyle"](oElement, 'backgroundImage')
                );

                if (typeof oElementOrClassName === 'string') {
                    UCF_DomUtil["removeFromDom"](oElement);
                }

                if (sBackgroundImage && sBackgroundImage !== 'none') {
                    return UCF_JsUtil["oJsonParse"](sBackgroundImage["slice"](
                        sBackgroundImage["indexOf"]('{'),
                        sBackgroundImage["lastIndexOf"]('}') + 1
                    ));
                } else {
                    return null;
                }
            } catch (e) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Error getting metadata from background-image of "' + oElement["className"] + '" (got: "' + sBackgroundImage + '"): ' + e["message"], "ResourceUtil.js(758): oGetMetadataFromTheme");
                }
                ;

                return null;
            }
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Could not get metadata from ' + oElementOrClassName, "ResourceUtil.js(763): oGetMetadataFromTheme");
            }
            ;

            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["oGetMetadataFromTheme"] = 0;
    }
    ;

    /**
     * @private
     * @param {HTMLLinkElement} oDomRefLink the link element
     * @return {boolean}
     */
    UCF_ResourceUtil["bIsStylesheetLoaded"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsStylesheetLoaded"]++;
        }
        ;
        /** @type {StyleSheetList} */
        var aStyleSheets = document["styleSheets"];
        /** @type {number} */
        var i;

        for (i = 0; i < aStyleSheets["length"]; i++) {
            if (aStyleSheets[i]["href"] === oDomRefLink["href"]) {
                try {
                    if (UCF_UserAgent["bIsFirefox"]()) {
                        return (aStyleSheets[i]["cssRules"] && aStyleSheets[i]["cssRules"]["length"] > 0);
                    } else {
                        return aStyleSheets[i]["rules"] && aStyleSheets[i]["rules"]["length"] > 0;
                    }
                } catch (e) {
                    return !UCF_ResourceUtil["bIsBackGroundTransparent"](oDomRefLink);
                }
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsStylesheetLoaded"] = 0;
    }
    ;

    /**
     * @private
     * @param {HTMLLinkElement} oDomRefLink the link element
     * @return {boolean}
     */
    UCF_ResourceUtil["bIsBackGroundTransparent"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsBackGroundTransparent"]++;
        }
        ;
        /** @type {string} */
        var sCheckStyle = UCF_DomUtil["sGetCurrentStyle"](
            oDomRefLink,
            'backgroundColor'
        );

        return !sCheckStyle || UCF_ColorUtil["sColor"](sCheckStyle) === 'rgba(0, 0, 0, 0)';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsBackGroundTransparent"] = 0;
    }
    ;

    /**
     * @protected
     * @return {UCF_Promise<void>} the promise
     */
    UCF_ResourceUtil["initTheme"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["initTheme"]++;
        }
        ;
        return UCF_ResourceUtil["ensureSupportedTheme"]()
            ["then"](UCF_ResourceUtil["ensureLightspeedCssLoaded"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["initTheme"] = 0;
    }
    ;

    /**
     * @private
     * @return {UCF_Promise<void>}
     */
    UCF_ResourceUtil["ensureSupportedTheme"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["ensureSupportedTheme"]++;
        }
        ;
        // always wait for the css to be loaded => has to be async (via fDone)
        return UCF_ResourceUtil["ensureLightspeedCssLoaded"]()["then"](function () {
            return new (UCF_ClassLoader["oGetClass"]("UCF_Promise"))(function (resolve) {
                // oExtractCssValidationInfo does not contain all information now
                // Note: use this call instead of requestAnimationFrame() because
                // it may not work in Chrome with nested/invisible IFrames (IFrame-popups in FLP!)
                UCF_JsUtil["setImmediate"](function () {
                    /** @type {UCF_ResourceUtil_FallbackThemeID} */
                    var sFallbackThemeID;

                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, window["UCF_System"]["sThemeID"] + '@' + window["UCF_System"]["sThemeRepositoryURL"], "ResourceUtil.js(836): ensureSupportedTheme");
                    }
                    ;

                    // has to be executed before oExtractCssValidationInfo
                    UCF_ResourceUtil["applyIECssRuleLimitWorkaround"]();

                    if (UCF_ResourceUtil["bIsValidTheme"]()) {
                        // theme is valid => done
                        resolve();
                    } else if (
                        // theme not valid but has specified FallbackThemeID
                        // => load from same ThemeRepository
                        UCF_ResourceUtil["bHasFallbackThemeID"]()
                    ) {
                        sFallbackThemeID = UCF_ResourceUtil["sGetFallbackThemeID"]();

                        UCF_ResourceUtil["recursiveThemeFallbackTo"]({
                            "sThemeID": sFallbackThemeID,
                            "sThemeRepositoryURL": UCF_ResourceUtil["bIsSapThemeID"](sFallbackThemeID)
                                ? window["UCF_System"]["sThemeFallbackRepositoryURL"] || window["UCF_System"]["sThemeRepositoryURL"]
                                : window["UCF_System"]["sThemeRepositoryURL"]
                        })["then"](resolve);
                    } else if (
                        // theme not valid and has no FallbackThemeID
                        // => load first sap theme in extends chain from ThemeFallbackRepository
                        UCF_ResourceUtil["bHasExtendsThemeID"]()
                    ) {
                        UCF_ResourceUtil["recursiveThemeFallbackTo"]({
                            "sThemeID": UCF_ResourceUtil["sGetExtendsThemeID"](),
                            "sThemeRepositoryURL": window["UCF_System"]["sThemeFallbackRepositoryURL"] || window["UCF_System"]["sThemeRepositoryURL"]
                        })["then"](resolve);
                    } else if (
                        // sap theme could not be loaded from ThemeRepository
                        // => try again from ThemeFallbackRepository
                        UCF_ResourceUtil["bIsSapThemeID"](window["UCF_System"]["sThemeID"]) &&
                        window["UCF_System"]["sThemeFallbackRepositoryURL"] &&
                        !UCF_ResourceUtil["bIsOperatingOnThemeFallbackRepository"]()
                    ) {
                        UCF_ResourceUtil["recursiveThemeFallbackTo"]({
                            "sThemeRepositoryURL": window["UCF_System"]["sThemeFallbackRepositoryURL"] || window["UCF_System"]["sThemeRepositoryURL"]
                        })["then"](resolve);
                    } else if (
                        window["UCF_System"]["sThemeFallbackID"] &&
                        (window["UCF_System"]["sThemeFallbackRepositoryURL"] || window["UCF_System"]["sThemeRepositoryURL"])
                    ) {
                        // no fallback found in fallback or extends chain, but ThemeFallbackID
                        // specified => direct fallback to ThemeFallbackID@ThemeFallbackRepositoryURL
                        UCF_ResourceUtil["directThemeFallbackTo"]({
                            "sThemeID": window["UCF_System"]["sThemeFallbackID"],
                            "sThemeRepositoryURL": window["UCF_System"]["sThemeFallbackRepositoryURL"] || window["UCF_System"]["sThemeRepositoryURL"]
                        })["then"](resolve);
                    } else {
                        // no fallback found in fallback or extends chain, no ThemeFallbackID
                        // => direct fallback to ThemeFallbackCSSURL
                        UCF_ResourceUtil["directThemeFallbackTo"]({
                            "sThemeFallbackCSSURL": window["UCF_System"]["sThemeFallbackCSSURL"]
                        })["then"](resolve);
                    }
                });
            });
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["ensureSupportedTheme"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {{sThemeRepositoryURL: string, sThemeID: string}} oParams
     * @return {UCF_Promise<void>}
     */
    UCF_ResourceUtil["recursiveThemeFallbackTo"] = function (oParams) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["recursiveThemeFallbackTo"]++;
        }
        ;
        /** @type {{sThemeID: string, sThemeRepositoryURL: string}} */
        var oConf = UCF_JsUtil["extend"]({
            "sThemeID": window["UCF_System"]["sThemeID"],
            "sThemeRepositoryURL": window["UCF_System"]["sThemeRepositoryURL"]
        }, oParams);

        if (window["UCF_System"]["sThemeID"] !== oConf["sThemeID"]) {
            window["UCF_System"]["setThemeID"](oConf["sThemeID"]);
        }
        if (window["UCF_System"]["sThemeRepositoryURL"] !== oConf["sThemeRepositoryURL"]) {
            window["UCF_System"]["setThemeRepositoryURL"](oConf["sThemeRepositoryURL"]);
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, oConf["sThemeID"] + '@' + oConf["sThemeRepositoryURL"], "ResourceUtil.js(918): recursiveThemeFallbackTo");
        }
        ;
        UCF_ResourceUtil["setLightspeedCssLinkUrl"](UCF_ResourceUtil["sGetCssUrl"]());

        return UCF_ResourceUtil["ensureSupportedTheme"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["recursiveThemeFallbackTo"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {{sThemeFallbackCSSURL: string}} oParams
     * @return {UCF_Promise<void>}
     */
    UCF_ResourceUtil["directThemeFallbackTo"] = function (oParams) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["directThemeFallbackTo"]++;
        }
        ;
        /** @type {{sThemeFallbackCSSURL: string}} */
        var oConf = UCF_JsUtil["extend"]({
            "sThemeFallbackCSSURL": window["UCF_System"]["sThemeFallbackCSSURL"]
        }, oParams);

        if (oConf["sThemeID"] && oConf["sThemeRepositoryURL"]) {
            // repository mode => direct fallback to ThemeFallbackID@ThemeRepositoryURL
            window["UCF_System"]["setThemeID"](oConf["sThemeID"]);
            window["UCF_System"]["setThemeRepositoryURL"](oConf["sThemeRepositoryURL"]);
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, oConf["sThemeID"] + '@' + oConf["sThemeRepositoryURL"], "ResourceUtil.js(940): directThemeFallbackTo");
            }
            ;
            UCF_ResourceUtil["setLightspeedCssLinkUrl"](UCF_ResourceUtil["sGetCssUrl"]());
        } else {
            // last resort mode => direct fallback to ThemeFallbackCSSURL
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, oConf["sThemeFallbackCSSURL"], "ResourceUtil.js(944): directThemeFallbackTo");
            }
            ;
            UCF_ResourceUtil["setLightspeedCssLinkUrl"](oConf["sThemeFallbackCSSURL"]);
        }

        return UCF_ResourceUtil["ensureLightspeedCssLoaded"]()["then"](function () {
            return new (UCF_ClassLoader["oGetClass"]("UCF_Promise"))(function (resolve) {
                // oExtractCssMetaData doesn't contain the ThemeID in Safari at this moment
                // => request AF, try later
                UCF_JsUtil["requestAnimationFrame"](function () {
                    /** @type {string} */
                    var sThemeID = UCF_ResourceUtil["sGetThemeID"]();

                    if (sThemeID && window["UCF_System"]["sThemeID"] !== sThemeID) {
                        window["UCF_System"]["setThemeID"](sThemeID);
                    }

                    resolve();
                });
            });
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["directThemeFallbackTo"] = 0;
    }
    ;

    /**
     * @protected
     * @static
     * @param {UCF_ResourceUtil_CssMetaData} [oCssMetaData]
     * @return {string}
     */
    UCF_ResourceUtil["sGetThemeID"] = function (oCssMetaData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeID"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_CssMetaData} */
        var oCM = oCssMetaData || UCF_ResourceUtil["oExtractCssMetaData"]();

        // eslint-disable-next-line no-magic-numbers
        return oCM && oCM["Path"] && oCM["Path"]["split"]('.')[2] || '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeID"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @return {boolean}
     */
    UCF_ResourceUtil["bIsValidTheme"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsValidTheme"]++;
        }
        ;
        return !UCF_ResourceUtil["oExtractCssValidationInfo"]()["isRejected"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsValidTheme"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @return {boolean} `true` if the theme has a FallbackThemeID, otherwise `false`
     */
    UCF_ResourceUtil["bHasFallbackThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bHasFallbackThemeID"]++;
        }
        ;
        return !!UCF_ResourceUtil["sGetFallbackThemeID"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bHasFallbackThemeID"] = 0;
    }
    ;

    /** @type {{string: UCF_ResourceUtil_FallbackThemeID}} */
    UCF_ResourceUtil["oFallbackThemeIDs"] = {};

    /**
     * @private
     * @static
     * @return {UCF_ResourceUtil_FallbackThemeID}
     */
    UCF_ResourceUtil["sGetFallbackThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetFallbackThemeID"]++;
        }
        ;
        /** @type {string} */
        var sCssUrl;

        if (UCF_ResourceUtil["bIsRepositoryMode"]()) {
            sCssUrl = UCF_ResourceUtil["sGetCssUrl"]();

            if (!(sCssUrl in UCF_ResourceUtil["oFallbackThemeIDs"])) {
                UCF_ResourceUtil["oFallbackThemeIDs"][sCssUrl] = UCF_ResourceUtil["sGetThemeFallbackIDFromFallbackThemeID"](
                    UCF_ResourceUtil["oExtractCssMetaData"]()
                ) || '';
            }

            return UCF_ResourceUtil["oFallbackThemeIDs"][sCssUrl];
        } else {
            return '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetFallbackThemeID"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @return {boolean}
     */
    UCF_ResourceUtil["bHasExtendsThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bHasExtendsThemeID"]++;
        }
        ;
        return !!UCF_ResourceUtil["sGetExtendsThemeID"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bHasExtendsThemeID"] = 0;
    }
    ;

    /** @type {{string: UCF_ResourceUtil_ExtendsThemeID}} */
    UCF_ResourceUtil["oExtendsThemeIDs"] = {};

    /**
     * @private
     * @static
     * @return {UCF_ResourceUtil_ExtendsThemeID}
     */
    UCF_ResourceUtil["sGetExtendsThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetExtendsThemeID"]++;
        }
        ;
        /** @type {string} */
        var sCssUrl;

        if (UCF_ResourceUtil["bIsRepositoryMode"]()) {
            sCssUrl = UCF_ResourceUtil["sGetCssUrl"]();

            if (!(sCssUrl in UCF_ResourceUtil["oExtendsThemeIDs"])) {
                UCF_ResourceUtil["oExtendsThemeIDs"][sCssUrl] = UCF_ResourceUtil["sGetThemeFallbackIDFromExtends"](
                    UCF_ResourceUtil["oExtractCssMetaData"]()
                ) || '';
            }

            return UCF_ResourceUtil["oExtendsThemeIDs"][sCssUrl];
        } else {
            return '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetExtendsThemeID"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sThemeID
     * @return {boolean} `true` if `sThemeID` starts with `sap_`, otherwise `false`
     */
    UCF_ResourceUtil["bIsSapThemeID"] = function (sThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsSapThemeID"]++;
        }
        ;
        return typeof sThemeID === 'string'
            && UCF_StringUtil["bStartsWith"](sThemeID, 'sap_');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsSapThemeID"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @return {boolean} `true` if the theme repository is also the theme fallback
     * repository, otherwise `false`
     */
    UCF_ResourceUtil["bIsOperatingOnThemeFallbackRepository"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsOperatingOnThemeFallbackRepository"]++;
        }
        ;
        return window["UCF_System"]["sThemeRepositoryURL"] &&
            typeof window["UCF_System"]["sThemeRepositoryURL"] === 'string' &&
            window["UCF_System"]["sThemeRepositoryURL"] === window["UCF_System"]["sThemeFallbackRepositoryURL"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsOperatingOnThemeFallbackRepository"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_ResourceUtil_CssMetaData} oCssMetaData
     * @return {string}
     */
    UCF_ResourceUtil["sGetThemeFallbackIDFromFallbackThemeID"] = function (oCssMetaData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromFallbackThemeID"]++;
        }
        ;
        return oCssMetaData
            && UCF_ResourceUtil["sGetSupportedThemeFallbackID"](
                oCssMetaData["FallbackThemeId"]
            );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromFallbackThemeID"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_ResourceUtil_CssMetaData} oCssMetaData
     * @return {string}
     */
    UCF_ResourceUtil["sGetThemeFallbackIDFromExtends"] = function (oCssMetaData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromExtends"]++;
        }
        ;
        return oCssMetaData
            && oCssMetaData["Extends"]
            && (
                // 1) try with SapFallbackChain (sap_belize -> sap_bluecrystal)
                UCF_ResourceUtil["sGetSupportedThemeFallbackID"](
                    UCF_ResourceUtil["sGetThemeFallbackIDFromSapFallbackChain"](
                        window["UCF_System"]["sThemeID"]
                    )
                ) ||
                // 2) try with 1st of Extends Chain (sap_belize -> sap_base_fiori)
                UCF_ResourceUtil["sGetSupportedThemeFallbackID"](oCssMetaData["Extends"][0])
            );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromExtends"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sFallbackThemeID
     * @return {string}
     */
    UCF_ResourceUtil["sGetSupportedThemeFallbackID"] = function (sFallbackThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetSupportedThemeFallbackID"]++;
        }
        ;
        /** @type {string} */
        var sID;

        if (typeof sFallbackThemeID === 'string' && !UCF_ResourceUtil["bIsSapThemeID"](sFallbackThemeID)) {
            // non-sap fallback theme => use directly
            return sFallbackThemeID;
        } else if (sFallbackThemeID === null) {
            // no fallback theme found => break
            return null;
        } else {
            // fallback possible => check SapFallbackChain, use only if different
            sID = sFallbackThemeID || window["UCF_System"]["sThemeID"];

            if (UCF_ResourceUtil["bIsSapThemeID"](sID)) {
                return window["UCF_System"]["bIsSupportedSapThemeID"](sID)
                    ? (sID === window["UCF_System"]["sThemeID"] ? null : sID)
                    : UCF_ResourceUtil["sGetSupportedThemeFallbackID"](
                        UCF_ResourceUtil["sGetThemeFallbackIDFromSapFallbackChain"](sID)
                    );
            } else {
                return sFallbackThemeID;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetSupportedThemeFallbackID"] = 0;
    }
    ;

    /**
     * The hard-coded fallback chain of SAP themes
     * ===========================================
     *
     * ```
     * +------------------+
     * | sap_fiori_3_dark |
     * +---------+--------+
     *           |
     * +---------+--------+ +------------------+
     * |    sap_fiori_3   | |  sap_belize_plus |
     * +---------+--------+ +---------+--------+
     *           |                    |
     * +---------+--------------------+--------+                                           +------------------+
     * |               sap_belize              |                                           |  sap_fiori_hcw   |
     * +---------+-----------------------------+                                           +---------+--------+
     *           |                                                                                   |
     * +---------+--------+ +------------------+                      +------------------+ +---------+--------+
     * |  sap_bluecrystal | |     sap_corbu    |                      |  sap_fiori_3_hcb | |  sap_belize_hcw  |
     * +---------+--------+ +---------+--------+                      +---------+--------+ +---------+--------+
     *           |                    |                                         |                    |
     * +---------+--------------------+--------+ +------------------+ +---------+--------------------+--------+
     * |          sap_goldreflection           | |   sap_platinum   | |            sap_belize_hcb             |
     * +-------------------+-------------------+ +---------+--------+ +------------------------------+--------+
     *                     |                               |                                         |
     * +-------------------+-------------------------------+--------+ +------------------+ +---------+--------+
     * |                        sap_tradeshow_plus                  | |    sap_chrome    | |     sap_hcb      |
     * +------------------------------+-----------------------------+ +---------+--------+ +---------+--------+
     *                                |                                         |                    |
     * +------------------------------+-----------------------------------------+--------------------+--------+
     * |                                             sap_tradeshow                                            |
     * +------------------------------------------------------------------------------------------------------+
     * ```
     *
     * @private
     * @static
     * @param {string} sThemeID
     * @return {string}
     */
    UCF_ResourceUtil["sGetThemeFallbackIDFromSapFallbackChain"] = function (sThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromSapFallbackChain"]++;
        }
        ;
        switch (sThemeID) {
            /* beautify preserve:start */
            case 'sap_fiori_3_dark':
                return 'sap_fiori_3';
            case 'sap_fiori_3':
                return 'sap_belize';
            case 'sap_belize_plus':
                return 'sap_belize';
            case 'sap_belize':
                return 'sap_bluecrystal';
            case 'sap_bluecrystal':
                return 'sap_goldreflection';
            case 'sap_corbu':
                return 'sap_goldreflection';
            case 'sap_goldreflection':
                return 'sap_tradeshow_plus';
            case 'sap_platinum':
                return 'sap_tradeshow_plus';
            case 'sap_tradeshow_plus':
                return 'sap_tradeshow';
            case 'sap_chrome':
                return 'sap_tradeshow';
            case 'sap_fiori_3_hcw':
                return 'sap_belize_hcw';
            case 'sap_fiori_3_hcb':
                return 'sap_belize_hcb';
            case 'sap_belize_hcw':
                return 'sap_belize_hcb';
            case 'sap_belize_hcb':
                return 'sap_hcb';
            case 'sap_hcb':
                return 'sap_tradeshow';
            default:
                return null;
            /* beautify preserve:end */
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetThemeFallbackIDFromSapFallbackChain"] = 0;
    }
    ;

    /**
     * @public
     * @param {HTMLLinkElement} [oDomRefLink=UCF_ResourceUtil.oGetLightspeedCssLink()]
     * the LINK DOM element of the stylesheet.
     * @return {UCF_ResourceUtil_VersionInfo} the result
     */
    UCF_ResourceUtil["oExtractCssValidationInfo"] = function (oDomRefLink) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["oExtractCssValidationInfo"]++;
        }
        ;
        /** @type {Array.<string>} */
        var aVersionOrder = ['major', 'minor', 'revision', 'patch', 'build'];
        /** @type {UCF_ResourceUtil_VersionInfo} */
        var oInfo = {
            "versionCss": null,
            "versionCssRequired": null,
            "versionRuntimeRequired": null,
            "versionRuntime": null,
            "matchResult": null,
            "isRejected": false
        };
        /** @type {Object.<string,string>} */
        var oVersionStrings = {
            "versionCss": null,
            "versionCssRequired": null,
            "versionRuntimeRequired": null,
            "versionRuntime": null
        };
        /** @type {UCF_ResourceUtil_CssMetaData} */
        var oCssMetaData;
        /** @type {string} */
        var sThemeID = window["UCF_System"]["sThemeID"];
        /** @type {UCF_ResourceUtil_ExtendsThemeID} */
        var sExtendsThemeID;
        /** @type {string} */
        var sId;
        /** @type {string} */
        var sVersion;
        /** @type {Array.<string>} */
        var aSplit;
        /** @type {number} */
        var i;
        /** @type {string} */
        var sVersionLevel;

        if (!oDomRefLink) {
            oDomRefLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
        }

        // Retrieve the versionCss
        if (oDomRefLink["className"]) {
            oCssMetaData = UCF_ResourceUtil["oExtractCssMetaData"](oDomRefLink);

            if (oCssMetaData) {
                if (oCssMetaData["Version"]) {
                    if (oCssMetaData["Version"]["Build"]) {
                        oVersionStrings["versionCss"] = oCssMetaData["Version"]["Build"];
                    }
                    if (oCssMetaData["Version"]["Required"]) {
                        oVersionStrings["versionRuntimeRequired"] =
                            oCssMetaData["Version"]["Required"];
                    }
                }
                if (oCssMetaData["Path"]) {
                    // eslint-disable-next-line no-magic-numbers
                    sThemeID = oCssMetaData["Path"]["split"]('.')[2];
                }

                if (oVersionStrings["versionCss"]) {
                    oDomRefLink["setAttribute"](
                        'data-sap-ls-css-version',
                        oVersionStrings["versionCss"]
                    );
                }
                if (oVersionStrings["versionRuntimeRequired"]) {
                    oDomRefLink["setAttribute"](
                        'data-sap-ls-css-requiredruntimeversion',
                        oVersionStrings["versionRuntimeRequired"]
                    );
                }
            } else if (UCF_ResourceUtil["bIsStylesheetLoaded"](oDomRefLink)) {
                oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["MetadataUnavailable"];

                if (UCF_ResourceUtil["bIsBackGroundTransparent"](oDomRefLink)) {
                    oInfo["matchResult"] =
                        UCF_ResourceUtil["MATCH_RESULT"]["ResourceUnavailable"];
                }
            } else {
                oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["ResourceUnavailable"];
            }
        }

        // Retrieve required version and runtime version
        oVersionStrings["versionCssRequired"] = oDomRefLink["getAttribute"](
            'data-sap-ls-css-requiredversion'
        );
        oVersionStrings["versionRuntime"] = oDomRefLink["getAttribute"](
            'data-sap-ls-runtimeVersion'
        );

        if (!oVersionStrings["versionCssRequired"] && oVersionStrings["versionRuntime"]) {
            oVersionStrings["versionCssRequired"] = oVersionStrings["versionRuntime"];
        }

        if (!oInfo["matchResult"] && sThemeID) {
            sExtendsThemeID = UCF_JsUtil["find"](
                [sThemeID]["concat"]((oCssMetaData && oCssMetaData["Extends"]) || []),
                function (sTheme) {
                    return UCF_ResourceUtil["bIsSapThemeID"](sTheme);
                }
            );

            if (
                sExtendsThemeID &&
                !window["UCF_System"]["bIsSupportedSapThemeID"](sExtendsThemeID)
            ) {
                oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["Unsupported"];
            }
        }

        if (!oVersionStrings["versionCssRequired"] && !oInfo["matchResult"]) {
            oInfo["matchResult"] =
                UCF_ResourceUtil["MATCH_RESULT"]["RequiredVersionUnavailable"];
        }

        if (!oInfo["matchResult"]) {
            // Parse versions
            for (sId in oVersionStrings) {
                sVersion = oVersionStrings[sId];

                if (sVersion) {
                    aSplit = sVersion["split"]('.');
                    oInfo[sId] = {"versionString": sVersion};

                    for (i = 0; i < aVersionOrder["length"]; i++) {
                        if (aSplit[i]) {
                            oInfo[sId][aVersionOrder[i]] = parseInt(aSplit[i], 10);
                        }
                    }
                }
            }

            // STAGE1 Compare if required CSS version is lower than CSS version
            if (oInfo["versionCss"] && oInfo["versionCssRequired"]) {
                oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["Match"];

                for (i = 0; i < aVersionOrder["length"]; i++) {
                    sVersionLevel = aVersionOrder[i];

                    if (sVersionLevel in oInfo["versionCssRequired"] &&
                        sVersionLevel in oInfo["versionCss"]
                    ) {
                        if (oInfo["versionCssRequired"][sVersionLevel] >
                            oInfo["versionCss"][sVersionLevel]
                        ) {
                            oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["MismatchCss"];
                            break;
                        } else if (oInfo["versionCssRequired"][sVersionLevel] <
                            oInfo["versionCss"][sVersionLevel]
                        ) {
                            oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["Match"];
                            break;
                        } // continue when equals
                    }
                }
            }

            // STAGE2 Compare if required runtime version is lower than runtime version
            if (oInfo["matchResult"] === UCF_ResourceUtil["MATCH_RESULT"]["Match"]) {
                if (!oInfo["versionRuntime"] && oInfo["versionRuntimeRequired"]) {
                    oInfo["matchResult"] =
                        UCF_ResourceUtil["MATCH_RESULT"]["RuntimeVersionUnavailable"];
                } else if (oInfo["versionRuntime"] && oInfo["versionRuntimeRequired"]) {
                    for (i = 0; i < aVersionOrder["length"]; i++) {
                        sVersionLevel = aVersionOrder[i];

                        if (sVersionLevel in oInfo["versionRuntimeRequired"] &&
                            sVersionLevel in oInfo["versionRuntime"]
                        ) {
                            if (oInfo["versionRuntimeRequired"][sVersionLevel] >
                                oInfo["versionRuntime"][sVersionLevel]
                            ) {
                                oInfo["matchResult"] =
                                    UCF_ResourceUtil["MATCH_RESULT"]["MismatchRuntime"];
                                break;
                            } else if (oInfo["versionRuntimeRequired"][sVersionLevel] <
                                oInfo["versionRuntime"][sVersionLevel]
                            ) {
                                oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["Match"];
                                break;
                            } // continue when equals
                        }
                    }
                }
            }
        }

        if (!oInfo["matchResult"]) {
            oInfo["matchResult"] = UCF_ResourceUtil["MATCH_RESULT"]["Unavailable"];
        }

        oInfo["isRejected"] = UCF_ResourceUtil["bIsThemeRejected"](oInfo, sExtendsThemeID);

        oDomRefLink["setAttribute"]('data-sap-ls-css-version-match', oInfo["matchResult"]);
        oDomRefLink["setAttribute"](
            'data-sap-ls-css-version-isrejected',
            oInfo["isRejected"]
        );

        return oInfo;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["oExtractCssValidationInfo"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {UCF_ResourceUtil_VersionInfo} oInfo
     * @param {string} sFirstSapThemeID
     * @return {boolean}
     */
    UCF_ResourceUtil["bIsThemeRejected"] = function (oInfo, sFirstSapThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bIsThemeRejected"]++;
        }
        ;
        switch (oInfo["matchResult"]) {
            case UCF_ResourceUtil["MATCH_RESULT"]["Match"]:
                return false;
            case UCF_ResourceUtil["MATCH_RESULT"]["MismatchCss"]:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'The loaded CSS does not match to the rendered HTML. This will lead to display problems. The runtime requires a CSS version ' + oInfo["versionCssRequired"]["versionString"] + ' while actually version ' + oInfo["versionCss"]["versionString"] + ' is provided.', "ResourceUtil.js(1431): bIsThemeRejected");
                }
                ;
                return true; // eslint-disable-line newline-before-return
            case UCF_ResourceUtil["MATCH_RESULT"]["MismatchRuntime"]:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'The loaded CSS does not match to the rendered HTML. This will lead to display problems. The CSS requires a runtime version ' + oInfo["versionRuntimeRequired"]["versionString"] + ' while actually version ' + oInfo["versionRuntime"]["versionString"] + ' is provided.', "ResourceUtil.js(1434): bIsThemeRejected");
                }
                ;
                return true; // eslint-disable-line newline-before-return
            case UCF_ResourceUtil["MATCH_RESULT"]["Unsupported"]:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'The loaded CSS derives from a theme that is not supported by the application. Only themes deriving from one of ' + window["UCF_System"]["sSupportedSapThemeIDs"] + ' are supported, "' + sFirstSapThemeID + '" is none of them.', "ResourceUtil.js(1437): bIsThemeRejected");
                }
                ;
                return true; // eslint-disable-line newline-before-return
            case UCF_ResourceUtil["MATCH_RESULT"]["RuntimeVersionUnavailable"]:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'The loaded CSS requires a runtime version but runtime version is not available.', "ResourceUtil.js(1440): bIsThemeRejected");
                }
                ;
                return true; // eslint-disable-line newline-before-return
            case UCF_ResourceUtil["MATCH_RESULT"]["ResourceUnavailable"]:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'The CSS resource could not be loaded.', "ResourceUtil.js(1443): bIsThemeRejected");
                }
                ;
                return true; // eslint-disable-line newline-before-return
            default:
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Failed to compare producer version. Reason: ' + oInfo["matchResult"], "ResourceUtil.js(1446): bIsThemeRejected");
                }
                ;
                return false; // eslint-disable-line newline-before-return
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bIsThemeRejected"] = 0;
    }
    ;

    /** @type {Object<string, UCF_ResourceUtil_SvgLibInfo>} map of sLibUrl=>oLibInfo */
    UCF_ResourceUtil["mLoadedSvgLibs"] = {};
    /** @type {number} */
    UCF_ResourceUtil["iCurrentInlineIdPrefixCount"] = 0;
    /** @type {number} */
    UCF_ResourceUtil["iCurrentUseIdCount"] = 0;

    /**
     * @param {string} sHtml the html string to decode
     * @return {string} the decoded html string
     */
    UCF_ResourceUtil["sDecodeSvgHtml"] = function (sHtml) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sDecodeSvgHtml"]++;
        }
        ;
        return sHtml["replace"](/&#x(.+?);/g, function (sMatch, sHexCharCode) {
            return String["fromCharCode"](parseInt(sHexCharCode, 16));
        })["replace"](/&(lt|gt|amp|quot);/g, function (sMatch, sEntity) {
            if (sEntity === 'lt') {
                return '<';
            }
            if (sEntity === 'gt') {
                return '>';
            }
            if (sEntity === 'amp') {
                return '&';
            }
            if (sEntity === 'quot') {
                return '"';
            }

            return null;
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sDecodeSvgHtml"] = 0;
    }
    ;

    /** @public */
    UCF_ResourceUtil["enableSVG"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["enableSVG"]++;
        }
        ;
        UCF_ResourceUtil["bSVGEnabled"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["enableSVG"] = 0;
    }
    ;

    /**
     * @private
     * @const {RegExp}
     */
    UCF_ResourceUtil["R_SVG"] = /\<svg (.+?)xlink\:href\=([\'\"])(.*?\.svg)(?:#|\?.*?#|.*?&#x23;)(.+?)(?:\2|(?:(\?|&amp;)metric|(\?|&amp;)aspectRatio|(\?|&amp;)color|(\?|&)metric|(\?|&)aspectRatio|(\?|&)color)=.*?\2)(.*?\>)/g;

    /**
     * @private
     * @const {RegExp}
     */
    UCF_ResourceUtil["R_METRIC"] = /(\?|&)?metric=(s|m|l|xl)/;
    /**
     * @private
     * @const {RegExp}
     */
    UCF_ResourceUtil["R_ASPECT_RATIO"] = /(\?|&)?aspectRatio=(1|2)/;
    /**
     * @private
     * @const {RegExp}
     */
    UCF_ResourceUtil["R_COLOR"] = /(\?|&)?color=(Contrast|Critical|Default|Marker|Negative|Neutral|NonInteractive|Positive|Tile)/;

    /**
     * URL rewritung by HTML replacement instead of DOM operation
     * Looks risky but takes only 2-10 ms for a huge HTML and avoids afterwards an
     * onload event for the SVGs which results in a performance improvement
     *
     * @public
     * @param {string} sHtml the html to inline the svg
     * @param {UCF_LS} [oLS] the lightspeed instance
     * @return {string} sHtml with the svgs inlined
     */
    UCF_ResourceUtil["sInlineSvgByHtmlExchange"] = function (sHtml, oLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sInlineSvgByHtmlExchange"]++;
        }
        ;
        /** @type {string} */
        var sResultHtml;

        if (UCF_ResourceUtil["bSVGEnabled"]) {
            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(START, 'Inline SVG by HTML exchange');
            }
            ;

            // eslint-disable-next-line complexity
            sResultHtml = sHtml["replace"](UCF_ResourceUtil["R_SVG"], function (sMatch, sAfterSvg, sQuoteCharacter, sLibUrl, sLibIconId, sTail) {
                /** @type {UCF_ResourceUtil_SvgLibInfo} */
                var oLibInfo;
                /** @type {string} */
                var sResultSvg = sMatch;
                /** @type {UCF_LS} */
                var oMainLS;
                /** @type {window} */
                var oMainWindow;
                /** @type {UCF_ResourceUtil} */
                var oMainResourceUtil;
                /** @type {UCF_ResourceUtil_SvgLibInfo} */
                var oMainLibInfo;
                /** @type {Document} */
                var oMainDocument;
                /** @type {string} */
                var sMainSvgLib;
                /** @type {boolean} */
                var bLibReady;
                /** @type {string} */
                var sIconRef;
                /** @type {string} */
                var sEncodedIconRef;
                /** @type {string} */
                var sUseId;

                //sAfterSvg = UCF_ResourceUtil.sDecodeSvgHtml(sAfterSvg);
                //sTail = UCF_ResourceUtil.sDecodeSvgHtml(sTail);
                sLibIconId = UCF_ResourceUtil["sDecodeSvgHtml"](sLibIconId);

                if (UCF_ResourceUtil["R_METRIC"]["test"](sLibIconId)) {
                    sLibIconId = sLibIconId["replace"](UCF_ResourceUtil["R_METRIC"], '');
                }

                if (UCF_ResourceUtil["R_ASPECT_RATIO"]["test"](sLibIconId)) {
                    sLibIconId = sLibIconId["replace"](UCF_ResourceUtil["R_ASPECT_RATIO"], '');
                }

                if (UCF_ResourceUtil["R_COLOR"]["test"](sLibIconId)) {
                    sLibIconId = sLibIconId["replace"](UCF_ResourceUtil["R_COLOR"], '');
                }

                if (UCF_ResourceUtil["R_ASPECT_RATIO"]["test"](sLibUrl)) {
                    sLibUrl = sLibUrl["replace"](UCF_ResourceUtil["R_ASPECT_RATIO"], '');
                }

                sLibUrl = UCF_ResourceUtil["sDecodeSvgHtml"](sLibUrl);

                oLibInfo = UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl];

                if (!oLibInfo && oLS) {
                    // (1) When this is a Popup reuse the SVG lib content of the Main
                    // window if possible
                    if (!oLS["bIsMainLS"]()) {
                        oMainLS = oLS["oGetMainLS"]();

                        if (oMainLS) {
                            oMainWindow = oMainLS["oGetWindow"]();
                            oMainResourceUtil = oMainWindow["UCF_ResourceUtil"];
                            oMainLibInfo = oMainResourceUtil["mLoadedSvgLibs"][sLibUrl];

                            if (oMainLibInfo &&
                                oMainLibInfo["sReadyState"] === UCF_ResourceUtil["READY_STATE"]["Ready"]
                            ) {
                                oMainDocument = oMainWindow["document"];
                                sMainSvgLib = oMainDocument["getElementById"](
                                    oMainLibInfo["sInlineIdPrefix"]
                                )["innerHTML"];

                                sMainSvgLib = sMainSvgLib["replace"](/[\r\n]/g, '');

                                // Remove inline CSS
                                sMainSvgLib = sMainSvgLib["replace"](
                                    /\<style[^\>]*?data\-sap\-ls\-svglib\-inlinecss.*\<\/style\>/i,
                                    ''
                                );

                                UCF_ResourceUtil["inlineSvgLib"](
                                    sLibUrl, {
                                        "sContent": sMainSvgLib,
                                        "mSvgs": UCF_JsUtil["reduce"](
                                            UCF_JsUtil["entries"](oMainWindow["UCF_ResourceUtil"]["mLoadedSvgLibs"][sLibUrl]["mSvgs"]),
                                            function (mSvgs, aEntry) {
                                                mSvgs[aEntry[0]] = UCF_JsUtil["extend"]({},
                                                    aEntry[1], {"bInlined": false}
                                                );

                                                return mSvgs;
                                            }, {}
                                        ),
                                        "sInlineIdPrefix": oMainLibInfo["sInlineIdPrefix"]
                                    }
                                );

                                oLibInfo = UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl];
                            }
                        }
                    }

                    // (2) Just load the lib
                    if (!oLibInfo) {
                        UCF_ResourceUtil["inlineSvgLib"](sLibUrl);
                        oLibInfo = UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl];
                    }
                }

                if (oLibInfo) {
                    bLibReady = oLibInfo["sReadyState"] ===
                        UCF_ResourceUtil["READY_STATE"]["Ready"];
                    sIconRef = oLibInfo["sInlineIdPrefix"] + sLibIconId;
                    sEncodedIconRef = UCF_XSSEncoder["encodeHTML"](sIconRef);

                    if (bLibReady) {
                        UCF_ResourceUtil["ensureSvgInDom"](sEncodedIconRef, oLibInfo);
                    } else {
                        // if lib not loaded yet apply lib depending attributes extracted
                        // from lib CSS (e.g color) afterwards
                        sUseId = 'use_' +
                            (UCF_ResourceUtil["iCurrentUseIdCount"]++) +
                            '_' +
                            sEncodedIconRef;
                        oLibInfo["aPendingApplyUseTag"]["push"]([sUseId, sLibIconId, oLibInfo["sLibUrl"]]);
                    }

                    sResultSvg = '<svg data-sap-ls-svg-inline="true" ' +
                        'data-sap-ls-svg-inlineHtmlExchange="true"' +
                        sAfterSvg +
                        'xlink:href="&#x23;' + sEncodedIconRef + '"' +
                        ((bLibReady && sLibIconId in oLibInfo["mIdToCssClassMap"])
                            ? ' class="' + oLibInfo["mIdToCssClassMap"][sLibIconId] + '"'
                            : '') +
                        (sUseId ? ' id="' + sUseId + '" ' : '') +
                        sTail;
                }

                return sResultSvg;
            });

            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, 'Inline SVG by HTML exchange');
            }
            ;

            return sResultHtml;
        }

        return sHtml;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sInlineSvgByHtmlExchange"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {string} sId the internal ID of an svg icon
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo
     */
    UCF_ResourceUtil["ensureSvgInDom"] = function (sId, oLibInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["ensureSvgInDom"]++;
        }
        ;
        /** @type {string} */
        var sSvg;
        /** @type {string} */
        var sValidationMessage;
        /** @type {HTMLDivElement} */
        var oLibRef;

        if (
            typeof sId === 'string' &&
            oLibInfo &&
            oLibInfo["mSvgs"] &&
            sId in oLibInfo["mSvgs"] &&
            !oLibInfo["mSvgs"][sId]["bInlined"]
        ) {
            sSvg = oLibInfo["mSvgs"][sId]["sSvg"];
            sValidationMessage = UCF_ResourceUtil["sIsValidSvgLib"](sSvg);

            if (sValidationMessage === '') {
                oLibRef = UCF_DomUtil["$"](oLibInfo["sInlineIdPrefix"]);

                if (UCF_UserAgent["bIsIE"]()) {
                    // Fortify ignore this line
                    // eslint-disable-next-line no-unsanitized/property
                    oLibRef["innerHTML"] += '<svg xmlns="http://www.w3.org/2000/svg">' + sSvg + '</svg>';
                } else {
                    // Fortify ignore this line
                    // eslint-disable-next-line no-unsanitized/property
                    UCF_DomUtil["firstChild"](oLibRef, 'svg')["innerHTML"] += sSvg;
                }
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Svg "' + oLibInfo["sLibId"] + '#' + sId + '" not inlined: ' + sValidationMessage, "ResourceUtil.js(1711): ensureSvgInDom");
                }
                ;
            }
            oLibInfo["mSvgs"][sId]["bInlined"] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["ensureSvgInDom"] = 0;
    }
    ;

    /**
     * Loads the passed SVG lib and inlines the lib string in the document.
     *
     * @param {string} sLibUrl library URL
     * @param {UCF_ResourceUtil_SvgLibPassInfo} [oSvgLibPassInfo]
     *
     * @public
     */
    UCF_ResourceUtil["inlineSvgLib"] = function (sLibUrl, oSvgLibPassInfo) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["inlineSvgLib"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_SvgLibInfo} */
        var oLibInfo;
        /** @type {function(string): void} */
        var fApplySvgLib;
        /** @type {boolean} */
        var bSameOrigin;
        /** @type {string} */
        var sLibId;

        if (!(sLibUrl in UCF_ResourceUtil["mLoadedSvgLibs"])) {
            bSameOrigin = sLibUrl["indexOf"]('http') !== 0 ||
                sLibUrl["indexOf"](UCF_ResourceUtil["sGetDocumentOrigin"]()) === 0;
            sLibId = sLibUrl["substring"](
                sLibUrl["lastIndexOf"]('/') + 1,
                sLibUrl["lastIndexOf"]('.svg')
            );

            // Validate, inline and register a SVG lib string in a potentially async
            // method (e.g. after loading)
            /**
             * @example
             * ```js
             * fApplySvgLib(`
             * <!doctype ...>
             * <?xml...?>
             * <!-- ... -->
             * <svg ...>
             *   <!-- ... -->
             *   <symbol id=\"\" .../>
             * </svg>
             * `)
             * ```
             * @param {string} sSvgLib the raw string of the svg lib to inline
             */
            fApplySvgLib = function (sSvgLib) {
                /** @type {Array.<{0: string, 1: string, 2:UCF_ResourceUtil_SvgLibInfo}>} */
                var aPendingApplyUseTag;
                /** @type {RegExpMatchArray} */
                var aMetaDataMatch;
                /** @type {Object} */
                var oMetaData;
                /** @type {HTMLDivElement} */
                var oElement;
                /** @type {UCF_ResourceUtil_SvgLibInfo} */
                var oLibInfo;
                /** @type {Object.<string,Array.<string>>} */
                var mCssClassToIdMap;
                /** @type {Object.<string,Array.<string>>} */
                var mIdToCssClassMap;
                /** @type {string} */
                var sCssClass;
                /** @type {Array.<string>} */
                var aCssClassToIdMap;
                /** @type {number} */
                var iii;
                /** @type {string} */
                var sSvgMapId;
                /** @type {boolean} */
                var bSuccess;
                /** @type {HTMLStyleElement} */
                var oStyle;
                /** @type {SVGElement} */
                var oSvgRef;

                // <symbol id=\"...\" .../>
                // =>
                // <symbol id="..." .../>
                sSvgLib = decodeURIComponent(sSvgLib)["replace"](/\\\"/g, '"');

                aMetaDataMatch = sSvgLib["match"](/\<\!\-\- data\:(\{.*?\}) \-\-\>/);
                oMetaData = (aMetaDataMatch && aMetaDataMatch["length"] > 1 && aMetaDataMatch[1])
                    ? UCF_JsUtil["oJsonParse"](aMetaDataMatch[1])
                    : null;

                // <!-- ... -->
                // <...><!-- ... -->
                //   =>
                // <...>
                sSvgLib = sSvgLib["replace"](/\<\!\-\-(.|[\n\r])*?\-\-\>/gi, '');
                // <?xml ...?>
                // <...>
                //   =>
                // <...>
                sSvgLib = sSvgLib["replace"](/\<\?(xml\-stylesheet|xml ).*?\?\>/gi, '');
                // <!doctype ...>
                // <...>
                //   =>
                // <...>
                sSvgLib = sSvgLib["replace"](/\<\!DOCTYPE.*?\>/gi, '');

                oElement = document["createElement"]('div');
                oLibInfo = UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl];

                oElement["setAttribute"]('style', 'display:none');
                oElement["setAttribute"]('id', oLibInfo["sInlineIdPrefix"]);
                oElement["setAttribute"]('data-sap-ls-svglib-id', oLibInfo["sLibId"]);
                oElement["setAttribute"]('data-sap-ls-svglib-url', oLibInfo["sLibUrl"]);
                oElement["setAttribute"](
                    'data-sap-ls-svglib-load-method',
                    oLibInfo["sLoadingMethod"]
                );
                oElement["setAttribute"](
                    'data-sap-ls-svglib-sameorigin',
                    oLibInfo["bSameOrigin"]
                );

                if (oMetaData) {
                    mCssClassToIdMap = oMetaData["mCssClassToIdMap"]
                        ? oMetaData["mCssClassToIdMap"]
                        : {};
                    mIdToCssClassMap = {};

                    oLibInfo["mCssClassToIdMap"] = mCssClassToIdMap;
                    oLibInfo["mIdToCssClassMap"] = mIdToCssClassMap;

                    for (sCssClass in mCssClassToIdMap) {
                        aCssClassToIdMap = mCssClassToIdMap[sCssClass];

                        for (iii = 0; iii < aCssClassToIdMap["length"]; iii++) {
                            sSvgMapId = aCssClassToIdMap[iii];
                            if (mIdToCssClassMap[sSvgMapId]) {
                                mIdToCssClassMap[sSvgMapId] += ' ' + sCssClass;
                            } else {
                                mIdToCssClassMap[sSvgMapId] = sCssClass;
                            }
                        }
                    }
                }

                if (sSvgLib) {
                    if (oLibInfo["sLoadingMethod"] !==
                        UCF_ResourceUtil["LOADING_METHOD"]["Content"]
                    ) {
                        sSvgLib = sSvgLib["replace"](
                            /(\<symbol\s+id\=")/g,
                            '$1' + oLibInfo["sInlineIdPrefix"]
                        );
                    }
                    UCF_ResourceUtil["addSvgsToLibInfo"](oLibInfo, sSvgLib);

                    if (!UCF_UserAgent["bIsIE"]()) {
                        oSvgRef = document["createElementNS"]('http://www.w3.org/2000/svg', 'svg');
                        oSvgRef["setAttributeNS"]('http://www.w3.org/2000/svg', 'preserveAspectRatio', 'none');
                        UCF_DomUtil["append"](oElement, oSvgRef);
                    }
                    // Fortify should ignore that line
                }

                if (oMetaData && oMetaData["sInlineCss"]) {
                    oStyle = document["createElement"]('style');
                    UCF_DomUtil["setInnerText"](oStyle, oMetaData["sInlineCss"]);
                    UCF_DomUtil["append"](oElement, oStyle);
                }

                UCF_DomUtil["append"](document["body"], oElement);

                oLibInfo["sReadyState"] = UCF_ResourceUtil["READY_STATE"]["Ready"];

                aPendingApplyUseTag = oLibInfo["aPendingApplyUseTag"];
                oLibInfo["aPendingApplyUseTag"] = [];

                for (iii = 0; iii < aPendingApplyUseTag["length"]; iii++) {
                    bSuccess = UCF_ResourceUtil["bApplySvgInlineHref"]["apply"](
                        UCF_ResourceUtil,
                        aPendingApplyUseTag[iii]
                    );
                    if (!bSuccess) {
                        // TODO what happens to the use tags which have not been applied?
                        oLibInfo["aPendingApplyUseTag"]["push"](aPendingApplyUseTag[iii]);
                    }
                }
            };

            oLibInfo = {
                "sLibId": sLibId,
                "sLibUrl": sLibUrl,
                "bSameOrigin": bSameOrigin,
                "sInlineIdPrefix": '_' +
                    sLibId +
                    '_' +
                    (UCF_ResourceUtil["iCurrentInlineIdPrefixCount"]++) +
                    '_',
                "sLoadingMethod": null,
                "sReadyState": UCF_ResourceUtil["READY_STATE"]["Pending"],
                "aPendingApplyUseTag": [],
                "mCssClassToIdMap": {},
                "mIdToCssClassMap": {},
                "mSvgs": {}
            };

            UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl] = oLibInfo;

            if (oSvgLibPassInfo) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Inlining SVG lib "' + sLibUrl + '" by passed SVG lib content', "ResourceUtil.js(1919): inlineSvgLib");
                }
                ;
                oLibInfo["sInlineIdPrefix"] = oSvgLibPassInfo["sInlineIdPrefix"];
                oLibInfo["sLoadingMethod"] = UCF_ResourceUtil["LOADING_METHOD"]["Content"];

                UCF_ResourceUtil["inlineSvgLibByContent"](oLibInfo, oSvgLibPassInfo, fApplySvgLib);
            } else if (bSameOrigin) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Inlining SVG lib "' + sLibUrl + '" by XML HTTP request approach due to located in same origin.', "ResourceUtil.js(1925): inlineSvgLib");
                }
                ;
                oLibInfo["sLoadingMethod"] = UCF_ResourceUtil["LOADING_METHOD"]["Xhr"];

                UCF_ResourceUtil["inlineSvgLibByXhr"](oLibInfo, fApplySvgLib);
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Inlining SVG lib "' + oLibInfo["sLibUrl"] + '" by CSS embedding approach due to NOT located in same origin.', "ResourceUtil.js(1930): inlineSvgLib");
                }
                ;
                oLibInfo["sLoadingMethod"] = UCF_ResourceUtil["LOADING_METHOD"]["Css"];

                UCF_ResourceUtil["inlineSvgLibByCss"](oLibInfo, fApplySvgLib);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["inlineSvgLib"] = 0;
    }
    ;

    /**
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo
     * @param {string} sSvgLib
     */
    UCF_ResourceUtil["addSvgsToLibInfo"] = function (oLibInfo, sSvgLib) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["addSvgsToLibInfo"]++;
        }
        ;
        if (oLibInfo && typeof sSvgLib === 'string') {
            oLibInfo["mSvgs"] = UCF_JsUtil["extend"](oLibInfo["mSvgs"], UCF_JsUtil["reduce"](
                sSvgLib["match"](/<symbol\s+id="[^"]+".*?<\/symbol>/g) || [],
                function (mSvgs, sMatch) {
                    /** @type {RegExpMatchArray} */
                    var aMatch = sMatch["match"](/id="[^"]+"/g);

                    if (aMatch && aMatch["length"] > 0) {
                        mSvgs[aMatch[0]["slice"]('id="'["length"], -'"'["length"])] = {
                            "sSvg": sMatch,
                            "bInlined": false
                        };
                    }

                    return mSvgs;
                }, {}
            ));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["addSvgsToLibInfo"] = 0;
    }
    ;

    /**
     * security validation. It scans for unallowed tags, attributes etc. and
     * stops inlining process when found invalid expressions
     * @param {string} sSvgLib
     * @return {string} `''` to indicate a valid svg lib, or an error message
     */
    UCF_ResourceUtil["sIsValidSvgLib"] = function (sSvgLib) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sIsValidSvgLib"]++;
        }
        ;
        /** @type {string} */
        var sValidation = sSvgLib["replace"](/(\n|\r)*/g, '');

        if (/\\|\&/["test"](sValidation)) {
            // Escaping caracters are not allowed
            return 'Invalid characters detected. SVG content must not contain \'\\\' and \'&\'';
        } else {
            // Allowed attributes
            sValidation = sValidation["replace"](
                / (style|id|viewbox|d|class|xmlns|y|x|transform|height|width|preserveaspectratio)\=\".*?\"/gi,
                ''
            );
            // Allowed tags
            sValidation = sValidation["replace"](
                /\s*\<\/?\s*(svg|symbol|path|g|rect|defs|link)\s*\/?\>\s*/gi,
                ''
            );
            // Allowed XML processing instructions
            sValidation = sValidation["replace"](
                /\<\?(xml\-stylesheet|xml ).*?\?\>/gi,
                ''
            );
            // Allowed XML DOCTYPE
            sValidation = sValidation["replace"](/\<\!DOCTYPE.*?\>/gi, '');

            if (sValidation) {
                return 'Unknown content fragments"' + sValidation + '"';
            }
        }

        return '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sIsValidSvgLib"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo the lib information
     * @param {UCF_ResourceUtil_SvgLibPassInfo} oPassInfo the lib information passed
     * @param {function(string): void} fApplySvgLib
     */
    UCF_ResourceUtil["inlineSvgLibByContent"] = function (oLibInfo, oPassInfo, fApplySvgLib) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["inlineSvgLibByContent"]++;
        }
        ;
        UCF_ResourceUtil["mLoadedSvgLibs"][oLibInfo["sLibUrl"]]["mSvgs"] = oPassInfo["mSvgs"];

        fApplySvgLib(UCF_ResourceUtil
            ["sDecodeSvgHtml"](oPassInfo["sContent"])
            ["replace"](
            new RegExp(oPassInfo["sInlineIdPrefix"], 'g'),
            oLibInfo["sInlineIdPrefix"]
        ));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["inlineSvgLibByContent"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo the lib information
     * @param {function(string): void} fApplySvgLib
     */
    UCF_ResourceUtil["inlineSvgLibByXhr"] = function (oLibInfo, fApplySvgLib) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["inlineSvgLibByXhr"]++;
        }
        ;
        /** @type {XMLHttpRequest} */
        var oXhr = new XMLHttpRequest();

        oXhr["open"]('GET', oLibInfo["sLibUrl"]);
        oXhr["setRequestHeader"]('Content-type', 'image/svg+xml');
        oXhr["send"]();

        oXhr["onreadystatechange"] = function () {
            if (oXhr["readyState"] === 4) { // eslint-disable-line no-magic-numbers
                fApplySvgLib(oXhr["responseText"]);
            }
        };
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["inlineSvgLibByXhr"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo the lib information
     * @param {function(string): void} fApplySvgLib
     */
    UCF_ResourceUtil["inlineSvgLibByCss"] = function (oLibInfo, fApplySvgLib) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["inlineSvgLibByCss"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oTmpLink;

        /** */
        function fLoaded() {
            if (UCF_UserAgent["bIsChromium"]() || UCF_UserAgent["bIsWebKit"]() || UCF_UserAgent["bIsMSEdge"]()) {
                UCF_JsUtil["setImmediate"](function () {
                    UCF_ResourceUtil["onSvgCssLoaded"](oTmpLink, oLibInfo, fApplySvgLib, fLoaded);
                });
            } else {
                UCF_ResourceUtil["onSvgCssLoaded"](oTmpLink, oLibInfo, fApplySvgLib, fLoaded);
            }
        };

        oTmpLink = document["createElement"]('link');
        oTmpLink["setAttribute"]('href', oLibInfo["sLibUrl"]["replace"]('.svg', '.css'));
        oTmpLink["setAttribute"]('rel', 'stylesheet');
        oTmpLink["setAttribute"]('type', 'text/css');
        oTmpLink["setAttribute"]('class', 'sapSvgLib' + oLibInfo["sLibId"]);

        UCF_DomUtil["attachEvent"](oTmpLink, 'load', fLoaded);
        UCF_DomUtil["attachEvent"](oTmpLink, 'error', fLoaded);
        UCF_DomUtil["attachEvent"](oTmpLink, 'readystatechange', fLoaded);

        document["getElementsByTagName"]('head')[0]["appendChild"](oTmpLink);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["inlineSvgLibByCss"] = 0;
    }
    ;

    /**
     * @private
     * @static
     * @param {HTMLLinkElement} oTmpLink
     * @param {UCF_ResourceUtil_SvgLibInfo} oLibInfo
     * @param {function(string): void} fApplySvgLib
     * @param {function(): void} fLoaded
     */
    UCF_ResourceUtil["onSvgCssLoaded"] = function (oTmpLink, oLibInfo, fApplySvgLib, fLoaded) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["onSvgCssLoaded"]++;
        }
        ;
        /** @type {string} */
        var sInfoStyle;
        /** @type {number} */
        var iChunkCount = 0;
        /** @type {string} */
        var sSvgLib = '';
        /** @type {Array.<string>} */
        var aInfoStyle;
        /** @type {string} */
        var sClassName;

        do {
            sClassName = 'sapSvgLib' + oLibInfo["sLibId"] + '_' + (iChunkCount++);
            oTmpLink["setAttribute"]('class', sClassName);
            sInfoStyle = UCF_DomUtil["sGetCurrentStyle"](
                oTmpLink,
                'backgroundImage'
            );

            if (sInfoStyle && sInfoStyle !== 'none') {
                aInfoStyle = sInfoStyle["match"](/^url\((\'|\")?.*?\,(.*)\1\)$/);

                if (!aInfoStyle) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(WARNING, 'Invalid format in SVG lib "' + oLibInfo["sLibUrl"] + '" chunk number "' + (iChunkCount - 1) + '".', "ResourceUtil.js(2105): onSvgCssLoaded");
                    }
                    ;
                    sSvgLib = null;
                    break;
                }

                // aInfoStyle[0] == url("a,b") (whole match)
                // aInfoStyle[1] == '|"|undefined
                // aInfoStyle[2] == b
                sSvgLib += aInfoStyle[2]; // eslint-disable-line no-magic-numbers
            }
        } while (sInfoStyle && sInfoStyle !== 'none');

        if (sSvgLib) {
            fApplySvgLib(sSvgLib);
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Unable to inline SVG lib "' + oLibInfo["sLibUrl"] + '"', "ResourceUtil.js(2120): onSvgCssLoaded");
            }
            ;
        }

        UCF_DomUtil["detachEvent"](oTmpLink, 'load', fLoaded);
        UCF_DomUtil["detachEvent"](oTmpLink, 'error', fLoaded);
        UCF_DomUtil["detachEvent"](oTmpLink, 'readystatechange', fLoaded);
        UCF_DomUtil["removeFromDom"](oTmpLink);

        oTmpLink = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["onSvgCssLoaded"] = 0;
    }
    ;

    /**
     * Applies the new reference and CSS class to an <use> tag which referes to an
     * inlined SVG
     *
     * @public
     * @param {string|SVGUseElement} oUseTag use tag
     * @param {string} sLibIconId if of the icon lib
     * @param {string} sLibUrl the url of the lib
     * @return {string} `true` if update was successful
     */
    UCF_ResourceUtil["bApplySvgInlineHref"] = function (oUseTag, sLibIconId, sLibUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["bApplySvgInlineHref"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_SvgLibInfo} */
        var oLibInfo = UCF_ResourceUtil["mLoadedSvgLibs"][sLibUrl];
        /** @type {string} */
        var sUseTag;
        /** @type {string} */
        var sInternalIconId = oLibInfo["sInlineIdPrefix"] + sLibIconId;

        UCF_ResourceUtil["ensureSvgInDom"](sInternalIconId, oLibInfo);

        if (oUseTag && typeof oUseTag === 'string') {
            sUseTag = oUseTag;
            oUseTag = document["getElementById"](sUseTag);

            if (!oUseTag) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Not able to find SVG USE tag DOM element "' + sUseTag + '"', "ResourceUtil.js(2156): bApplySvgInlineHref");
                }
                ;

                return false;
            }
        }

        if (oUseTag) {
            oUseTag["setAttributeNS"](
                'http://www.w3.org/1999/xlink',
                'href',
                '#' + oLibInfo["sInlineIdPrefix"] + sLibIconId
            );

            if (sLibIconId in oLibInfo["mIdToCssClassMap"]) {
                oUseTag["setAttribute"]('class', oLibInfo["mIdToCssClassMap"][sLibIconId]);
            }

            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["bApplySvgInlineHref"] = 0;
    }
    ;

    /**
     * Normalizes a passed URL
     *
     * @public
     * @param {string} sUrl the url to normalize
     * @return {string} the normalized url
     */
    UCF_ResourceUtil["sNormalizeUrl"] = function (sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sNormalizeUrl"]++;
        }
        ;
        /** @type {Array.<string>} */
        var aTmpMatch = null;
        /** @type {string} */
        var sUrlPre = null;
        /** @type {string} */
        var sUrlPath;
        /** @type {Array.<string>} */
        var aResultUrl;
        /** @type {Array.<string>} */
        var aSplitUrl;
        /** @type {number} */
        var i;
        /** @type {string} */
        var sUrlFragment;

        if (!sUrlPre) { // Extract protocol, host, port
            aTmpMatch = sUrl["match"](/^(http|https)\:\/\/[a-zA-Z0-9\-\.]+(:[0-9]*)?/);
            if (aTmpMatch) {
                sUrlPre = aTmpMatch[0] + '/';
            }
        }

        if (!sUrlPre) { // Server relative url
            aTmpMatch = sUrl["match"](/^\//);
            if (aTmpMatch) {
                sUrlPre = '/';
            }
        }

        // Remove unneccessary url parts
        sUrlPath = sUrl
            ["substring"](sUrlPre["length"])
            ["replace"](/\/\/+/, '/')
            ["replace"](/\/+(\.)?\/+/gi, '/');

        if (/\.\//["test"](sUrlPath)) {
            aResultUrl = [];
            aSplitUrl = sUrlPath["split"]('/');

            // Resolve the URL parts into an array
            for (i = 0; i < aSplitUrl["length"]; i++) {
                sUrlFragment = aSplitUrl[i];

                if (sUrlFragment === '..') {
                    aResultUrl["pop"]();
                } else {
                    aResultUrl["push"](sUrlFragment);
                }
            }

            sUrlPath = aResultUrl["join"]('/');
        }

        return sUrlPre + sUrlPath;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sNormalizeUrl"] = 0;
    }
    ;

    /**
     * @public
     * @return {string} the documents host including protocol and port
     */
    UCF_ResourceUtil["sGetDocumentOrigin"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["sGetDocumentOrigin"]++;
        }
        ;
        /** @type {Location} */
        var oLocation = document["location"];

        return oLocation["protocol"] + '//' + oLocation["host"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["sGetDocumentOrigin"] = 0;
    }
    ;

    UCF_ResourceUtil["applyThemeChange"] = function (fnLoaded) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ResourceUtil["_"]["applyThemeChange"]++;
        }
        ;
        UCF_ResourceUtil["setLightspeedCssLinkUrl"](UCF_ResourceUtil["sGetCssUrl"](window["UCF_System"]["sThemeID"]));
        UCF_ResourceUtil["ensureLightspeedCssLoaded"]()["then"](fnLoaded);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ResourceUtil["_"]["applyThemeChange"] = 0;
    }
    ;


    UCF_ResourceUtil.prototype["aPublicMethods"] = ["fGetThemingVersion", "sGetThemeUrlAppendix", "sGetCssFileName", "sGetThemesRoot", "sGetThemeRoot", "sGetCssRoot", "sGetControlAssetsRoot", "sGetFontsRoot", "sGetControlAssetUrl", "sGetCssUrl", "sGetSpacerImageUrl", "sGetJsRoot", "sGetHtmlRoot", "sGetMessageBundlesRoot", "sGetQUnitRoot", "bIsLightspeedCssLink", "setLightspeedCssLinkUrl", "ensureLightspeedCssLoaded", "bLightspeedCssLoaded", "sGetLightspeedCssLinkUrl", "oGetLightspeedCssLink", "oGetLightspeedCssStylesheet", "applyIECssRuleLimitWorkaround", "oExtractCssMetaData", "oExtractCssValidationInfo", "enableSVG", "sInlineSvgByHtmlExchange", "inlineSvgLib", "bApplySvgInlineHref", "sNormalizeUrl", "sGetDocumentOrigin"].concat(UCF_ResourceUtil.prototype.aPublicMethods || []);
    /* global _assert */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>

    /** @typedef {'full'} UCF_SemanticEvent_TransportMethod_Full */
    /** @typedef {'partial'} UCF_SemanticEvent_TransportMethod_Partial */
    /** @typedef {UCF_SemanticEvent_TransportMethod_Full|UCF_SemanticEvent_TransportMethod_Partial} UCF_SemanticEvent_TransportMethod */

    /** @typedef {'multiple'} UCF_SemanticEvent_Cardinality_Multiple */
    /** @typedef {'single'} UCF_SemanticEvent_Cardinality_Single */
    /** @typedef {'none'} UCF_SemanticEvent_Cardinality_None */
    /** @typedef {UCF_SemanticEvent_Cardinality_Multiple|UCF_SemanticEvent_Cardinality_Single|UCF_SemanticEvent_Cardinality_None} UCF_SemanticEvent_Cardinality */

    /** @typedef {'full'} UCF_SemanticEvent_ResponseData_Full */
    /** @typedef {'delta'} UCF_SemanticEvent_ResponseData_Delta */
    /** @typedef {'inherit'} UCF_SemanticEvent_ResponseData_Inherit */
    /** @typedef {UCF_SemanticEvent_ResponseData_Full|UCF_SemanticEvent_ResponseData_Delta|UCF_SemanticEvent_ResponseData_Inherit} UCF_SemanticEvent_ResponseData */

    /** @typedef {'submit'} UCF_SemanticEvent_Action_Submit */
    /** @typedef {'submitAsync'} UCF_SemanticEvent_Action_SubmitAsync */
    /** @typedef {'enqueue'} UCF_SemanticEvent_Action_Enqueue */
    /** @typedef {'none'} UCF_SemanticEvent_Action_None */
    /** @typedef {UCF_SemanticEvent_Action_Submit|UCF_SemanticEvent_Action_SubmitAsync|UCF_SemanticEvent_Action_Enqueue|UCF_SemanticEvent_Action_None} UCF_SemanticEvent_Action */

    /** @typedef {'full'} UCF_SemanticEvent_Delay_Full */
    /** @typedef {'none'} UCF_SemanticEvent_Delay_None */
    /** @typedef {UCF_SemanticEvent_Delay_Full|UCF_SemanticEvent_Delay_None} UCF_SemanticEvent_Delay */

    /**
     * @typedef {Object} UCF_SemanticEvent_UcfParameters
     * @property {boolean} Composite
     * @property {UCF_SemanticEvent_Action} ClientAction
     * @property {UCF_SemanticEvent_Cardinality} EnqueueCardinality
     * @property {UCF_SemanticEvent_ResponseData} ResponseData
     * @property {UCF_SemanticEvent_TransportMethod} TransportMethod
     * @property {UCF_SemanticEvent_Delay} Delay
     * @property {string} ActionUrl
     * @property {string} PrepareScript
     * @property {boolean} SyncExecution
     */

    /** @typedef {Object} UCF_SemanticEvent_Parameters */

    /** @typedef {Object} UCF_SemanticEvent_CustomParameters */

    /**
     * A Lightspeed semantic event that is passed to the framework
     * @class
     * @param {string} sControl The Control ID
     * @param {string} sName The event name
     * @param {Object} mParameters Parameter map
     * @param {Object} oEventInfoParameters Event Info Parameters
     */
    function UCF_SemanticEvent(sControl, sName, mParameters, oEventInfoParameters) {
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["UCF_SemanticEvent"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sControl === 'string', "typeof sControl === 'string'", "SemanticEvent.js(58): UCF_SemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sControl !== '', "sControl !== ''", "SemanticEvent.js(59): UCF_SemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sName === 'string', "typeof sName === 'string'", "SemanticEvent.js(60): UCF_SemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sName !== '', "sName !== ''", "SemanticEvent.js(61): UCF_SemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(mParameters instanceof Object, "mParameters instanceof Object", "SemanticEvent.js(62): UCF_SemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["bIsObject"](oEventInfoParameters) || UCF_JsUtil["bIsArray"](oEventInfoParameters), "UCF_JsUtil.bIsObject(oEventInfoParameters) || UCF_JsUtil.bIsArray(oEventInfoParameters)", "SemanticEvent.js(63): UCF_SemanticEvent");
        }
        ;

        UCF_Object["apply"](this);
        /** @type {string} */
        this["sControl"] = sControl;
        /** @type {string} */
        this["sName"] = sName;
        /** @type {UCF_SemanticEvent_Parameters} */
        this["mParameters"] = mParameters;
        /** @type {boolean} */
        this["bCanceled"] = false;

        // JsUtil functions also work for Arrays and Objects instances from other frames
        if (UCF_JsUtil["bIsObject"](oEventInfoParameters)) {
            /** @type {UCF_SemanticEvent_UcfParameters} */
            this["mUcfParameters"] = {};
            /** @type {UCF_SemanticEvent_CustomParameters} */
            this["mCustomParameters"] = oEventInfoParameters;
        } else if (UCF_JsUtil["bIsArray"](oEventInfoParameters)) {
            /** @type {UCF_SemanticEvent_UcfParameters} */
            this["mUcfParameters"] = oEventInfoParameters[0];
            /** @type {UCF_SemanticEvent_CustomParameters} */
            this["mCustomParameters"] = oEventInfoParameters[1];
        } else {
            /** @type {UCF_SemanticEvent_UcfParameters} */
            this["mUcfParameters"] = {};
            /** @type {UCF_SemanticEvent_CustomParameters} */
            this["mCustomParameters"] = {};
        }
    };window["UCF_SemanticEvent"] = UCF_SemanticEvent;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_SemanticEvent");
        UCF_SemanticEvent["_"] = {UCF_SemanticEvent: 0};
    }
    ;
    ;
    UCF_SemanticEvent["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_SemanticEvent.prototype["sClassName"] = "UCF_SemanticEvent";

    /** @override */
    UCF_SemanticEvent["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["destroy"]++;
        }
        ;
        this["sControl"] = null;
        this["sName"] = null;
        this["mParameters"] = null;
        this["mUcfParameters"] = null;
        this["mCustomParameters"] = null;
        this["oForm"] = null;
        this["oSourceLS"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["destroy"] = 0;
    }
    ;

    /**
     * Return the control of the semantic event
     *
     * @public
     * @return {string} control of the semantic event
     */
    UCF_SemanticEvent["prototype"]["sGetControl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["sGetControl"]++;
        }
        ;
        return this["sControl"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["sGetControl"] = 0;
    }
    ;

    /**
     * Return the name of the semantic event
     *
     * @public
     * @return {string} name of the semantic event
     */
    UCF_SemanticEvent["prototype"]["sGetName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["sGetName"]++;
        }
        ;
        return this["sName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["sGetName"] = 0;
    }
    ;

    /**
     * Get the Lightspeed-defined event parameters for this event
     *
     * @public
     * @return {map} event parameters map
     */
    UCF_SemanticEvent["prototype"]["mGetParameters"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["mGetParameters"]++;
        }
        ;
        return this["mParameters"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["mGetParameters"] = 0;
    }
    ;

    /**
     * Adds a parameter to the list.
     * Used for databinding where the template id and the binding context needs to be transfered to the server.
     *
     * @public
     * @param {string} sName name to add
     * @param {string} sValue value to add
     */
    UCF_SemanticEvent["prototype"]["addParameter"] = function (sName, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["addParameter"]++;
        }
        ;
        this["mParameters"][sName] = sValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["addParameter"] = 0;
    }
    ;

    /**
     * Get the framework-defined event parameters for this event
     *
     * @public
     * @return {UCF_SemanticEvent_CustomParameters} framework-defined event parameters for this event
     */
    UCF_SemanticEvent["prototype"]["mGetCustomParameters"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["mGetCustomParameters"]++;
        }
        ;
        return this["mCustomParameters"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["mGetCustomParameters"] = 0;
    }
    ;

    /**
     * @private
     * @return {UCF_SemanticEvent_UcfParameters} UCF event parameters for this event
     */
    UCF_SemanticEvent["prototype"]["mGetUcfParameters"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["mGetUcfParameters"]++;
        }
        ;
        return this["mUcfParameters"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["mGetUcfParameters"] = 0;
    }
    ;

    /**
     * @private
     * @return {boolean} `true` if the event is marked as composite event
     */
    UCF_SemanticEvent["prototype"]["bIsCompositeEvent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["bIsCompositeEvent"]++;
        }
        ;
        //TODO: assert ClientAction == none
        return this["mUcfParameters"] && !!this["mUcfParameters"]["Composite"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["bIsCompositeEvent"] = 0;
    }
    ;

    /**
     * Cancel the event, do not add it to the UCF event queue
     *
     * @public
     */
    UCF_SemanticEvent["prototype"]["cancel"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["cancel"]++;
        }
        ;
        this["bCanceled"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["cancel"] = 0;
    }
    ;

    /** @return {boolean} `true` if the semantic event has been canceled */
    UCF_SemanticEvent["prototype"]["bIsCanceled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["bIsCanceled"]++;
        }
        ;
        return this["bCanceled"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["bIsCanceled"] = 0;
    }
    ;

    /**
     * Set form reference (not the form interface)
     *
     * @private
     * @param {UCF_Form} oForm
     */
    UCF_SemanticEvent["prototype"]["setForm"] = function (oForm) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setForm"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oForm) === 'object', "typeof(oForm) === 'object'", "SemanticEvent.js(198): setForm");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oForm) !== 'string', "typeof(oForm) !== 'string'", "SemanticEvent.js(199): setForm");
        }
        ; //don't use formId here

        this["oForm"] = oForm;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setForm"] = 0;
    }
    ;

    /**
     * @private
     * @return {UCF_Form} form object
     */
    UCF_SemanticEvent["prototype"]["oGetForm"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["oGetForm"]++;
        }
        ;
        return this["oForm"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["oGetForm"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} name
     * @param {string} value
     */
    UCF_SemanticEvent["prototype"]["setCustomParameter"] = function (name, value) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setCustomParameter"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (name) === 'string', "typeof(name) === 'string'", "SemanticEvent.js(218): setCustomParameter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (value) === 'string', "typeof(value) === 'string'", "SemanticEvent.js(219): setCustomParameter");
        }
        ;

        this["mCustomParameters"][name] = value;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setCustomParameter"] = 0;
    }
    ;

    /**
     * Set UCF client action
     *
     * @param {string} sClientAction
     *
     * @public
     */
    UCF_SemanticEvent["prototype"]["setClientAction"] = function (sClientAction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setClientAction"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sClientAction === 'submit' || sClientAction === 'submitAsync' || sClientAction === 'enqueue' || sClientAction === 'none', "sClientAction === 'submit' || sClientAction === 'submitAsync' || sClientAction === 'enqueue' || sClientAction === 'none'", "SemanticEvent.js(232): setClientAction");
        }
        ;

        this["mUcfParameters"]["ClientAction"] = sClientAction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setClientAction"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sEnqueueCardinality UCF enqueue cardinality
     */
    UCF_SemanticEvent["prototype"]["setEnqueueCardinality"] = function (sEnqueueCardinality) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setEnqueueCardinality"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sEnqueueCardinality === 'multiple' || sEnqueueCardinality === 'single', "sEnqueueCardinality === 'multiple' || sEnqueueCardinality === 'single'", "SemanticEvent.js(242): setEnqueueCardinality");
        }
        ;

        this["mUcfParameters"]["EnqueueCardinality"] = sEnqueueCardinality;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setEnqueueCardinality"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sResponseData UCF response data
     */
    UCF_SemanticEvent["prototype"]["setResponseData"] = function (sResponseData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setResponseData"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sResponseData === 'full' || sResponseData === 'delta' || sResponseData === 'inherit', "sResponseData === 'full' || sResponseData === 'delta' || sResponseData === 'inherit'", "SemanticEvent.js(252): setResponseData");
        }
        ;

        this["mUcfParameters"]["ResponseData"] = sResponseData;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setResponseData"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sTransportMethod UCF transport method
     */
    UCF_SemanticEvent["prototype"]["setTransportMethod"] = function (sTransportMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setTransportMethod"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sTransportMethod === 'full' || sTransportMethod === 'partial', "sTransportMethod === 'full' || sTransportMethod === 'partial'", "SemanticEvent.js(262): setTransportMethod");
        }
        ;

        this["mUcfParameters"]["TransportMethod"] = sTransportMethod;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setTransportMethod"] = 0;
    }
    ;

    /**
     * @public
     * @param {boolean} bDelay UCF Delay  - flag marking delayed event
     */
    UCF_SemanticEvent["prototype"]["setDelay"] = function (bDelay) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setDelay"]++;
        }
        ;
        this["mUcfParameters"]["Delay"] = bDelay ? 'full' : 'none';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setDelay"] = 0;
    }
    ;

    /**
     * @public
     * @param {string} sActionUrl UCF action URL
     */
    UCF_SemanticEvent["prototype"]["setActionUrl"] = function (sActionUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setActionUrl"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sActionUrl) === 'string', "typeof(sActionUrl) === 'string'", "SemanticEvent.js(280): setActionUrl");
        }
        ;

        this["mUcfParameters"]["ActionUrl"] = sActionUrl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setActionUrl"] = 0;
    }
    ;

    /**
     * Some events need a direct sync js request to the server
     *
     * @param {boolean} bSyncExecution
     *
     * @public
     */
    UCF_SemanticEvent["prototype"]["setSyncExecution"] = function (bSyncExecution) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setSyncExecution"]++;
        }
        ;
        this["mUcfParameters"]["SyncExecution"] = bSyncExecution;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setSyncExecution"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_LS} oSourceLS the source LS instance of the event
     */
    UCF_SemanticEvent["prototype"]["setSourceLS"] = function (oSourceLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["setSourceLS"]++;
        }
        ;
        this["oSourceLS"] = oSourceLS;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["setSourceLS"] = 0;
    }
    ;

    /**
     * @public
     * @return {UCF_LS} source LS instance
     */
    UCF_SemanticEvent["prototype"]["oGetSourceLS"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_SemanticEvent["_"]["oGetSourceLS"]++;
        }
        ;
        return this["oSourceLS"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_SemanticEvent["_"]["oGetSourceLS"] = 0;
    }
    ;

    UCF_SemanticEvent.prototype["aPublicMethods"] = ["sGetControl", "sGetName", "mGetParameters", "addParameter", "mGetCustomParameters", "cancel", "setCustomParameter", "setClientAction", "setEnqueueCardinality", "setResponseData", "setTransportMethod", "setDelay", "setActionUrl", "setSyncExecution", "oGetSourceLS"].concat(UCF_SemanticEvent.prototype.aPublicMethods || []);
    /* global _assert, _trace, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_VersionInfo */
/// <reference path="../../core/util/VersionInfo.js"/>
    /* global UCF_ControlInfo */
/// <reference path="./ControlInfo.js"/>
    /* global UCF_Exception */
/// <reference path="./Exception.js"/>
    /* global UCF_Property */
/// <reference path="./Property.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="./ResourceUtil.js"/>

    /** @typedef {0|1|2|3} UCF_System_LogLevel */
    /** @typedef {'AUTO'|'ISOLATED'} UCF_System_Embedding */
    /** @typedef {'NONE'|'CLASSIC'|'ARIA'} UCF_System_AccessibilityMode */
    /** @typedef {'KEYBOARD'|'TOUCH'} UCF_System_InteractionType */

    /** @typedef {HTMLElement} HTMLXmpElement */

    /**
     * Creates the client side representation of the System object.
     *
     * The system object can be used to access configuration information, like RTL,
     * ClientDebug, 508, ResourceRoot, etc...
     *
     * @constructor
     * @class UCF_System
     * @extends UCF_ControlInfo
     *
     * @param {HTMLElement} oDomRef the DOM reference for the system object
     * @param {UCF_LS} oLS the LightSpeed main object
     */
    function UCF_System(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["UCF_System"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "System.js(42): UCF_System");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "System.js(43): UCF_System");
        }
        ;

        if (oDomRef) {
            UCF_ControlInfo["apply"](this, [oDomRef, oLS]);
        }

        // Copy meta data reference before overwriting constructor with singelton instance
        this["_"] = UCF_System["_"];

        /** @type {UCF_System} */
        window["UCF_System"] = this;

        /** @enum {UCF_System_Embedding} */
        this["EMBEDDING"] = {
            "AUTO": 'AUTO',
            "ISOLATED": 'ISOLATED'
        };

        /** @enum {UCF_System_LogLevel} */
        this["E_LOG_LEVELS"] = {
            "Off": 0,
            "Fesr": 1,
            "Performance": 2,
            "Debug": 3
        };
        /** @type {UCF_System_LogLevel} */
        this["iDebugLevel"] = __UCF_DEBUG__
            ? this["E_LOG_LEVELS"]["Debug"]
            : this["E_LOG_LEVELS"][UCF_StringUtil["sTitleize"](
                this["sDebugLevel"]["toLowerCase"]()
            )];

        // Defaults for known system properties
        /** @type {string} */
        this["sUseFocusColor"] = '';
        /** @type {string} */
        this["sIsRemoteDesktop"] = 'false';
        /** @type {string} */
        this["sSetDirtyForRoundtrips"] = 'false';
        /** @type {boolean} */
        this["bIsAria"] = this["sAccessibility"] === 'ARIA' || this["sAccessibility"] === 'ARIA1.1';
        /** @type {boolean} */
        this["bAccTutor"] = true; // TODO Implement real session storage
        /** @type {RegExp[]} */
        this["aSupportedSapThemeIDs"] = null;

        this["collectGenericProperties"](oLS);
        this["collectWeekendDays"]();

        this["setDataTypeFormats"](this["sDataTypeFormats"]);

        this["checkRuntimeVersion"]();
    };window["UCF_System"] = UCF_System;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_System");
        UCF_System["_"] = {UCF_System: 0};
    }
    ;
    ;
    UCF_System["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_ControlInfo"))();
    UCF_System.prototype["sClassName"] = "UCF_System";

    /** @override */
    UCF_System["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["destroy"]++;
        }
        ;
        this["_"] = null;
        this["iDebugLevel"] = null;
        this["bIsAria"] = null;
        this["aSupportedSapThemeIDs"] = null;
        this["oDataTypeFormats"] = null;
        this["sThemeID"] = null; // eslint-disable-line ur/no-missing-setClientProperty
        this["sThemeRepositoryURL"] = null; // eslint-disable-line ur/no-missing-setClientProperty
        this["bIs508"] = null; // eslint-disable-line ur/no-missing-setClientProperty
        this["sParameter"] = null;
        this["sFeatureFlags"] = null;

        UCF_ControlInfo.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["destroy"] = 0;
    }
    ;

    /** @private */
    UCF_System["prototype"]["collectWeekendDays"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["collectWeekendDays"]++;
        }
        ;
        /** @type {Array<number>} */
        var aWeekendDays;
        /** @type {number} */
        var i;

        try {
            aWeekendDays = UCF_JsUtil["oJsonParse"](this["sWeekendDays"]);
        } catch (e) {
            aWeekendDays = [0, 6]; // eslint-disable-line no-magic-numbers
        }

        /** @type {Array<boolean>} */
        this["aWeekendDays"] = [false, false, false, false, false, false, false];
        for (i = 0; i < aWeekendDays["length"]; i++) {
            this["aWeekendDays"][aWeekendDays[i]] = true;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["collectWeekendDays"] = 0;
    }
    ;

    /** @private */
    UCF_System["prototype"]["checkRuntimeVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["checkRuntimeVersion"]++;
        }
        ;
        if (!this["sRuntimeVersion"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'No backend runtime version found at UCF_System.', "System.js(137): checkRuntimeVersion");
            }
            ;
        } else if (0 === UCF_VersionInfo["mVersionProperties"]["mUICore"]["urversion"]["indexOf"](this["sRuntimeVersion"])) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Runtime version match: "' + this["sRuntimeVersion"] + '" (backend) vs. "' + UCF_VersionInfo["mVersionProperties"]["mUICore"]["urversion"] + '" (frontend).', "System.js(139): checkRuntimeVersion");
            }
            ;
        } else if (__UCF_DEBUG__) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Runtime version mismatch: "' + this["sRuntimeVersion"] + '" (backend) vs. "' + UCF_VersionInfo["mVersionProperties"]["mUICore"]["urversion"] + '" (frontend).', "System.js(141): checkRuntimeVersion");
            }
            ;
        } else if (console && console["error"]) {
            console["error"]('Runtime version mismatch: "' + this["sRuntimeVersion"] + '" (backend) vs. "' + UCF_VersionInfo["mVersionProperties"]["mUICore"]["urversion"] + '" (frontend).');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["checkRuntimeVersion"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_LS} oLS
     */
    UCF_System["prototype"]["collectGenericProperties"] = function (oLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["collectGenericProperties"]++;
        }
        ;
        /** @type {NodeListOf<HTMLXmpElement>} */
        var aXMPs = UCF_DomUtil["childNodes"](this["oDomRef"], 'XMP');
        /** @type {number} */
        var i;
        /** @type {number} */
        var l;
        /** @type {HTMLXmpElement} */
        var oXMP;
        /** @type {} */
        var oProp;

        /** @type {Object<string,string>} */
        this["mProperties"] = {};

        for (i = 0, l = aXMPs["length"]; i < l; i++) {
            oXMP = aXMPs[i];
            if (oXMP["getAttribute"]('ct') === 'PROP') {
                oProp = new (UCF_ClassLoader["oGetClass"]("UCF_Property"))(oXMP, oLS);
                this["mProperties"][oProp["sKey"]] = oProp["sValue"];

                if (oProp["sKey"] === 'UseFocusColor') {
                    if (oProp["sValue"] === 'true') {
                        this["sUseFocusColor"] = 'true';
                    } else if (oProp["sValue"] === 'false') {
                        this["sUseFocusColor"] = 'false';
                    } else {
                        // Default = ''
                    }
                } else if (oProp["sKey"] === 'IsRemoteDesktop') {
                    if (oProp["sValue"] === 'true') {
                        this["sIsRemoteDesktop"] = 'true';
                    } else if (oProp["sValue"] === 'false') {
                        this["sIsRemoteDesktop"] = 'false';
                    } else {
                        // Default = 'false'
                    }
                } else if (oProp["sKey"] === 'SetDirtyForRoundtrips') {
                    if (oProp["sValue"] === 'true') {
                        this["sSetDirtyForRoundtrips"] = 'true';
                    } else if (oProp["sValue"] === 'false') {
                        this["sSetDirtyForRoundtrips"] = 'false';
                    } else {
                        // Default = 'false'
                    }
                }

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'set system property: ' + oProp["sKey"] + '=' + oProp["sValue"], "System.js(198): collectGenericProperties");
                }
                ;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["collectGenericProperties"] = 0;
    }
    ;

    /**
     * Sets the datatype formats provided by a JSON
     *
     * @private
     * @param {string} sJSON the data type formats to set
     */
    UCF_System["prototype"]["setDataTypeFormats"] = function (sJSON) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setDataTypeFormats"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sJSON === 'string', "typeof sJSON === 'string'", "System.js(210): setDataTypeFormats");
        }
        ;
        /** @type {Object} */
        this["oDataTypeFormats"] = sJSON ? UCF_JsUtil["oJsonParse"](sJSON) : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setDataTypeFormats"] = 0;
    }
    ;

    /**
     * Returns the Systems format string for a passed type
     *
     * @private
     * @param {string} sType the type to get the data type format for
     * @return {string} the data type format associated with `sType`
     */
    UCF_System["prototype"]["sGetDataTypeFormat"] = function (sType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["sGetDataTypeFormat"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sType === 'string', "typeof sType === 'string'", "System.js(223): sGetDataTypeFormat");
        }
        ;

        if (this["oDataTypeFormats"] && sType in this["oDataTypeFormats"]) {
            return this["oDataTypeFormats"][sType];
        } else if (sType === 'Date') {
            return 'MM/dd/yyyy'; // Last date fallback
        } else {
            return '';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["sGetDataTypeFormat"] = 0;
    }
    ;

    /**
     * Sets the ID of the Theme
     *
     * @private
     * @param {string} sThemeID the (legacy) theme id to set
     */
    UCF_System["prototype"]["setThemeID"] = function (sThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setThemeID"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sThemeID === 'string', "typeof sThemeID === 'string'", "System.js(241): setThemeID");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(WARNING, 'Changing ThemeID from "' + this["sThemeID"] + '" to "' + sThemeID + '"', "System.js(243): setThemeID");
        }
        ;
        this["sThemeID"] = sThemeID;
        // this.setClientProperty('ThemeID', this.sThemeID, true);

        // System object is not a control but the JS generator checks if
        // setClientProperty exists. A comment is enough. We should fix the generator
        // instead of this workaround...
        // this.setClientProperty("ThemeID", this.sThemeID, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setThemeID"] = 0;
    }
    ;

    /**
     * Sets the Theme Repository URL
     *
     * @private
     * @param {string} sThemeRepositoryURL the theme repository url to set
     */
    UCF_System["prototype"]["setThemeRepositoryURL"] = function (sThemeRepositoryURL) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setThemeRepositoryURL"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sThemeRepositoryURL === 'string', "typeof sThemeRepositoryURL === 'string'", "System.js(260): setThemeRepositoryURL");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(WARNING, 'Changing ThemeRepositoryURL from "' + this["sThemeRepositoryURL"] + '" to "' + sThemeRepositoryURL + '"', "System.js(262): setThemeRepositoryURL");
        }
        ;
        this["sThemeRepositoryURL"] = sThemeRepositoryURL;
        // this.setClientProperty('ThemeRepositoryURL', this.sThemeRepositoryURL, true);

        // System object is not a control but the JS generator checks if
        // setClientProperty exists. A comment is enough. We should fix the generator
        // instead of this workaround...
        // this.setClientProperty("ThemeRepositoryURL", this.sThemeRepositoryURL, true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setThemeRepositoryURL"] = 0;
    }
    ;

    /**
     * returns whether a day belongs to the weekend
     *
     * @public
     * @param {int} iDay the day to test
     * @return {boolean} `true` if the given day is in the weekend, otherwise
     * `false`
     */
    UCF_System["prototype"]["bIsWeekend"] = function (iDay) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["bIsWeekend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof iDay === 'number', "typeof iDay === 'number'", "System.js(281): bIsWeekend");
        }
        ;

        return iDay >= 0 && iDay < this["aWeekendDays"]["length"] && this["aWeekendDays"][iDay];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["bIsWeekend"] = 0;
    }
    ;

    /**
     * @example
     * oLS.oSystem.aGetWeekendDays()
     * // => [true, false, false, false, false, false, true]
     * // means 'Saturday and Sunday are weekend days'
     *
     * @public
     * @return {Array.<boolean>} day-indexed (0=Sunday) booleans, `true` = "is
     * weekend", `false` = "is not"
     */
    UCF_System["prototype"]["aGetWeekendDays"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["aGetWeekendDays"]++;
        }
        ;
        return this["aWeekendDays"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["aGetWeekendDays"] = 0;
    }
    ;

    /**
     * @param {number} iLevel the debug level to check
     * @return {boolean} `true` if messages at the given debug level
     * should be logged, otherwise `false`
     */
    UCF_System["prototype"]["bIsDebugLevelActive"] = function (iLevel) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["bIsDebugLevelActive"]++;
        }
        ;
        return this["iDebugLevel"] >= iLevel;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["bIsDebugLevelActive"] = 0;
    }
    ;

    /**
     * @protected
     * @param {string} sThemeID
     * @return {boolean}
     */
    UCF_System["prototype"]["bIsSupportedSapThemeID"] = function (sThemeID) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["bIsSupportedSapThemeID"]++;
        }
        ;
        if (!this["aSupportedSapThemeIDs"]) {
            // ['sap_tradeshow*','sap_belize_hc*','sap_*']
            // => [/^sap_tradeshow.*$/,/^sap_belize_hc.*$/,/^sap_.*$/]
            this["aSupportedSapThemeIDs"] = UCF_JsUtil["map"](
                // sSupportedSapThemeIDs == '' => UCF_JsUtil.oJsonParse('["sap_*"]') => ['sap_*']
                // sSupportedSapThemeIDs == 'null' => null => ['sap_*']
                UCF_JsUtil["oJsonParse"](this["sSupportedSapThemeIDs"] || '["sap_*"]') || ['sap_*'],
                function (sGlob) {
                    return new RegExp('^' + sGlob["replace"](/\*/g, '.*') + '$');
                }
            );
        }

        return UCF_ResourceUtil["bIsSapThemeID"](sThemeID) && UCF_JsUtil["some"](
            this["aSupportedSapThemeIDs"],
            function (rTheme) {
                return rTheme["test"](sThemeID);
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["bIsSupportedSapThemeID"] = 0;
    }
    ;

// #region setters ============================================================
// #region setAccessibility ---------------------------------------------------
    /**
     * Sets the accessibility mode for client side functionality. It does not
     * influence the server side rendering.
     *
     * Possible values:
     * "ARIA" to enable ARIA
     * "CLASSIC" to enable the classic 508 support
     * "NONE" to disabled accessibility
     *
     * @protected
     * @param {UCF_System_AccessibilityMode} sAccessibility sets the accessibility mode
     *
     * @see {@link UCF_LS#setSystemParameters}
     */
    UCF_System["prototype"]["setAccessibility"] = function (sAccessibility) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setAccessibility"]++;
        }
        ;
        /** @type {UCF_System} */
        var self = this;

        this["setParameter"]('sAccessibility', sAccessibility, ['NONE', 'ARIA', 'CLASSIC', 'ARIA1.1'], function () {
            self["bIsAria"] = self["sAccessibility"] === 'ARIA' || self["sAccessibility"] === 'ARIA1.1';
            self["bIs508"] = self["sAccessibility"] === 'CLASSIC';
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setAccessibility"] = 0;
    }
    ;
// #endregion
// #region setInteractionType -------------------------------------------------
    /**
     * @protected
     * @param {UCF_System_InteractionType} sInteractionType
     *
     * @see {@link UCF_LS#setSystemParameters}
     */
    UCF_System["prototype"]["setInteractionType"] = function (sInteractionType) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setInteractionType"]++;
        }
        ;
        this["setParameter"]('sInteractionType', sInteractionType, ['KEYBOARD', 'TOUCH']);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setInteractionType"] = 0;
    }
    ;
    /**
     * @protected
     * @param {UCF_System_Platform} sPlatform
     *
     * @see {@link UCF_LS#setSystemParameters}
     */
    UCF_System["prototype"]["setPlatform"] = function (sPlatform) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setPlatform"]++;
        }
        ;
        this["setParameter"]('sPlatform', sPlatform, UCF_JsUtil["values"](UCF_UserAgent["PLATFORM"]));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setPlatform"] = 0;
    }
    ;


// #endregion
// #region setDefaultClientAction ---------------------------------------------
    /**
     * @protected
     * @param {'SUBMIT'|'SUBMITASYNC'|'NONE'|'ENQUEUE'} sDefaultClientAction
     * @see {@link UCF_LS#setSystemParameters}
     */
    UCF_System["prototype"]["setDefaultClientAction"] = function (sDefaultClientAction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setDefaultClientAction"]++;
        }
        ;
        this["setParameter"]('sDefaultClientAction', sDefaultClientAction, ['SUBMIT', 'SUBMITASYNC', 'ENQUEUE', 'NONE']);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setDefaultClientAction"] = 0;
    }
    ;
// #endregion
// #region setDefaultResponseData ---------------------------------------------
    /**
     * @protected
     * @param {'FULL'|'DELTA'|'INHERIT'} sDefaultResponseData
     * @see {@link UCF_LS#setSystemParameters}
     */
    UCF_System["prototype"]["setDefaultResponseData"] = function (sDefaultResponseData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setDefaultResponseData"]++;
        }
        ;
        this["setParameter"]('sDefaultResponseData', sDefaultResponseData, ['FULL', 'DELTA', 'INHERIT']);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setDefaultResponseData"] = 0;
    }
    ;
// #endregion
// #region setFeatureFlags ----------------------------------------------------
    UCF_System["prototype"]["setFeatureFlags"] = function (sFeatureFlags) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setFeatureFlags"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sFeatureFlags === 'string', "typeof sFeatureFlags === 'string'", "System.js(404): setFeatureFlags");
        }
        ;

        this["sFeatureFlags"] = sFeatureFlags;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setFeatureFlags"] = 0;
    }
    ;
// #endregion
// #region setParameter -------------------------------------------------------
    /**
     * @private
     * @param {string} sParameter
     * @param {any} oValue
     * @param {any[]} aSupportedValues
     * @param {function(): void} fOnSuccess
     * @return {void}
     */
    UCF_System["prototype"]["setParameter"] = function (sParameter, oValue, aSupportedValues, fOnSuccess) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setParameter"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(UCF_JsUtil["contains"](aSupportedValues, oValue), "UCF_JsUtil.contains(aSupportedValues, oValue)", "System.js(419): setParameter");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sParameter in this, "sParameter in this", "System.js(420): setParameter");
        }
        ;

        /**
         * @param {Object} o
         * @return {string}
         */
        function sSerialize(o) {
            return typeof o === 'object'
                ? UCF_JsUtil["sJsonStringify"](o)
                : typeof o === 'string'
                    ? '"' + o + '"'
                    : o;
        }

        if (UCF_JsUtil["contains"](aSupportedValues, oValue)) {
            if (this[sParameter] === oValue) {
                throw new (UCF_ClassLoader["oGetClass"]("UCF_Exception"))(sSerialize(oValue) + ' is the same value for "' + sParameter + '" as before. Did not set anything!');
            } else {
                this[sParameter] = oValue;
                if (fOnSuccess) {
                    fOnSuccess(oValue);
                }
            }
        } else {
            throw new (UCF_ClassLoader["oGetClass"]("UCF_Exception"))(sSerialize(oValue) + ' is not a valid value for "' + sParameter + '" (valid values: ' + UCF_JsUtil["map"](aSupportedValues, sSerialize)["join"]('|') + ')');
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setParameter"] = 0;
    }
    ;
// #endregion
// #endregion

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #bIs508}
     * - {@link #bIsRTL}
     * - {@link #sDevice}
     * - {@link #sLanguage}
     * - {@link #iFirstDayOfWeek}
     * - {@link #iMinimalDaysInFirstWeek}
     * - {@link #bIsDesigntime}
     * - {@link #bClientDebug}
     * - Deprecated: {@link #sExternalThemeRoot}
     * - {@link #sCSSURL}
     * - {@link #sResourceRoot}
     * - Deprecated: {@link #sSpaceGif}
     * - {@link #bLoadOnDemand}
     * - {@link #bUseAnimation}
     * - {@link #bUseActiveX}
     * - {@link #bIsUCF}
     * - {@link #sPlatform}
     * - {@link #sClientVersionKey}
     * - {@link #sUserAgentName}
     * - {@link #fUserAgentVersion}
     * - {@link #bUseSafeTransportEncoding}
     * - Deprecated: {@link #bUseXHR}
     * - {@link #sAccessibility}
     * - Deprecated: {@link #sEmbedding}
     * - Deprecated: {@link #sCustomData}
     * - {@link #sThemeID}
     * - {@link #sThemeFileName}
     * - {@link #sThemeRepositoryURL}
     * - {@link #sThemeRepositoryURLAppendix}
     * - {@link #sThemeRequiredVersion}
     * - {@link #sThemeFallbackRepositoryURL}
     * - {@link #sThemeFallbackID}
     * - {@link #sThemeFallbackCSSURL}
     * - {@link #sDataTypeFormats}
     * - {@link #sRuntimeVersion}
     * - {@link #bEnableClientSideTesting}
     * - {@link #sBaseURL}
     * - {@link #sWeekendDays}
     * - {@link #bSetDirtyForRoundtrips}
     * - {@link #bIsRemoteDesktop}
     * - {@link #bUseFocusColor}
     * - {@link #sDebugLevel}
     * - {@link #sFeatureChannel}
     * - {@link #sFeatureFlags}
     * - {@link #sBrowserName}
     * - {@link #sBrowserVersion}
     * - {@link #sNonce}
     * - {@link #sSubmitMethod}
     * - {@link #sInteractionType}
     * - {@link #sSupportedSapThemeIDs}
     * - {@link #sDefaultClientAction}
     * - {@link #sDefaultResponseData}
     * @private
     * @type {string[]}
     */
    UCF_System["prototype"]["aAttributeNames"] = ['bIs508', 'bIsRTL', 'sDevice', 'sLanguage', 'iFirstDayOfWeek', 'iMinimalDaysInFirstWeek', 'bIsDesigntime', 'bClientDebug', 'sExternalThemeRoot', 'sCSSURL', 'sResourceRoot', 'sSpaceGif', 'bLoadOnDemand', 'bUseAnimation', 'bUseActiveX', 'bIsUCF', 'sPlatform', 'sClientVersionKey', 'sUserAgentName', 'fUserAgentVersion', 'bUseSafeTransportEncoding', 'bUseXHR', 'sAccessibility', 'sEmbedding', 'sCustomData', 'sThemeID', 'sThemeFileName', 'sThemeRepositoryURL', 'sThemeRepositoryURLAppendix', 'sThemeRequiredVersion', 'sThemeFallbackRepositoryURL', 'sThemeFallbackID', 'sThemeFallbackCSSURL', 'sDataTypeFormats', 'sRuntimeVersion', 'bEnableClientSideTesting', 'sBaseURL', 'sWeekendDays', 'bSetDirtyForRoundtrips', 'bIsRemoteDesktop', 'bUseFocusColor', 'sDebugLevel', 'sFeatureChannel', 'sFeatureFlags', 'sBrowserName', 'sBrowserVersion', 'sNonce', 'sSubmitMethod', 'sInteractionType', 'sSupportedSapThemeIDs', 'sDefaultClientAction', 'sDefaultResponseData'];

    /**
     * Array of names of events of the control:
     * @type {string[]}
     */
    UCF_System["prototype"]["aEventNames"] = [];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * no public API available
     *
     * @private
     * @type {string[]}
     */
    UCF_System["prototype"]["aMethodNames"] = [, 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     * Specifies whether the System is in 508 = accessibility mode or not.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bIs508"] = false;

    /**
     * Specifies whether the System is in right-to-left mode or not.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bIsRTL"] = false;

    /**
     * Sets the device string (browser) - mainly used in the look and feel infrastructure, the generated renderers and the javascript
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sDevice"] = 'ie6';

    /**
     * Sets the language string
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sLanguage"] = 'en';

    /**
     * Sets the first day of the week for the locale or user wehere 0=Sunday and 6 is Saturday.
     *
     * @private
     * @type {number}
     */
    UCF_System["prototype"]["iFirstDayOfWeek"] = 0;

    /**
     * Sets how many days are required in the first week of the year to make it week number 1, Default 4 = ISO 8601 = week number 1 is the week with the first Thursday.
     *
     * @private
     * @type {number}
     */
    UCF_System["prototype"]["iMinimalDaysInFirstWeek"] = 4;

    /**
     * Specifies whether the System renders for designtime or runtime.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bIsDesigntime"] = false;

    /**
     * Specified whether debug-libraries should be used.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bClientDebug"] = false;

    /**
     * Sets the external (browser) root path to the theme. It is used to render various image path from the theme in the generated HTML content.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sExternalThemeRoot"] = '';

    /**
     * Specified a URL to CSS that is used if InlineCSS=false. This URL is only used for the old theming infrastructure. When using the new Theming infrastructure use the parameter 'ThemeRepositoryURL'
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sCSSURL"] = '';

    /**
     * Sets the root path (external/browser) to the ressources .
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sResourceRoot"] = '.';

    /**
     * Sets the path to the spacer GIF image files in the System. Deprecated: Use resourceRoot instead which contains the 1x1.gif
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sSpaceGif"] = null;

    /**
     * Specifies whether control JS should be loaded on demand or intially.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bLoadOnDemand"] = true;

    /**
     * Specifies whether animation effects should be used. Implies UseFocusColor=true.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bUseAnimation"] = true;

    /**
     * Specifies whether ActiveX should be used.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bUseActiveX"] = true;

    /**
     * Specifies whether the System uses UCF features or not
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bIsUCF"] = false;

    /**
     * Sets the platform of the browser. Valid values are Windows, X11, Macintosh, iOS, Android
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sPlatform"] = 'Windows';

    /**
     * Sets the version for the client that is used to access the resources from the server. The framework has to ensure that the client version key is different between different customers on the same patch level. The client version key must be almost constant to avoid too many caching cleanups on runnings systems.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sClientVersionKey"] = '';

    /**
     * Sets the name of the user agent (rendering engine) that can be found in the user agent string of the request
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sUserAgentName"] = 'MSIE';

    /**
     * Sets the major and minor version number of the user agent (rendering engine). Minor number is the fraction in the float.  Please don't use the version number of the browser.
     *
     * @private
     * @type {number}
     */
    UCF_System["prototype"]["fUserAgentVersion"] = 0;

    /**
     * Specifies whether extra transport encoding of Event Queue data between client and server is used or not. Default setting (=true) guarantees the data gets passed in codepage-safe way, converted to low-ascii character. The consuming framework may disable this extra encoding (=false) on demand to get slimmer upstream network traffic, but only under assumption both client and server are using UTF8 encoding
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bUseSafeTransportEncoding"] = true;

    /**
     * Specifies whether IFrames should be used instead of XMLHttpRequest. Unsupported and for test purposes only.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bUseXHR"] = true;

    /**
     * Specifies the accessibility mode. See Accessibility enumeration for more details.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sAccessibility"] = 'NONE';

    /**
     * DO NOT USE!! AUTO | ISOLATED
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sEmbedding"] = 'AUTO';

    /**
     * Do not use
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sCustomData"] = '';

    /**
     * Sets the themeId - it's the technical name of the theme
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeID"] = null;

    /**
     * An optional name of a less file (without extension) in the theme which identifies the CSS to refer. If empty the Device is used to determine the ThemeFileName
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeFileName"] = '';

    /**
     * The URL to the root of the theme repository which has to be used to choose right Theminh data. It is mandartory that ThemeID is set additionally.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeRepositoryURL"] = '';

    /**
     * A string to be appended to the style URL after the '?'. This could be used e.g. for cache version handling
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeRepositoryURLAppendix"] = '';

    /**
     * The version string which is used to be compared with the CSS version. An empty version string means that no check is perfromed
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeRequiredVersion"] = '';

    /**
     * An optional fallback URL to an repository which is loaded when the CSS version does not match to the ThemeRequiredVersion
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeFallbackRepositoryURL"] = '';

    /**
     * An optional fallback ID used in combination with ThemeFallbackRepositoryURL
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeFallbackID"] = '';

    /**
     * An optional fallback URL to an stylesheet which is loaded when the CSS version does not match to the ThemeRequiredVersion
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sThemeFallbackCSSURL"] = '';

    /**
     * A string in JSON format which defines the format strings to parse and serialize data types. Supported types are 'Date' and 'Decimal'
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sDataTypeFormats"] = '';

    /**
     * The current runtime version of JS and renderer
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sRuntimeVersion"] = '';

    /**
     * Enables a special test mode.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bEnableClientSideTesting"] = false;

    /**
     * This URL is set for the base tag of the page
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sBaseURL"] = '';

    /**
     * Sets the weekend days as an array where 0=Sunday and 6 is Saturday.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sWeekendDays"] = '[0,6]';

    /**
     * Specifies whether the UCF_WorkProtectHandler (IHub-related) is set to dirty when LightSpeed is locked (SetDirtyForRoundtrips=true) or only if LightSpeed is actually dirty (SetDirtyForRoundtrips=false, the default).
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bSetDirtyForRoundtrips"] = false;

    /**
     * Specifies whether the System is accessed via remote desktop.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bIsRemoteDesktop"] = false;

    /**
     * Specifies whether focus should be visualized.
     *
     * @private
     * @type {boolean}
     */
    UCF_System["prototype"]["bUseFocusColor"] = false;

    /**
     * Specifies the amount of debug information provided by Lightspeed. Default is OFF (== no information).
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sDebugLevel"] = "OFF";

    /**
     * Specifies the amount of features to be used. See FeatureChannel.enumeration. Default is STABLE.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sFeatureChannel"] = "STABLE";

    /**
     * Comma-separated list of specific features to enable (usually to test features during development)
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sFeatureFlags"] = '';

    /**
     * Specifies the browser name.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sBrowserName"] = '';

    /**
     * Specifies the browser version.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sBrowserVersion"] = '';

    /**
     * CSP-Nonce.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sNonce"] = '';

    /**
     * Determines the method used during submit.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sSubmitMethod"] = "FORM";

    /**
     * Determines the prefered interaction.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sInteractionType"] = "KEYBOARD";

    /**
     * List of all SAP themes supported by the application. Must be valid JSON, e.g. '["sap_tradeshow","sap_corbu","sap_belize","sap_belize_hcb"]'. "*" is supported as a wildcard, i.e. '["sap_belize*"]' equals '["sap_belize","sap_belize_plus""sap_belize_hcb","sap_belize_hcw"]'. Themes where the first SAP theme in the inheritance chain does not match any item in this list of SupportedThemes will be rejected, i.e. a theme fallback will be performed, possibly multiple times, until a supported theme is found. The default is 'null' (which is equal to '["*"]'), accepting all SAP themes.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sSupportedSapThemeIDs"] = 'null';

    /**
     * Sets the default ClientAction to be used in the ucf parameters of events. See ClientAction.enumeration. Defaults to ENQUEUE.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sDefaultClientAction"] = "ENQUEUE";

    /**
     * Sets the default ResponseData to be used in the ucf parameters of events. See ResponseData.enumeration. Defaults to INHERIT.
     *
     * @private
     * @type {string}
     */
    UCF_System["prototype"]["sDefaultResponseData"] = "INHERIT";


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_System["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_System["_"]["setDefaultValues"]++;
        }
        ;
        this["bIs508"] = false;
        this["bIsRTL"] = false;
        this["sDevice"] = 'ie6';
        this["sLanguage"] = 'en';
        this["iFirstDayOfWeek"] = 0;
        this["iMinimalDaysInFirstWeek"] = 4;
        this["bIsDesigntime"] = false;
        this["bClientDebug"] = false;
        this["sExternalThemeRoot"] = '';
        this["sCSSURL"] = '';
        this["sResourceRoot"] = '.';
        this["sSpaceGif"] = null;
        this["bLoadOnDemand"] = true;
        this["bUseAnimation"] = true;
        this["bUseActiveX"] = true;
        this["bIsUCF"] = false;
        this["sPlatform"] = 'Windows';
        this["sClientVersionKey"] = '';
        this["sUserAgentName"] = 'MSIE';
        this["fUserAgentVersion"] = 0;
        this["bUseSafeTransportEncoding"] = true;
        this["bUseXHR"] = true;
        this["sAccessibility"] = 'NONE';
        this["sEmbedding"] = 'AUTO';
        this["sCustomData"] = '';
        this["sThemeID"] = null;
        this["sThemeFileName"] = '';
        this["sThemeRepositoryURL"] = '';
        this["sThemeRepositoryURLAppendix"] = '';
        this["sThemeRequiredVersion"] = '';
        this["sThemeFallbackRepositoryURL"] = '';
        this["sThemeFallbackID"] = '';
        this["sThemeFallbackCSSURL"] = '';
        this["sDataTypeFormats"] = '';
        this["sRuntimeVersion"] = '';
        this["bEnableClientSideTesting"] = false;
        this["sBaseURL"] = '';
        this["sWeekendDays"] = '[0,6]';
        this["bSetDirtyForRoundtrips"] = false;
        this["bIsRemoteDesktop"] = false;
        this["bUseFocusColor"] = false;
        this["sDebugLevel"] = "OFF";
        this["sFeatureChannel"] = "STABLE";
        this["sFeatureFlags"] = '';
        this["sBrowserName"] = '';
        this["sBrowserVersion"] = '';
        this["sNonce"] = '';
        this["sSubmitMethod"] = "FORM";
        this["sInteractionType"] = "KEYBOARD";
        this["sSupportedSapThemeIDs"] = 'null';
        this["sDefaultClientAction"] = "ENQUEUE";
        this["sDefaultResponseData"] = "INHERIT";

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', 'ie6', true);
            this["setClientProperty"]('', 'en', true);
            this["setClientProperty"]('', 0, true);
            this["setClientProperty"]('', 4, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '.', true);
            this["setClientProperty"]('', null, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', 'Windows', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', 'MSIE', true);
            this["setClientProperty"]('', 0, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', true, true);
            this["setClientProperty"]('', 'NONE', true);
            this["setClientProperty"]('', 'AUTO', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', null, true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '[0,6]', true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', "OFF", true);
            this["setClientProperty"]('', "STABLE", true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', "FORM", true);
            this["setClientProperty"]('', "KEYBOARD", true);
            this["setClientProperty"]('', 'null', true);
            this["setClientProperty"]('', "ENQUEUE", true);
            this["setClientProperty"]('', "INHERIT", true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_System["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    UCF_System.prototype["aPublicMethods"] = ["bIsWeekend", "aGetWeekendDays"].concat(UCF_System.prototype.aPublicMethods || []);
    /* global UCF_Exception */

/// <reference path="./Exception.js"/>

    /**
     * ValidateException class
     *
     * This exception is thrown, when a validation error occurs while checking the
     * defined constraints for a type.
     *
     * @param {string} message
     * @param {string} violatedConstraints
     */
    function UCF_ValidateException(message, violatedConstraints) {
        if (__UCF_COVERAGE__) {
            UCF_ValidateException["_"]["UCF_ValidateException"]++;
        }
        ;
        this["name"] = "ValidateException";                // eslint-disable-line ur/no-memory-leaks
        this["message"] = message;                         // eslint-disable-line ur/no-memory-leaks
        this["violatedConstraints"] = violatedConstraints; // eslint-disable-line ur/no-memory-leaks
    };window["UCF_ValidateException"] = UCF_ValidateException;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ValidateException");
        UCF_ValidateException["_"] = {UCF_ValidateException: 0};
    }
    ;
    ;
    UCF_ValidateException["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Exception"))();
    UCF_ValidateException.prototype["sClassName"] = "UCF_ValidateException";


    UCF_ValidateException["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ValidateException["_"]["destroy"]++;
        }
        ;
        UCF_Exception.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ValidateException["_"]["destroy"] = 0;
    }
    ;


    /* global _assert, _trace, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* eslint consistent-this:0 */

    /**
     *
     *
     * @class UCF_BeaconRequest
     * @extends UCF_EventProvider
     * @param {UCF_LS} oLS the Lightspeed instance to measure
     * @param {string} sUrl URL of the becaon request
     */
    function UCF_BeaconRequest(oLS, sUrl) {
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["UCF_BeaconRequest"]++;
        }
        ;
        /** @type {Object[]} */
        this["aBuffer"] = null;
        /** @type {number} time in ms after the beacon will be sent to server */
        this["iTime"] = 60000;
        /** @type {number} amount of entries after the beacon will be sent */
        this["iCount"] = 10;
        /** @type {string} */
        this["sDelayedCallId"] = '';
        /** @type {Object|Object[]} data which is sent as the first entry of each beacon */
        this["ofixBeaconData"] = null;

        if (arguments["length"] > 0) {
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(UCF_JsUtil["bInstanceOf"](oLS, 'UCF_LS'), "UCF_JsUtil.bInstanceOf(oLS, 'UCF_LS')", "BeaconRequest.js(32): UCF_BeaconRequest");
            }
            ;

            UCF_EventProvider["apply"](this, [oLS]); // super() call
            /** @type {UCF_LS} */
            this["oLS"] = oLS;
            /** @type {string} */
            this["sUrl"] = sUrl;
            this["oLS"]["attachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeDestroy"], this, 'flush');
            this["oLS"]["oBrowserWindow"]["attachBeforeEvent"](
                this["oLS"]["oBrowserWindow"]["E_EVENTS"]["VisibilityChange"],
                this,
                'flush'
            );
            this["oLS"]["oBrowserWindow"]["attachBeforeEvent"](
                this["oLS"]["oBrowserWindow"]["E_EVENTS"]["BeforeUnload"],
                this,
                'flush'
            );
        }
    };window["UCF_BeaconRequest"] = UCF_BeaconRequest;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_BeaconRequest");
        UCF_BeaconRequest["_"] = {UCF_BeaconRequest: 0};
    }
    ;
    ;
    UCF_BeaconRequest["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_BeaconRequest.prototype["sClassName"] = "UCF_BeaconRequest";

    /**
     * Destroys the BeaconRequest after sending all data
     *
     * @public
     */
    UCF_BeaconRequest["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["destroy"]++;
        }
        ;

        this["flush"](); // ensure to send all data before destroy and reset timer

        if (this["oLS"] && this["oLS"]["oBrowserWindow"]) { //beacon could be already destroyed

            this["oLS"]["oBrowserWindow"]["detachBeforeEvent"](
                this["oLS"]["oBrowserWindow"]["E_EVENTS"]["VisibilityChange"],
                this,
                'flush'
            );
            this["oLS"]["oBrowserWindow"]["detachBeforeEvent"](
                this["oLS"]["oBrowserWindow"]["E_EVENTS"]["BeforeUnload"],
                this,
                'flush'
            );
            this["oLS"]["detachBeforeEvent"](this["oLS"]["E_EVENTS"]["BeforeDestroy"], this, 'flush');
        }

        this["iTime"] = null;
        this["iCount"] = null;
        this["ofixBeaconData"] = null;
        this["sUrl"] = null;
        this["oLS"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["destroy"] = 0;
    }
    ;

    /**
     * Flush all data and send beacon to URL
     *
     * @public
     */
    UCF_BeaconRequest["prototype"]["flush"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["flush"]++;
        }
        ;
        // reset timer until a new entry is added
        if (this["sDelayedCallId"]) {
            UCF_JsUtil["clearDelayedCall"](this["sDelayedCallId"]);
            this["sDelayedCallId"] = '';
        }

        if (this["aBuffer"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Send beacon request: ' + this["sUrl"], "BeaconRequest.js(101): flush");
            }
            ;

            // sBody is not yet implemented
            UCF_RequestUtil["sendBeaconRequest"](this["sUrl"], this["aBuffer"], '');

            //reset data structures
            this["aBuffer"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["flush"] = 0;
    }
    ;

    /**
     * Enqueue form parameter (name & value) whereas the name must not be unique
     *
     * @public
     * @param {string} name name of the parameter
     * @param {string} value value of the parameter
     * @param {boolean} [forceFlush] parameter to force a flush on the beacon
     */
    UCF_BeaconRequest["prototype"]["enqueueParameter"] = function (name, value, forceFlush) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["enqueueParameter"]++;
        }
        ;
        /** @type {Object<string, string>} */
        var oMap = {};

        if (!this["aBuffer"]) {
            this["aBuffer"] = [];
            if (this["ofixBeaconData"]) {
                if (this["ofixBeaconData"] instanceof Array) {
                    this["aBuffer"] = this["ofixBeaconData"];
                } else if (this["ofixBeaconData"] instanceof Object) {
                    this["aBuffer"]["push"](this["ofixBeaconData"]);
                }
            }

            // start timer once an entry is available
            if (this["iTime"] > 0 && this["sDelayedCallId"] === '') {
                this["sDelayedCallId"] = UCF_JsUtil["delayedCall"](this["iTime"], this, 'flush');
            }
        }

        oMap[name] = value;
        this["aBuffer"]["push"](oMap);

        if (forceFlush || (this["iCount"] > 0 && this["aBuffer"]["length"] >= this["iCount"])) {
            this["flush"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["enqueueParameter"] = 0;
    }
    ;

    /**
     * Sets beacon URL
     *
     * @public
     * @param {string} sUrl beacon URL
     */
    UCF_BeaconRequest["prototype"]["setBeaconUrl"] = function (sUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["setBeaconUrl"]++;
        }
        ;
        this["sUrl"] = sUrl;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["setBeaconUrl"] = 0;
    }
    ;

    /**
     * Sets data transfered always as first beacon data entry
     *
     * @public
     * @param {Object|Object[]} ofixBeaconData data in type string or name/value
     * pair object to add to each beacon request
     */
    UCF_BeaconRequest["prototype"]["setFixBeaconData"] = function (ofixBeaconData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["setFixBeaconData"]++;
        }
        ;
        this["ofixBeaconData"] = ofixBeaconData;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["setFixBeaconData"] = 0;
    }
    ;

    /**
     * Sets the amount of data entries until beacon is send.
     *
     * @public
     * @param {number} iCount amount of data entries until beacon is send. Use 0 to
     * deactivate automatic send
     */
    UCF_BeaconRequest["prototype"]["setBeaconEntryCount"] = function (iCount) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["setBeaconEntryCount"]++;
        }
        ;
        this["iCount"] = iCount;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["setBeaconEntryCount"] = 0;
    }
    ;

    /**
     * Sets the time after a beacon is send in millisecond
     *
     * @public
     * @param {number} iTime time after a beacon is send in millisecond, Use <=0 to
     * disable automatic send
     */
    UCF_BeaconRequest["prototype"]["setBeaconTimer"] = function (iTime) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_BeaconRequest["_"]["setBeaconTimer"]++;
        }
        ;
        this["iTime"] = iTime;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_BeaconRequest["_"]["setBeaconTimer"] = 0;
    }
    ;

    UCF_BeaconRequest.prototype["aPublicMethods"] = ["destroy", "flush", "enqueueParameter", "setBeaconUrl", "setFixBeaconData", "setBeaconEntryCount", "setBeaconTimer"].concat(UCF_BeaconRequest.prototype.aPublicMethods || []);
    /* global UCF_Event */
/// <reference path="../../core/Event.js"/>
    /* global UCF_Interface */
/// <reference path="../../core/Interface.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global _assert, _trace, DEBUG, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_ErrorMessage */
/// <reference path="../../core/util/ErrorMessage.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_Form */
/// <reference path="../controls/Form.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_System */
/// <reference path="../core/System.js"/>
    /* global UCF_EventQueue */
/// <reference path="./EventQueue.js"/>
    /* global UCF_EventQueueItem */
/// <reference path="./EventQueueItem.js"/>
    /* global UCF_EventTimer */
/// <reference path="./EventTimer.js"/>
    /* global UCF_PendingRequest */
/// <reference path="./PendingRequest.js"/>
    /* global UCF_WaitingEventQueue */
/// <reference path="./WaitingEventQueue.js"/>

    /** @typedef {'ClientAction'} UCF_EventHandler_Key_Action */
    /** @typedef {'EnqueueCardinality'} UCF_EventHandler_Key_Cardinality */
    /** @typedef {'TransportMethod'} UCF_EventHandler_Key_Transport */
    /** @typedef {'ResponseData'} UCF_EventHandler_Key_Response */
    /** @typedef {'ActionUrl'} UCF_EventHandler_Key_ActionUrl */
    /** @typedef {'PrepareScript'} UCF_EventHandler_Key_PrepareScript */
    /** @typedef {'Delay'} UCF_EventHandler_Key_Delay */
    /** @typedef {'SyncExecution'} UCF_EventHandler_Key_SyncExecution */
    /** @typedef {'ClientListener'} UCF_EventHandler_Key_ClientListener */
    /** @typedef {UCF_EventHandler_Key_Action|UCF_EventHandler_Key_Cardinality|UCF_EventHandler_Key_Transport|UCF_EventHandler_Key_Response|UCF_EventHandler_Key_ActionUrl|UCF_EventHandler_Key_PrepareScript|UCF_EventHandler_Key_Delay|UCF_EventHandler_Key_SyncExecution|UCF_EventHandler_Key_ClientListener} UCF_EventHandler_Key */
    /**
     * @typedef {Object} UCF_EventHandler_KeyEnum
     * @property {UCF_EventHandler_Key_Action} ACTION
     * @property {UCF_EventHandler_Key_Cardinality} CARDINALITY
     * @property {UCF_EventHandler_Key_Transport} TRANSPORT
     * @property {UCF_EventHandler_Key_Response} RESPONSE
     * @property {UCF_EventHandler_Key_ActionUrl} ACTIONURL
     * @property {UCF_EventHandler_Key_PrepareScript} PREPARESCRIPT
     * @property {UCF_EventHandler_Key_Delay} DELAY
     * @property {UCF_EventHandler_Key_SyncExecution} SYNCEXECUTION
     * @property {UCF_EventHandler_Key_ClientListener} CLIENTLISTENER
     */

    /**
     * @typedef {Object} UCF_EventHandler_TransportMethodEnum
     * @property {UCF_SemanticEvent_TransportMethod_Full} FULL
     * @property {UCF_SemanticEvent_TransportMethod_Partial} PARTIAL
     */

    /**
     * @typedef {Object} UCF_EventHandler_ActionEnum
     * @property {UCF_SemanticEvent_Action_Submit} SUBMIT
     * @property {UCF_SemanticEvent_Action_SubmitAsync} SUBMITASYNC
     * @property {UCF_SemanticEvent_Action_Enqueue} ENQUEUE
     * @property {UCF_SemanticEvent_Action_None} NONE
     */

    /**
     * @typedef {Object} UCF_EventHandler_CardinalityEnum
     * @property {UCF_SemanticEvent_Cardinality_Multiple} MULTIPLE
     * @property {UCF_SemanticEvent_Cardinality_Single} SINGLE
     * @property {UCF_SemanticEvent_Cardinality_None} NONE
     */

    /**
     * @typedef {Object} UCF_EventHandler_ResponseDataEnum
     * @property {UCF_SemanticEvent_ResponseData_Full} FULL
     * @property {UCF_SemanticEvent_ResponseData_Delta} DELTA
     * @property {UCF_SemanticEvent_ResponseData_Inherit} INHERIT
     */

    /**
     * @typedef {Object} UCF_EventHandler_DelayEnum
     * @property {UCF_SemanticEvent_Delay_Full} FULL
     * @property {UCF_SemanticEvent_Delay_None} NONE
     */

    /** @typedef {'FULL'} UCF_EventHandler_FormResponse_Full */
    /** @typedef {'DELTA'} UCF_EventHandler_FormResponse_Delta */
    /** @typedef {UCF_EventHandler_FormResponse_Full|UCF_EventHandler_FormResponse_Delta} UCF_EventHandler_FormResponse */
    /**
     * @typedef {Object} UCF_EventHandler_FormResponseEnum
     * @property {UCF_EventHandler_FormResponse_Full} FULL
     * @property {UCF_EventHandler_FormResponse_Delta} DELTA
     */

    /** @typedef {0} UCF_EventHandler_Source_Direct fire event via standard way */
    /** @typedef {1} UCF_EventHandler_Source_WQueue re-fire/post-process events from waiting queue */
    /** @typedef {2} UCF_EventHandler_Source_Timer re-fire/post-process delayed event via timer */
    /** @typedef {UCF_EventHandler_Source_Direct|UCF_EventHandler_Source_WQueue|UCF_EventHandler_Source_Timer} UCF_EventHandler_Source */
    /**
     * @typedef {Object} UCF_EventHandler_SourceEnum
     * @property {UCF_EventHandler_Source_Direct} DIRECT
     * @property {UCF_EventHandler_Source_WQueue} WQUEUE
     * @property {UCF_EventHandler_Source_Timer} TIMER
     */

    /**
     * @typedef {Object} UCF_EventHandler_ProcessSemanticEventScope
     * @property {UCF_SemanticEvent_Action} eClientAction
     * @property {UCF_SemanticEvent_Cardinality} eEnqueueCardinality
     * @property {UCF_SemanticEvent_ResponseData} eResponseData
     * @property {UCF_SemanticEvent_TransportMethod} eTransportMethod
     * @property {string} sActionUrl
     * @property {string} sPrepareScript
     * @property {UCF_SemanticEvent_Delay} eDelay
     * @property {boolean} bDelay
     * @property {boolean} bSyncExecution
     * @property {string} sClientListener
     * @property {UCF_SemanticEvent_UcfParameters} ucfParam
     * @property {function(UCF_SemanticEvent, UCF_LS): boolean} func
     * @property {boolean} bOk
     * @property {string} sId
     * @property {string} sParam
     * @property {UCF_EventQueue} oEventQueue
     * @property {UCF_Form} oFormControl
     * @property {string} sInternalFormId
     * @property {HTMLFormElement} oDomRef
     * @property {UCF_Page} oPage
     * @property {string} sFormId
     * @property {boolean} bDoLock
     * @property {string} sFocusIdForRequest
     * @property {UCF_EventQueueItem} oItem
     * @property {{getEventDelay: function(): number}} oClass
     */

    /**
     * Class LS EventHandler
     *
     * handles semantic events, adds them to the queue and triggers the request to the server
     *
     *
     * @class
     * @version
     * @param {UCF_LS}   oLS     reference to Lightspeed object
     */
    function UCF_EventHandler(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["UCF_EventHandler"]++;
        }
        ;
        /** @type {UCF_Page} */
        var oPage;
        /** @type {string} */
        var sFormId;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "EventHandler.js(157): UCF_EventHandler");
        }
        ;

        UCF_EventProvider["apply"](this);

        this["defineEvents"](['AfterRequestSubmit', 'EventQueueDataComplete']);

        /** @type {UCF_LS} */
        this["oLS"] = oLS;
        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["SemanticEvent"], this, 'onSemanticEvent');

        // There are one main queue and optional event queues

        /** @type {UCF_EventQueue} */
        this["oQueue"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventQueue"))(this["oLS"]);
        /** @type {Object<string, UCF_EventQueue>} */
        this["mFormQueues"] = {};
        /** @type {UCF_EventQueue} Queue for "partial" transport method */
        this["oPartialQueue"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventQueue"))(this["oLS"]);
        /** @type {boolean} */
        this["bPartialMode"] = false;

        // Assume default Queue on page, but check whether this is not moved to form
        /** @type {boolean} */
        this["bPageQueueEnabled"] = true;
        /** @type {string} */
        this["sPageQueueSubstitute"] = '';

        /** @type {UCF_WaitingEventQueue} Queue to keep events which have to wait */
        this["oWEQueue"] = new (UCF_ClassLoader["oGetClass"]("UCF_WaitingEventQueue"))();

        /** @type {UCF_EventTimer} Timer/Scheduler for delayed semantic events */
        this["oTimer"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventTimer"))();

        oPage = oLS["oGetPageInternal"]();

        if (oPage && !oPage["bHasEventQueue"]) {
            sFormId = oPage["sFormId"];

            if (sFormId) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Disabling EventQueue on Page - events now collected on Form: ' + sFormId, "EventHandler.js(196): UCF_EventHandler");
                }
                ;
                this["mFormQueues"][sFormId] = this["oQueue"];

                /** @type {boolean} */
                this["bPageQueueEnabled"] = false;
                /** @type {string} */
                this["sPageQueueSubstitute"] = sFormId;
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'EventQueue on Page could not be disabled, Page.FormId is missing', "EventHandler.js(204): UCF_EventHandler");
                }
                ;
            }
        }
    };window["UCF_EventHandler"] = UCF_EventHandler;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_EventHandler");
        UCF_EventHandler["_"] = {UCF_EventHandler: 0};
    }
    ;
    UCF_EventHandler["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_EventHandler.prototype["sClassName"] = "UCF_EventHandler";

    /**
     * Internal enumeration/mapping for the used UCF parameters
     * @private
     * @type {UCF_EventHandler_KeyEnum}
     */
    UCF_EventHandler["prototype"]["E_KEY"] = {
        "ACTION": 'ClientAction',
        "CARDINALITY": 'EnqueueCardinality',
        "TRANSPORT": 'TransportMethod',
        "RESPONSE": 'ResponseData',
        "ACTIONURL": 'ActionUrl',
        "PREPARESCRIPT": 'PrepareScript',
        "DELAY": 'Delay',
        "SYNCEXECUTION": 'SyncExecution',
        "CLIENTLISTENER": 'ClientListener'
    };

    /**
     * Internal enumeration/mapping of event queue transport method.
     * @private
     * @type {UCF_EventHandler_TransportMethodEnum}
     */
    UCF_EventHandler["prototype"]["E_TRANSPORT_METHOD"] = {
        "FULL": 'full',
        "PARTIAL": 'partial'
    };

    /**
     * Internal enumeration/mapping of event queue actions
     * @private
     * @type {UCF_EventHandler_ActionEnum}
     */
    UCF_EventHandler["prototype"]["E_ACTION"] = {
        "SUBMIT": 'submit',
        "SUBMITASYNC": 'submitAsync',
        "ENQUEUE": 'enqueue',
        "NONE": 'none'
    };

    /**
     * Internal enumeration/mapping of event cardinality (whether the event can
     * exist in single or multiple instances in the queue)
     * @private
     * @type {UCF_EventHandler_CardinalityEnum}
     */
    UCF_EventHandler["prototype"]["E_CARDINALITY"] = {
        "MULTIPLE": 'multiple',
        "SINGLE": 'single',
        "NONE": 'none'
    };

    /**
     * Internal enumeration/mapping of event response data, whether a full page or
     * delta update is expected
     * @private
     * @type {UCF_EventHandler_ResponseDataEnum}
     */
    UCF_EventHandler["prototype"]["E_RESPONSE_DATA"] = {
        "FULL": 'full',
        "DELTA": 'delta',
        "INHERIT": 'inherit'
    };

    /**
     * Internal enumeration/mapping of Delayed call
     * @private
     * @type {UCF_EventHandler_DelayEnum}
     */
    UCF_EventHandler["prototype"]["E_DELAY"] = {
        "NONE": 'none',
        "FULL": 'full'
    };

    /**
     * Internal enumeration/mapping of FORM response data, whether a full page or delta update is expected
     * @private
     * @type {UCF_EventHandler_FormResponseEnum}
     */
    UCF_EventHandler["prototype"]["E_FORM_RESPONSE_DATA"] = {
        "FULL": 'FULL',
        "DELTA": 'DELTA'
    };

    /**
     * source of the event, used to differentiate processing modes
     * @private
     * @type {UCF_EventHandler_SourceEnum}
     */
    UCF_EventHandler["prototype"]["E_SOURCE"] = {
        "DIRECT": 0,
        "WQUEUE": 1,
        "TIMER": 2
    };

// ------ Sets for dedicated property tests -----
    /**
     * @private
     * @param {UCF_SemanticEvent_Action} sAction
     * @return {boolean} `true` if sAction is an arbitrary submit
     */
    UCF_EventHandler["prototype"]["bActionSUBMITABLE"] = function (sAction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["bActionSUBMITABLE"]++;
        }
        ;
        return (sAction === this["E_ACTION"]["SUBMIT"]
            || sAction === this["E_ACTION"]["SUBMITASYNC"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["bActionSUBMITABLE"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_SemanticEvent_Action} sAction
     * @return {boolean} `true` if sAction is any action forcing enqueue
     */
    UCF_EventHandler["prototype"]["bActionENQUEUABLE"] = function (sAction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["bActionENQUEUABLE"]++;
        }
        ;
        return (sAction === this["E_ACTION"]["ENQUEUE"]
            || sAction === this["E_ACTION"]["SUBMIT"]
            || sAction === this["E_ACTION"]["SUBMITASYNC"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["bActionENQUEUABLE"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_SemanticEvent_Cardinality} sCardinality
     * @return {boolean} `true` if the cardinality matches one that affects the queue
     */
    UCF_EventHandler["prototype"]["bCardinalityENQUEUABLE"] = function (sCardinality) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["bCardinalityENQUEUABLE"]++;
        }
        ;
        return (sCardinality === this["E_CARDINALITY"]["SINGLE"]
            || sCardinality === this["E_CARDINALITY"]["MULTIPLE"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["bCardinalityENQUEUABLE"] = 0;
    }
    ;

// --------------------

    /**
     *
     */
    UCF_EventHandler["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["destroy"]++;
        }
        ;
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["SemanticEvent"], this);

        if (this["oQueue"]) {
            this["oQueue"]["destroy"]();
            this["oQueue"] = null;
        }

        if (this["oPartialQueue"]) {
            this["oPartialQueue"]["destroy"]();
            this["oPartialQueue"] = null;
        }

        UCF_JsUtil["forEach"](this["mFormQueues"], function (oQueues) {
            oQueues["destroy"]();
        });
        this["mFormQueues"] = null;

        if (this["oWEQueue"]) {
            this["oWEQueue"]["destroy"]();
            this["oWEQueue"] = null;
        }

        if (this["oTimer"]) {
            this["oTimer"]["destroy"]();
            this["oTimer"] = null;
        }

        this["sPageQueueSubstitute"] = null;
        this["oPendingRequestHandlerObject"] = null;
        this["sPendingRequestHandlerFunction"] = null;
        this["oLS"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["destroy"] = 0;
    }
    ;

    /**
     * Gets a event queue for a specific form. If it does not exist create it lazy.
     * Attaches to the destroy event of the form for later cleanup.
     *
     * @param {UCF_Form} oForm the form used
     * @return {UCF_EventQueue} oFormQueue
     */
    UCF_EventHandler["prototype"]["oGetFormQueue"] = function (oForm) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["oGetFormQueue"]++;
        }
        ;
        /** @type {UCF_EventQueue} */
        var oFormQueue;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oForm instanceof UCF_Form, "oForm instanceof UCF_Form", "EventHandler.js(388): oGetFormQueue");
        }
        ;

        oFormQueue = this["mFormQueues"][oForm["sId"]];

        if (!oFormQueue) {
            oFormQueue = new (UCF_ClassLoader["oGetClass"]("UCF_EventQueue"))(this["oLS"]);
            this["mFormQueues"][oForm["sId"]] = oFormQueue;
            oForm["attachEvent"](oForm["E_EVENTS"]["Destroy"], this, 'onFormDestroy');
        }

        return oFormQueue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["oGetFormQueue"] = 0;
    }
    ;

    /**
     * Event handler hooking the form destroy
     * @param {UCF_Event} oEvent
     */
    UCF_EventHandler["prototype"]["onFormDestroy"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["onFormDestroy"]++;
        }
        ;
        /** @type {string} */
        var sFormId;
        /** @type {UCF_EventQueue} */
        var oQueue;
        /** @type {UCF_Form} */
        var oForm;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "EventHandler.js(413): onFormDestroy");
        }
        ;

        // destroy() was already called !
        // TODO: The order of controls during LS destroy is random. I think it is not
        // appropriate to fire internal events during the destroy phase (UCF_Form!!)
        // because they may be dispatched to already destroyed controls (?)!

        if (this["mFormQueues"] != null) {
            sFormId = oEvent["oGetParam"]('Id');

            if (sFormId && this["oLS"]["oGetControlById"](sFormId)) {
                oForm = this["oLS"]["oGetControlById"](sFormId);
                if (oForm) {
                    oForm["detachEvent"](oForm["E_EVENTS"]["Destroy"], this);
                }
            }

            oQueue = this["mFormQueues"][sFormId];

            if (oQueue) {
                oQueue["reset"](); //why not calling destroy?!?
                delete this["mFormQueues"][sFormId];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["onFormDestroy"] = 0;
    }
    ;

    /**
     * Sets the pending request handler of the framework
     *
     * @param {Object} oPendingRequestHandlerObject the object
     * @param {string} sPendingRequestHandlerFunction the name of the handler
     * function
     */
    UCF_EventHandler["prototype"]["setPendingRequestHandler"] = function (oPendingRequestHandlerObject, sPendingRequestHandlerFunction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["setPendingRequestHandler"]++;
        }
        ;
        this["oPendingRequestHandlerObject"] = oPendingRequestHandlerObject;
        this["sPendingRequestHandlerFunction"] = sPendingRequestHandlerFunction;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["setPendingRequestHandler"] = 0;
    }
    ;

    /**
     * Send a form request by setting hidden fields and submitting the form
     * It puts the collected & formatted queue data to the hidden field(s) of the
     * form
     *
     * @param {UCF_Form} oForm
     * @param {UCF_EventQueue} oQueue
     * @param {string} sFocusIdForRequest
     */
    UCF_EventHandler["prototype"]["sendFormRequest"] = function (oForm, oQueue, sFocusIdForRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sendFormRequest"]++;
        }
        ;
        /** @type {UCF_PendingRequest} */
        var oPendingRequest;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oForm instanceof UCF_Form, "oForm instanceof UCF_Form", "EventHandler.js(464): sendFormRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oQueue instanceof UCF_EventQueue, "oQueue instanceof UCF_EventQueue", "EventHandler.js(465): sendFormRequest");
        }
        ;

        oPendingRequest = new (UCF_ClassLoader["oGetClass"]("UCF_PendingRequest"))(oQueue);
        oPendingRequest["setForm"](oForm);
        if (sFocusIdForRequest) {
            oPendingRequest["setFocusIdForRequest"](sFocusIdForRequest);
        }

        this["processPendingRequest"](oPendingRequest);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sendFormRequest"] = 0;
    }
    ;

    /**
     * Send XML HTTP Request to the given URL. It puts the collected & formatted
     * queue data to the post body
     *
     * @param {string} sActionUrl
     * @param {UCF_Form} oForm
     * @param {UCF_EventQueue} oQueue
     * @param {boolean} bSyncExecution
     * @param {string} sFocusIdForRequest
     */
    UCF_EventHandler["prototype"]["sendXmlHttpRequest"] = function (sActionUrl, oForm, oQueue, bSyncExecution, sFocusIdForRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sendXmlHttpRequest"]++;
        }
        ;
        /** @type {UCF_PendingRequest} */
        var oPendingRequest;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sActionUrl === 'string', "typeof sActionUrl === 'string'", "EventHandler.js(490): sendXmlHttpRequest");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oQueue instanceof UCF_EventQueue, "oQueue instanceof UCF_EventQueue", "EventHandler.js(491): sendXmlHttpRequest");
        }
        ;

        oPendingRequest = new (UCF_ClassLoader["oGetClass"]("UCF_PendingRequest"))(oQueue);
        if (oForm) {
            oPendingRequest["setForm"](oForm);
        }
        oPendingRequest["setActionUrl"](sActionUrl);
        oPendingRequest["setSyncExecution"](bSyncExecution);
        if (sFocusIdForRequest) {
            oPendingRequest["setFocusIdForRequest"](sFocusIdForRequest);
        }

        this["processPendingRequest"](oPendingRequest);
        this["bPartialMode"] = false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sendXmlHttpRequest"] = 0;
    }
    ;

    /**
     * Processes the pending request. If framework is has registered a callback
     * handler it is called and send event is subscribed to, otherwise it will be
     * sent directly
     *
     * @param {UCF_PendingRequest} oPendingRequest
     */
    UCF_EventHandler["prototype"]["processPendingRequest"] = function (oPendingRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["processPendingRequest"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oPendingRequest instanceof UCF_PendingRequest, "oPendingRequest instanceof UCF_PendingRequest", "EventHandler.js(515): processPendingRequest");
        }
        ;

        this["oLS"]["processPendingRequest"](oPendingRequest);

        if (oPendingRequest["bIsSuspended"]()) {
            // invoke callback
            oPendingRequest["attachEvent"](
                oPendingRequest["E_EVENTS"]["Send"],
                this,
                'onPendingRequestSend'
            );
        } else {
            // send directly
            this["sendPendingRequest"](oPendingRequest);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["processPendingRequest"] = 0;
    }
    ;

    /**
     * Event handler for the pending request send event
     *
     * @param {UCF_Event} oEvent
     */
    UCF_EventHandler["prototype"]["onPendingRequestSend"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["onPendingRequestSend"]++;
        }
        ;
        /** @type {UCF_PendingRequest} */
        var oPendingRequest;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "EventHandler.js(541): onPendingRequestSend");
        }
        ;

        oPendingRequest = oEvent["oGetParam"]('oPendingRequest');
        oPendingRequest["detachEvent"](oPendingRequest["E_EVENTS"]["Send"], this);

        this["sendPendingRequest"](oPendingRequest);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["onPendingRequestSend"] = 0;
    }
    ;

    /**
     * Send a pending request to the server. It puts the collected & formatted
     * queue data to the hidden field(s) of the form/ the post body
     * @param {UCF_PendingRequest} oPendingRequest
     */
    UCF_EventHandler["prototype"]["sendPendingRequest"] = function (oPendingRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sendPendingRequest"]++;
        }
        ;
        /** @type {UCF_EventQueue} */
        var oQueue;
        /** @type {number} */
        var iType;
        /** @type {UCF_Form} */
        var oForm;
        /** @type {string} */
        var sHash;
        /** @type {string} */
        var sFocusedId;
        /** @type {UCF_Page} */
        var oPage;
        /** @type {Object} */
        var mQueueTransportMap;
        /** @type {string} hook to record queue state for debugging purposes */
        var sTstamp;
        /** @type {string} */
        var sActionUrl;
        /** @type {Object} */
        var mRequestParameters;
        /** @type {string} */
        var key;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oPendingRequest instanceof UCF_PendingRequest, "oPendingRequest instanceof UCF_PendingRequest", "EventHandler.js(578): sendPendingRequest");
        }
        ;

        this["oLS"]["fireBeforeRequest"]();

        oQueue = oPendingRequest["oGetQueue"]();
        iType = oPendingRequest["iGetType"]();
        oForm = oPendingRequest["oGetForm"]();
        sHash = (document["location"]["hash"]) ? document["location"]["hash"] : '';

        if (oForm) {
            this["oWEQueue"]["setProcessingLock"](false);

            sFocusedId = oPendingRequest["sGetFocusIdForRequest"]();
            if (sFocusedId === '') {
                sFocusedId = this["oLS"]["sGetFocusedElementId"]();
            }

            if (!oForm["bPageForm"] || oForm["bHasEventQueue"]) {
                // only those forms that were not implicitly created and has a queue
                oForm["fireRequest"](oForm["sId"], oQueue["bAsync"], sFocusedId, sHash, this["oLS"]["bHasDomChanged"](), this["oLS"]["bIsDirty"]());
            } else {
                oPage = this["oLS"]["oGetPageInternal"]();
                if (oPage) {
                    oPage["fireRequest"](oPage["sId"], oQueue["bAsync"], sFocusedId, sHash, this["oLS"]["bHasDomChanged"](), this["oLS"]["bIsDirty"]());
                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Semantic Event fired outside of the form, without an existing page: ' + sFocusedId, "EventHandler.js(603): sendPendingRequest");
                    }
                    ;
                }
            }
            this["oWEQueue"]["setProcessingLock"](true);
        }

        mQueueTransportMap = oQueue["mGetTransportMap"]();

        sTstamp = '@' + (new Date())["getTime"]();
        oQueue["setDebugSupplements"](true, sTstamp);
        this["fireEvent"](this["E_EVENTS"]["EventQueueDataComplete"]);
        oQueue["setDebugSupplements"](false, '');

        oQueue["reset"]();
        this["oLS"]["setDirty"](false);
        this["oLS"]["setPendingChange"](false);

        this["oLS"]["setDomChanged"](false);
        if (iType === UCF_PendingRequest["FORM"]) {
            oForm["putHiddenFieldsByMap"](mQueueTransportMap);

            this["oWEQueue"]["setProcessingLock"](false);
            oForm["submit"]();

        } else if (iType === UCF_PendingRequest["XMLHTTP"] || iType === UCF_PendingRequest["XMLHTTP_SYNC"]) {
            sActionUrl = oPendingRequest["sGetActionUrl"]();
            mRequestParameters = null;

            if (oForm == null) {
                mRequestParameters = mQueueTransportMap;
            } else {
                // reorder request parameters into a new map. queue data
                // to be copied at the end, to override HTTPWatch Bug (not parsing long first params)
                mRequestParameters = {};
                this["copyHiddenFieldsToMap"](oForm, mRequestParameters);

                for (key in mQueueTransportMap) {
                    mRequestParameters[key] = mQueueTransportMap[key];
                }
            }

            if (iType === UCF_PendingRequest["XMLHTTP"]) {
                UCF_RequestUtil["sendAsyncRequest"](sActionUrl, 'POST', mRequestParameters, this, 'onXmlHttpResponse');
            } else {
                this["onXmlHttpResponse"](UCF_RequestUtil["sendSyncRequest"](sActionUrl, 'POST', mRequestParameters));
            }
        }

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Sent request to the server', "EventHandler.js(651): sendPendingRequest");
        }
        ;

        this["fireEvent"](this["E_EVENTS"]["AfterRequestSubmit"]);
        this["oLS"]["fireAfterRequest"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sendPendingRequest"] = 0;
    }
    ;

    /**
     * Copy all hidden fields of given Form with their values to the map
     * takes only those with defined name
     * @param {UCF_Form} oForm
     * @param {Object} mMap
     */
    UCF_EventHandler["prototype"]["copyHiddenFieldsToMap"] = function (oForm, mMap) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["copyHiddenFieldsToMap"]++;
        }
        ;
        /** @type {HTMLFormElement} */
        var thisForm = oForm["oDomRef"];
        /** @type {number} */
        var i;
        /** @type {HTMLElement} */
        var srcElem;

        // iterate over all input fields of the form
        for (i = 0; i < thisForm["elements"]["length"]; i++) {
            srcElem = thisForm["elements"][i];
            if (srcElem["type"] === 'hidden' && srcElem["name"]) {
                if (mMap[srcElem["name"]]) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Transport value' + srcElem["name"] + ' uses ' + srcElem["value"] + ' instead of ' + mMap[srcElem["name"]], "EventHandler.js(676): copyHiddenFieldsToMap");
                    }
                    ;
                }
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Add ' + srcElem["name"] + ' with value ' + srcElem["value"] + ' to XHR request.', "EventHandler.js(678): copyHiddenFieldsToMap");
                }
                ;
                mMap[srcElem["name"]] = srcElem["value"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["copyHiddenFieldsToMap"] = 0;
    }
    ;

    /**
     * Event handler for the XmlHttpRequest call
     *
     * @param {UCF_RequestUtil_Response} oResponse
     */
    UCF_EventHandler["prototype"]["onXmlHttpResponse"] = function (oResponse) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["onXmlHttpResponse"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Received response from server', "EventHandler.js(690): onXmlHttpResponse");
        }
        ;

        if (!this["oLS"]["bDestroyed"]()) {
            // Running request may be canceled by 'reload' in the browser. In this case
            // WDA will destroy LS instance in its onunload-event handler

            this["oLS"]["fireAfterResponse"]();

            if (oResponse["bSuccess"] && !oResponse["oParseError"]) {
                if (!oResponse["oJson"]) {
                    this["oLS"]["oPageUpdater"]["processUpdateDocument"](oResponse["oDocument"]);
                }

                // a redirect script call might have destroyed LS
                // Added comment D030999: It seems that it can happen that in the
                // script-call phase the destructor of the LS object is called e.g. the
                // exit call of WDA. Therefore a further processing fails. This has to be
                // handled in PageUpdater.processAfterDomUpdate and
                // EventHandler.onXmlHttpResponse
                // TODO: clarify why this is done/necessary by WDA
                if (!this["oLS"]["bDestroyed"]()) {
                    this["oWEQueue"]["setProcessingLock"](false);

                    //client unlock only when there is no waiting sync in the queue
                    if (!this["refireWaitingEvents"]()) {
                        this["oLS"]["unlock"]();
                    }
                }
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Delta response could not be loaded', "EventHandler.js(719): onXmlHttpResponse");
                }
                ;
                if (oResponse["oParseError"]) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Error while parsing XML document: \nReason: ' + oResponse["oParseError"]["reason"] + '\nLocation:' + oResponse["oParseError"]["url"] + '\nSource: ' + oResponse["oParseError"]["srcText"] + '\nLine: ' + oResponse["oParseError"]["line"] + '\nColumn: ' + oResponse["oParseError"]["linepos"], "EventHandler.js(721): onXmlHttpResponse");
                    }
                    ;
                }

                if (parseInt(oResponse["sStatusCode"]) === 403) {
                    //in case of 403 show always the popup regardless of oResponse.sText (compatibility to older LS versions)
                    UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["UNAUTHORIZED"]);
                } else {
                    if (oResponse["sText"]) {
                        //oResponseText will be written into the HTML page by oLS.destroy
                        this["oLS"]["destroy"](oResponse["sText"], oResponse["sStatusCode"]); //UCF_ErrorMessage.show call oLS.destroy
                    } else {
                        //UCF_ErrorMessage.show calls oLS.destroy
                        switch (parseInt(oResponse["sStatusCode"])) {
                            case 0:
                                UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["NETWORK"]);
                                break;
                            default:
                                UCF_ErrorMessage["show"](UCF_ErrorMessage["E_TYPE"]["FATAL"]);
                                break;
                        }
                    }
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["onXmlHttpResponse"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_EventHandler_Source} iSource
     * @return {string}
     */
    UCF_EventHandler["prototype"]["sSourceToString"] = function (iSource) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sSourceToString"]++;
        }
        ;
        switch (iSource) {
            case this["E_SOURCE"]["DIRECT"]:
                return '(0):DIRECT';
            case this["E_SOURCE"]["WQUEUE"]:
                return '(1):WQUEUE';
            case this["E_SOURCE"]["TIMER"]:
                return '(2):TIMER';
            default:
                return '(' + iSource + '):UNKNOWN';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sSourceToString"] = 0;
    }
    ;

    /**
     * Event handler hooking all semantic events. It converts received semantic
     * event to the instance of EventQueueItem and then controls the actions in
     * dependency on UCF parameters
     *
     * @param {UCF_Event} oEvent
     */
    UCF_EventHandler["prototype"]["onSemanticEvent"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["onSemanticEvent"]++;
        }
        ;
        this["processSemanticEvent"](
            oEvent["oGetParam"]('oSemanticEvent'),
            this["E_SOURCE"]["DIRECT"]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["onSemanticEvent"] = 0;
    }
    ;

    /**
     * Process the semantic event according to its event info
     *
     * This central method handles 3 different cases, which are detected
     * by iSource parameter (directly, from waiting queue and from timer) !
     *
     * @private
     * @param {UCF_SemanticEvent} oSemanticEvent
     * @param {UCF_EventHandler_Source} iSource
     */
    UCF_EventHandler["prototype"]["processSemanticEvent"] = function (oSemanticEvent, iSource) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["processSemanticEvent"]++;
        }
        ;
        /** @type {UCF_EventHandler_ProcessSemanticEventScope} */
        var v/*= variables*/ = {
            "oSemanticEvent": oSemanticEvent,
            "iSource": iSource
        };
        /** @type {UCF_EventHandler} */
        var self = this;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof v["oSemanticEvent"] === 'object', "typeof v.oSemanticEvent === 'object'", "EventHandler.js(798): processSemanticEvent");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(v["oSemanticEvent"] != null, "v.oSemanticEvent != null", "EventHandler.js(799): processSemanticEvent");
        }
        ;

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, this["sSerializeForTrace"](v["oSemanticEvent"]), "EventHandler.js(801): processSemanticEvent");
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'Process Semantic Event called from Source=' + this["sSourceToString"](v["iSource"]), "EventHandler.js(802): processSemanticEvent");
        }
        ;

        if (oSemanticEvent["bIsCanceled"]()) {
            // do not process already canceled events
        } else if (this["oLS"]["bIsMainLS"]()) {
            // define variables for all used UCF parameters
            // assign DIRECT values to them
            v["eClientAction"] = this["E_ACTION"][window["UCF_System"]["sDefaultClientAction"] || 'ENQUEUE'];
            v["eEnqueueCardinality"] = this["E_CARDINALITY"]["MULTIPLE"];
            v["eResponseData"] = this["E_RESPONSE_DATA"][window["UCF_System"]["sDefaultResponseData"] || 'INHERIT'];
            v["eTransportMethod"] = this["E_TRANSPORT_METHOD"]["FULL"];
            v["sActionUrl"] = null;
            v["sPrepareScript"] = '';
            v["eDelay"] = this["E_DELAY"]["NONE"];
            v["bDelay"] = false;
            v["bSyncExecution"] = false;
            v["sClientListener"] = '';

            v["ucfParam"] = v["oSemanticEvent"]["mGetUcfParameters"]();
            if (v["ucfParam"] == null) {
                this["finishSemanticEvent"](v);
            } else {
                v["sPrepareScript"] = v["ucfParam"][this["E_KEY"]["PREPARESCRIPT"]] || v["sPrepareScript"];

                // Perform prepare script and possibly stop event processing of the script
                // Prepare script may change other event parameters !
                if (v["sPrepareScript"] === '') {
                    this["copyUcfParameters"](v);
                    this["finishSemanticEvent"](v);
                } else {
                    v["bOk"] = UCF_JsUtil["eval"](v["sPrepareScript"], UCF_JsUtil["extend"]({}, v, {
                        "oSemanticEvent": v["oSemanticEvent"]["oGetInterface"](),
                        "oLS": this["oLS"]["oGetInterface"]()
                    }));

                    if (v["bOk"] !== false) {
                        self["copyUcfParameters"](v);
                        self["finishSemanticEvent"](v);
                    }
                }
            }
        } else {
            // not the main window
            v["oSemanticEvent"]["setSourceLS"](this["oLS"]);

            this["oLS"]["oGetMainLS"]()["oEventHandler"]["processSemanticEvent"](v["oSemanticEvent"], v["iSource"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["processSemanticEvent"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_EventHandler_ProcessSemanticEventScope} v
     */
    UCF_EventHandler["prototype"]["copyUcfParameters"] = function (v) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["copyUcfParameters"]++;
        }
        ;
        v["sClientListener"] = v["ucfParam"][this["E_KEY"]["CLIENTLISTENER"]] || v["sClientListener"];
        v["eClientAction"] = v["ucfParam"][this["E_KEY"]["ACTION"]] || v["eClientAction"];
        v["eEnqueueCardinality"] = v["ucfParam"][this["E_KEY"]["CARDINALITY"]] || v["eEnqueueCardinality"];
        v["eResponseData"] = v["ucfParam"][this["E_KEY"]["RESPONSE"]] || v["eResponseData"];
        v["sActionUrl"] = v["ucfParam"][this["E_KEY"]["ACTIONURL"]] || v["sActionUrl"];
        v["eTransportMethod"] = v["ucfParam"][this["E_KEY"]["TRANSPORT"]] || v["eTransportMethod"];
        v["eDelay"] = v["ucfParam"][this["E_KEY"]["DELAY"]] || v["eDelay"];
        v["bDelay"] = (v["eDelay"] === this["E_DELAY"]["FULL"]);
        v["bSyncExecution"] = v["ucfParam"][this["E_KEY"]["SYNCEXECUTION"]];

        //generic add ControlTree to the semantic event actionurl for controls that have a client control tree.
        v["sId"] = '';
        if ((v["sId"] = v["oSemanticEvent"]["mParameters"]["Id"]) && typeof v["sActionUrl"] === 'string') {
            //check whether there is a client control
            if (this["oLS"]["oControlFactory"]["oGetClientControlById"](v["sId"])) { // eslint-disable-line max-depth
                v["sParam"] = (v["sActionUrl"]["indexOf"]('?') > 0 ? '&' : '?') + 'ControlTree=true';
                v["sActionUrl"] = v["sActionUrl"] + v["sParam"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["copyUcfParameters"] = 0;
    }
    ;

    UCF_EventHandler["prototype"]["finishSemanticEvent"] = function (v) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["finishSemanticEvent"]++;
        }
        ;  // eslint-disable-line complexity
        // Check compatible parameters for TransportMethod 'partial'
        if (v["eTransportMethod"] === this["E_TRANSPORT_METHOD"]["PARTIAL"]) {
            if (
                !this["bActionSUBMITABLE"](v["eClientAction"]) ||
                v["eEnqueueCardinality"] !== this["E_CARDINALITY"]["MULTIPLE"] ||
                v["eResponseData"] !== this["E_RESPONSE_DATA"]["DELTA"]
            ) {

                // Change back to old default for compatibility
                v["eTransportMethod"] = this["E_TRANSPORT_METHOD"]["FULL"];
                v["oSemanticEvent"]["setTransportMethod"](this["E_TRANSPORT_METHOD"]["FULL"]);

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Parameter values incompatible for TransportMethod="partial". Using "full". Event:' + v["oSemanticEvent"]["sGetControl"]() + '::' + v["oSemanticEvent"]["sGetName"]() + '::' + v["oSemanticEvent"]["mGetParameters"]()["Id"] + ' Parameters: ClientAction=' + v["eClientAction"] + ' EnqueueCardinality= ' + v["eEnqueueCardinality"] + ' ResponseData= ' + v["eResponseData"] + ' TransportMethod=' + v["eTransportMethod"] + ' ActionUrl=' + v["sActionUrl"], "EventHandler.js(890): finishSemanticEvent");
                }
                ;
            }
        }

        // Perform client listener and possibly stop event processing of the script
        if (v["sClientListener"] !== '') {
            v["func"] = null;
            if (UCF_JsUtil["bIsFunction"](v["sClientListener"])) {
                v["func"] = v["sClientListener"];
            }
            v["bOk"] = true;
            if (v["func"]) {
                v["sId"] = v["oSemanticEvent"]["mGetParameters"]()["Id"];
                v["bOk"] = v["func"](this["oLS"]["oGetControlById"](v["sId"]), v["oSemanticEvent"]["oGetInterface"]());
            }
            if (v["bOk"] === false) {
                return;
            }
        }

        // re-check event if event has been canceled in a meantime
        if (v["oSemanticEvent"]["bIsCanceled"]()) {
            return;
        }

        // Detect proper queue and form responsible for this event --------
        v["oEventQueue"] = this["oQueue"];

        // check whether a form is already contained in the event
        v["oFormControl"] = v["oSemanticEvent"]["oGetForm"]();

        if (v["oFormControl"] instanceof UCF_Interface) {
            //only for custom SemanticEvents - determine the internal Form object
            v["sInternalFormId"] = v["oFormControl"]["getId"]();
            v["oDomRef"] = UCF_DomUtil["$"](v["sInternalFormId"]);

            v["oFormControl"] = this["oLS"]["oGetControlByDomRef"](v["oDomRef"]);
            //TODO: this.oLS.oGetControlById(sInternalFormId); //doesn't work for strange reasons

            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(v["oFormControl"], "v.oFormControl", "EventHandler.js(929): finishSemanticEvent");
            }
            ; //!= null
            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(typeof v["oFormControl"] === 'object', "typeof v.oFormControl === 'object'", "EventHandler.js(930): finishSemanticEvent");
            }
            ;
        }

        // if there is a form defined, use the form queue
        if (v["oFormControl"]) {
            v["oEventQueue"] = this["oGetFormQueue"](v["oFormControl"]);
        } else {
            // find the form defined in the page and use it for sending the request
            v["oPage"] = this["oLS"]["oGetPageInternal"]();
            if (v["oPage"]) {
                v["sFormId"] = v["oPage"]["sFormId"];

                if (v["sFormId"]) { // eslint-disable-line max-depth
                    v["oFormControl"] = this["oLS"]["oControlFactory"]["oGetControlById"](v["sFormId"]);
                }
            }
        }

        if (this["bPartialMode"]) {
            // If this is a form/page Request event belonging to the single "partial" event
            // put it also in the partial queue (see sendPendingRequest)
            v["oEventQueue"] = this["oPartialQueue"];
        }

        //===============================================================================
        // Possible Synchronisation patterns shotened
        //===============================================================================
        //  Process                     [DIRx], [WQUx] [TIMx]     -> iSource
        //                              \\\\                      -> running timer
        //  Lightspeed   lock:          L+ L-                     -> oLS.lock()
        //  WaitingQueue lock:          W+ W-                     -> this.oWEQueue.setProcessingLock(...)
        //  Timer start/stop            T+ T-x                    ->
        //  EventQueue   enquee/Dequue  enqx deqx                 -> oEventQueue.addItem / oQueue.mGetTransportMap()
        //  WaitingQueue enqueu/dequeu  wnqx wdqx                 -> WEQueue.oEnqueue / .oDequeue/refire
        //  Request/response            reqx resx  [eventIdx]     ->

        //===============================================================================
        // (Event1)   (Event2)       EntryPoint  Timing procedure and locking pattern
        //===============================================================================
        // Sync      |             |   [DIR1] -> L+W+ enq1 req[1]...res[1] W-L-
        //--------------------------
        // Async     |             |   [DIR1] -> W+ enq1 req[1]...res[1] W-L-
        //--------------------------
        // SyncDelay |             |   [DIR1] -> L+W+ enq1 T1+
        //           |             |   [TIM1]               \\\T1- req[1]...res[1] W-L-
        //--------------------------
        // AsyncDelay|             |   [DIR1] -> W+ enq1 T1+
        //           |             |   [TIM1]             \\\T1- req[1]...res[1] W-L-
        //===============================================================================
        // Sync        <ANY>       |  *Note*  No overlap if <ANY> is triggered by user due to exclusive lock (L+)
        //                         |          but ActiveComp- or Portal-Events may get to WQUE and refired later
        //===============================================================================
        // Async       Sync        |   [DIR1] -> W+ enq1 req[1].......res[1]
        //                         |   [DIR2] ->              L+ (wnq2-----wdq2) refire2
        //                         |   [WQU2]                                     enq2 req[2]...res[2] W-L-
        //--------------------------
        // Async       Async       |   [DIR1] -> W+ enq1 req[1]...res[1]
        //                         |   [DIR2] ->        (wnq2-----------wdq2) refire2
        //                         |   [WQU2]                                   enq2 req[2]...res[2] W-L-
        //--------------------------
        // Async       Sync Delay  |   [DIR1] -> W+ enq1 req[1]...res[1]
        //                         |   [DIR2] ->        (wnq2------------wdq2) refire2
        //                         |   [WQU2]                                      L+ enq2 T2+
        //                         |   [TIM2] ->                                           \\\T2- req[2]...res[2] W-L-
        //--------------------------
        // Async       Async Delay |  *Note* identical to Async/SyncDelay without
        //                         |          settling Lightspeed Lock (L+)
        //===============================================================================
        // SyncDelay   Sync        |   [DIR1] -> enq1 T1+
        //                         |                  \\\\\\\\
        //                         |   [DIR2] ->   L+W+ enq2 T1- req[12].........res[12] W-L-
        //                         |
        //                         |    *Note* only this reject-scenario, if the timer expires earlier
        //                         |           then this converts to standard Sync/Sync case
        //--------------------------
        // SyncDelay   Async       |  [DIR1] -> enq1 T1+
        //                         |                   \\\\\\
        //                         |  [DIR2] ->  L+W+ enq2 T1-  req[12]...res[12] W-L-
        //--------------------------
        // SyncDelay   SyncDelay   |  [DIR1] -> enq1 T1+
        //                         |                  \\\\\\
        //                         |  [DIR2] ->  L+W+ enq2 T1-   T2+
        //                         |  [TIM2]                     \\\\ T2- req[12]...res[12] W-L-
        //--------------------------
        // SyncDelay   AsyncDelay  |  *Note* identical to SyncDelay/SyncDelay
        //                         |
        //===============================================================================
        // AsyncDelay   Sync       |  *Note* identcal to SyncDelay/Sync
        //--------------------------
        // AsyncDelay   Async      |  *Note* identcal to SyncDelay/Async without setting L+
        // -------------------------
        // AsyncDelay   SyncDelay  |  [DIR1] -> enq1 T1+
        //                         |                  \\\\\\
        //                         |  [DIR2] ->     enq2  T1-  T2+
        //                         |  [TIM2]                   \\\\T2- L+W+ req[12]...res[12] W-L-
        // -------------------------
        // ASyncDelay   ASyncDelay |  *Note* identcal to SyncDelay/Async without setting L+
        // -------------------------------------------------------------------------------

        // --- Resolve Locking & processing locks (part 1 - LS lock)
        v["bDoLock"] = false;

        v["sFocusIdForRequest"] = '';
        if (v["oSemanticEvent"]["sGetName"]() !== 'Scroll') {
            v["sFocusIdForRequest"] = this["oLS"]["sGetFocusedElementId"]();
        }

        if (this["bActionSUBMITABLE"](v["eClientAction"])) {
            v["bDoLock"] = v["iSource"] === this["E_SOURCE"]["TIMER"]
                // case 1: event comes delayed from timer  -> has to lock
                ? true
                : v["bDelay"]
                    // case 2: event is delayed                -> postpone locking
                    ? false
                    // case 3: event immediate without delay   -> has to lock
                    : true;

            if (v["bDoLock"] && (
                v["eClientAction"] === this["E_ACTION"]["SUBMIT"] ||
                this["oTimer"]["sGetPendingAction"]() === this["E_ACTION"]["SUBMIT"]
            )) {
                this["oLS"]["lock"]();
            }
        }

        // --- If queue is locked put event into the queue  ---
        if (this["oWEQueue"]["bIsProcessingLock"]()) {
            this["oWEQueue"]["oEnqueue"](v["oSemanticEvent"]);

            return;
        }

        // --- Resolve Locking & processing locks (part 2, WaitingQueue only ------
        if (v["bDoLock"]) {
            this["oWEQueue"]["setProcessingLock"](true);
        }

        // --- Add Event in queue if required -----------------

        if (v["iSource"] === this["E_SOURCE"]["TIMER"]) {
            // ignore, events fired by timer are already in the queue
        } else if (
            this["bActionENQUEUABLE"](v["eClientAction"]) &&
            this["bCardinalityENQUEUABLE"](v["eEnqueueCardinality"])
        ) {
            v["oItem"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventQueueItem"))(v["oSemanticEvent"]);

            switch (v["eEnqueueCardinality"]) {
                case this["E_CARDINALITY"]["SINGLE"]:
                    v["oEventQueue"]["purgeByItem"](v["oItem"]);
                    v["oEventQueue"]["addItem"](v["oItem"]);
                    break;
                case this["E_CARDINALITY"]["MULTIPLE"]:
                    // eslint-disable-next-line max-depth
                    if (v["eTransportMethod"] === this["E_TRANSPORT_METHOD"]["PARTIAL"]) {
                        this["bPartialMode"] = true;
                        v["oEventQueue"] = this["oPartialQueue"];
                        v["oEventQueue"]["addItem"](v["oItem"]);
                    } else {
                        v["oEventQueue"]["addItem"](v["oItem"]);
                    }
                    break;
            }
        }

        // Schedule & cancel processing of delayed events  ---------------

        if (v["iSource"] === this["E_SOURCE"]["TIMER"]) {
            this["oTimer"]["rejectCall"]();
        } else if (this["bActionSUBMITABLE"](v["eClientAction"])) {
            if (this["oTimer"]["bPendingDelay"]()) { // previous delayed to cancel
                this["oTimer"]["rejectCall"]();
            }

            if (v["bDelay"]) {
                v["oClass"] = UCF_ClassLoader["oGetClass"]('UCF_' + v["oSemanticEvent"]["sGetControl"]());

                if (v["oClass"]["getEventDelay"]) {
                    this["oTimer"]["setMaxDelay"](v["oClass"]["getEventDelay"]());
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Delay set to :' + v["oClass"]["getEventDelay"](), "EventHandler.js(1109): finishSemanticEvent");
                    }
                    ;
                }

                this["oTimer"]["scheduleCall"](
                    this,
                    'processSemanticEvent',
                    v["oSemanticEvent"], this["E_SOURCE"]["TIMER"],
                    v["eClientAction"]
                );

                return;
            }
        } else if (v["bDelay"]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Delay flag ignored for action ' + v["eClientAction"], "EventHandler.js(1122): finishSemanticEvent");
            }
            ;
        }

        // Decide Full/Delta------------------------------------------------

        if (this["bActionSUBMITABLE"](v["eClientAction"])) {
            // store flag on queue, for later resolving of focus events
            v["oEventQueue"]["bAsync"] = v["eClientAction"] === this["E_ACTION"]["SUBMITASYNC"];

            // resolve indirection of RedirectData on form
            if (v["eResponseData"] === this["E_RESPONSE_DATA"]["INHERIT"]) {
                if (v["oFormControl"]) {
                    // form based default (explicit delta or full);
                    v["eResponseData"] = (v["oFormControl"]["sResponseData"] === this["E_FORM_RESPONSE_DATA"]["DELTA"])
                        ? this["E_RESPONSE_DATA"]["DELTA"]
                        : this["E_RESPONSE_DATA"]["FULL"];
                } else {
                    // generic default
                    v["eResponseData"] = this["E_RESPONSE_DATA"]["FULL"];
                }
            }

            switch (v["eResponseData"]) {
                // ----------------------------
                case this["E_RESPONSE_DATA"]["FULL"]:
                    // if there is no form on the page create one for submitting
                    if (!v["oFormControl"]) {
                        v["oFormControl"] = this["oCreateForm"]();
                    }
                    // if action url is given in the event info, use it
                    if (v["sActionUrl"]) {
                        v["oFormControl"]["setAction"](v["sActionUrl"]);
                    }
                    this["sendFormRequest"](v["oFormControl"], v["oEventQueue"], v["sFocusIdForRequest"]);
                    break;
                // ----------------------------
                case this["E_RESPONSE_DATA"]["DELTA"]:
                    // if no action url try first to recycle one from the form
                    if (!v["sActionUrl"] && v["oFormControl"]) {
                        v["sActionUrl"] = v["oFormControl"]["sGetAction"]();
                    }
                    // as the very last option take the current location
                    if (!v["sActionUrl"]) {
                        v["sActionUrl"] = document["location"]["href"];
                    }
                    this["sendXmlHttpRequest"](v["sActionUrl"], v["oFormControl"], v["oEventQueue"], v["bSyncExecution"], v["sFocusIdForRequest"]);
                    break;
                //	----------------------------
                default:
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Unsupported value of ResponseData: ' + v["eResponseData"], "EventHandler.js(1171): finishSemanticEvent");
                    }
                    ;
                    break;
            }
        } // decide Full/Delta
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["finishSemanticEvent"] = 0;
    }
    ;

    /**
     * Fire semantic events that are waiting in the queue one after another
     * until a roundtrip is triggered
     * @return {boolean} Contains Sync Submit
     */
    UCF_EventHandler["prototype"]["refireWaitingEvents"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["refireWaitingEvents"]++;
        }
        ;
        /** @type {UCF_SemanticEvent} */
        var oSemanticEvent;
        /** @type {boolean} */
        var bCcontainsSyncSubmit = false;
        /** @type {string} */
        var sId;
        /** @type {UCF_LS} */
        var oSourceLS;

        if (this["oWEQueue"]["iGetLength"]() < 1) {
            return false;
        } else if (this["oLS"]["bIsDestroyed"]) {
            // This can happen if a framework destroys LS and exits/redirects the
            // window in a script-call during an update
            return false;
        } else if (this["oWEQueue"]["bIsRefireLock"]()) {
            return this["oWEQueue"]["bContainsSyncSubmit"]();
        } else {
            this["oWEQueue"]["setRefireLock"](true);

            while (!this["oWEQueue"]["bIsProcessingLock"]() && this["oWEQueue"]["iGetLength"]() > 0) {
                oSemanticEvent = this["oWEQueue"]["oDequeue"]();
                sId = oSemanticEvent["mGetParameters"]()["Id"];
                oSourceLS = oSemanticEvent["oGetSourceLS"]();

                if (!oSourceLS || oSourceLS["bIsDestroyed"]) {
                    oSourceLS = this["oLS"];
                }

                if (sId && oSourceLS["oControlFactory"]["oGetControlById"](sId)) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Process waiting queue event for control with id: ' + sId, "EventHandler.js(1213): refireWaitingEvents");
                    }
                    ;

                    if (this["oWEQueue"]["bIsSyncSubmit"](oSemanticEvent)) {
                        bCcontainsSyncSubmit = true;
                    }

                    this["processSemanticEvent"](oSemanticEvent, this["E_SOURCE"]["WQUEUE"]);
                } else {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Ignore waiting queue event. Corresponding control with id: ' + sId + ' does not exist', "EventHandler.js(1221): refireWaitingEvents");
                    }
                    ;
                }
            }

            this["oWEQueue"]["setRefireLock"](false);

            return bCcontainsSyncSubmit;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["refireWaitingEvents"] = 0;
    }
    ;

    /**
     * Ensure the event gets queued until the lightspeed framework gets fully
     * initialized -> divert semantic events in to a waiting queue
     */
    UCF_EventHandler["prototype"]["activateStartupQueueing"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["activateStartupQueueing"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Semantic Events diverted to WaitingQueue', "EventHandler.js(1236): activateStartupQueueing");
        }
        ;

        this["oWEQueue"]["setProcessingLock"](true);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["activateStartupQueueing"] = 0;
    }
    ;

    /**
     * Re-fire events after lightspeed startup
     */
    UCF_EventHandler["prototype"]["deactivateStartupQueueing"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["deactivateStartupQueueing"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Re-fire Events from WaitingQueue ', "EventHandler.js(1245): deactivateStartupQueueing");
        }
        ;

        this["oWEQueue"]["setProcessingLock"](false);
        this["refireWaitingEvents"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Finished', "EventHandler.js(1250): deactivateStartupQueueing");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["deactivateStartupQueueing"] = 0;
    }
    ;

    /**
     * Create a form
     * TODO: This is hacked
     * @return {UCF_Form} a UCF_Form
     */
    UCF_EventHandler["prototype"]["oCreateForm"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["oCreateForm"]++;
        }
        ;
        /** @type {HTMLFormElement} */
        var oFormRef = document["createElement"]('form');
        /** @type {UCF_Form} */
        var oForm;

        oFormRef["method"] = 'POST';
        oFormRef["style"]["margin"] = '0px';
        this["oLS"]["oGetStaticAreaRef"]()["appendChild"](oFormRef);

        oForm = new (UCF_ClassLoader["oGetClass"]("UCF_Form"))(oFormRef, this["oLS"]);
        oForm["initialize"]();
        oForm["bPageForm"] = true;

        return oForm;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["oCreateForm"] = 0;
    }
    ;

    /**
     * Serializes semantic event for trace purposes
     * @private
     * @param {UCF_SemanticEvent} oSemanticEvent Event
     * @return {string} serialized event trace
     */
    UCF_EventHandler["prototype"]["sSerializeForTrace"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sSerializeForTrace"]++;
        }
        ;
        return 'SemanticEvent\nsControl: ' + oSemanticEvent["sGetControl"]() +
            '\nsName: ' + oSemanticEvent["sGetName"]() +
            '\nsParameters: ' + this["sSerializeSectionForTrace"](oSemanticEvent["mGetParameters"]()) +
            '\nsUcfParameters: ' + this["sSerializeSectionForTrace"](oSemanticEvent["mGetUcfParameters"]()) +
            '\nsCustomParameters: ' + this["sSerializeSectionForTrace"](oSemanticEvent["mGetCustomParameters"]()) +
            '\n';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sSerializeForTrace"] = 0;
    }
    ;

    /**
     * serializes section of data for trace purposes
     * @param {Object} obj
     * @return {string}
     * @private
     */
    UCF_EventHandler["prototype"]["sSerializeSectionForTrace"] = function (obj) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventHandler["_"]["sSerializeSectionForTrace"]++;
        }
        ;
        return (obj == null) ? '' : UCF_JsUtil["sJsonStringify"](obj);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventHandler["_"]["sSerializeSectionForTrace"] = 0;
    }
    ;

    /* global _assert */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_EventQueueItem */
/// <reference path="./EventQueueItem.js"/>
    /* eslint no-magic-numbers:0 */

    /**
     * Class LS EventQueue
     *
     * collects the EventQueueItems created form semantic events
     * and keeps and formats them for the transport to the backend
     * @class
     *
     * @param {UCF_LS} oLS
     *
     * @version
     */
    function UCF_EventQueue(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["UCF_EventQueue"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "EventQueue.js(23): UCF_EventQueue");
        }
        ;

        UCF_Object["apply"](this);

        /** @type {UCF_LS} */
        this["oLS"] = oLS;
        /** @type {UCF_EventQueueItem[]} */
        this["aQueue"] = [];

        /** @type {boolean} */
        this["bDebugMarker"] = false;
        /** @type {string} */
        this["sDebugLabel"] = '';
    };window["UCF_EventQueue"] = UCF_EventQueue;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_EventQueue");
        UCF_EventQueue["_"] = {UCF_EventQueue: 0};
    }
    ;
    UCF_EventQueue["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_EventQueue.prototype["sClassName"] = "UCF_EventQueue";

    UCF_EventQueue["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["destroy"]++;
        }
        ;
        this["aQueue"] = null;
        this["bDebugMarker"] = null;
        this["sDebugLabel"] = null;
        this["oLS"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["destroy"] = 0;
    }
    ;

    /**
     * Adds an item to the queue
     *
     * @param {UCF_EventQueueItem} oItem
     */
    UCF_EventQueue["prototype"]["addItem"] = function (oItem) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["addItem"]++;
        }
        ;
        this["aQueue"]["push"](oItem);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["addItem"] = 0;
    }
    ;

    /** resets the queue, removing all collected content */
    UCF_EventQueue["prototype"]["reset"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["reset"]++;
        }
        ;
        this["aQueue"] = [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["reset"] = 0;
    }
    ;

    /**
     * removes events with the same event name for the same control
     * to remove
     * @param {UCF_EventQueueItem} oItemTemplate
     */
    UCF_EventQueue["prototype"]["purgeByItem"] = function (oItemTemplate) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["purgeByItem"]++;
        }
        ;
        /** @type {string} */
        var aTempQueue = [];
        /** @type {string} */
        var sItemName;
        /** @type {number} */
        var idx;
        /** @type {UCF_EventQueueItem} */
        var oItem;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oItemTemplate instanceof UCF_EventQueueItem, "oItemTemplate instanceof UCF_EventQueueItem", "EventQueue.js(77): purgeByItem");
        }
        ;

        sItemName = oItemTemplate["sGetItemName"]();

        for (idx = 0; idx < this["aQueue"]["length"]; idx++) {
            oItem = this["aQueue"][idx];
            if (oItem && oItem["sGetItemName"]() !== sItemName) {
                aTempQueue["push"](oItem);
            }
        }

        this["aQueue"] = aTempQueue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["purgeByItem"] = 0;
    }
    ;

    /**
     * Name of the request parameter to be used for passing of the queue.
     */
    UCF_EventQueue["prototype"]["REQUEST_PARAM_NAME"] = 'SAPEVENTQUEUE';

    /**
     * Returns map of transport fields which need to be added to the form
     *
     * @return {Object<string,string>}
     */
    UCF_EventQueue["prototype"]["mGetTransportMap"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["mGetTransportMap"]++;
        }
        ;
        /** @type {string[]} */
        var mDataBuffer = [];
        /** @type {boolean} */
        var bAnyData = false;
        /** @type {string} */
        var sSepar = '';
        /** @type {UCF_EventQueueItem} */
        var oItem;
        /** @type {number} */
        var idx;
        /** @type {string} */
        var resultData;
        /** @type {Object<string,string>} */
        var resultMap;

        for (idx = 0; idx < this["aQueue"]["length"]; idx++) {
            oItem = this["aQueue"][idx];

            if (oItem != null) {
                sSepar = (bAnyData) ? oItem["E_SEPARATORS"]["EVENT"] : '';
                mDataBuffer["push"](sSepar);
                mDataBuffer["push"](oItem["sGetSerializedData"]());
                bAnyData = true;
            }
        }

        resultData = mDataBuffer["join"]('');

        resultMap = {};
        resultMap[this["REQUEST_PARAM_NAME"]] = this["oLS"]["oSystem"]["bUseSafeTransportEncoding"]
            ? this["sSafeTransportEncode"](resultData)
            : resultData;

        return resultMap;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["mGetTransportMap"] = 0;
    }
    ;

    /**
     * Plain characters to be transported with no need to encode
     * @private
     * @type {string}
     */
    UCF_EventQueue["prototype"]["ENC_PLAIN"] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEDFGHIJKLMNOPQRSTUVWXYZ-_.';

    /**
     * Prefix for hexadecimal character encoding
     * @private
     * @type {string}
     */
    UCF_EventQueue["prototype"]["ENC_HPREFIX"] = '~';

    /**
     * Hexadecimal characters
     * @private
     * @type {string}
     */
    UCF_EventQueue["prototype"]["ENC_HDIGITS"] = '0123456789ABCDEF';

    /**
     * Encodes a unicode string to format containing only unreserved characters
     * as per RFC 3986 (January 2005), which guarantees such value gets
     * untouched during parameter transfer via HTTP.
     *
     *  AZaz09-_.   -> plain copy
     *  any other   -> ~XXXX  where XXXX is hexadecimal code of the char.
     *
     * The reason why we do not use simply UTF-8 is that then the decoding
     * in java would require to modify the charset of the servlet or portlet
     * yet before parameter access otherwise we did not get right codes back
     * For typical parameter strings containing keys and values mostly from
     * low ascii is the overhead about 15% comparing to input string.
     *
     * see also:
     * http://en.wikipedia.org/wiki/Percent-encoding#Current_standard
     *
     * @private
     * @param {string} s string to be encoded
     * @return {string} the encoded string
     */
    UCF_EventQueue["prototype"]["sSafeTransportEncode"] = function (s) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["sSafeTransportEncode"]++;
        }
        ;
        /** @type {string[]} */
        var sBuff = [];
        /** @type {number} */
        var code;
        /** @type {string} */
        var c;
        /** @type {number} */
        var i;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(s != null, "s != null", "EventQueue.js(190): sSafeTransportEncode");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof s === 'string', "typeof s === 'string'", "EventQueue.js(191): sSafeTransportEncode");
        }
        ;

        for (i = 0; i < s["length"]; i++) {
            c = s["charAt"](i);

            if (this["ENC_PLAIN"]["indexOf"](c) >= 0) {
                sBuff["push"](c);
            } else {
                sBuff["push"](this["ENC_HPREFIX"]);
                code = s["charCodeAt"](i);
                if (code < 256) {
                    sBuff["push"]('00');
                } else {
                    sBuff["push"](this["ENC_HDIGITS"]["charAt"]((code & 0xF000) >>> 12));
                    sBuff["push"](this["ENC_HDIGITS"]["charAt"]((code & 0x0F00) >>> 8));
                }
                sBuff["push"](this["ENC_HDIGITS"]["charAt"]((code & 0x00F0) >>> 4));
                sBuff["push"](this["ENC_HDIGITS"]["charAt"]((code & 0x000F)));
            }
        }

        return sBuff["join"]('');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["sSafeTransportEncode"] = 0;
    }
    ;

    /**
     * set local flags used for communication to event debugger
     * @param {boolean} bMarker
     * @param {string} sLabel
     */
    UCF_EventQueue["prototype"]["setDebugSupplements"] = function (bMarker, sLabel) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueue["_"]["setDebugSupplements"]++;
        }
        ;
        /** @type {boolean} */
        this["bDebugMarker"] = bMarker;
        /** @type {string} */
        this["sDebugLabel"] = sLabel;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueue["_"]["setDebugSupplements"] = 0;
    }
    ;

    /* global _trace, DEBUG, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_Object */

/// <reference path="../../core/Object.js"/>

    /**
     * Class UCF_EventQueueItem.
     *
     * Single item of the UCF_EventQueue, keeps event data in format
     * suitable for transport.
     *
     *
     * @version
     *
     * @class
     * @param {UCF_SemanticEvent} oSemanticEvent  - semantic event used
     */
    function UCF_EventQueueItem(oSemanticEvent) {
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["UCF_EventQueueItem"]++;
        }
        ;
        UCF_Object["apply"](this);

        /** @type {string} */
        this["sControlName"] = oSemanticEvent["sGetControl"]();
        /** @type {string} */
        this["sEventName"] = oSemanticEvent["sGetName"]();
        /** @type {string} */
        this["sControlId"] = oSemanticEvent["mGetParameters"]()["Id"];
        /** @type {string} */
        this["sItemName"] = this["sControlName"] + '::' + this["sEventName"] + '::' + this["sControlId"];
        /** @type {string} */
        this["sSerializedData"] = this["sSerialize"](oSemanticEvent);

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(DEBUG, 'EventQueueItem created', "EventQueueItem.js(32): UCF_EventQueueItem");
        }
        ;
    };window["UCF_EventQueueItem"] = UCF_EventQueueItem;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_EventQueueItem");
        UCF_EventQueueItem["_"] = {UCF_EventQueueItem: 0};
    }
    ;
    ;
    UCF_EventQueueItem["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_EventQueueItem.prototype["sClassName"] = "UCF_EventQueueItem";

    /** @override */
    UCF_EventQueueItem["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["destroy"]++;
        }
        ;
        this["sSerializedData"] = null;
        this["sItemName"] = null;
        this["sControlId"] = null;
        this["sEventName"] = null;
        this["sControlName"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["destroy"] = 0;
    }
    ;

    /**
     * gets name/type of the control related to the event
     * @return {string} controlName
     */
    UCF_EventQueueItem["prototype"]["sGetControlName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sGetControlName"]++;
        }
        ;
        return this["sControlName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sGetControlName"] = 0;
    }
    ;

    /**
     * gets name of the event
     * @return {string} eventName
     */
    UCF_EventQueueItem["prototype"]["sGetEventName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sGetEventName"]++;
        }
        ;
        return this["sEventName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sGetEventName"] = 0;
    }
    ;

    /**
     * gets controlId related to the event
     * @return {string} controlId
     */
    UCF_EventQueueItem["prototype"]["sGetControlId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sGetControlId"]++;
        }
        ;
        return this["sControlId"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sGetControlId"] = 0;
    }
    ;

    /**
     * gets name of the item as the concatenation of controlName, eventName and
     * controlId
     * @return {string} the name of the item
     */
    UCF_EventQueueItem["prototype"]["sGetItemName"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sGetItemName"]++;
        }
        ;
        return this["sItemName"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sGetItemName"] = 0;
    }
    ;

    /**
     * gets serialized representation of the event
     * @return {string} the serialized event
     */
    UCF_EventQueueItem["prototype"]["sGetSerializedData"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sGetSerializedData"]++;
        }
        ;
        return this["sSerializedData"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sGetSerializedData"] = 0;
    }
    ;

    /**
     * serializes event to string representation convenient for transport
     * @private
     * @param {UCF_SemanticEvent} oSemanticEvent
     * @return {string} serialized format
     */
    UCF_EventQueueItem["prototype"]["sSerialize"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sSerialize"]++;
        }
        ;
        /** @type {string[]} */
        var aBuff = [];
        /** @type {UCF_SemanticEvent} */
        var ose = oSemanticEvent;
        /** @type {UCF_SemanticEvent_UcfParameters} */
        var ucfParam;

        aBuff["push"](ose["sGetControl"]());
        aBuff["push"]('_');
        aBuff["push"](ose["sGetName"]());

        this["sSerializeSection"](ose["mGetParameters"](), aBuff, true);

        // passing of UCF params can be disabled on demand
        ucfParam = ose["mGetUcfParameters"]();
        if (ucfParam == null || ucfParam["Serialize"] === 'none') {
            ucfParam = {};
        }

        this["sSerializeSection"](ucfParam, aBuff, false);
        this["sSerializeSection"](ose["mGetCustomParameters"](), aBuff, false);

        return aBuff["join"]('');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sSerialize"] = 0;
    }
    ;

    /**
     * serializes one data section in the event data on the string array buffer
     * @private
     * @param {Object} oParams assoc.map of key/values
     * @param {string[]} aBuff buffer where to collect the result
     * @param {boolean} bCollectionAllowed usage of the multiple values allowed
     * @return {number} count of key/value pairs processed
     */
    UCF_EventQueueItem["prototype"]["sSerializeSection"] = function (oParams, aBuff, bCollectionAllowed) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sSerializeSection"]++;
        }
        ;
        /** @type {number} */
        var iCnt = 0;
        /** @type {boolean} */
        var bFirst = true;
        /** @type {string} */
        var i;

        aBuff["push"](this["E_SEPARATORS"]["SECTION_BEGIN"]);

        for (i in oParams) {
            if (bFirst) {
                bFirst = false;
            } else {
                aBuff["push"](this["E_SEPARATORS"]["KEYVALUE_PAIR"]);
            }
            aBuff["push"](i);
            aBuff["push"](this["E_SEPARATORS"]["KEYVALUE"]);
            this["sSerializePropertyValue"](oParams[i], aBuff, bCollectionAllowed);
            iCnt++;
        }
        aBuff["push"](this["E_SEPARATORS"]["SECTION_END"]);

        return iCnt;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sSerializeSection"] = 0;
    }
    ;

    /**
     * serializes one property value on the string array buffer
     * @private
     * @param {Object} oValue assoc.map of key/values
     * @param {string[]} aBuff buffer where to collect result
     * @param {boolean} bCollectionAllowed usage of the multiple values allowed
     */
    UCF_EventQueueItem["prototype"]["sSerializePropertyValue"] = function (oValue, aBuff, bCollectionAllowed) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["sSerializePropertyValue"]++;
        }
        ;
        /** @type {number} */
        var i;

        switch (typeof (oValue)) {
            case 'object':
                if (this["bInstanceOfArray"](oValue) && bCollectionAllowed) {
                    // collection inside values
                    for (i = 0; i < oValue["length"]; i++) {
                        switch (typeof (oValue[i])) {
                            case 'number':
                            case 'boolean':
                            case 'string':
                                if (i > 0) { // eslint-disable-line max-depth
                                    aBuff["push"](this["E_SEPARATORS"]["COLLECTION_ENTRY"]);
                                }
                                this["sSerializePropertyValue"](oValue[i], aBuff, false);
                                break;

                            default:
                                if (__UCF_TRACE__) {
                                    UCF_Tracer.trace(ERROR, 'Unsupported type in collection:' + typeof (oValue[i]), "EventQueueItem.js(181): sSerializePropertyValue");
                                }
                                ;
                                break;
                        }
                    }

                } else {
                    // object nested into object - refuse
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(ERROR, 'Unsupported type or nesting', "EventQueueItem.js(188): sSerializePropertyValue");
                    }
                    ;
                }
                break;
            default:
                aBuff["push"](oValue);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["sSerializePropertyValue"] = 0;
    }
    ;

    /**
     * @param {Object} oObject
     * @return {boolean}
     */
    UCF_EventQueueItem["prototype"]["bInstanceOfArray"] = function (oObject) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventQueueItem["_"]["bInstanceOfArray"]++;
        }
        ;
        // when object originates from different window/frame we need extra check
        // to deal with it.
        // -> Object.toString() trick in Flanagan's Definitive Guide
        // -> http://groups.google.com/group/comp.lang.javascript/browse_thread/thread/2fee4888edbb0389/102ab20c68aa738f
        // -> http://bytes.com/forum/thread91190.html

        if (oObject instanceof Array) {
            return true;
        }

        if ('[object Array]' === Object["prototype"]["toString"]["apply"](oObject)) {
            return true;
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventQueueItem["_"]["bInstanceOfArray"] = 0;
    }
    ;

    /**
     * Enumeration with predefined separators used for transport
     * @private
     */
    UCF_EventQueueItem["prototype"]["E_SEPARATORS"] = {
        "EVENT": '\ue001',
        "SECTION_BEGIN": '\ue002',
        "SECTION_END": '\ue003',
        "KEYVALUE": '\ue004',
        "KEYVALUE_PAIR": '\ue005',
        "COLLECTION_ENTRY": '\ue006'
    };

    /* global _assert, _trace, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Object */

/// <reference path="../../core/Object.js"/>

    /**
     * Class LS EventTimer
     *
     * Guards over delayed event and keep associated processing data (timers)...
     *
     *
     * @class
     * @version
     */
    function UCF_EventTimer() {
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["UCF_EventTimer"]++;
        }
        ;
        UCF_Object["apply"](this);
        this["iMaxDelay"] = 200; // ms
        this["sTimeoutId"] = null;
        this["sPendingAction"] = null;
    };window["UCF_EventTimer"] = UCF_EventTimer;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_EventTimer");
        UCF_EventTimer["_"] = {UCF_EventTimer: 0};
    }
    ;
    UCF_EventTimer["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_EventTimer.prototype["sClassName"] = "UCF_EventTimer";

    /** @override */
    UCF_EventTimer["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["destroy"]++;
        }
        ;
        this["sPendingAction"] = null;
        this["sTimeoutId"] = null;
        this["iMaxDelay"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["destroy"] = 0;
    }
    ;

    /**
     * sets maximal delay
     * @param {number} iMaxDelay
     */
    UCF_EventTimer["prototype"]["setMaxDelay"] = function (iMaxDelay) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["setMaxDelay"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (iMaxDelay) === 'number', "typeof(iMaxDelay) === 'number'", "EventTimer.js(39): setMaxDelay");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iMaxDelay > 0 && iMaxDelay < 10000, "iMaxDelay > 0 && iMaxDelay < 10000", "EventTimer.js(40): setMaxDelay");
        }
        ;
        this["iMaxDelay"] = iMaxDelay;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["setMaxDelay"] = 0;
    }
    ;

    /**
     * gets maximal delay
     * @return {number}
     */
    UCF_EventTimer["prototype"]["iGetMaxDelay"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["iGetMaxDelay"]++;
        }
        ;
        return this["iMaxDelay"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["iGetMaxDelay"] = 0;
    }
    ;

    /**
     * checks whether there is pending delay (timer is counting down)
     * @return {boolean}
     */
    UCF_EventTimer["prototype"]["bPendingDelay"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["bPendingDelay"]++;
        }
        ;
        return (this["sTimeoutId"] != null);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["bPendingDelay"] = 0;
    }
    ;

    /**
     * gets Pending delayed action (submit/submitAsync)
     * @return {string}
     */
    UCF_EventTimer["prototype"]["sGetPendingAction"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["sGetPendingAction"]++;
        }
        ;
        return this["sPendingAction"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["sGetPendingAction"] = 0;
    }
    ;

    /**
     * rejects scheduled call
     */
    UCF_EventTimer["prototype"]["rejectCall"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["rejectCall"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'rejectCall', "EventTimer.js(72): rejectCall");
        }
        ;

        if (this["sTimeoutId"] != null) {
            UCF_JsUtil["clearDelayedCall"](this["sTimeoutId"]);
            this["sTimeoutId"] = null;
            this["sPendingAction"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["rejectCall"] = 0;
    }
    ;

    /**
     * schedules event fired in the the future, with predefined delay
     * @param {Object} oHandlerObject
     * @param {string} sHandlerMethod
     * @param {UCF_SemanticEvent} oSemanticEvent
     * @param {number} iVariant
     * @param {string} sPendingAction
     */
    UCF_EventTimer["prototype"]["scheduleCall"] = function (oHandlerObject, sHandlerMethod, oSemanticEvent, iVariant, sPendingAction) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_EventTimer["_"]["scheduleCall"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'scheduleCall for next ' + this["iMaxDelay"] + 'ms; action=' + sPendingAction, "EventTimer.js(90): scheduleCall");
        }
        ;

        this["sPendingAction"] = sPendingAction;
        this["sTimeoutId"] = UCF_JsUtil["delayedCall"](
            this["iMaxDelay"],
            oHandlerObject, sHandlerMethod,
            [oSemanticEvent, iVariant]
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_EventTimer["_"]["scheduleCall"] = 0;
    }
    ;

    /* global _assert, _trace, _measure, START, STOP, INFO, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_ClientControlTree */
/// <reference path="../core/ClientControlTree.js"/>
    /* global UCF_ClientElement */
/// <reference path="../core/ClientElement.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_RenderManager */
/// <reference path="../core/RenderManager.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="../core/ResourceUtil.js"/>
    /* global UCF_ClientContainer */

    /** @typedef {Node} UCF_PageUpdater_Update */

    /**
     * PageUpdater handles updates of the current page, which are rendered using
     * the PageUpdate control on the server side
     * @class
     *
     * @param {UCF_LS} oLS Reference to Lightspeed object
     */
    function UCF_PageUpdater(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["UCF_PageUpdater"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "PageUpdater.js(35): UCF_PageUpdater");
        }
        ;

        UCF_Object["apply"](this);

        /** @type {UCF_LS} */
        this["oLS"] = oLS;
        /** @type {Object<string,UCF_PageUpdater_Update[]>} */
        this["mWaitingUpdates"] = {};
        /** @type {number} */
        this["iWaitingUpdates"] = 0;
        /** @type {UCF_PageUpdater_Update[]} */
        this["aMissingModel"] = [];
        /** @type {UCF_ModelControl} */
        this["aUnlockModels"] = [];

        if (this["oLS"]["bControlsInitialized"]) {
            UCF_JsUtil["delayedCall"](0, this, 'initialize');
        } else {
            this["oLS"]["attachEvent"](
                this["oLS"]["E_EVENTS"]["ControlsInitialized"],
                this,
                'onControlsInitialized'
            );
        }
    };window["UCF_PageUpdater"] = UCF_PageUpdater;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_PageUpdater");
        UCF_PageUpdater["_"] = {UCF_PageUpdater: 0};
    }
    ;
    UCF_PageUpdater["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_PageUpdater.prototype["sClassName"] = "UCF_PageUpdater";

    /** @private */
    UCF_PageUpdater["prototype"]["onControlsInitialized"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["onControlsInitialized"]++;
        }
        ;
        this["oLS"]["detachEvent"](
            this["oLS"]["E_EVENTS"]["ControlsInitialized"],
            this,
            'onControlsInitialized'
        );
        this["initialize"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["onControlsInitialized"] = 0;
    }
    ;

    /**
     * Processes initial updates of the page. This can be used for applications,
     * where the initial page already contains popup windows to avoid multiple
     * roundtrips
     * @private
     */
    UCF_PageUpdater["prototype"]["initialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["initialize"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oInitialUpdateRef = UCF_DomUtil["$"]('UCF_InitialUpdate');
        /** @type {string} */
        var sXMLText;
        /** @type {Object} */
        var oXMLDoc;

        if (oInitialUpdateRef) {
            sXMLText = oInitialUpdateRef["innerHTML"];
            oXMLDoc = UCF_JsUtil["oParseXMLDocument"](sXMLText);

            if (oXMLDoc["documentElement"]) {
                // In serverDebug mode there are comments rendered into the XML
                UCF_JsUtil["removeComments"](oXMLDoc["documentElement"]);

                this["processUpdateDocument"](oXMLDoc);

                oInitialUpdateRef["parentNode"]["removeChild"](oInitialUpdateRef);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["initialize"] = 0;
    }
    ;

    /**
     * @see UCF_Object
     */
    UCF_PageUpdater["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["destroy"]++;
        }
        ;
        this["mWaitingUpdates"] = null;
        this["mWindowOpenEvents"] = null; // TODO this may be dangerous
        this["oLS"] = null;
        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["destroy"] = 0;
    }
    ;

    /**
     * Processes the Updates
     *
     * @param {XMLDocument} oDocument
     * @private
     */
    UCF_PageUpdater["prototype"]["processUpdateDocument"] = function (oDocument) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processUpdateDocument"]++;
        }
        ;
        /** @type {Node} */
        var oRootRef;
        /** @type {NodeListOf<UCF_PageUpdater_Update>} */
        var aUpdates;
        /** @type {UCF_PageUpdater_Update} */
        var oUpdateRef;
        /** @type {string} */
        var sWindowId;
        /** @type {number} */
        var i;
        /** @type {UCF_PageUpdater_Update[]} */
        var aRealUpdates;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDocument != null, "oDocument != null", "PageUpdater.js(131): processUpdateDocument");
        }
        ;

        if (oDocument && oDocument["documentElement"]) {
            oRootRef = oDocument["documentElement"];
            if (oRootRef["tagName"] === 'updates') {
                aUpdates = oRootRef["childNodes"];
                i = 0;

                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Starting update, found updates for ' + aUpdates["length"] + ' windows', "PageUpdater.js(139): processUpdateDocument");
                }
                ;

                this["oLS"]["fireBeforeUpdateDocument"]({
                    "iUpdates": aUpdates["length"]
                });

                // filter real dom nodes
                aRealUpdates = [];
                for (i = 0; i < aUpdates["length"]; i++) {
                    if (aUpdates[i]["nodeType"] !== 1) {
                        continue;
                    }
                    aRealUpdates["push"](aUpdates[i]);
                }
                for (i = 0; i < aRealUpdates["length"]; i++) {
                    oUpdateRef = aRealUpdates[i];

                    if (oUpdateRef["nodeType"] !== 1) {
                        continue;
                    }

                    sWindowId = oUpdateRef["getAttribute"]('windowid');

                    if (sWindowId && sWindowId !== this["oLS"]["sGetMainWindowId"]()) {
                        this["processPopupWindowUpdate"](sWindowId, oUpdateRef);
                    } else {
                        this["processUpdates"](oUpdateRef, null, {
                            "iIndex": i,
                            "iCount": aRealUpdates["length"]
                        });
                    }
                }
                this["oLS"]["fireUpdateDocumentComplete"]();
            } else {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, 'Invalid update XML', "PageUpdater.js(169): processUpdateDocument");
                }
                ;
            }

        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processUpdateDocument"] = 0;
    }
    ;

    /**
     * Popup window update
     * @param {string} sWindowId
     * @param {Node} oUpdateRef
     * @private
     */
    UCF_PageUpdater["prototype"]["processPopupWindowUpdate"] = function (sWindowId, oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processPopupWindowUpdate"]++;
        }
        ;
        /** @type {UCF_PopupManager} */
        var oPopupManager = this["oLS"]["oGetPopupManagerInternal"]();
        /** @type {UCF_LS} */
        var oTargetLS = oPopupManager["oGetLSByPopupId"](sWindowId);
        /** @type {UCF_PopupWindow} */
        var oPopupWindow;

        // if LS exists, update can be applied, otherwise we have
        // to wait for the WindowOpen event for this window
        if (oTargetLS) {
            oPopupWindow = oPopupManager["oGetPopupById"](sWindowId);
            if (oPopupWindow) {
                oPopupWindow["beforeUpdate"]();
            }
            oTargetLS["oPageUpdater"]["processUpdates"](oUpdateRef);
        } else {
            if (this["iWaitingUpdates"] === 0) {
                oPopupManager["attachEvent"](
                    oPopupManager["E_EVENTS"]["WindowOpen"],
                    this,
                    'onWindowOpen'
                );
            }
            this["iWaitingUpdates"]++;

            // There might be more updates to come before the first was executed,
            // example is that this update triggers another server roundtrip that again
            // changes the content of this popup. Therefore this was changed to an
            // array of updates that need to be processed for this popup window.
            // CSN: 343896 2010
            if (this["mWaitingUpdates"][sWindowId]) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Multiple updates for PopupWindow ' + sWindowId, "PageUpdater.js(213): processPopupWindowUpdate");
                }
                ;
            } else {
                this["mWaitingUpdates"][sWindowId] = [];
            }
            this["mWaitingUpdates"][sWindowId]["push"](oUpdateRef);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processPopupWindowUpdate"] = 0;
    }
    ;

    /**
     * Popup Window Open handler
     *
     * @private
     * @param {UCF_Event} oEvent
     */
    UCF_PageUpdater["prototype"]["onWindowOpen"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["onWindowOpen"]++;
        }
        ;
        /** @type {UCF_LS} */
        var oTargetLS = oEvent["oGetParam"]('oTargetLS');

        if (oTargetLS["bControlsInitialized"]) {
            this["applyWindowUpdate"](oEvent);
        } else {
            // Theme-fallback: The PopupWindow instance may not exist yet, because
            // processInitilizeIDs() was not called yet.
            // Note:
            // This case is important for a WDA issue: They are putting "wrong"
            // script-calls with CustomStyles in an update with an PopupWindow ID that
            // does no longer exist (when popup is closed) - and they will probably NOT
            // fix it. In applyWindowUpdate() at the condition
            // "if (!PopupWindow && i > 0)" these "wrong" script-calls are in the
            // waiting-queue before the "real" full-update when the PopupWindow with
            // that ID is opened again. In this special case the content update for the
            // PopupWindow was thrown away and the popup remained empty! Therefore it
            // is important to wait for the LS inside the popup to initialize, when
            // this is done delayed because of a Theme-fallback....
            // Note 2:
            // Need to remember multiple events when two popups are opened in the same
            // request
            /** @type {Object<string,UCF_Event>} */
            this["mWindowOpenEvents"] = this["mWindowOpenEvents"] || {};
            this["mWindowOpenEvents"][oEvent["oGetParam"]('sPopupId')] = oEvent["copy"]();
            oTargetLS["attachEvent"](
                oTargetLS["E_EVENTS"]["ControlsInitialized"],
                this,
                'onTargetLSInitialized'
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["onWindowOpen"] = 0;
    }
    ;

    /**
     * Handle UCF_LS.E_EVENTS.ControlsInitialized inside popup IFrame - see
     * onWindowOpen()
     * @param {UCF_Event} oInitEvent
     */
    UCF_PageUpdater["prototype"]["onTargetLSInitialized"] = function (oInitEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["onTargetLSInitialized"]++;
        }
        ;
        /** @type {UCF_Event} */
        var oOpenEvent = this["mWindowOpenEvents"][oInitEvent["oGetParam"]('sPopupId')];
        /** @type {UCF_LS} */
        var oTargetLS = oOpenEvent["oGetParam"]('oTargetLS');

        oTargetLS["detachEvent"](oTargetLS["E_EVENTS"]["ControlsInitialized"], this);
        this["applyWindowUpdate"](oOpenEvent);
        delete this["mWindowOpenEvents"][oInitEvent["oGetParam"]('sPopupId')];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["onTargetLSInitialized"] = 0;
    }
    ;

    /**
     * @param {UCF_Event} oWindowOpenEvent
     */
    UCF_PageUpdater["prototype"]["applyWindowUpdate"] = function (oWindowOpenEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["applyWindowUpdate"]++;
        }
        ;
        /** @type {UCF_PopupManager} */
        var oPopupManager = this["oLS"]["oGetPopupManagerInternal"]();
        /** @type {UCF_LS} */
        var oTargetLS = oWindowOpenEvent["oGetParam"]('oTargetLS');
        /** @type {string} */
        var sWindowId = oWindowOpenEvent["oGetParam"]('sPopupId');
        /** @type {UCF_PageUpdater_Update[]} */
        var aUpdateRefs = this["mWaitingUpdates"][sWindowId];
        /** @type {number} */
        var i;
        /** @type {UCF_PopupWindow} */
        var oPopupWindow;

        delete this["mWaitingUpdates"][sWindowId];
        this["iWaitingUpdates"]--;
        if (this["iWaitingUpdates"] === 0) {
            oPopupManager["detachEvent"](oPopupManager["E_EVENTS"]["WindowOpen"], this);
        }
        // There might be more updates to come before the first was executed, example
        // is that this update triggers another server roundtrip that again changes
        // the content of this popup. Therefore this was changed to an array of
        // updates that need to be processed for this popup window.
        for (i = 0; i < aUpdateRefs["length"]; i++) {
            // safety check: it could happen that an update closes the PopupWindow. In
            // this case we need to stop and ignore other updates. This cannot be the
            // first update in the array (because this one creates the window
            oPopupWindow = oPopupManager["oGetPopupById"](sWindowId);
            if (oPopupWindow) {
                oPopupWindow["beforeUpdate"]();
            }
            if (!oPopupWindow && i > 0) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Updates for PopupWindow ' + sWindowId + ' were ignored, because the PopupWindow was destroyed before the updates could be processed.', "PageUpdater.js(310): applyWindowUpdate");
                }
                ;
                break;
            }
            oTargetLS["oPageUpdater"]["processUpdates"](aUpdateRefs[i], true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["applyWindowUpdate"] = 0;
    }
    ;

    /**
     * Processes the Updates
     *
     * @param {UCF_PageUpdater_Update} oNode
     * @param {boolean} bOnWindowOpen
     * @param {Document} oDocumentContext
     * @private
     */
    UCF_PageUpdater["prototype"]["processUpdates"] = function (oNode, bOnWindowOpen, oDocumentContext) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processUpdates"]++;
        }
        ;
        /** @type {NodeListOf<UCF_PageUpdater_Update>} */
        var aUpdates;
        /** @type {UCF_PageUpdater_Update} */
        var oUpdateRef;
        /** @type {string} */
        var sCommand;
        /** @type {HTMLElement} */
        var oActiveElementBeforeHTMLUpdate;
        /** @type {boolean} */
        var bHasActiveElementBeforeHTMLUpdate;
        /** @type {number} */
        var i;
        /** @type {UCF_PopupManager} */
        var oPopupManager;
        /** @type {boolean} */
        var bIsActiveWindow;
        /** @type {number} */
        var iSX;
        /** @type {number} */
        var iSY;

        if (__UCF_MEASURE__) {
            UCF_Tracer.measure(START, 'UCF_PageUpdater');
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oNode != null, "oNode != null", "PageUpdater.js(348): processUpdates");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oNode["tagName"] === 'delta-update' || oNode["tagName"] === 'full-update', "oNode.tagName === 'delta-update' || oNode.tagName === 'full-update'", "PageUpdater.js(349): processUpdates");
        }
        ;

        aUpdates = oNode["childNodes"];

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Applying updates for window "' + oNode["getAttribute"]('windowid') + '"', "PageUpdater.js(353): processUpdates");
        }
        ;

        // Execute all startup scripts before intializing the controls
        this["processStartScripts"](aUpdates);

        // Execute style updates at first to avoid double rendering
        this["processStyleUpdates"](aUpdates);

        oActiveElementBeforeHTMLUpdate = this["oGetActiveElement"]();
        bHasActiveElementBeforeHTMLUpdate = this["bCheckActiveElement"]();

        // Do all DOM updates, purge and initialize controls
        for (i = 0; i < aUpdates["length"]; i++) {
            oUpdateRef = aUpdates[i];

            if (oUpdateRef["nodeType"] !== 1) {
                continue;
            }
            sCommand = oUpdateRef["tagName"];
            switch (sCommand) {
                case 'content-update':
                    this["updateContent"](oUpdateRef);
                    break;
                case 'control-update':
                    this["updateControl"](oUpdateRef);
                    break;
                case 'control-append':
                    this["appendControl"](oUpdateRef);
                    break;
                case 'html-update':
                    this["updateHtml"](oUpdateRef);
                    break;
                case 'lsx-update':
                    this["updateLSX"](oUpdateRef);
                    break;
                case 'initialize-ids':
                    this["initializedIds"](oUpdateRef);
                    break;
                case 'animation-update':
                    this["updateAnimation"](oUpdateRef);
                    break;
            }
        }

        // Workaround - focus lost in IE10 after control update via innerHtml -> body
        // should have the focus
        // Workaround for standards mode - after innerHTML exchange the body is the
        // active element but if windows.open no focusOut occurs. Setting setActive
        // on body again solves this issue CSN 0004741261 2013
        // 982012 2015: IE will change body scroll position to top (0) -> store and
        // restore it
        oPopupManager = this["oLS"]["oGetPopupManagerInternal"]();
        if (oPopupManager) {
            bIsActiveWindow = oPopupManager["bIsActiveWindow"]();
        }
        if (
            UCF_UserAgent["bIsIE"]() &&
            bIsActiveWindow &&
            bHasActiveElementBeforeHTMLUpdate
        ) {
            if (
                // quirks mode: after innerHTML exchange the activeElement is moved to
                // the parent element of the exchanged container and not to the body.
                // ToDo: Chrome&&FF behaves the same but fix doesn't help
                (
                    oActiveElementBeforeHTMLUpdate !== this["oGetActiveElement"]() &&
                    !UCF_UserAgent["bIsStandardsMode"]()
                ) ||
                // When HTML update removed active element
                (
                    !this["oGetActiveElement"]() ||
                    this["oGetActiveElement"]()["tagName"]["toUpperCase"]() === 'BODY'
                )
            ) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Reset focus to body due to IE issue - body might not refocussed correctly after roundtrip', "PageUpdater.js(425): processUpdates");
                }
                ;
                try {
                    iSX = window["pageXOffset"] ? window["pageXOffset"] : document["scrollLeft"];
                    iSY = window["pageYOffset"] ? window["pageYOffset"] : document["scrollTop"];

                    // calling setActive crash on IE11/WIN10 (int. incident 1570743858) or
                    // looses the focus. The crash cannot be reproduced with ls version
                    // urchangelist=226187, urtimestamp=201602082101
                    document["body"]["setActive"]();
                    if (window["pageYOffset"]) {
                        window["scrollTo"](iSX, iSY);
                    } else {
                        document["scrollTop"] = iSY;
                        document["scrollLeft"] = iSX;
                    }
                } catch (e) {
                }
            }
        }
        this["processAfterDomUpdate"](aUpdates, bOnWindowOpen, oDocumentContext);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processUpdates"] = 0;
    }
    ;

    /**
     * Processes the updates array updates and executes fHandler for every update
     * with sTagname
     *
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates The updates to be applied
     * @param {string} sTagname The tagname of the update part to be executed
     * @param {function(UCF_PageUpdater_Update[]): void} fHandler The handler
     * function to be called for every update part
     */
    UCF_PageUpdater["prototype"]["processUpdateParts"] = function (aUpdates, sTagname, fHandler) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processUpdateParts"]++;
        }
        ;
        /** @type {UCF_PageUpdater_Update} */
        var oUpdateRef;
        /** @type {string} */
        var sCommand;
        /** @type {number} */
        var i;

        for (i = 0; i < aUpdates["length"]; i++) {
            oUpdateRef = aUpdates[i];
            if (oUpdateRef["nodeType"] !== 1) {
                continue;
            }
            sCommand = oUpdateRef["tagName"];
            if (sCommand === sTagname) {
                fHandler["apply"](this, [oUpdateRef]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processUpdateParts"] = 0;
    }
    ;

    /**
     * Processes the updates array style updates
     *
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates The updates of the control
     */
    UCF_PageUpdater["prototype"]["processStyleUpdates"] = function (aUpdates) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processStyleUpdates"]++;
        }
        ;
        this["processUpdateParts"](aUpdates, 'style-update', this["updateStyle"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processStyleUpdates"] = 0;
    }
    ;

    /**
     * Processes the updates array model updates
     *
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates The updates of the control
     */
    UCF_PageUpdater["prototype"]["processModelUpdates"] = function (aUpdates) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processModelUpdates"]++;
        }
        ;
        /** @type {number} */
        var i;

        this["processUpdateParts"](aUpdates, 'model-update', this["updateModel"]);
        if (this["aUnlockModels"]) {
            for (i = 0; i < this["aUnlockModels"]["length"]; i++) {
                this["aUnlockModels"][i]["unlock"]();
            }
            this["aUnlockModels"] = [];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processModelUpdates"] = 0;
    }
    ;

    /**
     * Processes the updates array model updates
     *
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates The updates of the control
     */
    UCF_PageUpdater["prototype"]["processStartScripts"] = function (aUpdates) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processStartScripts"]++;
        }
        ;
        this["processUpdateParts"](aUpdates, 'start-script', this["callScript"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processStartScripts"] = 0;
    }
    ;

    /**
     * Processes the updates array model updates
     *
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates The updates of the control
     */
    UCF_PageUpdater["prototype"]["processScriptCalls"] = function (aUpdates) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processScriptCalls"]++;
        }
        ;
        this["processUpdateParts"](aUpdates, 'script-call', this["callScript"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processScriptCalls"] = 0;
    }
    ;

    /**
     * @private
     * @param {UCF_PageUpdater_Update[]} aUpdates
     * @param {boolean} bOnWindowOpen
     * @param {Document} oDocumentContext
     */
    UCF_PageUpdater["prototype"]["processAfterDomUpdate"] = function (aUpdates, bOnWindowOpen, oDocumentContext) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["processAfterDomUpdate"]++;
        }
        ;
        /** @type {UCF_PageUpdater} */
        var self = this;

        /** */
        function processInitAndFireEvents() {
            self["oLS"]["processInitializeIDs"]();

            // Execute all script-calls after intializing the controls
            self["processScriptCalls"](aUpdates);

            if (__UCF_MEASURE__) {
                UCF_Tracer.measure(STOP, 'UCF_PageUpdater', 'Delta update');
            }
            ;

            // a redirect script call might have destroyed this.oLS
            // Added comment D030999: It seems that it can happen that in the
            // script-call phase the destructor of the LS object is called e.g. the
            // exit call of WDA. Therefore a further processing fails. This has to be
            // handled in PageUpdater.processAfterDomUpdate and
            // EventHandler.onXmlHttpResponse
            // TODO: clarify why this is done/necessary by WDA
            if (!self["oLS"]["bIsDestroyed"]) {
                // fire LayoutChange to guarantee proper resizing in external environments
                self["oLS"]["oBrowserWindow"]["notifyLayoutChangeFrom"](
                    null,
                    'UCF_PageUpdater',
                    oDocumentContext
                );
                self["oLS"]["fireUpdateComplete"]();

                // There might be "old" animations played after update complete so we let
                // the animation implementation take care, when to update animations
                if (self["oLS"]["oPage"]) {
                    self["oLS"]["oPage"]["updateAnimations"]();
                }
            }
        };

        // Execute all model-updates after and control tree updates are applied
        this["processModelUpdates"](aUpdates);

        this["oLS"]["purgeControls"]();

        if (bOnWindowOpen === true) {
            // There may have been a fallback-CSS loaded for the new LS instance inside
            // the PopupWindow, see coding UCF_LS constructor
            UCF_ResourceUtil["ensureLightspeedCssLoaded"]()["then"](processInitAndFireEvents);
        } else {
            processInitAndFireEvents();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["processAfterDomUpdate"] = 0;
    }
    ;

    /**
     * Get the active element of the document (if any)
     *
     * @private
     * @return {HTMLElement} The currently active element if any.
     */
    UCF_PageUpdater["prototype"]["oGetActiveElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["oGetActiveElement"]++;
        }
        ;
        /** @type {HTMLElement} */
        var o = null;

        try { // sometimes the access to active element was denied.
            if (this["bCheckActiveElement"]()) {
                o = document["activeElement"];
            }
        } catch (exception) {
        }

        return o;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["oGetActiveElement"] = 0;
    }
    ;

    /**
     * Returns true if document.activeElement is set and accessible.
     *
     * @private
     * @return {boolean}
     */
    UCF_PageUpdater["prototype"]["bCheckActiveElement"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["bCheckActiveElement"]++;
        }
        ;
        try {
            // In IE10 activeElement may be an empty object !
            return (
                typeof document["activeElement"] !== 'undefined' &&
                document["activeElement"] != null &&
                typeof (document["activeElement"]["tagName"]) !== 'undefined' &&
                document["activeElement"]["tagName"] != null
            );
        } catch (e) {
            // See comment in DomUtil.oGetActiveElement: there may be security
            // exceptions (?)
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["bCheckActiveElement"] = 0;
    }
    ;

    /**
     * Returns the CDATA node values
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     * @return {string} The CDATA node values
     */
    UCF_PageUpdater["sGetCDATAContent"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["sGetCDATAContent"]++;
        }
        ;
        /** @type {string} */
        var sContent = '';
        /** @type {Node} */
        var oCData = oUpdateRef["firstChild"];

        while (oCData != null) {
            // eslint-disable-next-line no-magic-numbers
            if (oCData["nodeType"] === 4) { // ignore non-CDATA nodes
                sContent += oCData["nodeValue"];
            }
            oCData = oCData["nextSibling"];
        }

        return sContent;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["sGetCDATAContent"] = 0;
    }
    ;

    /**
     * Initialized Ids control
     *
     * @param {UCF_PageUpdater_Update} oUpdateRef
     * @private
     */
    UCF_PageUpdater["prototype"]["initializedIds"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["initializedIds"]++;
        }
        ;
        /** @type {string} */
        var sHTML = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef);
        /** @type {HTMLElement} */
        var oRootRef = this["oLS"]["oGetRootRef"]();
        /** @type {HTMLSpanElement} */
        var oSpanRef = document["createElement"]('span');

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Updating Initialized Ids: ' + sHTML, "PageUpdater.js(659): initializedIds");
        }
        ;
        // eslint-disable-next-line no-unsanitized/property
        oSpanRef["innerHTML"] = sHTML;
        oRootRef["appendChild"](oSpanRef["firstChild"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["initializedIds"] = 0;
    }
    ;

    /**
     * Style Updates
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateStyle"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateStyle"]++;
        }
        ;
        /** @type {HTMLElement} */
        var oRootRef = this["oLS"]["oGetRootRef"]();
        /** @type {HTMLDivElement} */
        var oDiv = document["createElement"]('div');

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Updating Styles', "PageUpdater.js(677): updateStyle");
        }
        ;
        oDiv["style"]["display"] = 'none';
        oRootRef["appendChild"](oDiv);
        // TODO: For unknown reasons this does not work on Safari
        // CSN: C-703528 2010 Do the input field hack only for IE.
        if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
            // eslint-disable-next-line no-unsanitized/property
            oDiv["innerHTML"] = '<input type=hidden>' + UCF_PageUpdater["sGetCDATAContent"](
                oUpdateRef
            );
        } else {
            // eslint-disable-next-line no-unsanitized/property
            oDiv["innerHTML"] = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateStyle"] = 0;
    }
    ;

    /**
     * Update content
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateContent"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateContent"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {UCF_Control} */
        var oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
        /** @type {string} */
        var sHTML = '';
        /** @type {HTMLElement} */
        var oRootRef;

        if (oUpdateRef["getElementsByTagName"]('content')["length"] > 0) {
            // delta update
            sHTML = UCF_PageUpdater["sGetCDATAContent"](
                oUpdateRef["getElementsByTagName"]('content')[0]
            );
        } else {
            sHTML = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef); // full update
        }

        if (oControl == null) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Control to update not found: id=' + sId, "PageUpdater.js(720): updateContent");
            }
            ;
        } else {
            oRootRef = oControl["oRootRef"];

            sHTML = UCF_ResourceUtil["sInlineSvgByHtmlExchange"](sHTML, this["oLS"]);

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Updating content of control "' + sId + '"', "PageUpdater.js(726): updateContent");
            }
            ;
            // eslint-disable-next-line no-unsanitized/property
            oRootRef["innerHTML"] = sHTML;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateContent"] = 0;
    }
    ;

    /**
     * Update control
     *
     * @private
     * @param {element} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateControl"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateControl"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {Node} */
        var oContentRef = null;
        /** @type {Node} */
        var oControlTreeRef = null;
        /** @type {boolean} */
        var bSuppressControlTreeRendering = false;
        /** @type {string} */
        var sUpdateMethod = oUpdateRef["getAttribute"]('updateMethod');
        /** @type {UCF_Control} */
        var oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
        /** @type {UCF_ClientElement} */
        var oClientControl = this["oLS"]["oControlFactory"]["oGetClientControlById"](sId);
        /** @type {string} */
        var sHTML = null;
        /** @type {HTMLElement} */
        var oRootRef;
        /** @type {HTMLElement} */
        var oParentRef;
        /** @type {Element|Element[]} */
        var oRef;
        /** @type {DocumentFragment} */
        var oFragment;
        /** @type {Object[]} */
        var aModelUpdates;
        /** @type {number} */
        var i;
        /** @type {UCF_RenderManager} */
        var oTempRenderManager;
        /** @type {UCF_ClientControlTree} */
        var oControlTree;
        /** @type {string} */
        var n;
        /** @type {UCF_ClientElement} */
        var oTempControl;
        /** @type {boolean} */
        var bSuppress;

        oContentRef = oUpdateRef["getElementsByTagName"]('content')[0];
        oControlTreeRef = oUpdateRef["getElementsByTagName"]('controltree')[0];
        bSuppressControlTreeRendering = oUpdateRef["getAttribute"](
            'suppressControlTreeRendering'
        ) === 'true';

        // update the content if it was sent
        if (oContentRef && oControl) {
            oRootRef = oControl["oRootRef"];
            oParentRef = oRootRef["parentNode"];

            sHTML = UCF_PageUpdater["sGetCDATAContent"](oContentRef);
            sHTML = UCF_ResourceUtil["sInlineSvgByHtmlExchange"](sHTML, this["oLS"]);

            if (__UCF_TRACE__) {
                UCF_Tracer.trace(INFO, 'Updating control "' + sId + '" with method ' + (sUpdateMethod == null ? 'FULL' : sUpdateMethod) + '"', "PageUpdater.js(793): updateControl");
            }
            ;

            if (sUpdateMethod === 'PARTIAL') {
                // Notify control about partial update request
                oControl["updateHTML"](sHTML);
            } else if (
                !(UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) &&
                (
                    oParentRef["childNodes"]["length"] === 1 ||
                    UCF_DomUtil["firstChild"](oParentRef) === UCF_DomUtil["lastChild"](oParentRef)
                )
            ) {
                // Optimize HTML injection: Check if innerHTML is possible because
                // innerHTML is faster than outerHTML. This is possible when the parent
                // contains only one child
                //
                // Do not use for IE: This opt. causes the "asso-area offsetHeight=18"
                // problem AGAIN (regression) !

                // Replace content of parent (inner approach)
                // eslint-disable-next-line no-unsanitized/property
                oParentRef["innerHTML"] = sHTML;
            } else {
                // Create a documentfragment containing all nodes
                oFragment = document["createDocumentFragment"]();

                oRef = UCF_DomUtil["oHtmlToElement"](sHTML);
                UCF_JsUtil["forEach"](UCF_JsUtil["bIsArray"](oRef) ? oRef : [oRef], function (oRef) {
                    oFragment["appendChild"](oRef);
                });

                // Replace existing node with fragment
                oParentRef["replaceChild"](oFragment, oRootRef);
            }
        }
        if (this["aMissingModel"]["length"] > 0) {
            aModelUpdates = this["aMissingModel"]["concat"]([]);
            this["aMissingModel"] = [];
            for (i = 0; i < aModelUpdates["length"]; i++) {
                this["updateModel"](aModelUpdates[i]);
            }

        }
        if (oControlTreeRef) {
            if (oClientControl && oControl && sUpdateMethod === 'PARTIAL') {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Client side rendering parial update.', "PageUpdater.js(838): updateControl");
                }
                ;
                oTempRenderManager = new (UCF_ClassLoader["oGetClass"]("UCF_RenderManager"))(this["oLS"]);
                oControlTree = UCF_ClientControlTree["parse"](
                    UCF_PageUpdater["sGetCDATAContent"](oControlTreeRef)
                );
                this["oLS"]["oControlFactory"]["bAvoidClientControlRegistration"] = true;
                for (n in oControlTree) {
                    oTempControl = UCF_ClientElement["createInstance"](
                        n,
                        this["oLS"],
                        oControlTree[n]["Id"],
                        oControlTree[n],
                        null,
                        true
                    );
                }
                oTempRenderManager["renderControl"](oTempControl["getRenderInfo"]());
                sHTML = oTempRenderManager["getHTMLString"]();
                oControl["updateHTML"](sHTML);
                oTempControl["destroy"]();
                oTempControl = null;
                this["oLS"]["oControlFactory"]["bAvoidClientControlRegistration"] = false;
                oTempRenderManager["clearBuffer"]();
                oTempRenderManager["destroy"]();
                oTempRenderManager = null;
            } else {
                // suppress rerendering if oContentRef was sent or there was a previous
                // full update (its)
                bSuppress = (
                    oContentRef != null ||
                    this["bFullUpdate"] ||
                    bSuppressControlTreeRendering
                );
                this["updateClientControlTree"](oControlTreeRef, sId, bSuppress);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateControl"] = 0;
    }
    ;

    /**
     * Update control
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["appendControl"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["appendControl"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {UCF_Control} */
        var oControl = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
        /** @type {UCF_ClientContainer} */
        var oContent = null;
        /** @type {string} */
        var sCId;
        /** @type {UCF_Control} */
        var oContainer;
        /** @type {Node} */
        var oContentRef;
        /** @type {Node} */
        var oControlTreeRef;
        /** @type {HTMLElement} */
        var oParentRef;
        /** @type {string} */
        var sHTML;
        /** @type {HTMLDivElement} */
        var oDiv;
        /** @type {UCF_ClientContainer} */
        var oClientContainer;
        /** @type {UCF_ClientContainer} */
        var oNewContainer;
        /** @type {string} */
        var sControlTree;
        /** @type {Object} */
        var oItemJson;
        /** @type {UCF_ClientElement} */
        var oNewItem;

        // If control does already exist, just update it
        if (oControl) {
            this["updateControl"](oUpdateRef);
        } else {
            sCId = oUpdateRef["getAttribute"]('cid');
            oContainer = this["oLS"]["oControlFactory"]["oGetControlById"](sCId);
            oContentRef = oUpdateRef["getElementsByTagName"]('content')[0];
            oControlTreeRef = oUpdateRef["getElementsByTagName"]('controltree')[0];
            oParentRef = oContainer["oDomRef"];
            sHTML = UCF_ResourceUtil["sInlineSvgByHtmlExchange"](
                UCF_PageUpdater["sGetCDATAContent"](oContentRef),
                this["oLS"]
            );

            if (oContentRef) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Appending control "' + sId + '" to container ' + sCId, "PageUpdater.js(929): appendControl");
                }
                ;
                oDiv = document["createElement"]('div');
                oParentRef["appendChild"](oDiv);
                // eslint-disable-next-line no-unsanitized/property
                oDiv["innerHTML"] = sHTML;
            }
            if (oControlTreeRef) {
                // this is a strange case for Client Rendering as there is no "container"
                // that allows to inject HTML. therefore we need to create a simple
                // container that we add to the content aggregation
                oClientContainer = this["oLS"]["oControlFactory"]["oGetClientControlById"](sCId);
                if (!oClientContainer) {
                    if (__UCF_TRACE__) {
                        UCF_Tracer.trace(INFO, 'Appending control tree "' + sId + '" to container ' + sCId + ' failed. The client control for the container does not exist.', "PageUpdater.js(941): appendControl");
                    }
                    ;
                }
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(INFO, 'Appending control tree "' + sId + '" to container ' + sCId, "PageUpdater.js(943): appendControl");
                }
                ;
                if (oClientContainer instanceof UCF_ClientContainer) {
                    oContent = oClientContainer;
                } else {
                    oContent = oClientContainer["getContent"]();
                    if (oContent && !(oContent instanceof UCF_ClientContainer)) {
                        oNewContainer = this["oLS"]["oControlFactory"]["oCreateClientControl"](
                            'Container'
                        );
                        oNewContainer["setTransientRendering"](true);
                        oNewContainer["addItem"](oContent);
                        oClientContainer["setContent"](oNewContainer);
                        oContent = oNewContainer;
                    }
                }
                if (oContent && oContent["addItem"]) {
                    sControlTree = UCF_PageUpdater["sGetCDATAContent"](oControlTreeRef);
                    oItemJson = UCF_JsUtil["oJsonParse"](sControlTree);
                    oNewItem = this["oLS"]["oControlFactory"]["oCreateClientControl"](oItemJson);

                    oContent["addItem"](oNewItem, oContentRef != null);
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["appendControl"] = 0;
    }
    ;

    /**
     * Update html content, e.g. used for statemarker in LSF
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateHtml"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateHtml"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {boolean} */
        var bInnerHTML = oUpdateRef["getAttribute"]('innerHTML') === 'true';
        /** @type {Node} */
        var oContentRef = null;
        /** @type {HTMLElement} */
        var oRootRef = UCF_DomUtil["$"](sId);
        /** @type {string} */
        var sHTML;
        /** @type {HTMLDivElement} */
        var oTemp;
        /** @type {HTMLElement} */
        var oParentRef;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(this["oLS"]["oControlFactory"]["oGetControlById"](sId) == null, "this.oLS.oControlFactory.oGetControlById(sId) == null", "PageUpdater.js(991): updateHtml");
        }
        ;

        oContentRef = oUpdateRef["getElementsByTagName"]('content')[0];
        sHTML = UCF_ResourceUtil["sInlineSvgByHtmlExchange"](
            UCF_PageUpdater["sGetCDATAContent"](oContentRef),
            this["oLS"]
        );

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Updating html "' + sId + '"', "PageUpdater.js(999): updateHtml");
        }
        ;

        if (bInnerHTML) {
            // eslint-disable-next-line no-unsanitized/property
            oRootRef["innerHTML"] = sHTML;
        } else if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
            // eslint-disable-next-line no-unsanitized/property
            oRootRef["outerHTML"] = sHTML;
        } else {
            oTemp = document["createElement"]('div');
            // TODO: multiple tags with the same ID e.g. for JSF
            oParentRef = oRootRef["parentNode"];
            // eslint-disable-next-line no-unsanitized/property
            oTemp["innerHTML"] = sHTML;

            if (__UCF_ASSERT__) {
                UCF_Tracer.assert(oParentRef != null, "oParentRef != null", "PageUpdater.js(1014): updateHtml");
            }
            ;

            // Replace first child node
            oParentRef["replaceChild"](oTemp["firstChild"], oRootRef);

            // Append all following child nodes
            while (oTemp["firstChild"]) {
                oParentRef["appendChild"](oTemp["firstChild"]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateHtml"] = 0;
    }
    ;

    /**
     * Update lsx content
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateLSX"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateLSX"]++;
        }
        ;
        // TODO: XML parser
        /** @type {UCF_RenderManager} */
        var oRenderManager = this["oLS"]["oGetRenderManager"]();
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {string} */
        var sXML = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef);
        /** @type {HTMLElement} */
        var oRootRef = UCF_DomUtil["$"](sId);

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Update control "' + sId + '" with client side rendered controls.', "PageUpdater.js(1043): updateLSX");
        }
        ;
        oRenderManager["renderXMLStream"](sXML, oRootRef);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateLSX"] = 0;
    }
    ;

    /**
     * Call script
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     * @param {boolean} bResetControlTree
     */
    UCF_PageUpdater["prototype"]["callScript"] = function (oUpdateRef, bResetControlTree) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["callScript"]++;
        }
        ;
        UCF_JsUtil["eval"](
            UCF_PageUpdater["sGetCDATAContent"](oUpdateRef), {"oLS": this["oLS"]["oGetInterface"]()}
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["callScript"] = 0;
    }
    ;

    /**
     * Updates an animation of the page
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateAnimation"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateAnimation"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {string} */
        var sHTML = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef);
        /** @type {HTMLElement} */
        var oDomRef = UCF_DomUtil["$"](sId);
        /** @type {HTMLDivElement} */
        var oTemp;
        /** @type {DocumentFragment} */
        var oFragment;

        if (oDomRef && oDomRef["parentNode"]) {
            oTemp = document["createElement"]('div');
            // eslint-disable-next-line no-unsanitized/property
            oTemp["innerHTML"] = sHTML;

            oFragment = document["createDocumentFragment"]();
            while (oTemp["firstChild"]) {
                oFragment["appendChild"](oTemp["firstChild"]);
            }

            // Replace existing node with fragment
            oDomRef["parentNode"]["replaceChild"](oFragment, oDomRef);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateAnimation"] = 0;
    }
    ;

    /**
     * Updates the control tree of the client controls.
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     * @param {string} sId Id of ROM element to replace with control-tree
     * @param {boolean} bSuppress Suppress re-rendering (see
     * UCF_ControlFactory.updateClientControlTree())
     */
    UCF_PageUpdater["prototype"]["updateClientControlTree"] = function (oUpdateRef, sId, bSuppress) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateClientControlTree"]++;
        }
        ;
        /** @type {string} */
        var sControlTree = UCF_PageUpdater["sGetCDATAContent"](oUpdateRef);
        /** @type {UCF_ClientControlTree} */
        var oControlTree;
        /** @type {HTMLElement} */
        var oReplace;
        /** @type {HTMLElement} */
        var oCurrent;
        /** @type {HTMLSpanElement} */
        var oSpan;

        if (sControlTree) {
            // create the object tree for it
            oControlTree = new (UCF_ClassLoader["oGetClass"]("UCF_ClientControlTree"))(
                this["oLS"],
                UCF_ClientControlTree["parse"](sControlTree)
            );

            if (sId !== oControlTree["getRootId"]()) {
                // place into dom element with the given id
                oReplace = UCF_DomUtil["$"](sId);
                oCurrent = UCF_DomUtil["$"](oControlTree["getRootId"]());

                if (oReplace && !oCurrent) {
                    oSpan = document["createElement"]('span');
                    oSpan["setAttribute"]('id', oControlTree["getRootId"]());
                    oReplace["parentNode"]["replaceChild"](oSpan, oReplace);
                }
            }
            //initialize controls of an initial control tree
            this["oLS"]["oControlFactory"]["updateClientControlTree"](oControlTree, bSuppress);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateClientControlTree"] = 0;
    }
    ;

    /**
     * Updates or creates the model. If the model exists and the merge flag is
     * enabled the changes are merged into the existing model, otherwise the model
     * date is completly replaced.
     *
     * @private
     * @param {UCF_PageUpdater_Update} oUpdateRef
     */
    UCF_PageUpdater["prototype"]["updateModel"] = function (oUpdateRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PageUpdater["_"]["updateModel"]++;
        }
        ;
        /** @type {string} */
        var sId = oUpdateRef["getAttribute"]('id');
        /** @type {NodeListOf<HTMLDataElement>} */
        var oDataNodes = oUpdateRef["getElementsByTagName"]('data');
        /** @type {UCF_ModelControl} */
        var oModelControl = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
        /** @type {number} */
        var i;
        /** @type {HTMLDataElement} */
        var oDataNode;
        /** @type {boolean} */
        var bMerge;
        /** @type {string} */
        var sPath;
        /** @type {string} */
        var sData;
        /** @type {Object} */
        var oData;

        if (oModelControl) {
            oModelControl["lock"]();
            this["aUnlockModels"]["push"](oModelControl);

            for (i = 0; i < oDataNodes["length"]; i++) {
                oDataNode = oDataNodes[i];
                bMerge = oDataNode["getAttribute"]('merge') === 'true';
                sPath = oDataNode["getAttribute"]('path');
                sData = UCF_PageUpdater["sGetCDATAContent"](oDataNode);

                if (sData) {
                    oData = UCF_JsUtil["oJsonParse"](sData);

                    if ((oData !== null || oData !== undefined) && oModelControl) {
                        if (sPath) { // eslint-disable-line max-depth
                            oModelControl["setPathData"](sPath, oData, bMerge);
                        } else {
                            oModelControl["setData"](oData, bMerge);
                        }
                    }
                }
            }
        } else {
            this["aMissingModel"]["push"](oUpdateRef);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PageUpdater["_"]["updateModel"] = 0;
    }
    ;

    /* global _assert, _trace, INFO, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_Form */
/// <reference path="../controls/Form.js"/>
    /* global UCF_EventQueueItem */
/// <reference path="./EventQueueItem.js"/>

    /** @typedef {0} UCF_PendingRequest_FormType */
    /** @typedef {1} UCF_PendingRequest_XmlhttpType */
    /** @typedef {2} UCF_PendingRequest_XmlhttpSyncType */

    /** @typedef {UCF_PendingRequest_FormType|UCF_PendingRequest_XmlhttpType|UCF_PendingRequest_XmlhttpSyncType} UCF_PendingRequest_Type */

    /**
     * Single item of the UCF_EventQueue, keeps event data in format
     * suitable for transport.
     *
     *
     * @class
     * @version
     * @param {UCF_EventQueue} oQueue the event queue of this pending request
     */
    function UCF_PendingRequest(oQueue) {
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["UCF_PendingRequest"]++;
        }
        ;
        UCF_EventProvider["apply"](this);

        this["defineEvents"](['Send']);

        /** @type {UCF_EventQueue} */
        this["oQueue"] = oQueue;
        /** @type {UCF_PendingRequest_Type} */
        this["iType"] = UCF_PendingRequest["XMLHTTP"];
        /** @type {UCF_Form} */
        this["oForm"] = null;
        /** @type {string} */
        this["sActionUrl"] = '';
        /** @type {string} */
        this["sFocusIdForRequest"] = '';

        /** @type {number} the number of current operations to wait for */
        this["iSuspendCounter"] = 0;

        /**
         * @type {Object<string,boolean>} a map to identify different objects which
         * are using suspend/resume
         */
        this["mIdMap"] = {};
    };window["UCF_PendingRequest"] = UCF_PendingRequest;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_PendingRequest");
        UCF_PendingRequest["_"] = {UCF_PendingRequest: 0};
    }
    ;
    ;
    UCF_PendingRequest["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_PendingRequest.prototype["sClassName"] = "UCF_PendingRequest";

    /** @type {UCF_PendingRequest_FormType} */
    UCF_PendingRequest["FORM"] = 0;
    /** @type {UCF_PendingRequest_XmlhttpType} */
    UCF_PendingRequest["XMLHTTP"] = 1;
    /** @type {UCF_PendingRequest_XmlhttpSyncType} */
    UCF_PendingRequest["XMLHTTP_SYNC"] = 2;

    /** @override */
    UCF_PendingRequest["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["destroy"]++;
        }
        ;
        this["oQueue"] = null;
        this["iType"] = null;
        this["oForm"] = null;
        this["sActionUrl"] = null;
        this["sFocusIdForRequest"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["destroy"] = 0;
    }
    ;

    /** @param {UCF_Form} oForm */
    UCF_PendingRequest["prototype"]["setForm"] = function (oForm) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["setForm"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oForm instanceof UCF_Form, "oForm instanceof UCF_Form", "PendingRequest.js(73): setForm");
        }
        ;

        this["oForm"] = oForm;
        this["iType"] = UCF_PendingRequest["FORM"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["setForm"] = 0;
    }
    ;

    /** @param {boolean} bSyncExecution */
    UCF_PendingRequest["prototype"]["setSyncExecution"] = function (bSyncExecution) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["setSyncExecution"]++;
        }
        ;
        if (
            this["iType"] === UCF_PendingRequest["XMLHTTP"] ||
            this["iType"] === UCF_PendingRequest["XMLHTTP_SYNC"]
        ) {
            this["iType"] = bSyncExecution
                ? UCF_PendingRequest["XMLHTTP_SYNC"]
                : UCF_PendingRequest["XMLHTTP"];
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, 'Unsupported action for non-XHR request', "PendingRequest.js(89): setSyncExecution");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["setSyncExecution"] = 0;
    }
    ;

    /** @return {UCF_Form} */
    UCF_PendingRequest["prototype"]["oGetForm"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["oGetForm"]++;
        }
        ;
        return this["oForm"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["oGetForm"] = 0;
    }
    ;

    /** @param {string} sActionUrl */
    UCF_PendingRequest["prototype"]["setActionUrl"] = function (sActionUrl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["setActionUrl"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sActionUrl) === 'string', "typeof(sActionUrl) === 'string'", "PendingRequest.js(100): setActionUrl");
        }
        ;

        this["sActionUrl"] = sActionUrl;
        this["iType"] = UCF_PendingRequest["XMLHTTP"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["setActionUrl"] = 0;
    }
    ;

    /** @return {string} */
    UCF_PendingRequest["prototype"]["sGetActionUrl"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["sGetActionUrl"]++;
        }
        ;
        return this["sActionUrl"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["sGetActionUrl"] = 0;
    }
    ;

    /** @return {UCF_EventQueue} */
    UCF_PendingRequest["prototype"]["oGetQueue"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["oGetQueue"]++;
        }
        ;
        return this["oQueue"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["oGetQueue"] = 0;
    }
    ;

    /** @return {number} */
    UCF_PendingRequest["prototype"]["iGetType"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["iGetType"]++;
        }
        ;
        return this["iType"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["iGetType"] = 0;
    }
    ;

    /**
     * Suspend pending request while waiting for some operation to finish
     *
     * @public
     * @param {string} sId an id of the object that wants the request to wait
     */
    UCF_PendingRequest["prototype"]["suspend"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["suspend"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sId) === 'string', "typeof(sId) === 'string'", "PendingRequest.js(128): suspend");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "PendingRequest.js(129): suspend");
        }
        ;

        if (this["mIdMap"][sId]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Object "' + sId + '" has already called suspend on the pending request!', "PendingRequest.js(132): suspend");
            }
            ;
        }

        this["mIdMap"][sId] = true;
        this["iSuspendCounter"]++;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["suspend"] = 0;
    }
    ;

    /**
     * Resume pending request after operating has been completed
     *
     * @public
     * @param {string} sId an id of the object that wants to resume the request
     */
    UCF_PendingRequest["prototype"]["resume"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["resume"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sId) === 'string', "typeof(sId) === 'string'", "PendingRequest.js(146): resume");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "PendingRequest.js(147): resume");
        }
        ;

        if (!this["mIdMap"][sId]) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'Object "' + sId + '" has never suspended the pending request!', "PendingRequest.js(150): resume");
            }
            ;
        }

        this["mIdMap"][sId] = false;
        this["iSuspendCounter"]--;

        if (this["iSuspendCounter"] === 0) {
            this["mIdMap"] = {};
            this["fireEvent"](this["E_EVENTS"]["Send"], {"oPendingRequest": this});
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["resume"] = 0;
    }
    ;

    /**
     * @deprecated Send is no longer supported
     * @public
     */
    UCF_PendingRequest["prototype"]["send"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["send"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(ERROR, 'Send is no longer supported, please use suspend/resume instead.', "PendingRequest.js(167): send");
        }
        ;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["send"] = 0;
    }
    ;

    /**
     * Returns whether the request has been suspended
     *
     * @return {boolean}
     */
    UCF_PendingRequest["prototype"]["bIsSuspended"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["bIsSuspended"]++;
        }
        ;
        return this["iSuspendCounter"] > 0;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["bIsSuspended"] = 0;
    }
    ;

    /**
     * Add a semantic event to the queue of the pending event
     *
     * @public
     * @param {UCF_SemanticEvent} oSemanticEvent
     */
    UCF_PendingRequest["prototype"]["addSemanticEvent"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["addSemanticEvent"]++;
        }
        ;
        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'Semantic event "' + oSemanticEvent["sGetControl"]() + ':' + oSemanticEvent["sGetName"]() + '" occurred, ' + UCF_JsUtil["sJsonStringify"](oSemanticEvent["mGetParameters"]()) + ' ' + UCF_JsUtil["sJsonStringify"](oSemanticEvent["mGetCustomParameters"]()), "PendingRequest.js(186): addSemanticEvent");
        }
        ;

        this["oQueue"]["addItem"](new (UCF_ClassLoader["oGetClass"]("UCF_EventQueueItem"))(oSemanticEvent));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["addSemanticEvent"] = 0;
    }
    ;

    /**
     * Add a focusid to the pending event
     *
     * @public
     * @param {string} sFocusIdForRequest
     */
    UCF_PendingRequest["prototype"]["setFocusIdForRequest"] = function (sFocusIdForRequest) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["setFocusIdForRequest"]++;
        }
        ;
        this["sFocusIdForRequest"] = sFocusIdForRequest;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["setFocusIdForRequest"] = 0;
    }
    ;

    /**
     * Return the focusid for the pending event
     *
     * @public
     * @return {string} the focusid for the pending event
     */
    UCF_PendingRequest["prototype"]["sGetFocusIdForRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["sGetFocusIdForRequest"]++;
        }
        ;
        return this["sFocusIdForRequest"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["sGetFocusIdForRequest"] = 0;
    }
    ;

    /**
     * Returns whether the PendingRequest is async or not
     *
     * @public
     * @return {boolean} PendingRequest is async or not
     */
    UCF_PendingRequest["prototype"]["bAsync"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PendingRequest["_"]["bAsync"]++;
        }
        ;
        return this["oGetQueue"]()["bAsync"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PendingRequest["_"]["bAsync"] = 0;
    }
    ;

    UCF_PendingRequest.prototype["aPublicMethods"] = ["suspend", "resume", "send", "addSemanticEvent", "setFocusIdForRequest", "sGetFocusIdForRequest", "bAsync"].concat(UCF_PendingRequest.prototype.aPublicMethods || []);
    /* global _assert, _trace, INFO */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>

// TODO: reimplement something similar to :  http://www.safalra.com/web-design/javascript/queues/

    /**
     * Class LS WaitingEventsQueue
     *
     * Holds semantic events for delayed processing during pending submits
     * (FIFO mechanism)
     *
     *
     * @class
     * @version
     */
    function UCF_WaitingEventQueue() {
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["UCF_WaitingEventQueue"]++;
        }
        ;
        UCF_Object["apply"](this);
        /** @type {UCF_SemanticEvent[]} */
        this["aQueue"] = [];
        /** @type {boolean} */
        this["bProcessingLock"] = false;
        /** @type {boolean} */
        this["bRefireLock"] = false;

    };window["UCF_WaitingEventQueue"] = UCF_WaitingEventQueue;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_WaitingEventQueue");
        UCF_WaitingEventQueue["_"] = {UCF_WaitingEventQueue: 0};
    }
    ;
    UCF_WaitingEventQueue["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_WaitingEventQueue.prototype["sClassName"] = "UCF_WaitingEventQueue";

    /** @override */
    UCF_WaitingEventQueue["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["destroy"]++;
        }
        ;
        this["bRefireLock"] = null;
        this["bProcessingLock"] = null;
        this["aQueue"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["destroy"] = 0;
    }
    ;

    /**
     * Add a semantic event to the queue
     *
     * @param {UCF_SemanticEvent} oSemanticEvent the event to be added
     * @return {UCF_SemanticEvent}
     */
    UCF_WaitingEventQueue["prototype"]["oEnqueue"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["oEnqueue"]++;
        }
        ;
        /** @type {string} */
        var sControlId = oSemanticEvent["mGetParameters"]()["Id"];
        /** @type {string} */
        var sControlName = oSemanticEvent["sGetControl"]();
        /** @type {string} */
        var sEventName = oSemanticEvent["sGetName"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'ENQUEUE:' + sControlId + ':' + sControlName + ':' + sEventName, "WaitingEventQueue.js(53): oEnqueue");
        }
        ;

        this["aQueue"]["push"](oSemanticEvent);

        return oSemanticEvent;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["oEnqueue"] = 0;
    }
    ;

    /**
     * @param {UCF_SemanticEvent} oSE
     * @return {boolean}
     */
    UCF_WaitingEventQueue["prototype"]["bIsPartialEvent"] = function (oSE) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["bIsPartialEvent"]++;
        }
        ;
        /** @type {UCF_SemanticEvent_UcfParameters} */
        var ucfParam = oSE["mGetUcfParameters"]();
        /** @type {UCF_SemanticEvent_TransportMethod} */
        var sTP;

        if (ucfParam != null) {
            sTP = ucfParam["TransportMethod"];
            if (sTP === 'partial') {
                return true;
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["bIsPartialEvent"] = 0;
    }
    ;

    /**
     * Return the first event and remove it from the queue.
     *
     * @return {UCF_SemanticEvent}
     */
    UCF_WaitingEventQueue["prototype"]["oDequeue"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["oDequeue"]++;
        }
        ;
        /** @type {UCF_SemanticEvent} */
        var oSemanticEvent = this["aQueue"]["shift"]();
        /** @type {string} */
        var sControlId = oSemanticEvent["mGetParameters"]()["Id"];
        /** @type {string} */
        var sControlName = oSemanticEvent["sGetControl"]();
        /** @type {string} */
        var sEventName = oSemanticEvent["sGetName"]();

        if (__UCF_TRACE__) {
            UCF_Tracer.trace(INFO, 'DEQUEUE:' + sControlId + ':' + sControlName + ':' + sEventName, "WaitingEventQueue.js(95): oDequeue");
        }
        ;

        return oSemanticEvent;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["oDequeue"] = 0;
    }
    ;

    /**
     * Return the current length of the queue
     *
     * @return {number} current length of the queue
     */
    UCF_WaitingEventQueue["prototype"]["iGetLength"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["iGetLength"]++;
        }
        ;
        return this["aQueue"]["length"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["iGetLength"] = 0;
    }
    ;

    /** Reset the queue, discard all current queue items */
    UCF_WaitingEventQueue["prototype"]["reset"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["reset"]++;
        }
        ;
        this["aQueue"] = [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["reset"] = 0;
    }
    ;

    /**
     * returns true when the passed semantic event is synchronous (with the lock
     * otherwise false;
     *
     * TODO: fix the constants...
     * @param {UCF_SemanticEvent} oSemanticEvent
     * @return {boolean}
     */
    UCF_WaitingEventQueue["prototype"]["bIsSyncSubmit"] = function (oSemanticEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["bIsSyncSubmit"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oSemanticEvent === 'object', "typeof oSemanticEvent === 'object'", "WaitingEventQueue.js(123): bIsSyncSubmit");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oSemanticEvent != null, "oSemanticEvent != null", "WaitingEventQueue.js(124): bIsSyncSubmit");
        }
        ;

        return oSemanticEvent["mGetUcfParameters"]()["ClientAction"] === 'submit';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["bIsSyncSubmit"] = 0;
    }
    ;

    /**
     * Checks if any synchronous submit if found in the queue,
     *
     * @return {boolean}
     */
    UCF_WaitingEventQueue["prototype"]["bContainsSyncSubmit"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["bContainsSyncSubmit"]++;
        }
        ;
        /** @type {number} */
        var i;

        for (i = 0; i < this["aQueue"]["length"]; i++) {
            if (this["bIsSyncSubmit"](this["aQueue"][i])) {
                return true;
            }
        }

        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["bContainsSyncSubmit"] = 0;
    }
    ;

// ---------------------- locks --------------------------

    /**
     * Return the processing lock state
     *
     * @return {boolean}
     */
    UCF_WaitingEventQueue["prototype"]["bIsProcessingLock"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["bIsProcessingLock"]++;
        }
        ;
        return this["bProcessingLock"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["bIsProcessingLock"] = 0;
    }
    ;

    /**
     * Set a processing lock on the queue
     *
     * @param {boolean} bLock
     */
    UCF_WaitingEventQueue["prototype"]["setProcessingLock"] = function (bLock) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["setProcessingLock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bLock === 'boolean', "typeof bLock === 'boolean'", "WaitingEventQueue.js(164): setProcessingLock");
        }
        ;

        this["bProcessingLock"] = bLock;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["setProcessingLock"] = 0;
    }
    ;

    /**
     * Return the refire lock state
     *
     * @return {boolean}
     */
    UCF_WaitingEventQueue["prototype"]["bIsRefireLock"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["bIsRefireLock"]++;
        }
        ;
        return this["bRefireLock"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["bIsRefireLock"] = 0;
    }
    ;

    /**
     * Set a refire lock on the queue
     *
     * @param {boolean} bLock
     */
    UCF_WaitingEventQueue["prototype"]["setRefireLock"] = function (bLock) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_WaitingEventQueue["_"]["setRefireLock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof bLock === 'boolean', "typeof bLock === 'boolean'", "WaitingEventQueue.js(184): setRefireLock");
        }
        ;

        this["bRefireLock"] = bLock;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_WaitingEventQueue["_"]["setRefireLock"] = 0;
    }
    ;

    /* global _trace, WARNING */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_RequestUtil */
/// <reference path="../../core/util/RequestUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_Object */
/// <reference path="../../core/Object.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="../core/ResourceUtil.js"/>
    /* global UCF_System */
/// <reference path="../core/System.js"/>
    /* global UCF_Properties */

    /**
     * The class to load the appropriate message bundle from the server and provide
     * access to translatable texts by key
     * @class
     *
     * @version
     */
    function UCF_MessageBundle() {
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["UCF_MessageBundle"]++;
        }
        ;

        UCF_Object["apply"](this);

        this["bUseXHR"] = window["UCF_System"]["bUseXHR"] && (window["UCF_System"]["bUseActiveX"] || !(UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()));

        if (!this["bUseXHR"]) {
            this["loadTexts"]();
        }
        this["sLanguage"] = "en";

    };window["UCF_MessageBundle"] = UCF_MessageBundle;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_MessageBundle");
        UCF_MessageBundle["_"] = {UCF_MessageBundle: 0};
    }
    ;
    ;
    UCF_MessageBundle["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Object"))();
    UCF_MessageBundle.prototype["sClassName"] = "UCF_MessageBundle";
    UCF_MessageBundle["mTexts"] = null;

    /** @override */
    UCF_MessageBundle["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["destroy"]++;
        }
        ;
        this["bUseXHR"] = null;
        this["sLanguage"] = null;
        this["sFindMessageBundle"] = null;

        UCF_Object.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_MessageBundle["_"]["destroy"] = 0;
    }
    ;

    /**
     * Returns a translated text for a given key
     *
     * @param {string} sKey
     * @param {Array} aVars Array of variables to be replaced in the text
     * @return {string}
     */
    UCF_MessageBundle["prototype"]["sGetText"] = function (sKey, aVars) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["sGetText"]++;
        }
        ;
        var sText = this["sGetRawText"](sKey);

        if (sText) {
            if (aVars) {
                for (var i = 0; i < aVars["length"]; i++) {
                    sText = sText["replace"]("{" + i + "}", aVars[i]);
                }
            }
            return sText;
        } else {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(WARNING, "no text maintained for key " + sKey, "MessageBundle.js(68): sGetText");
            }
            ;
            return "";
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_MessageBundle["_"]["sGetText"] = 0;
    }
    ;

    /**
     * Returns a translated text for a given key or a empty string if key doesn't exist
     *
     * @param {string} sKey
     * @return {string} translated text
     */
    UCF_MessageBundle["prototype"]["sGetRawText"] = function (sKey) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["sGetRawText"]++;
        }
        ;
        if (!UCF_MessageBundle["mTexts"]) this["loadTexts"]();

        if (UCF_MessageBundle["mTexts"])
            return UCF_MessageBundle["mTexts"][sKey];
        else
            return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_MessageBundle["_"]["sGetRawText"] = 0;
    }
    ;

    /**
     * Loads texts from a property file on the server and adds a js mat to access them on the client
     * @return {none}
     */
    UCF_MessageBundle["prototype"]["loadTexts"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["loadTexts"]++;
        }
        ;
        if (UCF_MessageBundle["mTexts"] != null)
            return;
        var sLanguage = window["UCF_System"]["sLanguage"]["replace"]("-", "_"),
            sVersion = window["UCF_System"]["sClientVersionKey"],
            sMessageBundlePath = UCF_ResourceUtil["sGetMessageBundlesRoot"]() + "/",
            sMessageBundle = "messagebundle",
            sExtension = ".properties";

        if (sLanguage["length"] > 0) sMessageBundle += "_" + sLanguage;
        if (!this["sFindMessageBundle"]) this["sFindMessageBundle"] = sMessageBundle;

        var oResponse = {"bSuccess": false},
            sFindMessageBundle = this["sFindMessageBundle"],
            sLoadedLanguage = "en";
        var iLastScore;
        if (!this["bUseXHR"]) {
            oResponse["sText"] = UCF_Properties[sFindMessageBundle];
            oResponse["bSuccess"] = oResponse["sText"] && oResponse["sText"] != null;
            while (!oResponse["bSuccess"] && sFindMessageBundle["length"] > 0) {
                iLastScore = sFindMessageBundle["lastIndexOf"]("_");
                if (iLastScore > 0) {
                    sFindMessageBundle = sFindMessageBundle["substring"](0, iLastScore);
                } else {
                    break; //No truncation possible anymore
                }

                this["sFindMessageBundle"] = sFindMessageBundle;
                UCF_DomUtil["$"]("ls-messagebundle")["src"] = sMessageBundlePath + sFindMessageBundle + ".js" + (sVersion !== "" ? ("?" + sVersion) : "");
                UCF_JsUtil["delayedCall"](250, this, "loadTexts");
                return;
            }
        } else {
            while (!oResponse["bSuccess"] && sFindMessageBundle["length"] > 0) {
                var iLastDash = sFindMessageBundle["lastIndexOf"]("-");
                iLastScore = sFindMessageBundle["lastIndexOf"]("_");
                sLoadedLanguage = sFindMessageBundle;
                oResponse = UCF_RequestUtil["sendSyncRequest"](sMessageBundlePath + sFindMessageBundle + sExtension + (sVersion !== "" ? ("?" + sVersion) : ""));

                if (iLastDash > 0) {
                    sFindMessageBundle = sFindMessageBundle["substring"](0, iLastDash);
                } else if (iLastScore > 0) {
                    sFindMessageBundle = sFindMessageBundle["substring"](0, iLastScore);
                } else {
                    break; //No truncation possible anymore
                }
            }
        }

        //set the loaded language for the getter sGetLanguage that is used for date formatting
        //depending on the loaded language a toLowercase is needed
        if (sLoadedLanguage["indexOf"]("_") > -1) sLoadedLanguage = sLoadedLanguage["substring"](sLoadedLanguage["indexOf"]("_") + 1);
        else sLoadedLanguage = "en";
        this["sLanguage"] = sLoadedLanguage;

        if (oResponse["bSuccess"]) {
            var aLines = oResponse["sText"]["split"]("\n");
            UCF_MessageBundle["mTexts"] = {};
            for (var i = 0; i < aLines["length"]; i++) {
                if (aLines[i]["indexOf"]("#") === 0) continue;
                var iSeperatorPos = aLines[i]["indexOf"]("="),
                    sKey = aLines[i]["substring"](0, iSeperatorPos),
                    sValue = aLines[i]["substring"](iSeperatorPos + 1)["replace"](/^\s+|\s+$/, '');
                sValue = sValue["replace"](/"/g, '\\\"');
                sValue = sValue["replace"](/\\:/g, ':'); // just a work around for malformed entries
                sValue = sValue["replace"](/\r|\n/g, '');
                try {
                    UCF_MessageBundle["mTexts"][sKey] = UCF_JsUtil["oJsonParse"]('"' + sValue + '"');
                } catch (e) {
                }
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_MessageBundle["_"]["loadTexts"] = 0;
    }
    ;

    /**
     * Returns the language that is currently loaded
     * @return {string}
     */
    UCF_MessageBundle["prototype"]["sGetLanguage"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_MessageBundle["_"]["sGetLanguage"]++;
        }
        ;
        return this["sLanguage"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_MessageBundle["_"]["sGetLanguage"] = 0;
    }
    ;

    /* global _assert, _trace, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../core/EventProvider.js"/>
    /* global UCF_BrowserWindow */
/// <reference path="../browser/BrowserWindow.js"/>
    /* global UCF_Control */
/// <reference path="../core/Control.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_System */
/// <reference path="../core/System.js"/>
    /* global UCF_BlockLayer */

/// <reference path="./BlockLayer.js"/>

    /**
     * A helper class which manages the popups, the blocklayer etc
     * @class
     * @extends UCF_EventProvider
     * @param {UCF_LS} oLS LS instance
     */
    function UCF_PopupManager(oLS) {
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["UCF_PopupManager"]++;
        }
        ;
        UCF_EventProvider["apply"](this);


        /**
         * Internal events: They will be fired only from the "Main" PopupManager -
         * that is the instance attached to the Main-LS-isntance.
         * Registration:
         * <code>UCF_LS.oGetMainLS().oGetPopupManagerInternal().attach(...)</code>
         */
        this["defineEvents"]([
            /** IFrame-Popup: IFrame was loaded (PopupWindow instance will not exist yet) */
            'WindowOpen',
            'WindowClose',
            /** Div- or IFrame-PopupWindow instance is rendered and initialized */
            'PopupOpen',
            'PopupClose'
        ]);

        this["oLS"] = oLS;
        this["oPopupWindows"] = null;
        //this.sFocussedElementId = null; unused...

        this["aLSLoaded"] = [];
        this["aPopups"] = new Array();
        //this.aPopupIDsForLayering = new Array();

        //special mode: blocklayer is only in main LS
        //currently not used
        this["bBlocklayerLocal"] = false; // eslint-disable-line ur/no-memory-leaks
        this["bBlockLayerShaded"] = true; // eslint-disable-line ur/no-memory-leaks

        // Cache the Iframe which have been in use
        // Disable IFRame-reuse in FF which caused very strange problems.
        // It would refuse to load the template html page from WDA (in a single custom application)
        this["bIframeCaching"] = UCF_UserAgent["bIsFirefox"]() ? false : true; // eslint-disable-line ur/no-memory-leaks

        //this.oLS.attachEvent(this.oLS.E_EVENTS.UpdateComplete, this, "onUpdateComplete");
        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], this, "onPendingRequest");
        this["oDocument"] = window["document"];
        this["oTopWindow"] = null;

        this["bIFrameLoadingInProgress"] = false;
    };window["UCF_PopupManager"] = UCF_PopupManager;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_PopupManager");
        UCF_PopupManager["_"] = {UCF_PopupManager: 0};
    }
    ;
    ;

    UCF_PopupManager["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_PopupManager.prototype["sClassName"] = "UCF_PopupManager";

    UCF_PopupManager["IFRAME_PREFIX"] = "URLSPW-";
    UCF_PopupManager["ZINDEX_INCREMENT"] = 100;

    /**
     * @public
     * Enumerations for the display mode of the popup
     *
     * MODAL: with blocklayer
     * AMODAL: without blocklayer
     * FLOATING: without blocklayer always on top
     */
    UCF_PopupManager["prototype"]["DISPLAY_MODE"] = {
        "MODAL": "MODAL",
        "AMODAL": "AMODAL",
        "FLOATING": "FLOATING" //only ITS
    };

    /**
     * @return {Array} the internal popups array
     */
    UCF_PopupManager["prototype"]["aGetPopups"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["aGetPopups"]++;
        }
        ;
        if (this["oMainLS"]) {

            //CSN 700265 2010
            //we cannot determine if this popupmanager is the root popup manager since
            //we cannot depend on comparing the mainLS to a nulled this.oLS
            //-> so return the empty array to prevent endless loop in else part
            if (this["oLS"] == null) {
                return [];
            }
            if (this["oMainLS"] == this["oLS"]) {
                return this["aPopups"];
            } else {
                return this["oMainLS"]["oGetPopupManagerInternal"]()["aGetPopups"]();
            }
        }

        //no main ls yet -> find it
        var oIFrame = this["oLS"]["oGetPopupIFrame"]();

        if (oIFrame) {
            //iframe found -> mainLS is attached to the host window
            var sId = oIFrame["getAttribute"]("PWID");

            var oHW = this["oGetHostWindow"]();

            this["oMainLS"] = oHW["MAINLS_" + sId];
            // if (this.oMainLS === null || this.oMainLS === undefined) {
            //     return [];
            // }

            //avoid mem leaks!
            oHW["MAINLS_" + sId] = null;

        } else {
            //no iframe -> runs in mainLS
            this["oMainLS"] = this["oLS"];
        }

        return this["aGetPopups"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["aGetPopups"] = 0;
    }
    ;

    /**
     * Creates a modal popup window
     * @public
     * @param {String} sId the id of the popup
     * @param {String} sURL the URL which should be loaded into the popup
     * @param {window} oOpenerWindow the window of the opening application (optional if no oOnloadCallbackMethod)
     * @param {function} oOnloadCallbackMethod - a arbitrary callbackmethod which will
     * be called with the parameters (oSourceWindow,sId)
     */
    UCF_PopupManager["prototype"]["showModalDialog"] = function (sId, sURL, oOpenerWindow, oOnloadCallbackMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["showModalDialog"]++;
        }
        ;

        if (!oOpenerWindow) oOpenerWindow = window;

        if (!oOnloadCallbackMethod) oOnloadCallbackMethod = null;

        this["createPopupWindow"](oOpenerWindow, sURL, sId, oOnloadCallbackMethod, this["DISPLAY_MODE"]["MODAL"]);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["showModalDialog"] = 0;
    }
    ;

    /**
     * Creates a PopupWindow instance.
     *
     * @public
     *
     * @param {window} oOpenerWindow the window of the opening application / popup
     * @param {String} sURL the URL which should be loaded into the popup
     * @param {String} sId the id of the popup - must be identical with the PopupWindow control opened in the iframe
     * @param {function} oOnloadCallbackMethod - a arbitrary callbackmethod which will
     * be called with the parameters (oSourceWindow,sId)
     * @param {string} sDisplayMode (default if undefinded), AMODAL, FLOATING
     */
    UCF_PopupManager["prototype"]["createPopupWindow"] = function (oOpenerWindow, sURL, sId, oOnloadCallbackMethod, sDisplayMode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["createPopupWindow"]++;
        }
        ;
        if (!sDisplayMode) sDisplayMode = this["DISPLAY_MODE"]["MODAL"];
        if (sURL) {
            // WDA calls createPopupWindow always on the parent LS instance
            // In ITS and WDJ createPopupWindow is always called on the MAIN LS instance.
            // This would only lock the MAIN LS, but it seems we also need to lock the parent LS in this case, otherwise strange stuff can happen.
            var upperMostBrowserWindow = null;
            if (sDisplayMode == this["DISPLAY_MODE"]["MODAL"] && sURL) {
                var upperMostPopup = this["oGetLastModalPopup"]();
                upperMostBrowserWindow = this["oLS"]["oBrowserWindow"];
                if (upperMostPopup && upperMostPopup["ucfPopupWindow"]) {
                    upperMostBrowserWindow = upperMostPopup["ucfPopupWindow"]["oLS"]["oBrowserWindow"];
                }

                upperMostBrowserWindow["lock"](UCF_BrowserWindow["LOCKTYPES"]["POPUP"]);
            }

            var oIFrame = this["createIFrame"](sURL, oOpenerWindow);

            // Flag is only for testability support
            this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]()["bIFrameLoadingInProgress"] = true;

            //store opener ls to retrieve it later
            this["oGetHostWindow"]()["MAINLS_" + sId] = this["oLS"]["oGetMainLS"]();
            oIFrame["setAttribute"]("PWID", sId);

            this["addPopup"](oOpenerWindow, sId, sDisplayMode, oIFrame, upperMostBrowserWindow, false);

            var oPopupManager = this;

            var f = function () {
                if (oOnloadCallbackMethod) oOnloadCallbackMethod(oOpenerWindow, sId);

                // SVG loading optimization - see UCF_ResourceUtil.sInlineSvgByHtmlExchange():
                // LS must be initiaized in the empty "template" popup, so that oIFrame.contentWindow.UCF_ResourceUtil is available.
                // This should work, because the WDA or WebGUI onload handler, which creates the LS instance,
                // is alway called before this handler, because it is attached first in the page header (in WebGUI)
                if (oIFrame["contentWindow"]["UCF_ResourceUtil"] && oOpenerWindow["UCF_ResourceUtil"]) {
                    oIFrame["contentWindow"]["UCF_ResourceUtil"]["bSVGEnabled"] = oOpenerWindow["UCF_ResourceUtil"]["bSVGEnabled"];
                }

                //fire the window open event in the main window where the pageupdater is waiting for the event to process
                //the update for the popupwindows (needed in wd java where thomas only loads a template-> no register)
                var oMainPopupManager = oPopupManager["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]();
                oMainPopupManager["fireEvent"](oMainPopupManager["E_EVENTS"]["WindowOpen"], {
                    "oTargetLS": oMainPopupManager["aLSLoaded"][sId],
                    "sPopupId": sId
                });
                delete oMainPopupManager["aLSLoaded"][sId];

                if (sURL) UCF_DomUtil["detachEvent"](oIFrame, "load", f);
                oMainPopupManager["bIFrameLoadingInProgress"] = false;
                f = null;
            };

            if (sURL) UCF_DomUtil["attachEvent"](oIFrame, "load", f);
        } else {
            //when popup has already been opened and should be re-opened
            var oPopupWindow = this["oLS"]["oControlFactory"]["oGetControlById"](sId);
            if (oPopupWindow) oPopupWindow["initialize"]();
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["createPopupWindow"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["bIFrameIsLoading"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["bIFrameIsLoading"]++;
        }
        ;
        return this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]()["bIFrameLoadingInProgress"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["bIFrameIsLoading"] = 0;
    }
    ;

    /**
     * Notification from DIV-Popup that is is re-initialized (during update)
     * To co-exist with popups that are destroyed/added (with a new ID) in the same update
     * we must reflect the order of initialize() calls in the internal aPopups array!
     * So instead of calling addPopup() this function will move the popup
     * to the upper/top position (highest index in array).
     * @param {UCF_PopupWindow} oPopup
     */
    UCF_PopupManager["prototype"]["reInitDivPopup"] = function (oPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["reInitDivPopup"]++;
        }
        ;

        // TODO: Remove this? Currently only tested for WebGUI.
        if (!this["oLS"]["bIsAlternativeKeyboardHandling"]()) return;

        var aPopupList = this["aGetPopups"]();
        var iFound = -1;
        for (var x = 0; x < aPopupList["length"] && iFound === -1; x++) {
            if (!aPopupList[x]) continue;
            if (!aPopupList[x]["ucfPopupWindow"]) continue;
            if (aPopupList[x]["ucfPopupWindow"] === oPopup) iFound = x;
        }
        if (iFound > -1 && iFound < aPopupList["length"] - 1) {
            // Move to last position
            aPopupList[aPopupList["length"]] = aPopupList[iFound];
            aPopupList["splice"](iFound, 1);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["reInitDivPopup"] = 0;
    }
    ;

    /**
     * Adds info to the internal registry of popup instances. Called by Popup during the first initialize() call but
     * not for updates (re-initialize).
     * @param {window} oOpenerWindow
     * @param {string} sId
     * @param {string} sDisplayMode @see UCF_PopupManager.prototype.DISPLAY_MODE
     * @param {HTML_Element} oContainer
     * @param {UCF_BrowserWindow} [oLockedParentWindow]
     * @param {boolean} bIsDivPopup
     */
    UCF_PopupManager["prototype"]["addPopup"] = function (oOpenerWindow, sId, sDisplayMode, oContainer, oLockedParentWindow, bIsDivPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["addPopup"]++;
        }
        ;
        var aPopupList = this["aGetPopups"]();
        var iIndex = aPopupList["length"];
        aPopupList[iIndex] = {
            "sId": sId,
            "oOpenerWindow": oOpenerWindow,
            "oLS": this["oLS"], // "opener" LS
            "oContainer": oContainer,
            //focussedElementId: this.oLS.sGetFocusedElementId(), unused...
            "sDisplayMode": sDisplayMode,
            // Special "opener" LS for ITS - set below
            "oParentPopupLS": null,
            // If not null, this BrowserWindow was locked at the beginning of createPopupWindow() as the "uppermost" modal PW instance
            "oLockedParentWindow": oLockedParentWindow,
            "bIsDivPopup": bIsDivPopup
        };

        // Note on Opener-LS:
        // Scenario with two or more modal popups: In WDA the opener LS is always correct, because they call createPopupWindow()
        // in an update script. So the PageUpdater of the LS instance inside the parent popup is used and this.oLS above is correct.
        //
        // ITS: The ITS always calls createPopupWindow() for the main LS instance. If the opener-LS is not correct, refocusing the parent
        // popup in PopupWindow().close() will not work.
        // Fix:
        // Opener-LS is the instance of the last modal popup (if there is an top-most model popup
        // the event could have originated only from it because all other LS instances are locked).
        // Unfort. it is not possible to set the opener-LS in the data because ITS also calls oGetOpenerLSByPopupId() and expects the main LS instance.
        // => Special attribute for ITS: oParentPopupLS
        //
        if (this["oLS"]["bIsAlternativeKeyboardHandling"]()) {
            // Note: when several popups are opened at the same time, ucfPopupWindow might not exist yet
            if (iIndex > 0 && aPopupList[iIndex - 1]["ucfPopupWindow"] && aPopupList[iIndex - 1]["sDisplayMode"] == this["DISPLAY_MODE"]["MODAL"]) {
                aPopupList[iIndex]["oParentPopupLS"] = aPopupList[iIndex - 1]["ucfPopupWindow"]["oLS"];
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["addPopup"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["handleLSloaded"] = function (oLS, sPopupId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["handleLSloaded"]++;
        }
        ;

        this["aLSLoaded"][sPopupId] = oLS;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["handleLSloaded"] = 0;
    }
    ;

    /**
     * Creates a iframe and loads the url in it
     * the iframe is hidden until the PopupWindow Control renders
     *
     * @private
     * @param {String} sURL
     * @param {HTMLElement} oOpenerWindow
     * @return {HTMLElement}
     */
    UCF_PopupManager["prototype"]["createIFrame"] = function (sURL, oOpenerWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["createIFrame"]++;
        }
        ;

        var oHostDocument = this["oGetHostWindow"]()["document"];
        var baseURL;
        // Make relative URL absolute
        if (UCF_StringUtil["sTrim"](sURL)["indexOf"]("http") !== 0) {
            if (sURL["charAt"](0) === "/") {
                baseURL = oOpenerWindow["location"]["protocol"] + "//" + oOpenerWindow["location"]["host"];
            } else {
                baseURL = oOpenerWindow["location"]["protocol"] + "//" + oOpenerWindow["location"]["host"] + oOpenerWindow["location"]["pathname"];
                baseURL = baseURL["substr"](0, baseURL["lastIndexOf"]("/") + 1);
            }
            sURL = baseURL + sURL;
        }

        var index = 0,
            sIframeId = null,
            oIFrame = null,
            oLastInUseIFrame = null;
        for (; true; index++) {
            sIframeId = UCF_PopupManager["IFRAME_PREFIX"] + index;
            oIFrame = oHostDocument["getElementById"](sIframeId);

            if (oIFrame == null) break; //create one

            if (!UCF_UserAgent["bIsStandardsMode"]() && oIFrame["getAttribute"]("allowTransparency") && oOpenerWindow && (oOpenerWindow["document"]["getElementsByTagName"]("object")["length"] > 0 || oOpenerWindow["document"]["getElementsByTagName"]("embed")["length"] > 0)) {
                // If in Std. Mode (IE): Must not reuse IFrame with allowTransparency if opener window contains active content
                // see also: PopupWindow.openLayeredControl()
                break;
            }

            if (oIFrame["getAttribute"]("inuse") === "false") {
                //reuse
                oIFrame["style"]["display"] = "block";

                //Do not modify IFrame source after Iframe was created, otherwise the Iframe URL will be put in the
                //browser history and the backprevention will not work anymore.
                //oIFrame.setAttribute("src", sURL); would update the browser history
                oIFrame["contentWindow"]["document"]["location"]["replace"](sURL);

                oIFrame["setAttribute"]("inuse", "true");
                if (!(UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsWebKit"]())) {
                    oIFrame["style"]["width"] = "100px";
                    oIFrame["style"]["height"] = "50px";
                }
                oIFrame["style"]["top"] = "-5000px";
                return oIFrame;
            }
            // else: inuse == true
            oLastInUseIFrame = oIFrame;
        }

        oIFrame = oHostDocument["createElement"]("IFRAME");
        oIFrame["setAttribute"]("frameBorder", "no");
        oIFrame["setAttribute"]("id", sIframeId);
        oIFrame["setAttribute"]("name", sIframeId);
        oIFrame["setAttribute"]("tabIndex", "-1");
        //oIFrame.setAttribute("scrolling", "no");
        oIFrame["setAttribute"]("inuse", "true");
        //removed, reason: iframe was behind PDFs
        //    if (UCF_UserAgent.bIsIE(9) || UCF_UserAgent.bIsGecko() || UCF_UserAgent.bIsWebKit()) {
        //        oIFrame.setAttribute("allowTransparency", "-1");
        //    }

        //mark iframe as Lightspeed Popup
        oIFrame["setAttribute"](this["oLS"]["M_CONSTANTS"]["LSPOPUP"], "true");

        var style = oIFrame["style"];

        style["position"] = "absolute";
        if (!(UCF_UserAgent["bIsIOS"]() && UCF_UserAgent["bIsWebKit"]())) {
            style["width"] = "100px";
            style["height"] = "50px";
        }
        style["display"] = "block";
        style["left"] = "30px";
        style["top"] = "-5000px";
        style["zIndex"] = UCF_LS["E_LAYERS"]["POPUPWINDOWS"];

        //order is important: FF?
        oIFrame["setAttribute"]("src", sURL);

        if (oLastInUseIFrame && oLastInUseIFrame["nextSibling"]) {
            // We have to support nested PopupWindow from different LS instances
            // e.g. ITS transaction running inside a IFrame inside a WDA Popup and opens another Popup from ITS...
            // They have the same zindex but the order is determined by the DOM order
            // TODO: this will not work if we take a cached (inuse=false) IFrame in the code above  (!!)
            oHostDocument["body"]["insertBefore"](oIFrame, oLastInUseIFrame["nextSibling"]);
        } else {
            oHostDocument["body"]["insertBefore"](oIFrame, oHostDocument["body"]["firstChild"]);
        }

        return oIFrame;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["createIFrame"] = 0;
    }
    ;

// /**
//  * Add the ID of a DIV-popup to the list during an page update.
//  * This can be done by the framework in a script-call. The sequence of calls
//  * will reflect the order of the popup, but it is only valid during a single page-update.
//  * @public
//  * @param {string} sId The popup ID
//  */
// UCF_PopupManager.prototype.pushDivPopupId = function(sId) {
// 	this.aPopupIDsForLayering.push(sId);
// };


// /**
//  * Handles the event to calculate the z-index values for all DIV-popups
//  * in a single page update.
//  */
// UCF_PopupManager.prototype.onUpdateComplete = function() {
// 	if (this.aPopupIDsForLayering.length === 0) return;

// 	for (var p = 0; p < this.aPopupIDsForLayering.length - 1; p++) {
// 		this.updateZIndices(
// 		this.oGetPopupById(
// 				this.aPopupIDsForLayering[p]
// 			)
// 		);
// 	}
// 	this.aPopupIDsForLayering = new Array();
// };

    /**
     * Notifies that the given PopupWindow control is loaded
     * and can be managed by the PopupManager. DIV-popups must call addPopup() before!
     *
     * @param {UCF_PopupWindow} oPopup
     */
    UCF_PopupManager["prototype"]["register"] = function (oPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["register"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {

            if (popups[x] && popups[x]["oContainer"] === oPopup["oContainer"]) {
                popups[x]["ucfPopupWindow"] = oPopup;
                if (popups[x]["sDisplayMode"] === this["DISPLAY_MODE"]["MODAL"] && !popups[x]["bIsDivPopup"]) {
                    popups[x]["oLS"]["oBrowserWindow"]["lock"](UCF_BrowserWindow["LOCKTYPES"]["POPUP"]);
                }
                break;
            }

        }
        //if (!oPopup.bIsDivPopup || oPopup.bIsDivPopup && this.aPopupIDsForLayering.length === 0) {
        this["updateZIndices"](oPopup);
        //}
        // else: If Framework provided layering information calculate z-indices in onUpdateComplete()

        var oMainPopupManager = this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]();

        // Send open event after z-indices have been calculated
        oMainPopupManager["fireEvent"](oMainPopupManager["E_EVENTS"]["PopupOpen"], {
            "sPopupId": oPopup["sId"]
        });

        // Resume a possible pending request
        if (oMainPopupManager["oPendingRequest"] && !this["bHasPendingPopups"]()) {
            oMainPopupManager["oPendingRequest"]["resume"](this["sClassName"]);
            oMainPopupManager["oPendingRequest"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["register"] = 0;
    }
    ;

    /**
     * onPendingRequest
     *
     * suspends a pending requests if any occurs
     * @param {object} oEvent
     */
    UCF_PopupManager["prototype"]["onPendingRequest"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["onPendingRequest"]++;
        }
        ;

        //only do it in the main ls
        if (this["oLS"]["bIsMainLS"]() && this["bHasPendingPopups"]()) {
            this["oPendingRequest"] = oEvent["oGetParam"]("oPendingRequest");
            this["oPendingRequest"]["suspend"](this["sClassName"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["onPendingRequest"] = 0;
    }
    ;
    /**
     * bHasPendingPopups
     *
     * @return {boolean} true if at least one popup has not yet registered itself
     */
    UCF_PopupManager["prototype"]["bHasPendingPopups"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["bHasPendingPopups"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            //pending means, ucf control popupwindow is not yet there
            if (!popups[x]["ucfPopupWindow"]) return true;
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["bHasPendingPopups"] = 0;
    }
    ;

    /**
     *
     * @param {UCF_PopupWindow} ucfPopup
     */
    UCF_PopupManager["prototype"]["popupMoved"] = function (ucfPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["popupMoved"]++;
        }
        ;

        if (this["oBlockLayer"]) this["oBlockLayer"]["resizeBlocklayer"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["popupMoved"] = 0;
    }
    ;

    /**
     * Notifies the PopupManager that the popup has been deleted
     *
     * @param {string} sPopupId
     */
    UCF_PopupManager["prototype"]["unregister"] = function (sPopupId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["unregister"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (!popups[x]["ucfPopupWindow"]) continue;

            if (popups[x]["ucfPopupWindow"]["sId"] == sPopupId) {
                var oOpenerLS = popups[x]["oLS"];
                var oLockedParentWindow = popups[x]["oLockedParentWindow"];

                var bIsDivPW = popups[x]["bIsDivPopup"];
                if (!bIsDivPW) {
                    oOpenerLS["oBrowserWindow"]["detachEvent"](oOpenerLS["oBrowserWindow"]["E_EVENTS"]["Focus"], popups[x]["ucfPopupWindow"]);
                }

                //order is important! be careful when modifying
                popups["splice"](x, 1);

                this["updateZIndices"]();

                if (!bIsDivPW) {
                    oOpenerLS["applyStoredFocus"](); // Div popup does not have "stored focus" feature because there is no "stack" of LS instances

                    var oUnlockHere = oLockedParentWindow ? oLockedParentWindow : oOpenerLS["oBrowserWindow"];
                    oUnlockHere["unlock"](UCF_BrowserWindow["LOCKTYPES"]["POPUP"]);
                }

                var oMainPopupManager = this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]();
                oMainPopupManager["fireEvent"](oMainPopupManager["E_EVENTS"]["PopupClose"], {"sPopupId": sPopupId});

                break;
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["unregister"] = 0;
    }
    ;

    /**
     * Returns the index of the popup in the popup array
     *
     * @param {UCF_PopupWindow} oUcfPopup
     * @return {number}
     */
    UCF_PopupManager["prototype"]["getIndexOfPopup"] = function (oUcfPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["getIndexOfPopup"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;
            if (!popups[x]["ucfPopupWindow"]) continue;
            if (popups[x]["ucfPopupWindow"] == oUcfPopup) return x;
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["getIndexOfPopup"] = 0;
    }
    ;

    /**
     * Returns the length of the internal popups array
     * @return {number}
     */
    UCF_PopupManager["prototype"]["iGetPopupCount"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["iGetPopupCount"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        return popups["length"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["iGetPopupCount"] = 0;
    }
    ;

    /**
     * Returns the next popup instance in the internal array, or null
     * @param {UCF_PopupWindow} oUcfPopup
     * @return {UCF_PopupWindow|null}
     */
    UCF_PopupManager["prototype"]["oGetNextPopup"] = function (oUcfPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetNextPopup"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        var iFound = -1;
        for (var x = 0; x < popups["length"] && iFound === -1; x++) {
            if (!popups[x]) continue;
            if (!popups[x]["ucfPopupWindow"]) continue;
            if (popups[x]["ucfPopupWindow"] == oUcfPopup) iFound = x;
        }
        if (iFound > -1 && iFound < popups["length"] - 1) {
            return popups[iFound + 1]["ucfPopupWindow"];
        } else {
            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetNextPopup"] = 0;
    }
    ;

    /**
     * Returns the top modal PopupWindow instance or null.
     * @return {UCF_PopupWindow|null}
     * @public
     */
    UCF_PopupManager["prototype"]["oGetTopPopup"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetTopPopup"]++;
        }
        ;
        var oEntry = this["oGetLastModalPopup"]();
        return oEntry ? oEntry["ucfPopupWindow"] : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetTopPopup"] = 0;
    }
    ;

    /**
     * Returns the length of the internal popups array
     * @param {UCF_PopupWindow} oUcfPopup
     * @return {number}
     */
    UCF_PopupManager["prototype"]["getPopupCount"] = function (oUcfPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["getPopupCount"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        return popups["length"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["getPopupCount"] = 0;
    }
    ;

    /**
     *  Sets the host window to be used to create IFrames.
     *  @public
     *  @param {window} oHostWindow The host window reference
     */
    UCF_PopupManager["prototype"]["setHostWindow"] = function (oHostWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["setHostWindow"]++;
        }
        ;
        UCF_DomUtil["oGetTopWindow"]()["MAINLS_HOSTWINDOW"] = oHostWindow;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["setHostWindow"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["oGetHostWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetHostWindow"]++;
        }
        ;
        this["oTopWindow"] = this["oTopWindow"] || UCF_DomUtil["oGetTopWindow"]();
        var oHostWindow = this["oTopWindow"]["MAINLS_HOSTWINDOW"];
        try {
            return (oHostWindow && oHostWindow["document"] ? oHostWindow : this["oTopWindow"]);
        } catch (e) {
            // IE: oHostWindow.document may result in permission denied
            // (weird scenario with WebGUI embeded in WDA-IFrame and popups opened on both instances)
            return this["oTopWindow"];
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetHostWindow"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["focusUpperMostPopup"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["focusUpperMostPopup"]++;
        }
        ;
        var lastModalPopup = this["oGetLastModalPopup"]();

        if (lastModalPopup && lastModalPopup["ucfPopupWindow"]) {
            lastModalPopup["ucfPopupWindow"]["focus"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["focusUpperMostPopup"] = 0;
    }
    ;

    /**
     * Updates the z-index of all popups and the blocklayer
     * @param {UCF_PopupWindow} oFocussedPopup The the top-most / active popup
     *
     * @private
     */
    UCF_PopupManager["prototype"]["updateZIndices"] = function (oFocussedPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["updateZIndices"]++;
        }
        ;

        var iZIndex = UCF_LS["E_LAYERS"]["POPUPWINDOWS"];

        var nextZIndex = function () {
            var iResult = iZIndex;
            iZIndex += UCF_PopupManager["ZINDEX_INCREMENT"];
            if (iZIndex > UCF_LS["E_LAYERS"]["POPUPMENUS"]) {
                // This should not happen in real applications, we have room for 100 nested popups...
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(ERROR, "Too many nested PopupWindow controls", "PopupManager.js(680): updateZIndices");
                }
                ;
            }
            return iResult;
        };

        //no modal popup -> no blocklayer needed
        var bBLHidden = false;
        if (!this["oGetLastModalPopup"]()) {
            if (this["oBlockLayer"]) {
                this["oBlockLayer"]["hide"]();
                bBLHidden = true;
            }
        }

        var popups = this["aGetPopups"]();
        var oLastModal = this["oGetLastModalPopup"]();
        var popup;
        //MODAL / AMODAL Popups
        for (var x = 0; x < popups["length"]; x++) {
            popup = popups[x];

            //only consider loaded popups
            if (!popup || !popup["ucfPopupWindow"]) continue;

            if (popup["sDisplayMode"] === this["DISPLAY_MODE"]["FLOATING"]) continue;

            if (popup["sDisplayMode"] === this["DISPLAY_MODE"]["MODAL"]) {
                if (!this["oBlockLayer"]) this["oBlockLayer"] = this["oGetBlockLayer"](popup["bIsDivPopup"]);
                if (!this["oBlockLayer"]["bIsShown"]()) {
                    // Because DIV-Popups do not have "keepalive" flag the update of a PopupWindow would make the BockLayer visibly "flash" if UseAnimation=true
                    var bAvoidFlashing = popup["ucfPopupWindow"]["bIsDivPopup"] && bBLHidden;
                    this["oBlockLayer"]["show"](bAvoidFlashing);
                }
            }

            //blocklayer appears behind last modal popup
            if (popup == oLastModal) {
                //
                // Special case for Personas: This is a workaround/hack because IFrame- and Div-popups can not co-exist in the current implementation!
                // We allow only a one special case: A single Div-popup inside the last opened/modal IFrame-popup: In this case the index of the BlockLayer must not be changed
                // Note: If the Div-popup shall be MODAL the application has to create its own additional BlockLayer inside the IFrame-popup!
                //
                var bDivPopupInsideLastIFramePopup = (x > 0 && popup["ucfPopupWindow"]["bIsDivPopup"] && !popups[x - 1]["ucfPopupWindow"]["bIsDivPopup"]);
                if (!bDivPopupInsideLastIFramePopup) this["oBlockLayer"]["setZIndex"](nextZIndex());
            }
            //focussedPopup will be displayed on top of all others later
            if (popup["ucfPopupWindow"] != oFocussedPopup) popup["ucfPopupWindow"]["setZIndex"](nextZIndex());
        }

        //FLOATING POPUPS
        for (x = 0; x < popups["length"]; x++) {
            popup = popups[x];

            //only consider loaded popups
            if (!popup || !popup["ucfPopupWindow"]) continue;

            if (popup["sDisplayMode"] !== this["DISPLAY_MODE"]["FLOATING"]) continue;

            if (popup["ucfPopupWindow"] !== oFocussedPopup) popup["ucfPopupWindow"]["setZIndex"](nextZIndex());
        }

        //bring focussed popup to the top
        if (oFocussedPopup) {

            popup = null;

            for (x = 0; x < popups["length"]; x++) {

                //only consider loaded popups
                if (!popups[x] || !popups[x]["ucfPopupWindow"]) continue;

                if (popups[x]["ucfPopupWindow"] == oFocussedPopup) {
                    popup = popups[x];
                    break;
                }
            }

            if (popup["sDisplayMode"] !== this["DISPLAY_MODE"]["MODAL"] || popup == this["oGetLastModalPopup"]()) {
                oFocussedPopup["setZIndex"](nextZIndex());
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["updateZIndices"] = 0;
    }
    ;

    /**
     * Returns true if the given control instance is blocked by a modal popup, or in other words:
     * The block-layer is shown and the control is not on the top popup but
     * on the main page or another modal popup behind the top popup.
     * In case the given control is a UCF_LayeredControl that has a "opener" reference
     * (e.g. QuickView, PopupMenu), the opener-control is used
     * to check for the parent-PopupWindow as described above.
     * @param {UCF_Control} oControl
     * @return {boolean}
     */
    UCF_PopupManager["prototype"]["bControlIsBlocked"] = function (oControl) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["bControlIsBlocked"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl, "oControl", "PopupManager.js(775): bControlIsBlocked");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "PopupManager.js(776): bControlIsBlocked");
        }
        ;
        var oCheckControl = oControl;
        if (UCF_JsUtil["bInstanceOf"](oControl, 'UCF_LayeredControl') && oControl["oGetOpenerRef"]()) {
            oCheckControl = this["oLS"]["oGetControlByDomRef"](oControl["oGetOpenerRef"]());
        }
        if (this["oBlockLayer"] && this["oBlockLayer"]["bIsShown"]()) {
            var oParentPopup = oCheckControl["oGetParentPopupWindow"]();
            var oTopMostModalPopup = this["oGetLastModalPopup"]();
            var bIsContainedInTopModal = oParentPopup && oTopMostModalPopup && oParentPopup === oTopMostModalPopup["ucfPopupWindow"];
            return !bIsContainedInTopModal;
        } else {
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["bControlIsBlocked"] = 0;
    }
    ;

    /**
     * Returns the BlockLayer
     * @param {boolean} bIsDivPopup
     * @return {object} the BlockLayer
     */
    UCF_PopupManager["prototype"]["oGetBlockLayer"] = function (bIsDivPopup) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetBlockLayer"]++;
        }
        ;
        if (!this["oBlockLayer"]) {
            if (this["oLS"]["bIsMainLS"]()) {
                var oBlocklayerWindow = this["bBlocklayerLocal"] || bIsDivPopup ? this["oLS"]["oGetWindow"]() : this["oGetHostWindow"]();
                var bBLShaded = this["bBlockLayerShaded"] && (!window["UCF_System"]["bIsRemoteDesktop"] || window["UCF_System"]["sIsRemoteDesktop"] == "false");
                this["oBlockLayer"] = new (UCF_ClassLoader["oGetClass"]("UCF_BlockLayer"))("urPopupWindowBlockLayer", oBlocklayerWindow, bBLShaded, this["oLS"]["oGetPageInternal"]());

                this["oBlockLayer"]["attachEvent"](this["oBlockLayer"]["E_EVENTS"]["Click"], this, "focusUpperMostPopup");
                this["oBlockLayer"]["attachEvent"](this["oBlockLayer"]["E_EVENTS"]["Focus"], this, "focusUpperMostPopup");
            } else {
                return this["oMainLS"]["oGetPopupManagerInternal"]()["oGetBlockLayer"](bIsDivPopup);
            }
        }
        return this["oBlockLayer"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetBlockLayer"] = 0;
    }
    ;

    /**
     * Returns the last opened that means top most modal popup window
     * @return {Object}
     */
    UCF_PopupManager["prototype"]["oGetLastModalPopup"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetLastModalPopup"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = popups["length"] - 1; x >= 0; x--) {
            if (!popups[x] || !popups[x]["ucfPopupWindow"]) continue;
            if (popups[x]["sDisplayMode"] === this["DISPLAY_MODE"]["MODAL"]) return popups[x];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetLastModalPopup"] = 0;
    }
    ;

    /**
     * Returns the first opened modal popup window
     * @return {UCF_PopupWindows}
     */
    UCF_PopupManager["prototype"]["oGetFirstModalPopup"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetFirstModalPopup"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x <= popups["length"]; x++) {
            if (!popups[x] || !popups[x]["ucfPopupWindow"]) continue;
            if (popups[x]["sDisplayMode"] === this["DISPLAY_MODE"]["MODAL"]) return popups[x];
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetFirstModalPopup"] = 0;
    }
    ;

    /**
     * Determines whether the current window is the active window
     * In case no popups are opened it is the main window, otherwise
     * the top most modal popup
     * @return {boolean} current window is the active window
     */
    UCF_PopupManager["prototype"]["bIsActiveWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["bIsActiveWindow"]++;
        }
        ;

        //consider amodal/floating windows????
        var oLastModalPopup = this["oGetLastModalPopup"]();
        if (!oLastModalPopup) {
            return true;
        }
        if (oLastModalPopup["ucfPopupWindow"]) {
            return (this["oLS"] == oLastModalPopup["ucfPopupWindow"]["oLS"]);
        }
        return false;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["bIsActiveWindow"] = 0;
    }
    ;

    /**
     * @public
     *
     * @param {String} sId the id of the popup
     * @return {WINDOW} the window which belongs to the
     *  popup with the given id
     */
    UCF_PopupManager["prototype"]["oGetWindowByPopupId"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetWindowByPopupId"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (popups[x]["sId"] == sId) {
                var oWindow = popups[x]["oContainer"]["contentWindow"];

                return oWindow ? oWindow : popups[x]["oContainer"]["window"];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetWindowByPopupId"] = 0;
    }
    ;

    /**
     * @param {Object} oDomRefIframe Dom Reference
     */
    UCF_PopupManager["prototype"]["releaseIFrame"] = function (oDomRefIframe) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["releaseIFrame"]++;
        }
        ;

        if (!oDomRefIframe) return;

        //only root manager performs iframe handling
        if (!this["oLS"]["bIsMainLS"]()) {
            this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]()["releaseIFrame"](oDomRefIframe);
            return;
        }

        if (!this["bIframeCaching"]) {
            //remove from possible pools
            oDomRefIframe["setAttribute"]("id", "");
            //delayed call important for focus
            UCF_JsUtil["delayedCall"](2000, this, "delayedReleaseIFrame", [oDomRefIframe]);
        } else {
            //pooling active
            oDomRefIframe["setAttribute"]("inuse", "false");
            // Prevent Firefox to show the previous PW content for a blink of an eye befor the new URL gets loaded
            if (UCF_UserAgent["bIsFirefox"]()) {
                //Do not modify IFrame source after Iframe was created, otherwise the Iframe URL will be put in the
                //browser history and the backprevention will not work anymore.
                //oIFrame.setAttribute("src", sURL); would update the browser history

                //BCP 147743 2017: If Firefox is closed the next statement fires an unload event and interrupts the JS stack
                //All other JS statements after this line will be ignored. As result the LS framework will not completely destroyed and the unloadSrc Event (page.destroy) is not fired to backend.
                //The backend session is not closed. Detaching the unload event seems not to work.
                //Delayed call helps - not optimal solution
                UCF_JsUtil["delayedCall"](0, this, "delayedResetIFrameSrc", [oDomRefIframe]);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["releaseIFrame"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["delayedResetIFrameSrc"] = function (oDomRefIframe) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["delayedResetIFrameSrc"]++;
        }
        ;
        oDomRefIframe["contentWindow"]["document"]["location"]["replace"]("javascript:''");
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["delayedResetIFrameSrc"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["delayedReleaseIFrame"] = function (oDomRefIframe) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["delayedReleaseIFrame"]++;
        }
        ;
        if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
            oDomRefIframe["src"] = "javascript:''";
        }
        UCF_DomUtil["removeFromDom"](oDomRefIframe);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["delayedReleaseIFrame"] = 0;
    }
    ;

    /**
     * @private
     *
     * @param {String} sId the id of the popup
     * @return {UCF_LS} the LS object which belongs to the popup with the given id
     */
    UCF_PopupManager["prototype"]["oGetLSByPopupId"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetLSByPopupId"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (popups[x]["sId"] == sId && popups[x]["ucfPopupWindow"]) {
                return popups[x]["ucfPopupWindow"]["oLS"];
            }
        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetLSByPopupId"] = 0;
    }
    ;

    /**
     * @public
     *
     * @param {window} oWindow
     * @return {string} the the id of the popup with the given window
     */
    UCF_PopupManager["prototype"]["sGetPopupIdByWindow"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["sGetPopupIdByWindow"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (popups[x]["oContainer"]["contentWindow"] == oWindow) {
                return popups[x]["sId"];
            }
        }

        return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["sGetPopupIdByWindow"] = 0;
    }
    ;

    /**
     * @public
     *
     * @param {window} oWindow the window of the popup
     * @return {window} the window from which the popup with the window oWindow
     * has been openend
     */
    UCF_PopupManager["prototype"]["oGetOpenerWindow"] = function (oWindow) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetOpenerWindow"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            var contentWindow = popups[x]["oContainer"]["contentWindow"];
            if (contentWindow == oWindow) return popups[x]["oOpenerWindow"];

        }

        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetOpenerWindow"] = 0;
    }
    ;

    /**
     * @param {string} sId id of the popup
     * @param {boolean} bParentPopupLS Optional: Used in PopupWindow.close() - prefer parent-popup LS instanz if present (ITS)
     * @return {UCF_LS} the LS from which the popup with the id sId has been openend
     */
    UCF_PopupManager["prototype"]["oGetOpenerLSByPopupIdInternal"] = function (sId, bParentPopupLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetOpenerLSByPopupIdInternal"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (!popups[x]["sId"]) return null;

            if (popups[x]["sId"] == sId) {
                if (bParentPopupLS === true && popups[x]["oParentPopupLS"] != null) {
                    return popups[x]["oParentPopupLS"];
                } else {
                    return popups[x]["oLS"];
                }
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetOpenerLSByPopupIdInternal"] = 0;
    }
    ;

    /**
     * @public
     *
     * @param {string} sId id the window of the popup
     * @return {UCF_LS} the public LS interface from which the popup with the id sId has been openend
     */
    UCF_PopupManager["prototype"]["oGetOpenerLSByPopupId"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetOpenerLSByPopupId"]++;
        }
        ;
        var oLS = this["oGetOpenerLSByPopupIdInternal"](sId);

        return oLS ? oLS["oGetInterface"]() : null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetOpenerLSByPopupId"] = 0;
    }
    ;

    /**
     * setting the block layer to shaded = false renders a invisible blocklayer
     * @public
     * @param {boolean} bShaded
     */
    UCF_PopupManager["prototype"]["setBlockLayerShaded"] = function (bShaded) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["setBlockLayerShaded"]++;
        }
        ;

        if (this["oMainLS"] == this["oLS"]) {
            this["bBlockLayerShaded"] = bShaded;
        } else {
            this["oMainLS"]["oGetPopupManager"]()["setBlockLayerShaded"](bShaded);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["setBlockLayerShaded"] = 0;
    }
    ;
    /**
     * Closes a popup
     *
     * @public
     *
     * @param {String} sId the popup to close
     */
    UCF_PopupManager["prototype"]["closePopup"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["closePopup"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (popups[x]["sId"] != sId) continue;

            if (popups[x]["ucfPopupWindow"]) {
                // Send the event before PopupWindow.close() because this will destroy this LS instance
                var oMainPopupManager = this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]();
                oMainPopupManager["fireEvent"](oMainPopupManager["E_EVENTS"]["WindowClose"], {"sPopupId": sId});

                popups[x]["ucfPopupWindow"]["close"]();
            } else {

                //needed when you open and close the popup in the same second
                //popup is not registered yet but iframe has already been allocated
                var oPopup = popups[x];
                popups["splice"](x, 1);

                this["updateZIndices"]();

                var oContainer = oPopup["oContainer"];
                oContainer["setAttribute"]("inuse", "false");

                //TD paranoia mode memory leaks
                oPopup["oOpenerWindow"] = null;
                oPopup["oLS"] = null;
                oPopup["oContainer"] = null;
                oPopup["oParentPopupLS"] = null;
                oPopup["oLockedParentWindow"] = null;
                oPopup = null;

                this["oLS"]["oBrowserWindow"]["notifyLayerHidden"]();
            }

            return;
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["closePopup"] = 0;
    }
    ;

    /**
     * Notfies a PopupWindow, that its content has changed
     *
     * @public
     *
     * @param {String} sId the id of the popup
     */
    UCF_PopupManager["prototype"]["notifyContentUpdate"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["notifyContentUpdate"]++;
        }
        ;
        var popups = this["aGetPopups"]();

        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (!popups[x]["ucfPopupWindow"]) continue;

            if (popups[x]["sId"] == sId) {
                popups[x]["ucfPopupWindow"]["updateDimensions"]();
                return;
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["notifyContentUpdate"] = 0;
    }
    ;

    /**
     * Sets the title of a popup
     *
     * @public
     *
     * @param {String} sId the id of the popup
     * @param {String} sTitle the title to set
     */
    UCF_PopupManager["prototype"]["notifyTitleUpdate"] = function (sId, sTitle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["notifyTitleUpdate"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x]) continue;

            if (!popups[x]["ucfPopupWindow"]) continue;

            if (popups[x]["sId"] == sId) {
                popups[x]["ucfPopupWindow"]["setTitle"](sTitle);
                return;
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["notifyTitleUpdate"] = 0;
    }
    ;

    /**
     * clear references to objects in foreign frames
     *
     */
    UCF_PopupManager["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["destroy"]++;
        }
        ;

        //this.oLS.detachEvent(this.oLS.E_EVENTS.UpdateComplete, this, "onUpdateComplete");
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], this, "onPendingRequest");

        if (this["oLS"] == this["oMainLS"]) {
            if (this["oBlockLayer"]) {
                this["oBlockLayer"]["detachEvent"](this["oBlockLayer"]["E_EVENTS"]["Click"], this);
                //focus event??
                this["oBlockLayer"]["hide"]();
                this["oBlockLayer"]["destroy"]();
            }

            //need to remove all iframes, else they leak in a browser popup window
            var popups = this["aGetPopups"](),
                iFrame = null;
            for (var x = 0; x < popups["length"]; x++) {
                if (!popups[x]) continue;

                if (!popups[x]["ucfPopupWindow"]) continue;

                if (!popups[x]["oContainer"]) continue;

                if (popups[x]["oContainer"]["tagName"]["toUpperCase"]() == "IFRAME") {
                    iFrame = popups[x]["oContainer"];

                }

                popups[x]["ucfPopupWindow"]["destroy"]();

                UCF_DomUtil["removeFromDom"](iFrame);

                popups["splice"](x--, 1);

            }

            // Remove all IFrames that are currently not in use (by other LS instance)
            // Otherwise the IFrame objects would "leak"
            var oHostDocument = this["oGetHostWindow"]()["document"];
            if (oHostDocument) {
                var index = 0;
                var sIframeId = null;
                var oIFrame = null;
                for (; true; index++) {
                    sIframeId = UCF_PopupManager["IFRAME_PREFIX"] + index;
                    oIFrame = oHostDocument["getElementById"](sIframeId);

                    if (oIFrame == null) break; //exists loop assuming it is not possible to remove an IFrame in between and a higher number would exists
                    if (oIFrame["getAttribute"]("inuse") == "false") {
                        UCF_DomUtil["removeFromDom"](oIFrame);
                    }
                }
            }

            // Note: This is only used by WebGUI by using the special call setHostWindow()
            var oTW = UCF_DomUtil["oGetTopWindow"]();
            if (oTW && oTW["MAINLS_HOSTWINDOW"]) {
                oTW["MAINLS_HOSTWINDOW"] = null;
            }
        }

        this["oBlockLayer"] = null;
        this["oPopupWindows"] = null;

        this["oLS"] = null;
        this["aLSLoaded"] = null;
        this["aPopups"] = null;
        //this.aPopupIDsForLayering = null;
        this["oGetHostWindow"] = null;
        this["oDocument"] = null;
        this["oTopWindow"] = null;
        this["oMainLS"] = null;
        this["oPendingRequest"] = null;
        this["oSrcRect"] = null;
        this["oTrgtRect"] = null;
        this["fCallbackMethod"] = null;
        this["oAnimationRectangle"] = null;

        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["destroy"] = 0;
    }
    ;

    /**
     * Closes all PopupWindows
     *
     * @public
     */
    UCF_PopupManager["prototype"]["closeAllPopups"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["closeAllPopups"]++;
        }
        ;

        var popups = this["aGetPopups"]();
        //loop backwards, because of the modal stack
        for (var x = popups["length"] - 1; x >= 0; x--) {
            if (!popups[x]) continue;

            this["closePopup"](popups[x]["sId"]);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["closeAllPopups"] = 0;
    }
    ;

    UCF_PopupManager["prototype"]["sGetFocusedPopupId"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["sGetFocusedPopupId"]++;
        }
        ;

        var oLastModalPopup = this["oGetLastModalPopup"]();
        if (oLastModalPopup) return oLastModalPopup["sId"];

        //TODO: topmodal window not main LS window !!!!!!!!!!
        var oMainWindow = this["oLS"]["oGetMainLS"]()["oGetWindow"](),
            oActiveElement = oMainWindow["UCF_DomUtil"]["oGetActiveElement"]();

        if (!oActiveElement || (oActiveElement && oActiveElement["tagName"] && oActiveElement["tagName"]["toUpperCase"]() != "IFRAME")) {
            return "";
        }

        var sIFrameId = oActiveElement["id"];

        if (sIFrameId && sIFrameId["indexOf"](UCF_PopupManager["IFRAME_PREFIX"]) !== -1) {
            return this["sGetPopupIdByWindow"](oActiveElement["contentWindow"]);
        }

        return "";
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["sGetFocusedPopupId"] = 0;
    }
    ;

    /**
     * @param {string} sId The popup ID
     * @return {UCF_PopupWindow} The popup instance with the given ID
     */
    UCF_PopupManager["prototype"]["oGetPopupById"] = function (sId) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["oGetPopupById"]++;
        }
        ;
        var popups = this["aGetPopups"]();
        for (var x = 0; x < popups["length"]; x++) {
            if (!popups[x] || !popups[x]["ucfPopupWindow"]) continue;

            if (popups[x]["sId"] === sId) {
                return popups[x]["ucfPopupWindow"];
            }
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["oGetPopupById"] = 0;
    }
    ;

    /**
     * The popup handling reuses by default the Iframes created and added to the DOM for the next popup instances.
     * In some runtime modes this causes problems.
     * This method switches the caching on and off
     *
     * @param {boolean} bOn
     */
    UCF_PopupManager["prototype"]["setIframeCaching"] = function (bOn) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["setIframeCaching"]++;
        }
        ;

        if (!this["oLS"]["bIsMainLS"]()) {
            this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]()["setIframeCaching"](bOn);
        }
        this["bIframeCaching"] = bOn;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["setIframeCaching"] = 0;
    }
    ;

    /**
     * Is the caching of Iframes switched on?
     *
     * @return {boolean} true=on; false=off
     * @see {UCF_PopupManager.setIframeCaching}
     */
    UCF_PopupManager["prototype"]["bDoIframeCaching"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["bDoIframeCaching"]++;
        }
        ;
        if (!this["oLS"]["bIsMainLS"]()) {
            return this["oLS"]["oGetMainLS"]()["oGetPopupManagerInternal"]()["bDoIframeCaching"]();
        }
        return this["bIframeCaching"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["bDoIframeCaching"] = 0;
    }
    ;

    /**
     * Resize Animation
     *
     * @param {Object} oSrcRect
     * @param {Object} oTrgtRect
     * @param {function} fCallbackMethod
     * @private
     */
    UCF_PopupManager["prototype"]["showResizeAnimation"] = function (oSrcRect, oTrgtRect, fCallbackMethod) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["showResizeAnimation"]++;
        }
        ;
        if (UCF_UserAgent["bIsIE"]() && window["UCF_System"]["sDevice"] !== "standards") {
            if (fCallbackMethod) fCallbackMethod();
            return;
        }
        if (this["bAnimationInProgress"]) return;

        this["bAnimationInProgress"] = true;
        this["oSrcRect"] = oSrcRect;
        this["oTrgtRect"] = oTrgtRect;
        this["fCallbackMethod"] = fCallbackMethod;

        this["iAnimationStartTime"] = new Date()["valueOf"](); // eslint-disable-line ur/no-memory-leaks
        //create rect:
        this["createAnimationRectangle"]();
        this["doResizeAnimationStep"]();

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["showResizeAnimation"] = 0;
    }
    ;

    /**
     * Resize animation step
     *
     * @param {int} iStep
     */
    UCF_PopupManager["prototype"]["doResizeAnimationStep"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["doResizeAnimationStep"]++;
        }
        ;

        var iDuration = 150,
            iTime = new Date()["valueOf"]();

        if (iTime > this["iAnimationStartTime"] + iDuration || this["bStopAnimation"]) {
            //animation time elapsed:
            UCF_DomUtil["removeFromDom"](this["oAnimationRectangle"]);
            this["oAnimationRectangle"] = null;

            this["bAnimationInProgress"] = false;

            if (this["fCallbackMethod"] && !this["bStopAnimation"]) {
                this["fCallbackMethod"]();
                this["fCallbackMethod"] = null;
            }

        } else {
            //next animation step:
            var fFactor = (iTime - this["iAnimationStartTime"]) / iDuration,
                rect = {
                    "x": this["oSrcRect"]["x"],
                    "y": this["oSrcRect"]["y"],
                    "width": this["oSrcRect"]["width"],
                    "height": this["oSrcRect"]["height"]
                };

            rect["x"] += (this["oTrgtRect"]["x"] - this["oSrcRect"]["x"]) * fFactor;
            rect["y"] += (this["oTrgtRect"]["y"] - this["oSrcRect"]["y"]) * fFactor;
            rect["width"] += (this["oTrgtRect"]["width"] - this["oSrcRect"]["width"]) * fFactor;
            rect["height"] += (this["oTrgtRect"]["height"] - this["oSrcRect"]["height"]) * fFactor;

            var style = this["oAnimationRectangle"]["style"];
            style["left"] = rect["x"] + "px";
            style["top"] = rect["y"] + "px";
            style["width"] = rect["width"] + "px";
            style["height"] = rect["height"] + "px";

            UCF_JsUtil["delayedCall"](iDuration / 10, this, "doResizeAnimationStep", []);
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["doResizeAnimationStep"] = 0;
    }
    ;

    /**
     * Create Animation Rectangle
     *
     * @return {HTMLElement}
     */
    UCF_PopupManager["prototype"]["createAnimationRectangle"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["createAnimationRectangle"]++;
        }
        ;

        if (this["oAnimationRectangle"]) return this["oAnimationRectangle"];

        this["oAnimationRectangle"] = this["oDocument"]["createElement"]("div");

        var style = this["oAnimationRectangle"]["style"];
        style["border"] = "1px dotted black";
        style["position"] = "absolute";
        style["zIndex"] = 99999;
        style["top"] = "-9999px";

        this["oDocument"]["body"]["appendChild"](this["oAnimationRectangle"]);

        var innerDiv = this["oDocument"]["createElement"]("div");
        style = innerDiv["style"];
        style["backgroundColor"] = "#FFFFFF";
        style["width"] = "100%";
        style["height"] = "100%";

        UCF_DomUtil["setOpacityStyle"](innerDiv, 60);

        this["oAnimationRectangle"]["appendChild"](innerDiv);

        if (UCF_UserAgent["bIsIE"]() || UCF_UserAgent["bIsMSEdge"]()) {
            //prevent selection of the popup title during drag and drop
            this["oAnimationRectangle"]["onselectstart"] = function () {
                return false;
            };
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["createAnimationRectangle"] = 0;
    }
    ;

    /**
     * Stops resize animation
     */
    UCF_PopupManager["prototype"]["stopAnimation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["stopAnimation"]++;
        }
        ;
        this["bStopAnimation"] = true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["stopAnimation"] = 0;
    }
    ;
    /**
     * Focuses the opening LS
     * fix for the exotic case that a this PW gets closed and an external popup window will be opened
     * then the browserwindow no longer has the focus and therefore do NOT focus the main window
     * to retain the focus on the external window
     *
     * Needs to be static since it is called with delayed call and creates an error in case exit plug is fired
     * from within the popup
     *
     * @param {UCF_LS} oOpenerLS the opener LS
     */
    UCF_PopupManager["delayedFocusOpenerLS"] = function (oOpenerLS) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PopupManager["_"]["delayedFocusOpenerLS"]++;
        }
        ;

        if (oOpenerLS) {
            try {
                oOpenerLS["focusWindow"]();
            } catch (e /* freed script */) {
                //fail silently
            }
        }

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PopupManager["_"]["delayedFocusOpenerLS"] = 0;
    }
    ;


    UCF_PopupManager.prototype["aPublicMethods"] = ["showModalDialog", "createPopupWindow", "oGetTopPopup", "setHostWindow", "oGetWindowByPopupId", "sGetPopupIdByWindow", "oGetOpenerWindow", "oGetOpenerLSByPopupId", "setBlockLayerShaded", "closePopup", "notifyContentUpdate", "notifyTitleUpdate", "closeAllPopups"].concat(UCF_PopupManager.prototype.aPublicMethods || []);
    /* eslint-disable jsdoc/require-jsdoc */
    /* eslint-disable jsdoc/check-alignment */
    /* global _assert, _trace, DEBUG */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_Control */
/// <reference path="../core/Control.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_System */

/// <reference path="../core/System.js"/>

    /**
     *
     * Post Message Services holds a list of PM Services with their
     * implementations for handle PMs
     *
     * Let the class UCF_PMServiceGenericResponder build the response
     * for a service request like 'sap.ls.back'
     *
     * "sap.ls.back":"UCF_PMServiceGenericResponder"
     *
     *
     *
     * @class
     * @param {HTMLElement} oDomRef
     * @param {UCF_LS} oLS
     */
// eslint-disable-next-line jsdoc/check-syntax
    function UCF_PostMessageServices(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_PostMessageServices["_"]["UCF_PostMessageServices"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === 'object', "typeof(oDomRef) === 'object'", "PostMessageServices.js(37): UCF_PostMessageServices");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef !== null, "oDomRef !== null", "PostMessageServices.js(38): UCF_PostMessageServices");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "PostMessageServices.js(39): UCF_PostMessageServices");
        }
        ;

        UCF_Control["apply"](this, [oDomRef, oLS]);

        if (!UCF_UserAgent["bIsStandardsMode"]()) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageHubs are supported in standards mode only', "PostMessageServices.js(44): UCF_PostMessageServices");
            }
            ;
            // eslint-disable-next-line no-unsanitized/property
            this["oRootRef"]["innerHTML"] =
                oLS["sGetText"]('SAPUR_HTML5_CONTROL_ERROR', [
                    '<a target=\'_blank\' href=\'https://service.sap.com/sap/support/notes/1970689\'>Note 1970689</a>',
                    'Postmessage'
                ]);

            return;
        }
        if (!UCF_PostMessageServices["mServices"])
            UCF_PostMessageServices["mServices"] = {};
        try {
            if (oDomRef["innerHTML"]["substring"](12, oDomRef["innerHTML"]["length"] - 6) === '{}') ;
            //			this.mServices = {};
            else {
                var newValues = UCF_JsUtil["oJsonParse"](
                    oDomRef["innerHTML"]["substring"](12, oDomRef["innerHTML"]["length"] - 6)["replace"](/\\/g, ''));
                var aKeys = UCF_JsUtil["keys"](newValues);
                for (var iIndex = 0; iIndex < aKeys["length"]; iIndex++)
                    UCF_PostMessageServices["mServices"][aKeys[iIndex]] = newValues[aKeys[iIndex]];
            }
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageServices: Service List cannot be parsed', "PostMessageServices.js(67): UCF_PostMessageServices");
            }
            ;
        }
        this["oLS"] = oLS;
    };window["UCF_PostMessageServices"] = UCF_PostMessageServices;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_PostMessageServices");
        UCF_PostMessageServices["_"] = {UCF_PostMessageServices: 0};
    }
    ;
    ;

    UCF_PostMessageServices["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Control"))();
    UCF_PostMessageServices.prototype["sClassName"] = "UCF_PostMessageServices";

    UCF_PostMessageServices["addPostMessageService"] = function (sService, sImplementation) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PostMessageServices["_"]["addPostMessageService"]++;
        }
        ;
        if (!UCF_PostMessageServices["mServices"])
            UCF_PostMessageServices["mServices"] = {};
        UCF_PostMessageServices["mServices"][sService] = sImplementation;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PostMessageServices["_"]["addPostMessageService"] = 0;
    }
    ;

    UCF_PostMessageServices["removePostMessageService"] = function (sService) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PostMessageServices["_"]["removePostMessageService"]++;
        }
        ;
        if (UCF_PostMessageServices["mServices"])
            UCF_PostMessageServices["mServices"][sService] = null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PostMessageServices["_"]["removePostMessageService"] = 0;
    }
    ;

    UCF_PostMessageServices["dispatch"] = function (sService, oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PostMessageServices["_"]["dispatch"]++;
        }
        ;
        if (UCF_PostMessageServices["mServices"] == null) return false; // Trigger a RequestReceive Event
        if (UCF_PostMessageServices["mServices"][sService] == null || UCF_PostMessageServices["mServices"][sService] === '') return false;

        if (UCF_JsUtil["bIsFunction"](UCF_PostMessageServices["mServices"][sService])) {
            return UCF_PostMessageServices["mServices"][sService](sService, oEvent, window["UCF_System"]["oLS"]);
        } else if (UCF_PostMessageServices["mServices"][sService] && UCF_PostMessageServices["mServices"][sService] !== '') {
            var oImpl = UCF_ClassLoader["oGetClass"](UCF_PostMessageServices["mServices"][sService]);
            if (oImpl)
                return oImpl(sService, oEvent, window["UCF_System"]["oLS"]);
        }
        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PostMessageServices["_"]["dispatch"] = 0;
    }
    ;

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #sCustomData}
     * @private
     * @type {string[]}
     */
    UCF_PostMessageServices["prototype"]["aAttributeNames"] = ['sCustomData'];

    /**
     * Array of names of events of the control:
     * @type {string[]}
     */
    UCF_PostMessageServices["prototype"]["aEventNames"] = [];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * {@link #addPostMessageService}
     * Post a String to the parent
     * Parameter: {string} Name - The name of the Service
     * Parameter: {string} Implementation - The class name of the implementation
     *
     * {@link #removePostMessageService}
     * Post a String to the parent
     * Parameter: {string} Name - The name of the Service
     *
     * @private
     * @type {string[]}
     */
    UCF_PostMessageServices["prototype"]["aMethodNames"] = ['addPostMessageService', 'removePostMessageService', 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     * Sets a custom data string that can be retrieved on the client via method sGetCustomData() or getCustomData(sJsonPropertyName) in case it is a JSON string
     *
     * @private
     * @type {string}
     */
    UCF_PostMessageServices["prototype"]["sCustomData"] = '';


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_PostMessageServices["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_PostMessageServices["_"]["setDefaultValues"]++;
        }
        ;
        this["sCustomData"] = '';

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', '', true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_PostMessageServices["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    /* global _assert, _trace, WARNING, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_Event */
/// <reference path="../../core/Event.js"/>
    /* global UCF_ClassLoader */
/// <reference path="../../core/util/ClassLoader.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_StringUtil */
/// <reference path="../../core/util/StringUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_XSSEncoder */
/// <reference path="../../core/util/XSSEncoder.js"/>
    /* global UCF_Control */
/// <reference path="../core/Control.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_ResourceUtil */
/// <reference path="../core/ResourceUtil.js"/>
    /* global UCF_System */

/// <reference path="../core/System.js"/>

    /**
     * ClientInspector -  A control which inspects the client environment and
     * notifies the server about specific client properties. A notification of
     * parameters can be supressed by setting the parameter to OFF.
     *
     *
     *
     * @class
     * @version
     * @param {element} oDomRef
     * @param {UCF_LS} oLS
     * @private
     */
    function UCF_ClientInspector(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["UCF_ClientInspector"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof oDomRef === 'object', "typeof oDomRef === 'object'", "ClientInspector.js(40): UCF_ClientInspector");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "ClientInspector.js(41): UCF_ClientInspector");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "ClientInspector.js(42): UCF_ClientInspector");
        }
        ;

        UCF_Control["apply"](this, [oDomRef, oLS]);
        this["oNotificationInfo"] = null;

        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["Lock"], this, 'onLsLock');
        this["oLS"]["attachEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, 'onLsUnlock');
    };window["UCF_ClientInspector"] = UCF_ClientInspector;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ClientInspector");
        UCF_ClientInspector["_"] = {UCF_ClientInspector: 0};
    }
    ;
    ;
    UCF_ClientInspector["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Control"))();
    UCF_ClientInspector.prototype["sClassName"] = "UCF_ClientInspector";

    /******************************************************
     ** DESTRUCTOR
     *******************************************************/

    /**
     * Destructor
     */
    UCF_ClientInspector["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["destroy"]++;
        }
        ;
        UCF_JsUtil["clearDelayedCallsOfObject"](this);
        this["cleanUpPendingRequest"]();

        this["cleanUpNotification"]();

        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["Lock"], this, 'onLsLock');
        this["oLS"]["detachEvent"](this["oLS"]["E_EVENTS"]["Unlock"], this, 'onLsUnlock');

        UCF_Control.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["destroy"] = 0;
    }
    ;

    /******************************************************
     ** CONSTANTS
     *******************************************************/
    /** @typedef {number} UCF_ClientInspector_NotificationTrigger */
    /**
     * @constant
     * @enum {UCF_ClientInspector_NotificationTrigger}
     */
    UCF_ClientInspector["prototype"]["NOTIFICATION_TRIGGER"] = {
        "NONE": 'NONE',
        "INITIAL": 'INITIAL',
        "WHEN_CHANGED": 'WHEN_CHANGED'
    };

    /** @typedef {number} UCF_ClientInspector_CheckReason */
    /**
     * ATTENTION! These values are &-ed in checkParameter(). Use them with caution,
     * don't even think of changing them!
     *
     * @constant
     * @enum {UCF_ClientInspector_CheckReason}
     */
    UCF_ClientInspector["prototype"]["CHECK_REASON"] = {
        "NONE": 0,
        "INIT": 1,
        "RESIZE": 2,
        "ORIENTATION_CHANGED": 4
    };

    /**
     * @see UCF_Control
     */
    UCF_ClientInspector["prototype"]["initialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["initialize"]++;
        }
        ;
        if (window["UCF_System"]["sThemeFallbackCSSURL"] && !this["bGetCssMatchesHtmlVersion"]()) {
            // When CSS URL has been corrected because of mis-matching version the
            // fallback URL has to be loaded before ClientInspector initializes.
            // This is done by suspending pending requests and polling for CSS validity
            this["initializePendingRequest"]();
            this["checkFallbackCssLoaded"]();
        } else {
            this["doInitialize"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["initialize"] = 0;
    }
    ;

    /**
     * The actual initialization of the control
     */
    UCF_ClientInspector["prototype"]["doInitialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["doInitialize"]++;
        }
        ;
        if (this["sNotificationTrigger"] !== this["NOTIFICATION_TRIGGER"]["NONE"]) {
            this["check"](this["CHECK_REASON"]["INIT"]);

            this["initNotification"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["doInitialize"] = 0;
    }
    ;

    /**
     * Initializes the handling of pending requests
     */
    UCF_ClientInspector["prototype"]["initializePendingRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["initializePendingRequest"]++;
        }
        ;
        this["oPendingRequest"] = null;
        this["attachLSEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], 'onPendingRequest');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["initializePendingRequest"] = 0;
    }
    ;

    /**
     * Cleanup the handling of pending requests
     */
    UCF_ClientInspector["prototype"]["cleanUpPendingRequest"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["cleanUpPendingRequest"]++;
        }
        ;
        this["detachLSEvent"](this["oLS"]["E_EVENTS"]["PendingRequest"], 'onPendingRequest');

        if (this["oPendingRequest"]) {
            this["oPendingRequest"]["resume"](this["sId"]);
            this["oPendingRequest"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["cleanUpPendingRequest"] = 0;
    }
    ;

    /**
     * Stops pending requests. It is resumed when an optional fallback CSS has been
     * loaded
     *
     * @param {Object} oEvent
     */
    UCF_ClientInspector["prototype"]["onPendingRequest"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["onPendingRequest"]++;
        }
        ;
        this["oPendingRequest"] = oEvent["oGetParam"]('oPendingRequest');
        this["oPendingRequest"]["suspend"](this["sId"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["onPendingRequest"] = 0;
    }
    ;

    /**
     * Checks if the fallback CSS has been loaded
     *
     * @param {int} iIteration
     */
    UCF_ClientInspector["prototype"]["checkFallbackCssLoaded"] = function (iIteration) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["checkFallbackCssLoaded"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oLightspeedCssLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
        /** @type {boolean} */
        var bCssLoaded = false;
        /** @type {boolean} */
        var bForceContinue;

        if (typeof iIteration !== 'number') {
            iIteration = 1;
        }

        // eslint-disable-next-line no-magic-numbers
        bForceContinue = !oLightspeedCssLink || iIteration >= 30;

        if (!bForceContinue) {
            try {
                bCssLoaded = oLightspeedCssLink["href"] === __UCF_IE6__
                    ? oLightspeedCssLink["styleSheet"]["href"]
                    : oLightspeedCssLink["sheet"]["href"];
            } catch (e) {
                bForceContinue = true;
            }
        }

        if (bForceContinue || bCssLoaded) {
            if (bForceContinue) {
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(WARNING, 'Waiting for CSS loaded did not succeed. Force continue.', "ClientInspector.js(189): checkFallbackCssLoaded");
                }
                ;
            }

            this["doInitialize"]();
            this["cleanUpPendingRequest"]();
        } else {
            // eslint-disable-next-line no-magic-numbers
            UCF_JsUtil["delayedCall"](100, this, 'checkFallbackCssLoaded', [++iIteration]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["checkFallbackCssLoaded"] = 0;
    }
    ;

    /**
     * Checks if a notification has to be sent
     *
     * @param {UCF_ClientInspector_CheckReason} mReason a map entry which
     * identifies the reason of the check
     */
    UCF_ClientInspector["prototype"]["check"] = function (mReason) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["check"]++;
        }
        ;
        /** @type {Array<string>} */
        var aData = [];

        if (
            // ATTENTION! Yep, this is a binary &. The CHECK_REASON enum values
            // are prepared for that. Don't even think of changing them!
            mReason & this["CHECK_REASON"]["INIT"] ||
            mReason & this["CHECK_REASON"]["ORIENTATION_CHANGED"] ||
            mReason & this["CHECK_REASON"]["RESIZE"]
        ) {
            this["checkParameter"]('i', 'ClientWidth', 'px', aData);
            if (
                !UCF_UserAgent["bIsAndroid"]() ||
                (UCF_DomUtil["oGetActiveElement"]()["nodeName"] !== 'INPUT' &&
                    UCF_DomUtil["oGetActiveElement"]()["nodeName"] !== 'TEXTAREA')
            ) {
                // Android changes the clientHeight when the onScreen keyboard opens.
                // This causess a server roundtrip and the onScreen keyboard closes...
                this["checkParameter"]('i', 'ClientHeight', 'px', aData);
            }
            this["checkParameter"]('i', 'ScreenWidth', 'px', aData);
            this["checkParameter"]('i', 'ScreenHeight', 'px', aData);
            this["checkParameter"]('s', 'ScreenOrientation', '', aData);
            this["checkParameter"]('s', 'ThemedLayoutPaddingTop', '', aData);
            this["checkParameter"]('s', 'ThemedLayoutPaddingBottom', '', aData);
            this["checkParameter"]('s', 'ThemedLayoutPaddingLeft', '', aData);
            this["checkParameter"]('s', 'ThemedLayoutPaddingRight', '', aData);
            this["checkParameter"]('s', 'ThemedValueHelpHeight', '', aData);
            this["checkParameter"]('s', 'ThemedValueHelpWidth', '', aData);
        }

        // Parameters which are check only on initialization
        if (mReason & this["CHECK_REASON"]["INIT"]) {
            this["checkParameter"]('b', 'QME', '', aData);
            this["checkParameter"]('s', 'RenderingModeCompatibility', '', aData);
            this["checkParameter"]('s', 'ThemedTableRowHeight', '', aData);
            this["checkParameter"]('s', 'ThemedFormLayoutRowHeight', '', aData);
            this["checkParameter"]('s', 'ThemedScrollbarDimension', '', aData);
            this["checkParameter"]('s', 'ThemedDocumentBackgroundColor', '', aData);
            // this["checkParameter"]('s', 'ThemedSvgLibs', '', aData);
            // this["checkParameter"]('s', 'ThemedSvgLibUrls', '', aData, true);
            this["checkParameter"]('s', 'ThemedRasterHeight', '', aData);
            this["checkParameter"]('s', 'ThemedRasterWidth', '', aData);
            this["checkParameter"]('s', 'ThemedAbapListRasterHeight', '', aData);
            this["checkParameter"]('s', 'ThemedAbapListRasterWidth', '', aData);
            this["checkParameter"]('a', 'ThemeTags', '', aData);
            this["checkParameter"]('s', 'ThemeID', '', aData);
            this["checkParameter"]('s', 'SapThemeID', '', aData);
            this["checkParameter"]('b', 'WordEnabled', '', aData);
            this["checkParameter"]('b', 'ExcelEnabled', '', aData);
            this["checkParameter"]('b', 'FlashEnabled', '', aData);
            this["checkParameter"]('b', 'AcrobatEnabled', '', aData);
            this["checkParameter"]('b', 'SilverlightEnabled', '', aData);
            this["checkParameter"]('b', 'JavaEnabled', '', aData);
            this["checkParameter"]('s', 'JavaVersion', '', aData);
            this["checkParameter"]('b', 'WebSocketsEnabled', '', aData);
            this["checkParameter"]('s', 'DeviceType', '', aData);
            this["checkParameter"]('b', 'CssMatchesHtmlVersion', '', aData);
            this["checkParameter"]('s', 'Platform', '', aData);
            this["checkParameter"]('b', 'WindowOpenerExists', '', aData);
            this["checkParameter"]('s', 'DocumentDomain', '', aData, true);
            this["checkParameter"]('s', 'ClientURL', '', aData, true);
            this["checkParameter"]('b', 'IsTopWindow', '', aData);
            this["checkParameter"]('b', 'ParentAccessible', '', aData);
        }

        if (aData["length"]) {
            this["fireNotify"](this["sId"], aData["join"](';'));
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["check"] = 0;
    }
    ;

    /**
     * @template T
     * @param {string} sType the type of the parameter
     * @param {string} sName the name of the parameter
     * @param {string} sSuffix suffix to the parameter value (e.g. `'px'`)
     * @param {Array<string>} aData data collection to add the value to
     * @param {boolean} [bNoEncode=false] `true` to add the value "as-is", `false`
     * to encode it
     */
    UCF_ClientInspector["prototype"]["checkParameter"] = function (sType, sName, sSuffix, aData, bNoEncode) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["checkParameter"]++;
        }
        ;
        /** @type {string} */
        var sValue = this['s' + sName];
        /** @type {T} */
        var oValueCurrent;
        /** @type {string} */
        var sValueCurrent;
        /** @type {T} */
        var oValueToSet;
        /** @type {function(T,T):boolean} */
        var bCompareFunction;

        if (sValue !== 'OFF' && sValue !== '[]') {
            oValueCurrent = this[sType + 'Get' + sName]();
            sValueCurrent = null;
            oValueToSet = null;
            bCompareFunction = this["bParameterCompareDefault"];

            if (sType === 'i') { //Integer
                sValueCurrent = oValueCurrent + '';
                oValueToSet = parseInt(sValue);
            } else if (sType === 'b') { //Boolen
                sValueCurrent = oValueCurrent ? 'TRUE' : 'FALSE';
                oValueToSet = sValue["toUpperCase"]() === 'TRUE';
            } else if (sType === 's') { //String
                sValueCurrent = oValueCurrent;
                oValueToSet = sValue;
            } else if (sType === 'a') { //Array
                sValueCurrent = oValueCurrent
                    ? UCF_StringUtil["sTrim"](oValueCurrent["join"](',')["replace"](/(\s*,\s*)/, ','))
                    : '';
                sValue = UCF_StringUtil["sTrim"](sValue["replace"](/(\s*,\s*)/, ','));
                oValueToSet = sValue ? sValue["split"](',') : [];
                bCompareFunction = this["bParameterCompareList"];
            }

            if (!bCompareFunction(oValueCurrent, oValueToSet)) {
                sValueCurrent = bNoEncode ? sValueCurrent : this["sEscapeValue"](sValueCurrent);

                aData["push"](sName + ':' + sValueCurrent + sSuffix);
                this['s' + sName] = sValueCurrent;
                this["setClientProperty"](sName, sValueCurrent, true);
            }
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["checkParameter"] = 0;
    }
    ;

    /**
     * @param {string} sValue the value to escape
     * @return {string}
     */
    UCF_ClientInspector["prototype"]["sEscapeValue"] = function (sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sEscapeValue"]++;
        }
        ;
        return sValue["replace"](/\:/gi, '\\x58')["replace"](/\;/gi, '\\x59');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sEscapeValue"] = 0;
    }
    ;

    /**
     * @template T
     * @param {T} oValueCurrent the current value
     * @param {T} oValueToSet the "next" value
     * @return {boolean}
     */
    UCF_ClientInspector["prototype"]["bParameterCompareDefault"] = function (oValueCurrent, oValueToSet) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bParameterCompareDefault"]++;
        }
        ;
        return oValueCurrent === oValueToSet;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bParameterCompareDefault"] = 0;
    }
    ;

    /**
     * @template T
     * @param {Array<T>} aValueCurrent the current values
     * @param {Array<T>} aValueToSet the "next" values
     * @return {boolean}
     */
    UCF_ClientInspector["prototype"]["bParameterCompareList"] = function (aValueCurrent, aValueToSet) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bParameterCompareList"]++;
        }
        ;
        /** @type {Object<T,T>} */
        var mValueCurrent;
        /** @type {number} */
        var i;
        /** @type {number} */
        var j;

        if (aValueToSet["length"] === 0 && aValueCurrent["length"] === 0) {
            return true;
        }
        if (aValueToSet["length"] === 0 && aValueCurrent["length"] !== 0) {
            return false;
        }
        if (aValueToSet["length"] !== 0 && aValueCurrent["length"] === 0) {
            return false;
        }

        mValueCurrent = {};

        for (i = 0; i < aValueCurrent["length"]; i++) {
            mValueCurrent[aValueCurrent[i]] = null;
        }

        for (j = 0; j < aValueToSet["length"]; j++) {
            if (!(aValueToSet[j] in mValueCurrent)) {
                return false;
            }
        }

        return true;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bParameterCompareList"] = 0;
    }
    ;

    /** @return {number} */
    UCF_ClientInspector["prototype"]["iGetClientWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetClientWidth"]++;
        }
        ;
        // The name of this function is misleading: It does not return the
        // clientWidth, it returns the innerWidth (which is clientWidth + scrollbar)!
        // But for compatibility reasons, we can't change this
        return window["innerWidth"] || document["body"]["clientWidth"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetClientWidth"] = 0;
    }
    ;

    /** @return {number} */
    UCF_ClientInspector["prototype"]["iGetClientHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetClientHeight"]++;
        }
        ;
        // The name of this function is misleading: It does not return the
        // clientHeight, it returns the innerHeight (which is clientHeight + scrollbar)!
        // But for compatibility reasons, we can't change this
        return window["innerHeight"] || document["body"]["clientHeight"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetClientHeight"] = 0;
    }
    ;

    /** @return {number} */
    UCF_ClientInspector["prototype"]["iGetScreenWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetScreenWidth"]++;
        }
        ;
        return UCF_DomUtil["iScreenWidth"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetScreenWidth"] = 0;
    }
    ;

    /** @return {number} */
    UCF_ClientInspector["prototype"]["iGetScreenHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetScreenHeight"]++;
        }
        ;
        return UCF_DomUtil["iScreenHeight"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetScreenHeight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetScreenOrientation"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetScreenOrientation"]++;
        }
        ;
        return UCF_DomUtil["sScreenOrientation"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetScreenOrientation"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetQME"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetQME"]++;
        }
        ;
        return UCF_UserAgent["bIsQME"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetQME"] = 0;
    }
    ;

    /** @return {'QME'|'IE_STANDARDS<=8'|'COMPATIBLE'} */
    UCF_ClientInspector["prototype"]["sGetRenderingModeCompatibility"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetRenderingModeCompatibility"]++;
        }
        ;
        if (UCF_UserAgent["bIsIE"]()) {
            if (UCF_UserAgent["bIsQME"]()) {
                return 'QME';
            } else if (!__UCF_IE6__ && parseInt(document["documentMode"]) <= 8) {
                return 'IE_STANDARDS<=8';
            }
        }

        return 'COMPATIBLE';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetRenderingModeCompatibility"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedTableRowHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedTableRowHeight"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedTableRowHeight');
        /** @type {string} */
        var sHeight = this["sGetCurrentStyle"](oDomRef, 'height');

        return (
            sHeight &&
            sHeight !== 'auto' &&
            sHeight !== this["sThemedTableRowHeight"]
        )
            ? sHeight
            : this["sThemedTableRowHeight"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedTableRowHeight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedFormLayoutRowHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedFormLayoutRowHeight"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedFormLayoutRowHeight');
        /** @type {string} */
        var sHeight = this["sGetCurrentStyle"](oDomRef, 'height');

        return (
            sHeight &&
            sHeight !== 'auto' &&
            sHeight !== this["sThemedFormLayoutRowHeight"]
        )
            ? sHeight
            : this["sThemedFormLayoutRowHeight"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedFormLayoutRowHeight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedScrollbarDimension"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedScrollbarDimension"]++;
        }
        ;
        /** @type {string} */
        var sWidth = UCF_DomUtil["iGetScrollbarWidth"]() + 'px';

        return (
            sWidth &&
            sWidth !== 'auto' &&
            sWidth !== this["sThemedScrollbarDimension"]
        )
            ? sWidth
            : this["sThemedScrollbarDimension"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedScrollbarDimension"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedDocumentBackgroundColor"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedDocumentBackgroundColor"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedDocumentBackgroundColor');
        /** @type {string} */
        var sColor = this["sGetCurrentStyle"](oDomRef, 'background-color');

        return (sColor && sColor !== this["sThemedDocumentBackgroundColor"])
            ? sColor
            : this["sThemedDocumentBackgroundColor"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedDocumentBackgroundColor"] = 0;
    }
    ;

    /**
     * @private
     * @return {string}
     */
    UCF_ClientInspector["prototype"]["sGetThemedSvgLibs"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedSvgLibs"]++;
        }
        ;
        /** @type {Array<string>} */
        var aSvgLibs = this["aGetThemedSvgLibsBackgroundImage"]() || [];
        /** @type {string} */
        var sSvgLibs = aSvgLibs["join"](',');

        this["inlineSvgLib"](aSvgLibs);

        return (sSvgLibs && sSvgLibs !== this["sThemedSvgLibs"]) ?
            sSvgLibs :
            this["sThemedSvgLibs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedSvgLibs"] = 0;
    }
    ;

    /**
     * @private
     * @return {string}
     */
    UCF_ClientInspector["prototype"]["sGetThemedSvgLibUrls"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedSvgLibUrls"]++;
        }
        ;
        /** @type {Array<string>} */
        var aSvgLibs = this["aGetThemedSvgLibsDataUri"]() || [];
        /** @type {string} */
        var sSvgLibs = '';
        /** @type {Array<string>} */
        var aThemedSvgLibUrls = null;
        /** @type {Object<string,string>} */
        var oResult;

        try {
            aThemedSvgLibUrls = UCF_JsUtil["oJsonParse"](this["sThemedSvgLibUrls"]);
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(ERROR, 'No valid JSON for in parameter ThemedSvgLibUrls' + this["sThemedSvgLibUrls"], "ClientInspector.js(531): sGetThemedSvgLibUrls");
            }
            ;

            return '';
        }

        oResult = UCF_JsUtil["reduce"](aThemedSvgLibUrls, function (oResult, sId) {
            /** @type {string} */
            var sUrl = UCF_JsUtil["find"](aSvgLibs, function (sLibUrl) {
                return UCF_StringUtil["bContains"](sLibUrl, sId + '.svg');
            });

            if (sUrl) {
                oResult[sId] = sUrl;
            }

            return oResult;
        }, {});

        this["inlineSvgLib"](UCF_JsUtil["values"](oResult));

        sSvgLibs = UCF_JsUtil["sJsonStringify"](oResult);

        return (sSvgLibs && sSvgLibs !== this["sThemedSvgLibs"]) ?
            sSvgLibs :
            this["sThemedSvgLibs"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedSvgLibUrls"] = 0;
    }
    ;

    /**
     * @private
     * @param {Array<string>} aSvgLibs  Array of to be loaded SVG Libs
     */
    UCF_ClientInspector["prototype"]["inlineSvgLib"] = function (aSvgLibs) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["inlineSvgLib"]++;
        }
        ;
        if (aSvgLibs && aSvgLibs["length"] > 0) {
            UCF_ResourceUtil["enableSVG"]();
        }

        UCF_JsUtil["forEach"](
            UCF_JsUtil["filter"](aSvgLibs, UCF_JsUtil["bIsAbsoluteUrl"]),
            function (sLib) {
                UCF_ResourceUtil["inlineSvgLib"](decodeURIComponent(sLib));
            }
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["inlineSvgLib"] = 0;
    }
    ;

    /**
     * @private
     * @return {Array<string>}
     */
    UCF_ClientInspector["prototype"]["aGetThemedSvgLibsBackgroundImage"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["aGetThemedSvgLibsBackgroundImage"]++;
        }
        ;
        /** @type {HTMLDivElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedSvgLibs');
        /** @type {string} */
        var sBgImage = this["sGetCurrentStyle"](oDomRef, 'background-image');
        /** @type {RegExp} */
        var rSvgLibsMatch;
        /** @type {Array.<string>} */
        var aSvgLibs;
        /** @type {string} */
        var sDocumentOrigin;
        /** @type {string} */
        var sSvgLib;

        if (sBgImage) {
            rSvgLibsMatch = /url\(\s*(?:\"|\')?(.*?)(?:\"|\')?\s*\)/g;
            aSvgLibs = [];
            sDocumentOrigin = UCF_ResourceUtil["sGetDocumentOrigin"]();

            while (rSvgLibsMatch["test"](sBgImage)) {
                sSvgLib = RegExp["$1"];

                // Remove host when it is the same as document
                if (sSvgLib["indexOf"](sDocumentOrigin) === 0) {
                    sSvgLib = sSvgLib["replace"](sDocumentOrigin, '');
                }

                if (/^\./["test"](sSvgLib)) {
                    sSvgLib = UCF_ResourceUtil["sGetThemeRoot"]() + '/' + sSvgLib;
                }

                aSvgLibs["push"](encodeURIComponent(UCF_ResourceUtil["sNormalizeUrl"](sSvgLib)));
            }
        }

        return aSvgLibs;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["aGetThemedSvgLibsBackgroundImage"] = 0;
    }
    ;

    /** @return {Array<string>} */
    UCF_ClientInspector["prototype"]["aGetThemedSvgLibsDataUri"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["aGetThemedSvgLibsDataUri"]++;
        }
        ;
        /** @type {string} */
        var sBaseUrl = UCF_ResourceUtil["oGetLightspeedCssLink"]()["href"];
        /** @type {{'SAP-icons': string, 'SAPGUI-icons': string, 'SAPWeb-icons': string}} */
        var oMetadata = UCF_ResourceUtil["oGetMetadataFromTheme"](
            UCF_DomUtil["$"](this["sId"] + '-ThemedSvgLibsDataUri')
        );

        return UCF_JsUtil["map"]([
            oMetadata['SAP-icons'],
            oMetadata['SAPGUI-icons'],
            oMetadata['SAPWeb-icons']
        ], function (sUrl) {
            return /^\s*url\(/["test"](sUrl)
                ? UCF_JsUtil["sGetResolvedUrl"](/(?:url\(\s*(?:\"|\')?)(.*?\.svg)/["exec"](sUrl)[1], sBaseUrl)
                : UCF_StringUtil["sTrim"](sUrl);
        });
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["aGetThemedSvgLibsDataUri"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedRasterHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedRasterHeight"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedRasterHeight', 'height', 'auto', this["sThemedRasterHeight"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedRasterHeight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedRasterWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedRasterWidth"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedRasterWidth', 'width', 'auto', this["sThemedRasterWidth"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedRasterWidth"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedLayoutPaddingTop"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedLayoutPaddingTop"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedLayoutPaddingTop', 'paddingTop', '', this["sThemedLayoutPaddingTop"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedLayoutPaddingTop"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedLayoutPaddingLeft"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedLayoutPaddingLeft"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedLayoutPaddingLeft', 'paddingLeft', '', this["sThemedLayoutPaddingLeft"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedLayoutPaddingLeft"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedLayoutPaddingBottom"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedLayoutPaddingBottom"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedLayoutPaddingBottom', 'paddingBottom', '', this["sThemedLayoutPaddingBottom"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedLayoutPaddingBottom"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedLayoutPaddingRight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedLayoutPaddingRight"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedLayoutPaddingRight', 'paddingRight', '', this["sThemedLayoutPaddingRight"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedLayoutPaddingRight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedAbapListRasterHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedAbapListRasterHeight"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedAbapListRasterHeight', 'height', 'auto', this["sThemedAbapListRasterHeight"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedAbapListRasterHeight"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedAbapListRasterWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedAbapListRasterWidth"]++;
        }
        ;
        return this["sGetThemedProperty"]('-ThemedAbapListRasterWidth', 'width', 'auto', this["sThemedAbapListRasterWidth"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedAbapListRasterWidth"] = 0;
    }
    ;

    /**
     * @private
     * @param {string} sIdSuffix
     * @param {string} sProperty
     * @param {string} sDefault
     * @param {string} sValue
     * @return {string}
     */
    UCF_ClientInspector["prototype"]["sGetThemedProperty"] = function (sIdSuffix, sProperty, sDefault, sValue) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedProperty"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + sIdSuffix);
        /** @type {string} */
        var sResult = this["sGetCurrentStyle"](oDomRef, sProperty);

        return (sResult && sResult !== sDefault && sResult !== sValue)
            ? sResult
            : sValue;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedProperty"] = 0;
    }
    ;

// #region ThemedValueHelpHeight ==============================================

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedValueHelpHeight"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedValueHelpHeight"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedValueHelpHeight');
        /** @type {string} */
        var sResult = this["sGetCurrentStyle"](oDomRef, 'height');

        return sResult
            ? sResult === 'auto'
                ? '-1'
                : UCF_StringUtil["bEndsWith"](sResult, 'px')
                    ? this["iGetThemedValueHelpHeightPx"](parseInt(sResult, 10)) + 'px'
                    : sResult
            : '-1';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedValueHelpHeight"] = 0;
    }
    ;

    /**
     * @param {number} iPx
     * @return {number}
     */
    UCF_ClientInspector["prototype"]["iGetThemedValueHelpHeightPx"] = function (iPx) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetThemedValueHelpHeightPx"]++;
        }
        ;
        return UCF_UserAgent["bMatchesResponsiveBreakpoint"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]["S"], this["oLS"])
            ? iPx
            // eslint-disable-next-line no-magic-numbers
            : Math["min"](iPx, Math["floor"](this["iGetClientHeight"]() * (100 - UCF_ClientInspector["iGetThemedValueHelpHeightMarginPercent"]()) / 100));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetThemedValueHelpHeightPx"] = 0;
    }
    ;

    /** @type {number} */
    UCF_ClientInspector["iThemedValueHelpHeightMarginPercent"] = null;

    UCF_ClientInspector["iGetThemedValueHelpHeightMarginPercent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetThemedValueHelpHeightMarginPercent"]++;
        }
        ;
        if (UCF_ClientInspector["iThemedValueHelpHeightMarginPercent"] === null) {
            UCF_ClientInspector["iThemedValueHelpHeightMarginPercent"] = 2 * parseInt(
                UCF_ClassLoader["oGetClass"]('UCF_PopupWindow')["oGetMetadata"]()["iMaxSizeMarginY"]
            ) || 0;
        }

        return UCF_ClientInspector["iThemedValueHelpHeightMarginPercent"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetThemedValueHelpHeightMarginPercent"] = 0;
    }
    ;

// #endregion
// #region ThemedValueHelpWidth ===============================================

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemedValueHelpWidth"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemedValueHelpWidth"]++;
        }
        ;
        /** @type {HTMLSpanElement} */
        var oDomRef = UCF_DomUtil["$"](this["sId"] + '-ThemedValueHelpWidth');
        /** @type {string} */
        var sResult = this["sGetCurrentStyle"](oDomRef, 'width');

        return sResult
            ? sResult === 'auto'
                ? '-1'
                : UCF_StringUtil["bEndsWith"](sResult, 'px')
                    ? this["iGetThemedValueHelpWidthPx"](parseInt(sResult, 10)) + 'px'
                    : sResult
            : '-1';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemedValueHelpWidth"] = 0;
    }
    ;

    /**
     * @param {number} iPx
     * @return {number}
     */
    UCF_ClientInspector["prototype"]["iGetThemedValueHelpWidthPx"] = function (iPx) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetThemedValueHelpWidthPx"]++;
        }
        ;
        return UCF_UserAgent["bMatchesResponsiveBreakpoint"](UCF_UserAgent["RESPONSIVE_BREAKPOINT"]["S"], this["oLS"])
            ? iPx
            : Math["min"](iPx, Math["floor"](this["iGetClientWidth"]() * (100 - UCF_ClientInspector["iGetThemedValueHelpWidthMarginPercent"]()) / 100));
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetThemedValueHelpWidthPx"] = 0;
    }
    ;

    /** @type {number} */
    UCF_ClientInspector["iThemedValueHelpWidthMarginPercent"] = null;

    /**
     * @static
     * @return {number}
     */
    UCF_ClientInspector["iGetThemedValueHelpWidthMarginPercent"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["iGetThemedValueHelpWidthMarginPercent"]++;
        }
        ;
        if (UCF_ClientInspector["iThemedValueHelpWidthMarginPercent"] === null) {
            UCF_ClientInspector["iThemedValueHelpWidthMarginPercent"] = 2 * parseInt(
                UCF_ClassLoader["oGetClass"]('UCF_PopupWindow')["oGetMetadata"]()["iMaxSizeMarginX"]
            ) || 0;
        }

        return UCF_ClientInspector["iThemedValueHelpWidthMarginPercent"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["iGetThemedValueHelpWidthMarginPercent"] = 0;
    }
    ;

// #endregion

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetThemeID"]++;
        }
        ;
        return UCF_ResourceUtil["sGetThemeID"]() || window["UCF_System"]["sThemeID"] || '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetThemeID"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetSapThemeID"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetSapThemeID"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_CssMetaData} */
        var oCssMetaData = UCF_ResourceUtil["oExtractCssMetaData"]();

        return UCF_JsUtil["find"](
            [this["sGetThemeID"]()]["concat"]((oCssMetaData && oCssMetaData["Extends"]) || []),
            function (sThemeID) {
                return UCF_StringUtil["bStartsWith"](sThemeID, 'sap_');
            }
        ) || '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetSapThemeID"] = 0;
    }
    ;

    /** @return {Array<string>} */
    UCF_ClientInspector["prototype"]["aGetThemeTags"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["aGetThemeTags"]++;
        }
        ;
        /** @type {UCF_ResourceUtil_CssMetaData} */
        var oCssMetaData = UCF_ResourceUtil["oExtractCssMetaData"]();

        return (oCssMetaData && oCssMetaData["Tags"]) ? oCssMetaData["Tags"] : [];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["aGetThemeTags"] = 0;
    }
    ;

    /**
     * @param {HTMLDivElement} oDomRef the element
     * @param {string} sStyleAttribute the attribute
     * @return {string}
     */
    UCF_ClientInspector["prototype"]["sGetCurrentStyle"] = function (oDomRef, sStyleAttribute) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetCurrentStyle"]++;
        }
        ;
        return oDomRef
            ? this["sFormatCurrentStyle"](
                UCF_DomUtil["sGetCurrentStyle"](oDomRef, sStyleAttribute)
            )
            : '';
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetCurrentStyle"] = 0;
    }
    ;

    /**
     * @param {string} sCurrentStyle the current style
     * @return {string} the formatted current style
     */
    UCF_ClientInspector["prototype"]["sFormatCurrentStyle"] = function (sCurrentStyle) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sFormatCurrentStyle"]++;
        }
        ;
        /** @type {RegExpMatchArray} */
        var aMatch;
        /** @type {string} */
        var sValue;
        /** @type {string} */
        var sUnit;

        if (sCurrentStyle) {
            aMatch = sCurrentStyle["match"](/(^[\d\.]+)(\w*)$/);

            // eslint-disable-next-line no-magic-numbers
            if (aMatch && aMatch["length"] >= 3) { // Is single dimension value
                sValue = aMatch[1];
                sUnit = aMatch[2]["toLowerCase"](); // eslint-disable-line no-magic-numbers

                if (sUnit === 'px') {
                    sValue = new String(Math["round"](parseFloat(sValue)));
                }

                sCurrentStyle = sValue + sUnit;
            }

            return sCurrentStyle;
        } else {

            return null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sFormatCurrentStyle"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetWordEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetWordEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["WORD"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetWordEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetExcelEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetExcelEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["EXCEL"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetExcelEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetFlashEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetFlashEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["FLASH"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetFlashEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetAcrobatEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetAcrobatEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["ACROBAT"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetAcrobatEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetSilverlightEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetSilverlightEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["SILVERLIGHT"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetSilverlightEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetJavaEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetJavaEnabled"]++;
        }
        ;
        return UCF_JsUtil["bIsActiveComponentEnabled"](UCF_JsUtil["eActiveComponents"]["JAVA"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetJavaEnabled"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetJavaVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetJavaVersion"]++;
        }
        ;
        return UCF_JsUtil["sGetInstalledJavaVersion"](UCF_JsUtil["eActiveComponents"]["JAVA"]);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetJavaVersion"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetWebSocketsEnabled"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetWebSocketsEnabled"]++;
        }
        ;
        return 'WebSocket' in window;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetWebSocketsEnabled"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetWindowOpenerExists"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetWindowOpenerExists"]++;
        }
        ;
        try {
            return window["top"]["opener"] ? true : false;
        } catch (e) {
            return window["opener"] ? true : false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetWindowOpenerExists"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetDocumentDomain"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetDocumentDomain"]++;
        }
        ;
        return document["domain"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetDocumentDomain"] = 0;
    }
    ;

    /** @return {string} */
    UCF_ClientInspector["prototype"]["sGetClientURL"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetClientURL"]++;
        }
        ;
        return document["location"]["href"];
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetClientURL"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetIsTopWindow"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetIsTopWindow"]++;
        }
        ;
        return window === top;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetIsTopWindow"] = 0;
    }
    ;

    /** @return {boolean} */
    UCF_ClientInspector["prototype"]["bGetParentAccessible"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetParentAccessible"]++;
        }
        ;
        /** @type {string} */
        var test;

        try {
            test = window["parent"]["name"]; // eslint-disable-line no-unused-vars

            return true;
        } catch (e) {
            return false;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetParentAccessible"] = 0;
    }
    ;

    /** @return {'PHONE'|'TABLET'|'DESKTOP'} */
    UCF_ClientInspector["prototype"]["sGetDeviceType"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetDeviceType"]++;
        }
        ;
        if (UCF_UserAgent["bIsTablet"]()) {
            return 'TABLET';
        } else if (UCF_UserAgent["bIsPhone"]()) {
            return 'PHONE';
        } else if (UCF_UserAgent["bIsCombi"]()) {
            return 'COMBI';
        } else {
            return 'DESKTOP';
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetDeviceType"] = 0;
    }
    ;

    /** @return {string} see platform enumeration*/
    UCF_ClientInspector["prototype"]["sGetPlatform"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["sGetPlatform"]++;
        }
        ;
        return UCF_UserAgent["sGetPlatform"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["sGetPlatform"] = 0;
    }
    ;

    /**
     * Checks if the  HTML rendering fits to the currently applied CSS resources.
     *
     * @private
     * @return {boolean} returns if the  HTML rendering fits to the currently
     *  applied CSS resources
     */
    UCF_ClientInspector["prototype"]["bGetCssMatchesHtmlVersion"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bGetCssMatchesHtmlVersion"]++;
        }
        ;
        /** @type {HTMLLinkElement} */
        var oLightspeedCssLink = UCF_ResourceUtil["oGetLightspeedCssLink"]();
        /** @type {string} */
        var sCssVersionIsrejected;
        /** @type {boolean} */
        var bResult = true;

        if (oLightspeedCssLink) {
            sCssVersionIsrejected = oLightspeedCssLink["getAttribute"]('data-sap-ls-css-version-isrejected');

            if (sCssVersionIsrejected) {
                bResult = sCssVersionIsrejected == 'false'; // eslint-disable-line eqeqeq
            }
        }

        return bResult;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bGetCssMatchesHtmlVersion"] = 0;
    }
    ;

    /**
     *
     * First quick implementation of resize notification
     * TODO finalize it
     *
     */

    /**
     * Initializes the all notifications
     */
    UCF_ClientInspector["prototype"]["initNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["initNotification"]++;
        }
        ;
        /** @type {UCF_ClientInspector} */
        var self = this;

        /** @type {{bStopped: boolean, fResizeHandler: function, fOrientationHandler: function}} */
        this["oNotificationInfo"] = {
            "bStopped": false,
            "fResizeHandler": null,
            "fOrientationHandler": null
        };

        if (this["bNeedResizeNotification"]() && 'onresize' in window) {
            this["oNotificationInfo"]["fResizeHandler"] = function () {
                self["onBrowserWindowResize"]();
            };
        }

        if (
            this["bNeedOrientationChangedNotification"]() &&
            'onorientationchange' in window
        ) {
            this["oNotificationInfo"]["fOrientationHandler"] = function () {
                self["onScreenOrientationChanged"]();
            };
        }

        if (this["oNotificationInfo"]["fResizeHandler"]) {
            UCF_DomUtil["attachEvent"](
                window,
                'resize',
                this["oNotificationInfo"]["fResizeHandler"],
                false
            );
        }
        if (this["oNotificationInfo"]["fOrientationHandler"]) {
            UCF_DomUtil["attachEvent"](
                window,
                'orientationchange',
                this["oNotificationInfo"]["fOrientationHandler"],
                false
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["initNotification"] = 0;
    }
    ;

    /**
     * CleanUp the notification
     */
    UCF_ClientInspector["prototype"]["cleanUpNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["cleanUpNotification"]++;
        }
        ;
        if (this["oNotificationInfo"]) {
            UCF_JsUtil["resetMassNotificationFilter"](this["oNotificationInfo"]);

            if (this["oNotificationInfo"]["fResizeHandler"]) {
                UCF_DomUtil["detachEvent"](
                    window,
                    'resize',
                    this["oNotificationInfo"]["fResizeHandler"],
                    false
                );
            }
            if (this["oNotificationInfo"]["fOrientationHandler"]) {
                UCF_DomUtil["detachEvent"](
                    window,
                    'orientationchange',
                    this["oNotificationInfo"]["fOrientationHandler"],
                    false
                );
            }

            this["oNotificationInfo"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["cleanUpNotification"] = 0;
    }
    ;

    /**
     * Returns true if the configuration of the ClientInspector needs a resize
     * notification
     *
     * @return {boolean} return value
     */
    UCF_ClientInspector["prototype"]["bNeedResizeNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bNeedResizeNotification"]++;
        }
        ;
        return this["sNotificationTrigger"] === this["NOTIFICATION_TRIGGER"]["WHEN_CHANGED"] && (
            this["sClientHeight"] !== 'OFF' ||
            this["sClientWidth"] !== 'OFF' ||
            this["sThemedLayoutPaddingTop"] !== 'OFF' ||
            this["sThemedLayoutPaddingBottom"] !== 'OFF' ||
            this["sThemedLayoutPaddingLeft"] !== 'OFF' ||
            this["sThemedLayoutPaddingRight"] !== 'OFF' ||
            this["sThemedValueHelpWidth"] !== 'OFF' ||
            this["sThemedValueHelpHeight"] !== 'OFF'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bNeedResizeNotification"] = 0;
    }
    ;

    /**
     * Returns true if the configuration of the ClientInspector needs a orientation
     * changed notification
     *
     * @return {boolean} return value
     */
    UCF_ClientInspector["prototype"]["bNeedOrientationChangedNotification"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["bNeedOrientationChangedNotification"]++;
        }
        ;
        return this["sNotificationTrigger"] === this["NOTIFICATION_TRIGGER"]["WHEN_CHANGED"] && (
            this["sScreenOrientation"] !== 'OFF' ||
            this["sThemedValueHelpWidth"] !== 'OFF' ||
            this["sThemedValueHelpHeight"] !== 'OFF'
        );
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["bNeedOrientationChangedNotification"] = 0;
    }
    ;

    /** The handler called by the resize event */
    UCF_ClientInspector["prototype"]["onBrowserWindowResize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["onBrowserWindowResize"]++;
        }
        ;
        if (!this["oNotificationInfo"]["bStopped"]) {
            UCF_JsUtil["feedMassNotificationFilter"](
                500, // eslint-disable-line no-magic-numbers
                this["oNotificationInfo"],
                this,
                'check', [this["CHECK_REASON"]["RESIZE"]]
            );
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["onBrowserWindowResize"] = 0;
    }
    ;

    /** The handler called by the orientation change event */
    UCF_ClientInspector["prototype"]["onScreenOrientationChanged"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["onScreenOrientationChanged"]++;
        }
        ;
        if (!this["oNotificationInfo"]["bStopped"]) {
            this["check"](this["CHECK_REASON"]["ORIENTATION_CHANGED"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["onScreenOrientationChanged"] = 0;
    }
    ;

    /**
     * Handler for the unlock event of lightspeed
     *
     * @private
     * @param {UCF_Event} oEvent The reference to internal event
     */
    UCF_ClientInspector["prototype"]["onLsUnlock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["onLsUnlock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "ClientInspector.js(1120): onLsUnlock");
        }
        ;

        if (this["oNotificationInfo"]) {
            this["oNotificationInfo"]["bStopped"] = false;
            this["check"](this["CHECK_REASON"]["ORIENTATION_CHANGED"] | this["CHECK_REASON"]["RESIZE"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["onLsUnlock"] = 0;
    }
    ;

    /**
     * Handler for the lock event of lightspeed
     *
     * @private
     * @param {UCF_Event} oEvent The reference to internal event
     */
    UCF_ClientInspector["prototype"]["onLsLock"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["onLsLock"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oEvent instanceof UCF_Event, "oEvent instanceof UCF_Event", "ClientInspector.js(1135): onLsLock");
        }
        ;

        if (this["oNotificationInfo"]) {
            this["oNotificationInfo"]["bStopped"] = true;
            UCF_JsUtil["resetMassNotificationFilter"](this["oNotificationInfo"]);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["onLsLock"] = 0;
    }
    ;

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #sNotificationTrigger}
     * - {@link #sClientWidth}
     * - {@link #sClientHeight}
     * - {@link #sScreenWidth}
     * - {@link #sScreenHeight}
     * - {@link #sScreenOrientation}
     * - Deprecated: {@link #sQME}
     * - {@link #sRenderingModeCompatibility}
     * - {@link #sThemeID}
     * - {@link #sSapThemeID}
     * - {@link #sThemeScope}
     * - {@link #sThemedTableRowHeight}
     * - {@link #sThemedFormLayoutRowHeight}
     * - {@link #sThemedScrollbarDimension}
     * - {@link #sThemedDocumentBackgroundColor}
     * - Deprecated: {@link #sThemedSvgLibs}
     * - {@link #sThemedSvgLibUrls}
     * - {@link #sThemedRasterHeight}
     * - {@link #sThemedRasterWidth}
     * - {@link #sThemedLayoutPaddingTop}
     * - {@link #sThemedLayoutPaddingLeft}
     * - {@link #sThemedLayoutPaddingBottom}
     * - {@link #sThemedLayoutPaddingRight}
     * - {@link #sThemedAbapListRasterHeight}
     * - {@link #sThemedAbapListRasterWidth}
     * - {@link #sThemedValueHelpHeight}
     * - {@link #sThemedValueHelpWidth}
     * - {@link #sThemeTags}
     * - {@link #sWordEnabled}
     * - {@link #sExcelEnabled}
     * - {@link #sFlashEnabled}
     * - {@link #sAcrobatEnabled}
     * - {@link #sSilverlightEnabled}
     * - {@link #sJavaEnabled}
     * - {@link #sJavaVersion}
     * - {@link #sWebSocketsEnabled}
     * - {@link #sDeviceType}
     * - {@link #sCssMatchesHtmlVersion}
     * - {@link #sCustomData}
     * - {@link #sPlatform}
     * - {@link #sWindowOpenerExists}
     * - {@link #sClientURL}
     * - {@link #sDocumentDomain}
     * - {@link #sIsTopWindow}
     * - {@link #sParentAccessible}
     * @private
     * @type {string[]}
     */
    UCF_ClientInspector["prototype"]["aAttributeNames"] = ['sNotificationTrigger', 'sClientWidth', 'sClientHeight', 'sScreenWidth', 'sScreenHeight', 'sScreenOrientation', 'sQME', 'sRenderingModeCompatibility', 'sThemeID', 'sSapThemeID', 'sThemeScope', 'sThemedTableRowHeight', 'sThemedFormLayoutRowHeight', 'sThemedScrollbarDimension', 'sThemedDocumentBackgroundColor', 'sThemedSvgLibs', 'sThemedSvgLibUrls', 'sThemedRasterHeight', 'sThemedRasterWidth', 'sThemedLayoutPaddingTop', 'sThemedLayoutPaddingLeft', 'sThemedLayoutPaddingBottom', 'sThemedLayoutPaddingRight', 'sThemedAbapListRasterHeight', 'sThemedAbapListRasterWidth', 'sThemedValueHelpHeight', 'sThemedValueHelpWidth', 'sThemeTags', 'sWordEnabled', 'sExcelEnabled', 'sFlashEnabled', 'sAcrobatEnabled', 'sSilverlightEnabled', 'sJavaEnabled', 'sJavaVersion', 'sWebSocketsEnabled', 'sDeviceType', 'sCssMatchesHtmlVersion', 'sCustomData', 'sPlatform', 'sWindowOpenerExists', 'sClientURL', 'sDocumentDomain', 'sIsTopWindow', 'sParentAccessible'];

    /**
     * Array of names of events of the control:
     * - Notify
     * @type {string[]}
     */
    UCF_ClientInspector["prototype"]["aEventNames"] = ['Notify'];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * no public API available
     *
     * @private
     * @type {string[]}
     */
    UCF_ClientInspector["prototype"]["aMethodNames"] = [, 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     * Defines in which point in time it is checked if a notification is necessary
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sNotificationTrigger"] = "INITIAL";

    /**
     * The 'px' width of the client window.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sClientWidth"] = 'OFF';

    /**
     * The 'px' height of the client window.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sClientHeight"] = 'OFF';

    /**
     * The 'px' width of the screen.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sScreenWidth"] = 'OFF';

    /**
     * The 'px' height of screen.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sScreenHeight"] = 'OFF';

    /**
     * 'landscape' or 'portrait'
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sScreenOrientation"] = 'OFF';

    /**
     * 'TRUE' if QME is used on client side, 'FALSE' if not. Deprecated use RenderingModeCompatibility instead
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sQME"] = 'OFF';

    /**
     * 'COMPATIBLE' if document runs in a supported rendering mode, 'QME' if QME and 'IE_STANDARDSxx8' if IE standards mode in docmode 8 or lower
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sRenderingModeCompatibility"] = 'OFF';

    /**
     * The ID of the applied theme. E.g. 'sap_goldreflection' in UR/ls/sap_goldreflection/standards.css
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemeID"] = 'OFF';

    /**
     * The ID of the sap the the applied theme derives from. E.g. 'sap_belize' if 'myCocaColaBelize' derives from 'sap_belize', 'sap_belize' if 'sap_belize' is the applied theme.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sSapThemeID"] = 'OFF';

    /**
     * Defines the scopename in which the themed attributes are calculated
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemeScope"] = '';

    /**
     * The CSS height of a standard table row defined in the client applied theme.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedTableRowHeight"] = 'OFF';

    /**
     * The CSS height of a layout row used to align forms defined in the client applied theme.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedFormLayoutRowHeight"] = 'OFF';

    /**
     * The CSS dimension of the scrollbars.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedScrollbarDimension"] = 'OFF';

    /**
     * The CSS document background color.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedDocumentBackgroundColor"] = 'OFF';

    /**
     * Returns a comma separated list of URL-encoded paths referring to the available SVG libs
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedSvgLibs"] = 'OFF';

    /**
     * Returns a JSON string of URL-encoded paths referring to the available SVG libs
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedSvgLibUrls"] = '[]';

    /**
     * The CSS height of a raster row used to position elements.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedRasterHeight"] = 'OFF';

    /**
     * The CSS width of a raster column used to position elements.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedRasterWidth"] = 'OFF';

    /**
     * The CSS padding top of the layout.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedLayoutPaddingTop"] = 'OFF';

    /**
     * The CSS padding left of the layout.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedLayoutPaddingLeft"] = 'OFF';

    /**
     * The CSS padding bottom of the layout.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedLayoutPaddingBottom"] = 'OFF';

    /**
     * The CSS padding right of the layout.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedLayoutPaddingRight"] = 'OFF';

    /**
     * The CSS height of a raster row of a AbapList screen used to position elements.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedAbapListRasterHeight"] = 'OFF';

    /**
     * The CSS width of a raster column of a AbapList screen used to position elements.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedAbapListRasterWidth"] = 'OFF';

    /**
     * The minimum CSS height of the value help dialog as specified in the theme and the currently available height for a PopupWindow. '-1' (the default height of the PopupWindow) if the theme did not specify a height. This may be viewport- and orientation-dependent, so you may want to use NotificationTrigger=WHEN_CHANGED.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedValueHelpHeight"] = 'OFF';

    /**
     * The minimum CSS width of the value help dialog as specified in the theme and the currently available width for a PopupWindow. '-1' (the default width of the PopupWindow) if the theme did not specify a width. This may be viewport- and orientation-dependent, so you may want to use NotificationTrigger=WHEN_CHANGED.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemedValueHelpWidth"] = 'OFF';

    /**
     * A list of tags applied to the theme
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sThemeTags"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Word', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sWordEnabled"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Excel', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sExcelEnabled"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Flash', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sFlashEnabled"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Acrobat', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sAcrobatEnabled"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Silverlight', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sSilverlightEnabled"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle the active component 'Java', 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sJavaEnabled"] = 'OFF';

    /**
     * 'NOT_INSTALLED' if Java is not installed, 'UNKNOWN' if version unknown or X.X depending on the java version e.g. '1.4'. Patch levels are not included
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sJavaVersion"] = 'OFF';

    /**
     * 'TRUE' if client side is able to handle web sockets, 'FALSE' if not
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sWebSocketsEnabled"] = 'OFF';

    /**
     * 'DESKTOP', 'TABLET' or 'PHONE'. Server needs to set one of these values to be notified.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sDeviceType"] = 'OFF';

    /**
     * 'TRUE', 'FALSE'
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sCssMatchesHtmlVersion"] = 'OFF';

    /**
     * Sets a custom data string that can be retrieved on the client via method sGetCustomData() or getCustomData(sJsonPropertyName) in case it is a JSON string
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sCustomData"] = '';

    /**
     * See platform enumeration. Server needs to set one of these values to be notified.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sPlatform"] = 'OFF';

    /**
     * 'TRUE' when a opener does exist.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sWindowOpenerExists"] = 'OFF';

    /**
     * document.location.href
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sClientURL"] = 'OFF';

    /**
     * document.domain
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sDocumentDomain"] = 'OFF';

    /**
     * 'TRUE' when the window is top.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sIsTopWindow"] = 'OFF';

    /**
     * 'TRUE' when the parent window can be accessed.
     *
     * @private
     * @type {string}
     */
    UCF_ClientInspector["prototype"]["sParentAccessible"] = 'OFF';


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_ClientInspector["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["setDefaultValues"]++;
        }
        ;
        this["sNotificationTrigger"] = "INITIAL";
        this["sClientWidth"] = 'OFF';
        this["sClientHeight"] = 'OFF';
        this["sScreenWidth"] = 'OFF';
        this["sScreenHeight"] = 'OFF';
        this["sScreenOrientation"] = 'OFF';
        this["sQME"] = 'OFF';
        this["sRenderingModeCompatibility"] = 'OFF';
        this["sThemeID"] = 'OFF';
        this["sSapThemeID"] = 'OFF';
        this["sThemeScope"] = '';
        this["sThemedTableRowHeight"] = 'OFF';
        this["sThemedFormLayoutRowHeight"] = 'OFF';
        this["sThemedScrollbarDimension"] = 'OFF';
        this["sThemedDocumentBackgroundColor"] = 'OFF';
        this["sThemedSvgLibs"] = 'OFF';
        this["sThemedSvgLibUrls"] = '[]';
        this["sThemedRasterHeight"] = 'OFF';
        this["sThemedRasterWidth"] = 'OFF';
        this["sThemedLayoutPaddingTop"] = 'OFF';
        this["sThemedLayoutPaddingLeft"] = 'OFF';
        this["sThemedLayoutPaddingBottom"] = 'OFF';
        this["sThemedLayoutPaddingRight"] = 'OFF';
        this["sThemedAbapListRasterHeight"] = 'OFF';
        this["sThemedAbapListRasterWidth"] = 'OFF';
        this["sThemedValueHelpHeight"] = 'OFF';
        this["sThemedValueHelpWidth"] = 'OFF';
        this["sThemeTags"] = 'OFF';
        this["sWordEnabled"] = 'OFF';
        this["sExcelEnabled"] = 'OFF';
        this["sFlashEnabled"] = 'OFF';
        this["sAcrobatEnabled"] = 'OFF';
        this["sSilverlightEnabled"] = 'OFF';
        this["sJavaEnabled"] = 'OFF';
        this["sJavaVersion"] = 'OFF';
        this["sWebSocketsEnabled"] = 'OFF';
        this["sDeviceType"] = 'OFF';
        this["sCssMatchesHtmlVersion"] = 'OFF';
        this["sCustomData"] = '';
        this["sPlatform"] = 'OFF';
        this["sWindowOpenerExists"] = 'OFF';
        this["sClientURL"] = 'OFF';
        this["sDocumentDomain"] = 'OFF';
        this["sIsTopWindow"] = 'OFF';
        this["sParentAccessible"] = 'OFF';

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', "INITIAL", true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', '[]', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
            this["setClientProperty"]('', 'OFF', true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    /**
     * Event fires when given parameter values did not match to the given API value
     *
     * @private
     * @param {string} sId Identifier of the ClientInspector control.
     * @param {string} sData A map of parameters with their current values. The key/value is separated by ':' while the pairs are separated by ';'
     * @fires ClientInspector:Notify
     */
    UCF_ClientInspector["prototype"]["fireNotify"] = function (sId, sData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ClientInspector["_"]["fireNotify"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Data: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 2, "arguments.length == 2", "ClientInspector.js(1696): fireNotify");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "ClientInspector.js(1697): fireNotify");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "ClientInspector.js(1698): fireNotify");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sData != null, "sData != null", "ClientInspector.js(1699): fireNotify");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sData === 'string', "typeof sData === 'string'", "ClientInspector.js(1700): fireNotify");
        }
        ;

        mParams = {
            "Id": sId,
            "Data": sData
        };

        this["fireSemanticEvent"]('ClientInspector', 'Notify', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ClientInspector["_"]["fireNotify"] = 0;
    }
    ;

    /* eslint-disable jsdoc/require-returns */
    /* eslint-disable jsdoc/require-jsdoc */
    /* eslint-disable jsdoc/check-syntax */
    /* eslint-disable jsdoc/check-alignment */
    /* global _assert, _trace, DEBUG, ERROR */
/// <reference path="../../core/debug/Tracer.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../core/util/UserAgent.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../core/util/JsUtil.js"/>
    /* global UCF_BrowserWindow */
/// <reference path="../browser/BrowserWindow.js"/>
    /* global UCF_Control */
/// <reference path="../core/Control.js"/>
    /* global UCF_LS */
/// <reference path="../core/LS.js"/>
    /* global UCF_PostMessageServices */
/// <reference path="../controls/PostMessageServices.js"/>

// eslint-disable-next-line jsdoc/require-returns
    /**
     * Class LS IHubPostMessage
     *
     * Handles post message requests and resonses
     * Post message services can register and handle such requests/responses
     *
     * @class
     * @param {HTMLElement} oDomRef
     * @param {UCF_LS} oLS
     *
     *
     */
    function UCF_IHubPostMessage(oDomRef, oLS) {
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["UCF_IHubPostMessage"]++;
        }
        ;
        if (arguments["length"] === 0)
            return;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === 'object', "typeof(oDomRef) === 'object'", "IHubPostMessage.js(39): UCF_IHubPostMessage");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "IHubPostMessage.js(40): UCF_IHubPostMessage");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oLS instanceof UCF_LS, "oLS instanceof UCF_LS", "IHubPostMessage.js(41): UCF_IHubPostMessage");
        }
        ;

        UCF_Control["apply"](this, [oDomRef, oLS]);
        if (!UCF_UserAgent["bIsStandardsMode"]()) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageHubs are supported in standards mode only', "IHubPostMessage.js(45): UCF_IHubPostMessage");
            }
            ;
            // eslint-disable-next-line no-unsanitized/property
            this["oRootRef"]["innerHTML"] =
                oLS["sGetText"]('SAPUR_HTML5_CONTROL_ERROR', ['<a target="_blank" href="https://service.sap.com/sap/support/notes/1970689">Note 1970689</a>',
                    'Postmessage'
                ]);
            return;
        }
        UCF_IHubPostMessage["oInstance"] = this;
        this["oIHub"] = this["oGetParent"]();

        this["bSynchronous"] = oDomRef["getAttribute"]('sync') === 'true';
        this["setClientProperty"]('Synchronous', this["bSynchronous"], true);

        var sContents = oDomRef["innerHTML"]["substring"](11, oDomRef["innerHTML"]["length"] - 5);
        this["oLS"] = oLS;
        var aMessages;
        try {
            aMessages = UCF_JsUtil["oJsonParse"](sContents);
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageHub invalid JSON', "IHubPostMessage.js(65): UCF_IHubPostMessage");
            }
            ;
        }
        this["bAllResponsesReceived"] = true;
        UCF_IHubPostMessage["mMessageIds"] = new Object();
        UCF_DomUtil["attachEvent"](window, 'message', UCF_IHubPostMessage["postMessageHandler"], false);
        if (this["sServiceProviderListId"] && this["sServiceProviderListId"] !== '') {
            if (!UCF_IHubPostMessage["oPostMessageServiceList"])
                UCF_IHubPostMessage["oPostMessageServiceList"] =
                    oLS["oControlFactory"]["oGetControlById"](this["sServiceProviderListId"]);
        }
        if (aMessages != null) {
            if (aMessages["length"] !== undefined) {
                for (var i = 0; i < aMessages["length"]; i++)
                    this["postMessage"](UCF_JsUtil["sJsonStringify"](aMessages[i]));
            } else
                this["postMessage"](UCF_JsUtil["sJsonStringify"](aMessages));
        }
        if (this["sServiceWhitelist"]) {
            try {
                UCF_IHubPostMessage["aServiceWhitelist"] = UCF_JsUtil["oJsonParse"](this["sServiceWhitelist"]);
            } catch (e) {
                try {
                    if (typeof (this["sServiceWhitelist"]) === 'string')
                        UCF_IHubPostMessage["aServiceWhitelist"] = this["sServiceWhitelist"]["split"](",");
                } catch (e) {
                }
                if (__UCF_TRACE__) {
                    UCF_Tracer.trace(DEBUG, 'PostMessageHub error parsing ServiceWhitelist', "IHubPostMessage.js(90): UCF_IHubPostMessage");
                }
                ;
            }
        }
        if (this["bSynchronous"] && aMessages && aMessages["length"] > 0)
            oLS["oBrowserWindow"]["lock"](UCF_BrowserWindow["LOCKTYPES"]["POSTMESSAGE"]);
    };window["UCF_IHubPostMessage"] = UCF_IHubPostMessage;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_IHubPostMessage");
        UCF_IHubPostMessage["_"] = {UCF_IHubPostMessage: 0};
    }
    ;
    ;

    UCF_IHubPostMessage["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_Control"))();
    UCF_IHubPostMessage.prototype["sClassName"] = "UCF_IHubPostMessage";

    UCF_IHubPostMessage["prototype"]["initialize"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["initialize"]++;
        }
        ;
        // just to avoid assertions
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["initialize"] = 0;
    }
    ;

    UCF_IHubPostMessage["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["destroy"]++;
        }
        ;
        this["oIHub"] = null;
        this["bSynchronous"] = null;
        UCF_DomUtil["detachEvent"](window, 'message', UCF_IHubPostMessage["postMessageHandler"], false);
        UCF_Control.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["destroy"] = 0;
    }
    ;

    UCF_IHubPostMessage["addToServiceWhitelist"] = function (asEntries) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["addToServiceWhitelist"]++;
        }
        ;
        if (typeof (asEntries) === 'string')
            UCF_IHubPostMessage["aServiceWhitelist"]["push"](asEntries);
        else if (asEntries instanceof Array)
            UCF_IHubPostMessage["aServiceWhitelist"] = UCF_IHubPostMessage["aServiceWhitelist"]["concat"](asEntries);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["addToServiceWhitelist"] = 0;
    }
    ;

    UCF_IHubPostMessage["postMessageInternal"] = function (sData, sTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postMessageInternal"]++;
        }
        ;
        UCF_JsUtil["postMessage"](sData, sTarget);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postMessageInternal"] = 0;
    }
    ;

    UCF_IHubPostMessage["postObjectMessage"] = function (oMessage, sTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postObjectMessage"]++;
        }
        ;
        if (oMessage && oMessage["request_id"]) {
            if (!UCF_IHubPostMessage["mMessageIds"])
                UCF_IHubPostMessage["mMessageIds"] = new Object();
            if (oMessage["request_id"] !== '-1' && oMessage["request_id"] !== '' && oMessage["type"] === 'request') {
                UCF_IHubPostMessage["oInstance"]["bAllResponsesReceived"] = false;
                UCF_IHubPostMessage["mMessageIds"][oMessage["request_id"]] = true;
            }
        }
        UCF_IHubPostMessage["postMessageInternal"](UCF_JsUtil["sJsonStringify"](oMessage), sTarget);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postObjectMessage"] = 0;
    }
    ;

    UCF_IHubPostMessage["postServiceMessage"] = function (oMessage, oTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postServiceMessage"]++;
        }
        ;
        if (typeof (oMessage) === 'string')
            oTarget["postMessage"](oMessage, '*');
        else
            oTarget["postMessage"](UCF_JsUtil["sJsonStringify"](oMessage), '*');
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postServiceMessage"] = 0;
    }
    ;

    UCF_IHubPostMessage["prototype"]["postMessage"] = function (sData, sTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postMessage"]++;
        }
        ;
        var oMessage;
        try {
            oMessage = UCF_JsUtil["oJsonParse"](sData);
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageHub invalid JSON', "IHubPostMessage.js(145): postMessage");
            }
            ;
            UCF_IHubPostMessage["postMessageInternal"](sData, sTarget);
            return;
        }
        if (oMessage && oMessage[0]) {
            for (var i = 0; i < oMessage["length"]; i++)
                UCF_IHubPostMessage["postObjectMessage"](oMessage[i], sTarget);
            if (UCF_IHubPostMessage["oInstance"]["bSynchronous"] && oMessage["length"] > 1)
                UCF_IHubPostMessage["oInstance"]["oLS"]["oBrowserWindow"]["lock"](UCF_BrowserWindow["LOCKTYPES"]["POSTMESSAGE"]);
        } else
            UCF_IHubPostMessage["postObjectMessage"](oMessage, sTarget);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postMessage"] = 0;
    }
    ;

    /**
     * Posts a message to the sTarget
     * @param {string} sData
     * @param {string} sTarget
     * @public
     */
    UCF_IHubPostMessage["postMessageStatic"] = function (sData, sTarget) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postMessageStatic"]++;
        }
        ;
        UCF_IHubPostMessage["postMessageInternal"](sData, sTarget);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postMessageStatic"] = 0;
    }
    ;

    UCF_IHubPostMessage["postMessageHandler"] = function (oEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["postMessageHandler"]++;
        }
        ;
        var n;
        try {
            // Don't use UCF_JsUtil - we don'T want to see an assertion
            var oMessageContent = JSON["parse"](oEvent["data"]);
            // To be handled by a registered service ?

            /*				{
						    "type": "request",
						    "service": "sap.ushell.services.Container.setDirtyFlag",
						    "request_id": "id-1406564112128-0",
						    "body": {
						        "bIsDirty": true|false
						        }
						    }
						}
		*/
            if (oMessageContent["service"] && UCF_PostMessageServices && UCF_PostMessageServices["mServices"] !== null) {
                var oResponse = UCF_PostMessageServices["dispatch"](oMessageContent["service"], oEvent);
                if (typeof (oResponse) === 'boolean')
                    if (oResponse === true) return;
                if (oResponse) {
                    UCF_IHubPostMessage["postServiceMessage"](oResponse, oEvent["source"]);
                    return;
                }
            }
            if (oMessageContent && oMessageContent["request_id"] && oMessageContent["request_id"] !== '-1' && oMessageContent["request_id"] !== ''
                && UCF_IHubPostMessage["mMessageIds"] && true === UCF_IHubPostMessage["mMessageIds"][oMessageContent["request_id"]]) {
                UCF_IHubPostMessage["mMessageIds"][oMessageContent["request_id"]] = oMessageContent;
                UCF_IHubPostMessage["oInstance"]["bAllResponsesReceived"] = true;
                for (n in UCF_IHubPostMessage["mMessageIds"]) {
                    if (UCF_IHubPostMessage["mMessageIds"][n] === true) {
                        UCF_IHubPostMessage["oInstance"]["bAllResponsesReceived"] = false;
                        break;
                    }
                }
                // Fire event
                if (UCF_IHubPostMessage["oInstance"]["bAllResponsesReceived"]) {
                    if (UCF_IHubPostMessage["oInstance"]["bSynchronous"])
                        UCF_IHubPostMessage["oInstance"]["oLS"]["oBrowserWindow"]["unlock"](UCF_BrowserWindow["LOCKTYPES"]["POSTMESSAGE"]);
                    var aResponses = new Array();
                    for (n in UCF_IHubPostMessage["mMessageIds"])
                        aResponses["push"](UCF_IHubPostMessage["mMessageIds"][n]);
                    UCF_IHubPostMessage["mMessageIds"] = null;
                    UCF_IHubPostMessage["oInstance"]["fireReceive"](UCF_IHubPostMessage["oInstance"]["sId"],
                        UCF_JsUtil["sJsonStringify"](aResponses));
                    if (UCF_IHubPostMessage["mRequestQueue"] && UCF_IHubPostMessage["mRequestQueue"]["length"]) {
                        UCF_IHubPostMessage["oInstance"]["fireRequestReceive"](UCF_IHubPostMessage["oInstance"]["sId"],
                            UCF_JsUtil["sJsonStringify"](UCF_IHubPostMessage["mRequestQueue"]));
                        UCF_IHubPostMessage["mRequestQueue"] = [];
                    }
                }
            } else if (UCF_IHubPostMessage["oInstance"]["bHasEventListeners"]('RequestReceive')) { // unexpected request message received
                if (oMessageContent["type"] === 'request') {
                    if (UCF_IHubPostMessage["aServiceWhitelist"]) {
                        if (!UCF_IHubPostMessage["aServiceWhitelist"]["find"](function (X) {
                            return (X === oMessageContent["service"]);
                        })) return;
                    }
                    if (!UCF_IHubPostMessage["oInstance"]["bAllResponsesReceived"] && UCF_IHubPostMessage["oInstance"]["bSynchronous"]) {
                        if (!UCF_IHubPostMessage["mRequestQueue"])
                            UCF_IHubPostMessage["mRequestQueue"] = new Array();
                        UCF_IHubPostMessage["mRequestQueue"]["push"](oMessageContent);
                        return;
                    }
                    UCF_IHubPostMessage["oInstance"]["fireRequestReceive"](UCF_IHubPostMessage["oInstance"]["sId"],
                        UCF_JsUtil["sJsonStringify"](oMessageContent));
                }
            }
        } catch (e) {
            if (__UCF_TRACE__) {
                UCF_Tracer.trace(DEBUG, 'PostMessageHub invalid JSON received', "IHubPostMessage.js(238): postMessageHandler");
            }
            ;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["postMessageHandler"] = 0;
    }
    ;

// =============================================================================
// Copyright 2009 - SAP - NW UI F. All rights reserved. SAP
// PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
// =============================================================================

    /**
     * Array of names of transported parameters/attributes (clientaccess defined). In the current control:
     * - {@link #sServiceProviderListId}
     * - {@link #sTarget}
     * - {@link #bSynchronous}
     * - {@link #sServiceWhitelist}
     * - {@link #sCustomData}
     * @private
     * @type {string[]}
     */
    UCF_IHubPostMessage["prototype"]["aAttributeNames"] = ['sServiceProviderListId', 'sTarget', 'bSynchronous', 'sServiceWhitelist', 'sCustomData'];

    /**
     * Array of names of events of the control:
     * - Receive
     * - RequestReceive
     * @type {string[]}
     */
    UCF_IHubPostMessage["prototype"]["aEventNames"] = ['Receive', 'RequestReceive'];

    /**
     * Array of names of public methods of the control - public control API are:
     *
     * {@link #postMessage}
     * Post a String to the parent
     * Parameter: {string} Data - The string - JSON object - to be sent
     * Parameter: {string} Target - The target document
     *
     * {@link #addToServiceWhitelist}
     * Add an entry to the Servicewhitelist
     * Parameter: {string} ServiceName - Add a service name to the Whitelist
     *
     * @private
     * @type {string[]}
     */
    UCF_IHubPostMessage["prototype"]["aMethodNames"] = ['postMessage', 'addToServiceWhitelist', 'updateEvent', 'addClientListener', 'removeClientListener', 'playAnimation', 'getCustomData', 'sGetCustomData', 'show', 'hide', 'focus', 'oGetParentControl'];

// ===== Default values of the transported parameters =========================

    /**
     * Identifier of the Hub Plugin
     *
     * @private
     * @type {string}
     */
    UCF_IHubPostMessage["prototype"]["sServiceProviderListId"] = '';

    /**
     * Target
     *
     * @private
     * @type {string}
     */
    UCF_IHubPostMessage["prototype"]["sTarget"] = '';

    /**
     * Sync/Async behaviour
     *
     * @private
     * @type {boolean}
     */
    UCF_IHubPostMessage["prototype"]["bSynchronous"] = false;

    /**
     * Services allowed to fire a Requestreceive - JSON array of servicenames
     *
     * @private
     * @type {string}
     */
    UCF_IHubPostMessage["prototype"]["sServiceWhitelist"] = null;

    /**
     * Sets a custom data string that can be retrieved on the client via method sGetCustomData() or getCustomData(sJsonPropertyName) in case it is a JSON string
     *
     * @private
     * @type {string}
     */
    UCF_IHubPostMessage["prototype"]["sCustomData"] = '';


//#JSCOVER_EXCL_START
    /**
     * Default value setter
     * @private
     */
    UCF_IHubPostMessage["prototype"]["setDefaultValues"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["setDefaultValues"]++;
        }
        ;
        this["sServiceProviderListId"] = '';
        this["sTarget"] = '';
        this["bSynchronous"] = false;
        this["sServiceWhitelist"] = null;
        this["sCustomData"] = '';

        if (this["getClientControl"]() && !this["bKeepAlive"]) {
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', '', true);
            this["setClientProperty"]('', false, true);
            this["setClientProperty"]('', null, true);
            this["setClientProperty"]('', '', true);
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["setDefaultValues"] = 0;
    }
    ;
//#JSCOVER_EXCL_STOP

    /**
     * Event fires when a message has been received
     *
     * @private
     * @param {string} sId Identifier of the control
     * @param {string} sData Message payload - Json stringified
     * @fires IHubPostMessage:Receive
     */
    UCF_IHubPostMessage["prototype"]["fireReceive"] = function (sId, sData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["fireReceive"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Data: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 2, "arguments.length == 2", "IHubPostMessage.js(363): fireReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "IHubPostMessage.js(364): fireReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "IHubPostMessage.js(365): fireReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sData != null, "sData != null", "IHubPostMessage.js(366): fireReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sData === 'string', "typeof sData === 'string'", "IHubPostMessage.js(367): fireReceive");
        }
        ;

        mParams = {
            "Id": sId,
            "Data": sData
        };

        this["fireSemanticEvent"]('IHubPostMessage', 'Receive', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["fireReceive"] = 0;
    }
    ;

    /**
     * Event fires when a request message (object with type=='request' has been received
     *
     * @private
     * @param {string} sId Identifier of the control
     * @param {string} sData Message payload - Json stringified
     * @fires IHubPostMessage:RequestReceive
     */
    UCF_IHubPostMessage["prototype"]["fireRequestReceive"] = function (sId, sData) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_IHubPostMessage["_"]["fireRequestReceive"]++;
        }
        ;
        /** @type {UCF_Control} */
        var oControl;
        /** @type {{Id: string, Data: string}} */
        var mParams;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(arguments["length"] == 2, "arguments.length == 2", "IHubPostMessage.js(391): fireRequestReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sId != null, "sId != null", "IHubPostMessage.js(392): fireRequestReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sId === 'string', "typeof sId === 'string'", "IHubPostMessage.js(393): fireRequestReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(sData != null, "sData != null", "IHubPostMessage.js(394): fireRequestReceive");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof sData === 'string', "typeof sData === 'string'", "IHubPostMessage.js(395): fireRequestReceive");
        }
        ;

        mParams = {
            "Id": sId,
            "Data": sData
        };

        this["fireSemanticEvent"]('IHubPostMessage', 'RequestReceive', mParams, false, false, false);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_IHubPostMessage["_"]["fireRequestReceive"] = 0;
    }
    ;

    UCF_IHubPostMessage.prototype["aPublicMethods"] = ["postMessageStatic"].concat(UCF_IHubPostMessage.prototype.aPublicMethods || []);
    /* global _assert */
/// <reference path="../../../core/debug/Tracer.js"/>
    /* global UCF_DomUtil */
/// <reference path="../../../core/util/DomUtil.js"/>
    /* global UCF_JsUtil */
/// <reference path="../../../core/util/JsUtil.js"/>
    /* global UCF_UserAgent */
/// <reference path="../../../core/util/UserAgent.js"/>
    /* global UCF_EventProvider */
/// <reference path="../../../core/EventProvider.js"/>
    /* global UCF_Control */
/// <reference path="../../core/Control.js"/>
    /* global UCF_System */

/// <reference path="../../core/System.js"/>

    /**
     * Helper Class for all controls that need scrolling area events.
     * Control must register for its ScrollDomRef to scroll event,  because it does not bubble.
     *
     * @example  <caption>How to use</caption>
     *  var oScrollDomRef = UCF_DomUtil.$(this.sId + "-scrl");
     *    this.oScrollArea = 	new UCF_ScrollArea(oScrollDomRef);
     *    this.attachBrowserEvent("scroll", oScrollDomRef);
     *    this.oScrollArea.attachEvent(this.oScrollArea.E_EVENTS.Scroll,this,"onScroll");
     *    this.addDelegate(this.oScrollArea);
     *
     * @class
     * @param {HTMLElement} oDomRef
     */
    function UCF_ScrollArea(oDomRef) {
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["UCF_ScrollArea"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (oDomRef) === "object", "typeof(oDomRef) === \"object\"", "ScrollArea.js(32): UCF_ScrollArea");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oDomRef != null, "oDomRef != null", "ScrollArea.js(33): UCF_ScrollArea");
        }
        ;

        UCF_EventProvider["apply"](this);

        this["defineEvents"](['Scroll']);

        this["oDomRef"] = oDomRef;
        // eslint-disable-next-line ur/no-memory-leaks
        this["bDragScrollingEnabled"] = true;

        this["sTimeOutId"] = null;

        this["iCurrentStepY"] = 0;
        this["iCurrentStepX"] = 0;

        // eslint-disable-next-line ur/no-memory-leaks
        this["iScrollTop"] = 0;
        // eslint-disable-next-line ur/no-memory-leaks
        this["iScrollLeft"] = 0;

        // Some controls don't use static oCreateAndConnectScrollArea() !
        // They do: new UCF_ScrollArea(...); ...
        this["oDomRef"]["setAttribute"](UCF_ScrollArea["ScrollAttribute"], "true");
    };window["UCF_ScrollArea"] = UCF_ScrollArea;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ScrollArea");
        UCF_ScrollArea["_"] = {UCF_ScrollArea: 0};
    }
    ;
    ;
    UCF_ScrollArea["prototype"] = new (UCF_ClassLoader["oGetClass"]("UCF_EventProvider"))();
    UCF_ScrollArea.prototype["sClassName"] = "UCF_ScrollArea";

    UCF_ScrollArea["ScrollAttribute"] = "lsscrl";

    /**
     * Creates a scollarea if possible, adds it as delegate and attaches all necessary event handlers
     *
     * @param {UCF_Control} oControl
     * @param {string} sScrollingMode The scrolling mode of the area
     * @param {string} sScrollHandlerName The name of the scrollhandler which is called in the passed control by scroll events
     *
     * @type { UCF_ScrollArea }
     * @return { UCF_ScrollArea } The ScrollArea
     *
     * @see UCF_ScrollArea.disconnectScrollArea
     */
    UCF_ScrollArea["oCreateAndConnectScrollArea"] = function (oControl, sScrollingMode, sScrollHandlerName, oScrollDomRef) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["oCreateAndConnectScrollArea"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl != null, "oControl != null", "ScrollArea.js(74): oCreateAndConnectScrollArea");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "ScrollArea.js(75): oCreateAndConnectScrollArea");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sScrollingMode) === "string", "typeof(sScrollingMode) === \"string\"", "ScrollArea.js(76): oCreateAndConnectScrollArea");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (sScrollHandlerName) === "string", "typeof(sScrollHandlerName) === \"string\"", "ScrollArea.js(77): oCreateAndConnectScrollArea");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl[sScrollHandlerName] != null, "oControl[sScrollHandlerName] != null", "ScrollArea.js(78): oCreateAndConnectScrollArea");
        }
        ;

        var oScrollArea = null;

        if (sScrollingMode !== "NONE") { //scroll area only exists when a height is provided
            oScrollDomRef = oScrollDomRef || UCF_DomUtil["$"](oControl["sId"] + "-scrl");
            if (oScrollDomRef) {
                oScrollArea = new (UCF_ClassLoader["oGetClass"]("UCF_ScrollArea"))(oScrollDomRef);
                oControl["attachBrowserEvent"]("scroll", oScrollDomRef);
                oScrollArea["attachEvent"](oScrollArea["E_EVENTS"]["Scroll"], oControl, sScrollHandlerName);
                oControl["addDelegate"](oScrollArea);
            }
        }

        return oScrollArea;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["oCreateAndConnectScrollArea"] = 0;
    }
    ;

    /**
     * Disconnects a scroll area connected by the static method "oConnectAndGetScrollArea" and destroys it.
     *
     * @param {UCF_Control} oControl
     * @param {UCF_ScrollArea} oScrollArea The scroll area
     *
     * @see UCF_ScrollArea.oCreateAndConnectScrollArea
     */
    UCF_ScrollArea["disconnectAndDestroyScrollArea"] = function (oControl, oScrollArea) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["disconnectAndDestroyScrollArea"]++;
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(oControl instanceof UCF_Control, "oControl instanceof UCF_Control", "ScrollArea.js(104): disconnectAndDestroyScrollArea");
        }
        ;

        if (oScrollArea) {
            if (oScrollArea["E_EVENTS"]) {
                oScrollArea["detachEvent"](oScrollArea["E_EVENTS"]["Scroll"], oControl);
            }

            if (oScrollArea["oDomRef"]) {
                oScrollArea["oDomRef"]["removeAttribute"](UCF_ScrollArea["ScrollAttribute"]);
                oControl["detachBrowserEvent"]("scroll", oScrollArea["oDomRef"]);
            }

            oScrollArea["destroy"]();
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["disconnectAndDestroyScrollArea"] = 0;
    }
    ;

    UCF_ScrollArea["prototype"]["destroy"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["destroy"]++;
        }
        ;
        this["oDomRef"] = null;
        this["cleanUpScrollTiming"]();
        UCF_EventProvider.prototype["destroy"]["apply"](this, arguments);
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["destroy"] = 0;
    }
    ;

    /**
     * Handles the scroll event.
     * Only fire if necessary. Do not fire:
     * - When scroll position was defined
     *
     * @param {UCF_BrowserEvent} oBrowserEvent
     */
    UCF_ScrollArea["prototype"]["onscroll"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["onscroll"]++;
        }
        ;

        oBrowserEvent["cancelBubble"]();

        if (this["bIgnoreScrollEvent"]) {
            return;
        }

        this["handleScroll"]();

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["onscroll"] = 0;
    }
    ;

    /**
     *    A timeout is used to avoid multiple scroll events while scrolling,
     *  instead only one -in this case two- events are fired when the scroll process
     *  has finished.
     *  BUT in case no timeout is started yet one event is fired upfront
     *  this is to avoid having a scroll event in an event quue that no longer belongs
     *  to the new context.
     */
    UCF_ScrollArea["prototype"]["handleScroll"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["handleScroll"]++;
        }
        ;

        if (this["sTimeOutId"] == null) {
            this["fireScroll"]();
        } else {
            this["cleanUpScrollTiming"]();
        }
        this["sTimeOutId"] = UCF_JsUtil["delayedCall"](200, this, "fireScroll");

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["handleScroll"] = 0;
    }
    ;

    /**
     *  Resets the scroll timing state and kills all time out processes
     */
    UCF_ScrollArea["prototype"]["cleanUpScrollTiming"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["cleanUpScrollTiming"]++;
        }
        ;
        if (this["sTimeOutId"]) {
            UCF_JsUtil["clearDelayedCall"](this["sTimeOutId"]);
            this["sTimeOutId"] = null;
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["cleanUpScrollTiming"] = 0;
    }
    ;

    /**
     * Fires the scroll event
     */
    UCF_ScrollArea["prototype"]["fireScroll"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["fireScroll"]++;
        }
        ;

        var iScrollTop, iScrollLeft;
        this["cleanUpScrollTiming"]();
        this["sTimeOutId"] = null;
        // Get positions from the DOM
        iScrollTop = this["oDomRef"]["scrollTop"];
        iScrollLeft = this["oDomRef"]["scrollLeft"];
        if (this["iScrollTop"] !== iScrollTop || this["iScrollLeft"] !== iScrollLeft) {
            this["iScrollTop"] = iScrollTop;
            this["iScrollLeft"] = iScrollLeft;
            // For RTL calculate scrollRight instead
            if (window["UCF_System"]["bIsRTL"]) {
                iScrollLeft = this["oDomRef"]["scrollWidth"] - this["oDomRef"]["clientWidth"] - this["oDomRef"]["scrollLeft"];
            }
            // Fire Scroll event for the control
            this["fireEvent"](this["E_EVENTS"]["Scroll"], {
                "iScrollTop": parseInt(iScrollTop),
                "iScrollLeft": parseInt(iScrollLeft)
            });
        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["fireScroll"] = 0;
    }
    ;

    /**
     * Sets the scroll position programmatically
     *
     * @param { int } iScrollTop
     * @param { int } iScrollLeft
     */
    UCF_ScrollArea["prototype"]["setScrollPosition"] = function (iScrollTop, iScrollLeft) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["setScrollPosition"]++;
        }
        ;

        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (iScrollTop) === "number", "typeof(iScrollTop) === \"number\"", "ScrollArea.js(205): setScrollPosition");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(typeof (iScrollLeft) === "number", "typeof(iScrollLeft) === \"number\"", "ScrollArea.js(206): setScrollPosition");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iScrollTop >= -1, "iScrollTop >= -1", "ScrollArea.js(207): setScrollPosition");
        }
        ;
        if (__UCF_ASSERT__) {
            UCF_Tracer.assert(iScrollLeft >= -1, "iScrollLeft >= -1", "ScrollArea.js(208): setScrollPosition");
        }
        ;

        // Get scroll height and scroll width to make sure that it has
        // been calculated properly by Internet Explorer
        var iScrollHeight = this["oDomRef"]["scrollHeight"],
            iScrollWidth = this["oDomRef"]["scrollWidth"];

        // Special value -1: Scroll to the end
        if (iScrollTop === -1) iScrollTop = iScrollHeight;
        if (iScrollLeft === -1) iScrollLeft = iScrollWidth;
        // For RTL calculate scrollRight instead
        if (window["UCF_System"]["bIsRTL"]) {
            iScrollLeft = iScrollWidth - this["oDomRef"]["clientWidth"] - iScrollLeft;
        }

        this["iScrollTop"] = iScrollTop;
        this["iScrollLeft"] = iScrollLeft;

        // Set new position in the DOM
        if (iScrollTop !== this["oDomRef"]["scrollTop"] || iScrollLeft !== this["oDomRef"]["scrollLeft"]) {
            this["setIgnoreScrollEvent"](true);

            // Apply new scroll positions

            // 1) Update the scrollposition of the scroll lock mechanism in the case that LS is locked
            // IE sometimes fires scroll events when srollTop/Left is set. Such events applies the formerly stored position to lock also scrolling while LS is locked.
            // To avoid this the stored positon is updated as well.
            this["oDomRef"]["lsStoredScrollTop"] = iScrollTop;
            this["oDomRef"]["lsStoredScrollLeft"] = iScrollLeft;

            // 2) set the actual position
            if (UCF_UserAgent["bIsIE"]() && this["oDomRef"]["tagName"] === "BODY" && document["documentElement"] !== undefined) {
                // make it also work in IE11 on the body, because this class is used by the Page only for this purpose....
                document["documentElement"]["scrollTop"] = iScrollTop;
                document["documentElement"]["scrollLeft"] = iScrollLeft;
            } else {
                this["oDomRef"]["scrollTop"] = iScrollTop;
                this["oDomRef"]["scrollLeft"] = iScrollLeft;
            }

            // In case LS is locked scroll events will not be dispatched
            // so clear scroll ignore flag after timeout
            UCF_JsUtil["delayedCall"](200, this, "setIgnoreScrollEvent", [false]);

        }
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["setScrollPosition"] = 0;
    }
    ;

    /**
     * Returns the scroll position of the ScrollArea
     *
     * @return { Object }
     */
    UCF_ScrollArea["prototype"]["oGetScrollPosition"] = function () {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["oGetScrollPosition"]++;
        }
        ;
        if (this["oDomRef"]) {
            return {
                "top": this["oDomRef"]["scrollTop"],
                "left": this["oDomRef"]["scrollLeft"]
            };
        }
        return null;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["oGetScrollPosition"] = 0;
    }
    ;

    /**
     * Set ignore scroll flag to avoid scroll events to be thrown
     * by setting the scroll position programmatically
     * @param {boolean} bIgnoreScrollEvent
     */
    UCF_ScrollArea["prototype"]["setIgnoreScrollEvent"] = function (bIgnoreScrollEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["setIgnoreScrollEvent"]++;
        }
        ;

        // eslint-disable-next-line ur/no-memory-leaks
        this["bIgnoreScrollEvent"] = bIgnoreScrollEvent;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["setIgnoreScrollEvent"] = 0;
    }
    ;

    /**
     * activate/deactivate scrolling during drag and drop
     * @param {boolean} bEnabled
     */
    UCF_ScrollArea["prototype"]["enableDragScrolling"] = function (bEnabled) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["enableDragScrolling"]++;
        }
        ;

        this["bDragScrollingEnabled"] = bEnabled;
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["enableDragScrolling"] = 0;
    }
    ;

    /**
     * fire scroll event because originally it is called delayed
     * and will not be in the event queue on drop
     * (ScrollArea has to be added as delegate before the drop delegate [which should be the case normally])
     * @param {UVF_BrowserEvent} oBrowserEvent
     */
    UCF_ScrollArea["prototype"]["onlsdrop"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["onlsdrop"]++;
        }
        ;
        this["cleanUpScrollTiming"]();
        this["fireScroll"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["onlsdrop"] = 0;
    }
    ;

    UCF_ScrollArea["prototype"]["onlsdragleave"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["onlsdragleave"]++;
        }
        ;
        this["cleanUpScrollTiming"]();
        this["fireScroll"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["onlsdragleave"] = 0;
    }
    ;

    /**
     * handle scrolling during drag and drop.
     * @param { UVF_BrowserEvent } oBrowserEvent
     */
    UCF_ScrollArea["prototype"]["onlsdragscroll"] = function (oBrowserEvent) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ScrollArea["_"]["onlsdragscroll"]++;
        }
        ;

        if (!this["bDragScrollingEnabled"])
            return;

        var oMouseLocation = {
            "x": oBrowserEvent["iPageX"](),
            "y": oBrowserEvent["iPageY"]()
        };

        var oViewPort = UCF_DomUtil["oGetObjectRect"](this["oDomRef"]);

        //consider scroll position for body
        if (this["oDomRef"] === document["body"]) {
            oViewPort["top"] += this["oDomRef"]["scrollTop"];
            oViewPort["left"] += this["oDomRef"]["scrollLeft"];
        }

        oViewPort["width"] = this["oDomRef"]["clientWidth"]; // TGCHECK
        oViewPort["height"] = this["oDomRef"]["clientHeight"];

        var iVerticalZone = Math["min"](35, oViewPort["height"] / 4);
        var iHorizontalZone = Math["min"](35, oViewPort["width"] / 4);

        var iScrollThresholdTop = oViewPort["top"] + iVerticalZone;
        var iScrollThresholdBottom = oViewPort["top"] + oViewPort["height"] - iVerticalZone;

        var iScrollThresholdLeft = oViewPort["left"] + iHorizontalZone;
        var iScrollThresholdRight = oViewPort["left"] + oViewPort["width"] - iHorizontalZone;

        //scroll up

        var iStepY = 0,
            iStepX = 0;

        if (oMouseLocation["x"] < iScrollThresholdLeft) {
            iStepX = -Math["round"]((iScrollThresholdLeft - oMouseLocation["x"]) / iHorizontalZone * 10);
        } else if (oMouseLocation["x"] > iScrollThresholdRight) {
            iStepX = Math["round"]((oMouseLocation["x"] - iScrollThresholdRight) / iHorizontalZone * 10);
        }

        if (oMouseLocation["y"] < iScrollThresholdTop) {
            iStepY = -Math["round"]((iScrollThresholdTop - oMouseLocation["y"]) / iVerticalZone * 10);
        } else if (oMouseLocation["y"] > iScrollThresholdBottom) {
            iStepY = Math["round"]((oMouseLocation["y"] - iScrollThresholdBottom) / iVerticalZone * 10);
        }

        if (this["iCurrentStepX"] < iStepX) {
            this["iCurrentStepX"]++;
        } else if (this["iCurrentStepX"] > iStepX) {
            this["iCurrentStepX"]--;
        }

        if (this["iCurrentStepY"] < iStepY) {
            this["iCurrentStepY"]++;
        } else if (this["iCurrentStepY"] > iStepY) {
            this["iCurrentStepY"]--;
        }

        this["oDomRef"]["scrollLeft"] += this["iCurrentStepX"];
        this["oDomRef"]["scrollTop"] += this["iCurrentStepY"];

        //creates a scroll event
        this["handleScroll"](oBrowserEvent);
        oBrowserEvent["cancelBubble"]();
    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ScrollArea["_"]["onlsdragscroll"] = 0;
    }
    ;

    /* global UCF_DomUtil */

/// <reference path="../../../core/util/DomUtil.js"/>

    /**
     * @class
     */
    function UCF_ControlUtil() {
        if (__UCF_COVERAGE__) {
            UCF_ControlUtil["_"]["UCF_ControlUtil"]++;
        }
        ;

    };window["UCF_ControlUtil"] = UCF_ControlUtil;
    ;
    if (__UCF_COVERAGE__) {
        window.UCF_classes.push("UCF_ControlUtil");
        UCF_ControlUtil["_"] = {UCF_ControlUtil: 0};
    }
    ;
    ;

    /**
     * Set the text-align style property to the given domRef
     * for value matrix compare UrBase.renderer - UrBase_sTextAlign
     *
     * @param {element} oDomRef  the domRef of an HTML element for the current style
     * @param {element} sTextAlign  textAlign enumeration
     * @param {element} sTextDirection  textDirection enumeration
     * @private
     */
    UCF_ControlUtil["setTextAlign"] = function (oDomRef, sTextAlign, sTextDirection) {
        ;
        if (__UCF_COVERAGE__) {
            UCF_ControlUtil["_"]["setTextAlign"]++;
        }
        ;
        var mSystemDirection = {
                "LTR": 0,
                "RTL": 1

            },
            mTextAlignStates = {
                "FORCEDLEFT": [{"LTR": "", "RTL": "left", "INHERIT": ""}, {
                    "LTR": "left",
                    "RTL": "left",
                    "INHERIT": "left"
                }],
                "LEFT": [{"LTR": "", "RTL": "", "INHERIT": ""}, {"LTR": "", "RTL": "", "INHERIT": ""}],
                "CENTER": [{"LTR": "center", "RTL": "center", "INHERIT": "center"}, {
                    "LTR": "center",
                    "RTL": "center",
                    "INHERIT": "center"
                }],
                "RIGHT": [{"LTR": "right", "RTL": "right", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "",
                    "INHERIT": ""
                }],
                "ENDOFLINE": [{"LTR": "right", "RTL": "left", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "left",
                    "INHERIT": "left"
                }],
                "FORCEDRIGHT": [{"LTR": "right", "RTL": "right", "INHERIT": "right"}, {
                    "LTR": "right",
                    "RTL": "",
                    "INHERIT": ""
                }],
                "BEGINOFLINE": [{"LTR": "left", "RTL": "right", "INHERIT": "left"}, {
                    "LTR": "left",
                    "RTL": "right",
                    "INHERIT": "right"
                }]
            },
            oTextAlignState = mTextAlignStates[sTextAlign],
            iLayoutDirection = UCF_DomUtil["bIsRTL"] ? mSystemDirection["RTL"] : mSystemDirection["LTR"],
            oTextAlignStateSD = oTextAlignState[iLayoutDirection],
            sTextAlignStyle = oTextAlignStateSD[sTextDirection];

        oDomRef["style"]["textAlign"] = sTextAlignStyle;

    };
    ;
    if (__UCF_COVERAGE__) {
        UCF_ControlUtil["_"]["setTextAlign"] = 0;
    }
    ;
})()
